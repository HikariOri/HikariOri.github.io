<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>木漏れ日</title>
  
  
  <link href="https://xinransix.github.io/atom.xml" rel="self"/>
  
  <link href="https://xinransix.github.io/"/>
  <updated>2024-08-06T04:59:09.062Z</updated>
  <id>https://xinransix.github.io/</id>
  
  <author>
    <name>Yao J</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++ 并发编程（从 C++11 到 C++17）</title>
    <link href="https://xinransix.github.io/2024/08/06/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BB%8EC-11%E5%88%B0C-17%EF%BC%89/"/>
    <id>https://xinransix.github.io/2024/08/06/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BB%8EC-11%E5%88%B0C-17%EF%BC%89/</id>
    <published>2024-08-06T04:38:14.000Z</published>
    <updated>2024-08-06T04:59:09.062Z</updated>
    
    <content type="html"><![CDATA[<p>自 C++11 标准以来，C++语言开始支持多线程模型。借助多线程模型，我们可以开发出更好的并发系统。本文以C++ 语言为例，讲解如何进行并发编程。并尽可能涉及 C++11，C++14 以及 C++17中的主要内容。</p><p><img data-src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/bg1.JPG" /></p><h2 id="为什么要并发编程">为什么要并发编程</h2><p>大型的软件项目常常包含非常多的任务需要处理。例如：对于大量数据的数据流处理，或者是包含复杂GUI界面的应用程序。如果将所有的任务都以串行的方式执行，则整个系统的效率将会非常低下，应用程序的用户体验会非常的差。</p><p>另一方面，自上个世纪六七十年代英特尔创始人之一 <ahref="https://en.wikipedia.org/wiki/Gordon_Moore">Gordon Moore</a> 提出<a href="https://en.wikipedia.org/wiki/Moore%27s_law">摩尔定义</a>以来，CPU 频率以每 18个月翻一番的指数速度增长。但这一增长在最近的十年已经基本停滞，大家会发现曾经有过一段时间CPU 的频率从 3G 到达 4G，但在这之后就停滞不前了。因此最近的新款 CPU也基本上都是 3G 左右的频率。相应的，CPU 以更多核的形式在增长。目前的Intel i7 有 8 核的版本，Xeon 处理器达到了 28核。并且，最近几年手机上使用的 CPU 也基本上是 4 核或者 8 核的了。</p><p>由此，掌握并发编程技术，利用多处理器来提升软件项目的性能将是软件工程师的一项基本技能。</p><p>本文以 C++ 语言为例，讲解如何进行并发编程。并尽可能涉及 C++11，C++14以及 C++17 中的主要内容。</p><h2 id="并发与并行">并发与并行</h2><p>并发（Concurrent）与并行（Parallel）都是很常见的术语。</p><p>Erlang 之父 Joe Armstrong曾经以人们使用咖啡机的场景为例描述了这两个术语。如下图所示：</p><p><img data-src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/con_and_par.jpg" /></p><ul><li><strong>并发</strong>：如果多个队列可以交替使用某台咖啡机，则这一行为就是并发的。</li><li><strong>并行</strong>：如果存在多台咖啡机可以被多个队列交替使用，则就是并行。</li></ul><p>这里队列中的每个人类比于计算机的任务，咖啡机类比于计算机处理器。因此：并发和并行都是在多任务的环境下的讨论。</p><p>更严格的来说：如果一个系统支持多个动作同时存在，那么这个系统就是一个并发系统。如果这个系统还支持多个动作（物理时间上）同时执行，那么这个系统就是一个并行系统。</p><p>你可能已经看出，“并行”其实是“并发”的子集。它们的区别在于是否具有多个处理器。如果存在多个处理器同时执行多个线程，就是并行。</p><p>在不考虑处理器数量的情况下，我们统称之为“并发”。</p><h2 id="进程与线程">进程与线程</h2><p>进程与线程是操作系统的基本概念。无论是桌面系统：MacOS，Linux，Windows，还是移动操作系统：Android，iOS，都存在进程和线程的概念。</p><blockquote><p><strong>进程</strong>（英语：process），是指计算机中已运行的程序。进程为曾经是分时系统的基本运作单位。在面向进程设计的系统（如早期的UNIX，Linux 2.4 及更早的版本）中，进程是程序的基本执行实体；</p><p><strong>线程</strong>（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</p><p>– 维基百科</p></blockquote><p>关于这两个概念在任何一本操作系统书上都可以找到定义。网上也有很多文章对它们进行了解释。因此这里不再赘述，这里仅仅提及一下它们与编程的关系。</p><p>对于绝大部分编程语言或者编程环境来说，我们所写的程序都会在一个进程中运行。一个进程至少会包含一个线程。这个线程我们通常称之为主线程。</p><p>在默认的情况下，我们写的代码都是在进程的主线程中运行，除非开发者在程序中创建了新的线程。</p><p>不同编程语言的线程环境会不一样，Java语言在很早就支持了多线程接口。（Java 程序在 Java虚拟机中运行，虚拟机通常还会包含自己特有的线程，例如垃圾回收线程。）。而对于JavaScript 这样的语言来说，它就没有多线程的概念。</p><p>当我们只有一个处理器时，所有的进程或线程会分时占用这个处理器。但如果系统中存在多个处理器时，则就可能有多个任务并行的运行在不同的处理器上。</p><p>下面两幅图以不同颜色的矩形代表不同的任务（可能是进程，也可能是线程）来描述它们可能在处理器上执行的顺序。</p><p>下图是单核处理器的情况：</p><p><img data-src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/single_core.png" /></p><p>下面是四核处理器的情况：</p><p><img data-src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/four_core.png" /></p><p>任务会在何时占有处理器，通常是由操作系统的调度策略决定的。在<ahref="https://paul.pub/android-process-schedule/">《Android系统上的进程管理：进程的调度》</a>一文中，我们介绍过 Linux的调度策略。</p><p>当我们在开发跨平台的软件时，我们不应当对调度策略做任何假设，而应该抱有“系统可能以任意顺序来调度我的任务”这样的想法。</p><h2 id="并发系统的性能">并发系统的性能</h2><p>开发并发系统最主要的动机就是提升系统性能（事实上，这是以增加复杂度为代价的）。</p><p>但我们需要知道，单纯的使用多线程并不一定能提升系统性能（当然，也并非线程越多系统的性能就越好）。从上面的两幅图我们就可以直观的感受到：线程（任务）的数量要根据具体的处理器数量来决定。假设只有一个处理器，那么划分太多线程可能会适得其反。因为很多时间都花在任务切换上了。</p><p>因此，在设计并发系统之前，一方面我们需要做好对于硬件性能的了解，另一方面需要对我们的任务有足够的认识。</p><p>关于这一点，你可能需要了解一下<ahref="https://en.wikipedia.org/wiki/Amdahl%27s_law">阿姆达尔定律</a>了。对于这个定律，简单来说：我们想要预先意识到那些任务是可以并行的，那些是无法并行的。只有明确了任务的性质，才能有的放矢的进行优化。这个定律告诉了我们将系统并行之后性能收益的上限。</p><p>关于阿姆达尔定律在<ahref="https://paul.pub/sysstat/#id-%E9%98%BF%E5%A7%86%E8%BE%BE%E5%B0%94%E5%AE%9A%E5%BE%8B">Linux系统监测工具 sysstat 介绍</a>一文中已经介绍过，因此这里不再赘述。</p><h2 id="c-与并发编程">C++ 与并发编程</h2><p>前面我们已经了解到，并非所有的语言都提供了多线程的环境。</p><p>即便是 C++ 语言，直到<ahref="https://en.wikipedia.org/wiki/C%2B%2B11">C++11</a>标准之前，也是没有多线程支持的。在这种情况下，Linux/Unix平台下的开发者通常会使用<ahref="https://en.wikipedia.org/wiki/POSIX_Threads">POSIXThreads</a>，Windows 上的开发者也会有<ahref="https://docs.microsoft.com/en-us/cpp/parallel/multithreading-with-cpp-and-mfc?view=vs-2019">相应的接口</a>。但很明显，这些API 都只针对特定的操作系统平台，可移植性较差。如果要同时支持 Linux 和Windows 系统，你可能要写两套代码。</p><blockquote><p>相较而言，Java 自 JDK 1.0 就包含了多线程模型。</p></blockquote><p>这个状态在 C++ 11 标准发布之后得到了改变。并且，在 C++ 14 和 C++ 17标准中又对并发编程机制进行了增强。</p><p>下图是最近几个版本的 C++ 标准特性的线路图。</p><p><img data-src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/cpp_timeline.png" /></p><h2 id="编译器与-c-标准">编译器与 C++ 标准</h2><p>编译器对于语言特性的支持是逐步完成的。想要使用特定的特性你需要相应版本的编译器。</p><ul><li>GCC 对于 C++ 特性的支持请参见这里：<ahref="https://www.gnu.org/software/gcc/projects/cxx-status.html">C++Standards Support in GCC</a>。</li><li>Clang 对于 C++ 特性的支持请参见这里：<ahref="https://clang.llvm.org/cxx_status.html">C++ Support inClang</a>。</li></ul><p>下面两个表格列出了 C++ 标准和相应编译器的版本对照：</p><ul><li>C++ 标准与相应的 GCC 版本要求如下：</li></ul><table><thead><tr class="header"><th>C++ 版本</th><th>GCC 版本</th></tr></thead><tbody><tr class="odd"><td>C++11</td><td>4.8</td></tr><tr class="even"><td>C++14</td><td>5.0</td></tr><tr class="odd"><td>C++17</td><td>7.0</td></tr></tbody></table><ul><li>C++ 标准与相应的 Clang 版本要求如下：</li></ul><table><thead><tr class="header"><th>C++ 版本</th><th>Clang 版本</th></tr></thead><tbody><tr class="odd"><td>C++11</td><td>3.3</td></tr><tr class="even"><td>C++14</td><td>3.4</td></tr><tr class="odd"><td>C++17</td><td>5.0</td></tr></tbody></table><p>默认情况下编译器是以较低的标准来进行编译的，如果希望使用新的标准，你需要通过编译参数<code>-std=c++xx</code>告知编译器，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++17 your_file.cpp -o your_program</span><br></pre></td></tr></table></figure><h2 id="测试环境">测试环境</h2><p>本文的源码可以到下载我的 github 上获取，地址：<ahref="https://github.com/paulQuei/cpp-concurrency">paulQuei/cpp-concurrency</a>。</p><p>你可以直接通过下面这条命令获取源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/paulQuei/cpp-concurrency.git</span><br></pre></td></tr></table></figure><p>源码下载之后，你可以通过任何文本编辑器浏览源码。如果希望编译和运行程序，你还需要按照下面的内容来准备环境。</p><p>本文中的源码使用<a href="https://cmake.org/">cmake</a>编译，只有cmake 3.8 以上的版本才支持 C++ 17，所以你需要安装这个或者更新版本的cmake。</p><p>另外，截止目前（2019 年 10月）为止，<code>clang</code>编译器还不支持<ahref="#id-并行算法">并行算法</a>。</p><p>但是<ahref="https://gcc.gnu.org/gcc-9/changes.html">gcc-9</a>是支持的。因此想要编译和运行这部分代码，你需要安装gcc 9.0 或更新的版本。并且，gcc-9 还要依赖<ahref="https://github.com/intel/tbb">Intel Threading BuildingBlocks</a>才能使用并行算法以及<code>&lt;execution&gt;</code>头文件。</p><p>具体的安装方法见下文。</p><blockquote><p>具体编译器对于 C++ 特性支持的情况请参见这里：<ahref="https://en.cppreference.com/w/cpp/compiler_support">C++ compilersupport</a>。</p></blockquote><p>安装好之后运行根目录下的下面这个命令即可：</p><p>它会完成所有的编译工作。</p><p>本文的源码在下面两个环境中经过测试，环境的准备方法如下。</p><h2 id="macos">MacOS</h2><p>在 Mac 上，我使用<ahref="https://brew.sh/">brew</a>工具安装<code>gcc</code>以及<code>tbb</code>库。</p><p>考虑到其他人与我的环境可能会有所差异，所以需要手动告知<code>tbb</code>库的安装路径。</p><p>读者需要执行下面这些命令来准备环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew install gcc</span><br><span class="line">brew install tbb</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> tbb_path=/usr/local/Cellar/tbb/2019_U8/</span><br><span class="line">./make_all.sh</span><br></pre></td></tr></table></figure><p>注意，请通过运行<code>g++-9</code>命令以确认 gcc的版本是否正确，如果版本较低，则需要通过<code>brew</code>命令将其升级到新版本：</p><h2 id="ubuntu">Ubuntu</h2><p>Ubuntu 上，通过下面的命令安装<code>gcc-9</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ubuntu-toolchain-r/test</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install  gcc-9 g++-9</span><br></pre></td></tr></table></figure><p>但安装<code>tbb</code>库就有些麻烦了。这是因为<ahref="https://launchpad.net/ubuntu/+source/tbb">Ubuntu 16.04默认关联的版本是较低的</a>，直接安装是无法使用的。我们需要安装<ahref="https://launchpad.net/ubuntu/+source/tbb/2019~U8-1">更新的版本</a>。</p><p>联网安装的方式<ahref="https://medium.com/@george.shuklin/how-to-install-packages-from-a-newer-distribution-without-installing-unwanted-6584fa93208f">步骤繁琐</a>，所以可以通过下载包的方式进行安装，我已经将这需要的两个文件放到的这里：</p><ul><li><ahref="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/libtbb2_2019%7EU8-1_amd64.deb">libtbb2_2019~U8-1_amd64.deb</a></li><li><ahref="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/libtbb-dev_2019%7EU8-1_amd64.deb">libtbb-dev_2019~U8-1_amd64.deb</a></li></ul><p>如果需要，你可以下载后通过<code>apt</code>命令安装即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ~/Downloads/libtbb2_2019~U8-1_amd64.deb </span><br><span class="line">sudo apt install ~/Downloads/libtbb-dev_2019~U8-1_amd64.deb </span><br></pre></td></tr></table></figure><h2 id="线程">线程</h2><h2 id="创建线程">创建线程</h2><p>创建线程非常的简单的，下面就是一个使用了多线程的 Hello World示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 01_hello_thread.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// ①</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// ②</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123; <span class="comment">// ③</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Hello World from new thread.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">thread <span class="title">t</span><span class="params">(hello)</span></span>; <span class="comment">// ④</span></span><br><span class="line">  t.<span class="built_in">join</span>(); <span class="comment">// ⑤</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这段代码说明如下：</p><ol type="1"><li>为了使用多线程的接口，我们需要<code>#include &lt;thread&gt;</code>头文件。</li><li>为了简化声明，本文中的代码都将<code>using namespace std;</code>。</li><li>新建线程的入口是一个普通的函数，它并没有什么特别的地方。</li><li>创建线程的方式就是构造一个<code>thread</code>对象，并指定入口函数。与普通对象不一样的是，此时编译器便会为我们创建一个新的操作系统线程，并在新的线程中执行我们的入口函数。</li><li>关于<code>join</code>函数在下文中讲解。</li></ol><p><code>thread</code>可以和<code>callable</code>类型一起工作，因此如果你熟悉<ahref="https://en.cppreference.com/w/cpp/language/lambda">lambda表达式</a>，你可以直接用它来写线程的逻辑，像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 02_lambda_thread.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">thread <span class="title">t</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    cout &lt;&lt; <span class="string">&quot;Hello World from lambda thread.&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">  t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为了减少不必要的重复，若无必要，下文中的代码将不贴出<code>include</code>指令以及<code>using</code>声明。</p></blockquote><p>当然，你可以传递参数给入口函数，像下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 03_thread_argument.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Welcome to &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">thread <span class="title">t</span><span class="params">(hello, <span class="string">&quot;https://paul.pub&quot;</span>)</span></span>;</span><br><span class="line">  t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过需要注意的是，参数是以拷贝的形式进行传递的。因此对于拷贝耗时的对象你可能需要传递指针或者引用类型作为参数。但是，如果是传递指针或者引用，你还需要考虑参数对象的生命周期。因为线程的运行长度很可能会超过参数的生命周期（见下文<code>detach</code>），这个时候如果线程还在访问一个已经被销毁的对象就会出现问题。</p><h2 id="join-与-detach">join 与 detach</h2><ul><li>主要 API</li></ul><table><thead><tr class="header"><th>API</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>join</td><td>等待线程完成其执行</td></tr><tr class="even"><td>detach</td><td>允许线程独立执行</td></tr></tbody></table><p>一旦启动线程之后，我们必须决定是要等待直接它结束（通过<code>join</code>），还是让它独立运行（通过<code>detach</code>），我们必须二者选其一。如果在<code>thread</code>对象<strong>销毁的时候</strong>我们还没有做决定，则<code>thread</code>对象在析构函数出将调用<code>std::terminate()</code>从而导致我们的进程异常退出。</p><blockquote><p>请思考在上面的代码示例中，<code>thread</code>对象在何时会销毁。</p></blockquote><p>需要注意的是：在我们做决定的时候，很可能线程已经执行完了（例如上面的示例中线程的逻辑仅仅是一句打印，执行时间会很短）。新的线程创建之后，究竟是新的线程先执行，还是当前线程的下一条语句先执行这是不确定的，因为这是由操作系统的调度策略决定的。不过这不要紧，我们只要在<code>thread</code>对象销毁前做决定即可。</p><ul><li><code>join</code>：调用此接口时，当前线程会一直阻塞，直到目标线程执行完成（当然，很可能目标线程在此处调用之前就已经执行完成了，不过这不要紧）。因此，如果目标线程的任务非常耗时，你就要考虑好是否需要在主线程上等待它了，因此这很可能会导致主线程卡住。</li><li><code>detach</code>：<code>detach</code>是让目标线程成为守护线程（daemonthreads）。一旦<code>detach</code>之后，目标线程将独立执行，即便其对应的<code>thread</code>对象销毁也不影响线程的执行。并且，你无法再与之通信。</li></ul><p>对于这两个接口，都必须是可执行的线程才有意义。你可以通过<code>joinable()</code>接口查询是否可以对它们进行<code>join</code>或者<code>detach</code>。</p><h2 id="管理当前线程">管理当前线程</h2><ul><li>主要 API</li></ul><table><thead><tr class="header"><th>API</th><th>C++ 标准</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>yield</td><td>C++11</td><td>让出处理器，重新调度各执行线程</td></tr><tr class="even"><td>get_id</td><td>C++11</td><td>返回当前线程的线程 id</td></tr><tr class="odd"><td>sleep_for</td><td>C++11</td><td>使当前线程的执行停止指定的时间段</td></tr><tr class="even"><td>sleep_until</td><td>C++11</td><td>使当前线程的执行停止直到指定的时间点</td></tr></tbody></table><p>上面是一些在线程内部使用的 API，它们用来对当前线程做一些控制。</p><ul><li><code>yield</code>通常用在自己的主要任务已经完成的时候，此时希望让出处理器给其他任务使用。</li><li><code>get_id</code> 返回当前线程的id，可以以此来标识不同的线程。</li><li><code>sleep_for</code> 是让当前线程停止一段时间。</li><li><code>sleep_until</code>和<code>sleep_for</code>类似，但是是以具体的时间点为参数。这两个 API都以<a href="https://en.cppreference.com/w/cpp/header/chrono">chrono</a>API（由于篇幅所限，这里不展开这方面内容）为基础。</li></ul><p>下面是一个代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 04_thread_self_manage.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_time</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> now = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> <span class="type">in_time_t</span> = chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line"></span><br><span class="line">  std::stringstream ss;</span><br><span class="line">  ss &lt;&lt; <span class="built_in">put_time</span>(<span class="built_in">localtime</span>(&amp;<span class="type">in_time_t</span>), <span class="string">&quot;%Y-%m-%d %X&quot;</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;now is: &quot;</span> &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sleep_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;[thread-&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] is waking up&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[thread-&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] print: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">print_time</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function">thread <span class="title">t1</span><span class="params">(sleep_thread)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t2</span><span class="params">(loop_thread)</span></span>;</span><br><span class="line"></span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print_time</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码应该还是比较容易理解的，这里创建了两个线程。它们都会有一些输出，其中一个会先停止3秒钟，然后再输出。主线程调用<code>join</code>会一直卡住等待它运行结束。</p><p>这段程序的输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">now is: 2019-10-13 10:17:48</span><br><span class="line">[thread-0x70000cdda000] <span class="built_in">print</span>: 0</span><br><span class="line">[thread-0x70000cdda000] <span class="built_in">print</span>: 1</span><br><span class="line">[thread-0x70000cdda000] <span class="built_in">print</span>: 2</span><br><span class="line">[thread-0x70000cdda000] <span class="built_in">print</span>: 3</span><br><span class="line">[thread-0x70000cdda000] <span class="built_in">print</span>: 4</span><br><span class="line">[thread-0x70000cdda000] <span class="built_in">print</span>: 5</span><br><span class="line">[thread-0x70000cdda000] <span class="built_in">print</span>: 6</span><br><span class="line">[thread-0x70000cdda000] <span class="built_in">print</span>: 7</span><br><span class="line">[thread-0x70000cdda000] <span class="built_in">print</span>: 8</span><br><span class="line">[thread-0x70000cdda000] <span class="built_in">print</span>: 9</span><br><span class="line">[thread-0x70000cd57000] is waking up</span><br><span class="line">now is: 2019-10-13 10:17:51</span><br></pre></td></tr></table></figure><h2 id="一次调用">一次调用</h2><ul><li>主要 API</li></ul><table><thead><tr class="header"><th>API</th><th>C++ 标准</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>call_once</td><td>C++11</td><td>即便在多线程环境下，也能保证只调用某个函数一次</td></tr><tr class="even"><td>once_flag</td><td>C++11</td><td>与<code>call_once</code>配合使用</td></tr></tbody></table><p>在一些情况下，我们有些任务需要执行一次，并且我们只希望它执行一次，例如资源的初始化任务。这个时候就可以用到上面的接口。这个接口会保证，即便在多线程的环境下，相应的函数也只会调用一次。</p><p>下面就是一个示例：有三个线程都会使用<code>init</code>函数，但是只会有一个线程真正执行它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 05_call_once.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Initialing...&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// Do something...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(once_flag* flag)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">call_once</span>(*flag, init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  once_flag flag;</span><br><span class="line"></span><br><span class="line">  <span class="function">thread <span class="title">t1</span><span class="params">(worker, &amp;flag)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t2</span><span class="params">(worker, &amp;flag)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t3</span><span class="params">(worker, &amp;flag)</span></span>;</span><br><span class="line"></span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line">  t3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们无法确定具体是哪一个线程会执行<code>init</code>。而事实上，我们也不关心，因为只要有某个线程完成这个初始化工作就可以了。</p><blockquote><p>请思考一下，为什么要在 main函数中创建<code>once_flag flag</code>。如果是在<code>worker</code>函数中直接声明一个<code>once_flag</code>并使用行不行？为什么？</p></blockquote><h2 id="并发任务">并发任务</h2><p>下面以一个并发任务为示例讲解如何引入多线程。</p><p>任务示例：现在假设我们需要计算某个范围内所有自然数的平方根之和，例如<code>[1, 10e8]</code>。</p><p>在单线程模型下，我们的代码可能是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 06_naive_multithread.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX = <span class="number">10e8</span>; <span class="comment">// ①</span></span><br><span class="line"><span class="type">static</span> <span class="type">double</span> sum = <span class="number">0</span>; <span class="comment">// ②</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123; <span class="comment">// ③</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">serial_task</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123; <span class="comment">// ④</span></span><br><span class="line">  <span class="keyword">auto</span> start_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">worker</span>(<span class="number">0</span>, MAX);</span><br><span class="line">  <span class="keyword">auto</span> end_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> ms = chrono::<span class="built_in">duration_cast</span>&lt;chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Serail task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed, Result: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码说明如下：</p><ol type="1"><li>通过一个常量指定数据范围，这个是为了方便调整。</li><li>通过一个全局变量来存储结果。</li><li>通过一个任务函数来计算值。</li><li>统计任务的执行时间。</li></ol><p>这段程序输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serail task finish, 6406 ms consumed, Result: 2.10819e+13</span><br></pre></td></tr></table></figure><p>很显然，上面单线程的做法性能太差了。我们的任务完全是可以并发执行的。并且任务很容易划分。</p><p>下面我们就尝试以多线程的方式来改造原先的程序。</p><p>改造后的程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 06_naive_multithread.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">concurrent_task</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> start_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> concurrent_count = thread::<span class="built_in">hardware_concurrency</span>(); <span class="comment">// ①</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;hardware_concurrency: &quot;</span> &lt;&lt; concurrent_count &lt;&lt; endl;</span><br><span class="line">  vector&lt;thread&gt; threads;</span><br><span class="line">  min = <span class="number">0</span>;</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; concurrent_count; t++) &#123; <span class="comment">// ②</span></span><br><span class="line">    <span class="type">int</span> range = max / concurrent_count * (t + <span class="number">1</span>);</span><br><span class="line">    threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(worker, min, range)); <span class="comment">// ③</span></span><br><span class="line">    min = range + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// ④</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> end_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> ms = chrono::<span class="built_in">duration_cast</span>&lt;chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed, Result: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码说明如下：</p><ol type="1"><li><code>thread::hardware_concurrency()</code>可以获取到当前硬件支持多少个线程并行执行。</li><li>根据处理器的情况决定线程的数量。</li><li>对于每一个线程都通过<code>worker</code>函数来完成任务，并划分一部分数据给它处理。</li><li>等待每一个线程执行结束。</li></ol><p>很好，似乎很简单就完成了并发的改造。然后我们运行一下这个程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hardware_concurrency: 16</span><br><span class="line">Concurrent task finish, 6246 ms consumed, Result: 1.78162e+12</span><br></pre></td></tr></table></figure><p>很抱歉，我们会发现这里的性能并没有明显的提升。更严重的是，这里的结果是错误的。</p><p>要搞清楚为什么结果不正确我们需要更多的背景知识。</p><p>我们知道，对于现代的处理器来说，为了加速处理的速度，每个处理器都会有自己的高速缓存（Cache），这个高速缓存是与每个处理器相对应的，如下图所示：</p><blockquote><p>事实上，目前大部分 CPU 的缓存已经不只一层。</p></blockquote><p><img data-src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/cpu.png" /></p><p>处理器在进行计算的时候，高速缓存会参与其中，例如数据的读和写。而高速缓存和系统主存（Memory）是有可能存在不一致的。即：某个结果计算后保存在处理器的高速缓存中了，但是没有同步到主存中，此时这个值对于其他处理器就是不可见的。</p><p>事情还远不止这么简单。我们对于全局变量值的修改：<code>sum += sqrt(i);</code>这条语句，它并非是原子的。它其实是很多条指令的组合才能完成。假设在某个设备上，这条语句通过下面这几个步骤来完成。它们的时序可能如下所示：</p><p><img data-src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/multithread.png" /></p><p>在时间点 a 的时候，所有线程对于<code>sum</code>变量的值是一致的。</p><p>但是在时间点 b 之后，thread3上已经对<code>sum</code>进行了赋值。而这个时候其他几个线程也同时在其他处理器上使用了这个值，那么这个时候它们所使用的值就是旧的（错误的）。最后得到的结果也自然是错的。</p><h2 id="竞争条件与临界区">竞争条件与临界区</h2><p>当多个进程或者线程同时访问共享数据时，只要有一个任务会修改数据，那么就可能会发生问题。此时结果依赖于这些任务执行的相对时间，这种场景称为<ahref="https://en.wikipedia.org/wiki/Race_condition"><strong>竞争条件</strong>（racecondition）</a>。</p><p>访问共享数据的代码片段称之为<strong>临界区</strong>（criticalsection）。具体到上面这个示例，临界区就是读写<code>sum</code>变量的地方。</p><p>要避免竞争条件，就需要对临界区进行数据保护。</p><p>很自然的，现在我们能够理解发生竞争条件是因为这些线程在同时访问共享数据，其中有些线程的改动没有让其他线程知道，导致其他线程在错误的基础上进行处理，结果自然也就是错误的。</p><p>那么，如果一次只让一个线程访问共享数据，访问完了再让其他线程接着访问，这样就可以避免问题的发生了。</p><p>接下来介绍的 API 提供的就是这样的功能。</p><h2 id="互斥体与锁">互斥体与锁</h2><h2 id="mutex">mutex</h2><p>开发并发系统的目的主要是为了提升性能：将任务分散到多个线程，然后在不同的处理器上同时执行。这些分散开来的线程通常会包含两类任务：</p><ol type="1"><li>独立的对于划分给自己的数据的处理</li><li>对于处理结果的汇总</li></ol><p>其中第 1 项任务因为每个线程是独立的，不存在竞争条件的问题。而第 2项任务，由于所有线程都可能往总结果（例如上面的<code>sum</code>变量）汇总，这就需要做保护了。在某一个具体的时刻，只应当有一个线程更新总结果，即：保证每个线程对于共享数据的访问是“互斥”的。<code>mutex</code>就提供了这样的功能。</p><p><code>mutex</code>是<strong>mut</strong>ual<strong>ex</strong>clusion（互斥）的简写。</p><ul><li>主要 API</li></ul><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>API</th><th>C++ 标准</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>mutex</td><td>C++11</td><td>提供基本互斥设施</td></tr><tr class="even"><td>timed_mutex</td><td>C++11</td><td>提供互斥设施，带有超时功能</td></tr><tr class="odd"><td>recursive_mutex</td><td>C++11</td><td>提供能被同一线程递归锁定的互斥设施</td></tr><tr class="even"><td>recursive_timed_mutex</td><td>C++11</td><td>提供能被同一线程递归锁定的互斥设施，带有超时功能</td></tr><tr class="odd"><td>shared_timed_mutex</td><td>C++14</td><td>提供共享互斥设施并带有超时功能</td></tr><tr class="even"><td>shared_mutex</td><td>C++17</td><td>提供共享互斥设施</td></tr></tbody></table><p>很明显，在这些类中，<code>mutex</code>是最基础的API。其他类都是在它的基础上的改进。所以这些类都提供了下面三个方法，并且它们的功能是一样的：</p><table><tbody><tr><td>方法</td><td>说明</td></tr><tr><td>lock</td><td>锁定互斥体，如果不可用，则阻塞</td></tr><tr><td>try_lock</td><td>尝试锁定互斥体，如果不可用，直接返回</td></tr><tr><td>unlock</td><td>解锁互斥体</td></tr></tbody></table><p>这三个方法提供了基础的锁定和解除锁定的功能。使用<code>lock</code>意味着你有很强的意愿一定要获取到互斥体，而使用<code>try_lock</code>则是进行一次尝试。这意味着如果失败了，你通常还有其他的路径可以走。</p><p>在这些基础功能之上，其他的类分别在下面三个方面进行了扩展：</p><ul><li><strong>超时</strong>：<code>timed_mutex</code>，<code>recursive_timed_mutex</code>，<code>shared_timed_mutex</code>的名称都带有<code>timed</code>，这意味着它们都支持超时功能。它们都提供了<code>try_lock_for</code>和<code>try_lock_until</code>方法，这两个方法分别可以指定超时的时间长度和时间点。如果在超时的时间范围内没有能获取到锁，则直接返回，不再继续等待。</li><li><strong>可重入</strong>：<code>recursive_mutex</code>和<code>recursive_timed_mutex</code>的名称都带有<code>recursive</code>。可重入或者叫做可递归，是指在同一个线程中，同一把锁可以锁定多次。这就避免了一些不必要的死锁。</li><li><strong>共享</strong>：<code>shared_timed_mutex</code>和<code>shared_mutex</code>提供了共享功能。对于这类互斥体，实际上是提供了两把锁：一把是共享锁，一把是互斥锁。一旦某个线程获取了互斥锁，任何其他线程都无法再获取互斥锁和共享锁；但是如果有某个线程获取到了共享锁，其他线程无法再获取到互斥锁，但是还有获取到共享锁。这里互斥锁的使用和其他的互斥体接口和功能一样。而共享锁可以同时被多个线程同时获取到（使用共享锁的接口见下面的表格）。共享锁通常用在<ahref="https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem">读者写者模型</a>上。</li></ul><p>使用共享锁的接口如下：</p><table><tbody><tr><td>方法</td><td>说明</td></tr><tr><td>lock_shared</td><td>获取互斥体的共享锁，如果无法获取则阻塞</td></tr><tr><td>try_lock_shared</td><td>尝试获取共享锁，如果不可用，直接返回</td></tr><tr><td>unlock_shared</td><td>解锁共享锁</td></tr></tbody></table><p>接下来，我们就借助刚学到的<code>mutex</code>来改造我们的并发系统，改造后的程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 07_mutex_lock.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX = <span class="number">10e8</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> mutex exclusive;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">concurrent_worker</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    exclusive.<span class="built_in">lock</span>(); <span class="comment">// ①</span></span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">    exclusive.<span class="built_in">unlock</span>(); <span class="comment">// ②</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">concurrent_task</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> start_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> concurrent_count = thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;hardware_concurrency: &quot;</span> &lt;&lt; concurrent_count &lt;&lt; endl;</span><br><span class="line">  vector&lt;thread&gt; threads;</span><br><span class="line">  min = <span class="number">0</span>;</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; concurrent_count; t++) &#123;</span><br><span class="line">    <span class="type">int</span> range = max / concurrent_count * (t + <span class="number">1</span>);</span><br><span class="line">    threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(concurrent_worker, min, range)); <span class="comment">// ③</span></span><br><span class="line">    min = range + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threads.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    threads[i].<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> end_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> ms = chrono::<span class="built_in">duration_cast</span>&lt;chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed, Result: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只有三个地方需要关注：</p><ol type="1"><li>在访问共享数据之前加锁</li><li>访问完成之后解锁</li><li>在多线程中使用带锁的版本</li></ol><p>执行之后结果输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hardware_concurrency: 16</span><br><span class="line">Concurrent task finish, 74232 ms consumed, Result: 2.10819e+13</span><br></pre></td></tr></table></figure><p>这下结果是对了，但是我们却发现这个版本比原先单线程的版本性能还要差很多。这是为什么？</p><p>这是因为加锁和解锁是有代价的，这里计算最耗时的地方在锁里面，每次只能有一个线程串行执行，相比于单线程模型，它不但是串行的，还增加了锁的负担，因此就更慢了。</p><p>这就是为什么前面说多线程系统会增加系统的复杂度，而且并非多线程系统一定就有更好的性能。</p><p>不过，对于这里的问题是可以改进的。我们仔细思考一下：我们划分给每个线程的数据其实是独立的，对于数据的处理是耗时的，但其实这部分逻辑每个线程可以单独处理，没必要加锁。只有在最后汇总数据的时候进行一次锁保护就可以了。</p><p>于是我们改造<code>concurrent_worker</code>，像下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 08_improved_mutex_lock.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">concurrent_worker</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> tmp_sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    tmp_sum += <span class="built_in">sqrt</span>(i); <span class="comment">// ①</span></span><br><span class="line">  &#125;</span><br><span class="line">  exclusive.<span class="built_in">lock</span>(); <span class="comment">// ②</span></span><br><span class="line">  sum += tmp_sum;</span><br><span class="line">  exclusive.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的改变在于两处：</p><ol type="1"><li>通过一个局部变量保存当前线程的处理结果</li><li>在汇总总结过的时候进行锁保护</li></ol><p>运行一下改进后的程序，其结果输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hardware_concurrency: 16</span><br><span class="line">Concurrent task finish, 451 ms consumed, Result: 2.10819e+13</span><br></pre></td></tr></table></figure><p>可以看到，性能一下就提升了好多倍。我们终于体验到多线程带来的好处了。</p><p>我们用锁的<strong>粒度</strong>（granularity）来描述锁的范围。<strong>细粒度</strong>（fine-grained）是指锁保护较小的范围，<strong>粗粒度</strong>（coarse-grained）是指锁保护较大的范围。出于性能的考虑，我们应该保证锁的粒度尽可能的细。并且，不应该在获取锁的范围内执行耗时的操作，例如执行IO。如果是耗时的运算，也应该尽可能的移到锁的外面。</p><blockquote><p>In general, a lock should be held for only the minimum possible timeneeded to perform the required operations.</p><p>–《C++ Concurrency in Action》</p></blockquote><h2 id="死锁">死锁</h2><p>死锁是并发系统很常见的一类问题。</p><p>死锁是指：两个或以上的运算单元，每一方都在等待其他方释放资源，但是所有方都不愿意释放资源。结果是没有任何一方能继续推进下去，于是整个系统无法再继续运转。</p><p>死锁在现实中也很常见，例如：两个孩子分别拿着玩具的一半然后哭着要从对方手里得到另外一半玩具，但是谁都不肯让步。</p><p>在成年人的世界里也会发生类似的情况，例如下面这个交通状况：</p><p><img data-src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/deadlock.gif" /></p><p>下面我们来看一个编程示例。</p><p>现在假设我们在开发一个银行的系统，这个系统包含了转账的功能。</p><p>首先我们创建一个<code>Account</code>类来描述银行账号。由于这仅仅是一个演示使用的代码，所以我们希望代码足够的简单。<code>Account</code>类仅仅包含名称和金额两个字段。</p><p>另外，为了支持并发，这个类包含了一个<code>mutex</code>对象，用来保护账号金额，在读写账号金额时需要先加锁保护。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 09_deadlock_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Account</span>(string name, <span class="type">double</span> money): <span class="built_in">mName</span>(name), <span class="built_in">mMoney</span>(money) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">changeMoney</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">    mMoney += amount;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMoney;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">mutex* <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;mMoneyLock;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string mName;</span><br><span class="line">  <span class="type">double</span> mMoney;</span><br><span class="line">  mutex mMoneyLock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Account</code>类很简单，我想就不用多做说明了。</p><p>接下来，我们再创建一个描述银行的<code>Bank</code>类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 09_deadlock_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">addAccount</span><span class="params">(Account* account)</span> </span>&#123;</span><br><span class="line">    mAccounts.<span class="built_in">insert</span>(account);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">transferMoney</span><span class="params">(Account* accountA, Account* accountB, <span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_guard <span class="title">guardA</span><span class="params">(*accountA-&gt;getLock())</span></span>; <span class="comment">// ①</span></span><br><span class="line">    <span class="function">lock_guard <span class="title">guardB</span><span class="params">(*accountB-&gt;getLock())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (amount &gt; accountA-&gt;<span class="built_in">getMoney</span>()) &#123; <span class="comment">// ②</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    accountA-&gt;<span class="built_in">changeMoney</span>(-amount); <span class="comment">// ③</span></span><br><span class="line">    accountB-&gt;<span class="built_in">changeMoney</span>(amount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">totalMoney</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : mAccounts) &#123;</span><br><span class="line">      sum += a-&gt;<span class="built_in">getMoney</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  set&lt;Account*&gt; mAccounts;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>银行类中记录了所有的账号，并且提供了一个方法用来查询整个银行的总金额。</p><p>这其中，我们最主要要关注转账的实现：<code>transferMoney</code>。该方法的几个关键点如下：</p><ol type="1"><li>为了保证线程安全，在修改每个账号之前，需要获取相应的锁。</li><li>判断转出账户金额是否足够，如果不够此次转账失败。</li><li>进行转账。</li></ol><p>有了银行和账户结构之后就可以开发转账系统了，同样的，由于是为了演示所用，我们的转账系统也会尽可能的简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 09_deadlock_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">randomTransfer</span><span class="params">(Bank* bank, Account* accountA, Account* accountB)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">double</span> randomMoney = ((<span class="type">double</span>)<span class="built_in">rand</span>() / RAND_MAX) * <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (bank-&gt;<span class="built_in">transferMoney</span>(accountA, accountB, randomMoney)) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Transfer &quot;</span> &lt;&lt; randomMoney &lt;&lt; <span class="string">&quot; from &quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getName</span>()</span><br><span class="line">           &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; accountB-&gt;<span class="built_in">getName</span>()</span><br><span class="line">           &lt;&lt; <span class="string">&quot;, Bank totalMoney: &quot;</span> &lt;&lt; bank-&gt;<span class="built_in">totalMoney</span>() &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Transfer failed, &quot;</span></span><br><span class="line">           &lt;&lt; accountA-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; has only $&quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getMoney</span>() &lt;&lt; <span class="string">&quot;, but &quot;</span></span><br><span class="line">           &lt;&lt; randomMoney &lt;&lt; <span class="string">&quot; required&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里每次生成一个随机数，然后通过银行进行转账。</p><p>最后我们在<code>main</code>函数中创建两个线程，互相在两个账号之间来回转账：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 09_deadlock_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Account <span class="title">a</span><span class="params">(<span class="string">&quot;Paul&quot;</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">  <span class="function">Account <span class="title">b</span><span class="params">(<span class="string">&quot;Moira&quot;</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  Bank aBank;</span><br><span class="line">  aBank.<span class="built_in">addAccount</span>(&amp;a);</span><br><span class="line">  aBank.<span class="built_in">addAccount</span>(&amp;b);</span><br><span class="line"></span><br><span class="line">  <span class="function">thread <span class="title">t1</span><span class="params">(randomTransfer, &amp;aBank, &amp;a, &amp;b)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t2</span><span class="params">(randomTransfer, &amp;aBank, &amp;b, &amp;a)</span></span>;</span><br><span class="line"></span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们的银行转账系统就开发完成了。然后编译并运行，其结果可能像下面这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Transfer 13.2901 from Paul to Moira, Bank totalMoney: 20042.6259 from Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer failed, Moira has only <span class="variable">$34</span>.7581, but 66.3208 required</span><br><span class="line">Transfer failed, Moira has only <span class="variable">$34</span>.7581, but </span><br><span class="line">Transfer 93.191 from 53.9176 required</span><br><span class="line">Transfer 60.6146 from Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer 49.7304 from Moira to Paul, Bank totalMoney: 200Paul to Moira, Bank totalMoney: </span><br><span class="line">Transfer failed, Moira has only <span class="variable">$17</span>.6041, but 18.1186 required</span><br><span class="line">Transfer failed, Moira has only <span class="variable">$17</span>.6041, but 18.893 required</span><br><span class="line">Transfer failed, Moira has only <span class="variable">$17</span>.6041, but 34.7078 required</span><br><span class="line">Transfer failed, Moira has only <span class="variable">$17</span>.6041, but 33.9569 required</span><br><span class="line">Transfer 12.7899 from 200</span><br><span class="line">Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer failed, Moira has only <span class="variable">$63</span>.9373, but 80.9038 required</span><br><span class="line">Transfer 50.933 from Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer failed, Moira has only <span class="variable">$13</span>.0043, but 30.2056 required</span><br><span class="line">Transfer failed, Moira has only <span class="variable">$Transfer</span> 59.123 from Paul to Moira, Bank totalMoney: 200</span><br><span class="line">Transfer 29.0486 from Paul to Moira, Bank totalMoney: 20013.0043, but 64.7307 required</span><br></pre></td></tr></table></figure><p>如果你运行了这个程序，你会发现很快它就卡住不动了。为什么？</p><p>因为发生了死锁。</p><p>我们仔细思考一下这两个线程的逻辑：这两个线程可能会同时获取其中一个账号的锁，然后又想获取另外一个账号的锁，此时就发生了死锁。如下图所示：</p><p><img data-src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/deadlock.png" /></p><p>当然，发生死锁的原因远不止上面这一种情况。如果两个线程互相<code>join</code>就可能发生死锁。还有在一个线程中对一个不可重入的互斥体（例如<code>mutex</code>而非<code>recursive_mutex</code>）多次加锁也会死锁。</p><p>你可能会觉得，我可不会这么傻，写出这样的代码。但实际上，很多时候是由于代码的深层次嵌套导致了死锁的发生，由于调用关系的复杂导致发现这类问题并不容易。</p><p>如果仔细看一下上面的输出，我们会发现还有另外一个问题：这里的输出是乱的。两个线程的输出混杂在一起了。究其原因也很容易理解：两个线程可能会同时输出，没有做好隔离。</p><p>下面我们就来逐步解决上面的问题。</p><p>对于输出混乱的问题很好解决，专门用一把锁来保护输出逻辑即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10_improved_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line">mutex sCoutLock;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">randomTransfer</span><span class="params">(Bank* bank, Account* accountA, Account* accountB)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">double</span> randomMoney = ((<span class="type">double</span>)<span class="built_in">rand</span>() / RAND_MAX) * <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (bank-&gt;<span class="built_in">transferMoney</span>(accountA, accountB, randomMoney)) &#123;</span><br><span class="line">      sCoutLock.<span class="built_in">lock</span>();</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Transfer &quot;</span> &lt;&lt; randomMoney &lt;&lt; <span class="string">&quot; from &quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getName</span>()</span><br><span class="line">          &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; accountB-&gt;<span class="built_in">getName</span>()</span><br><span class="line">          &lt;&lt; <span class="string">&quot;, Bank totalMoney: &quot;</span> &lt;&lt; bank-&gt;<span class="built_in">totalMoney</span>() &lt;&lt; endl;</span><br><span class="line">      sCoutLock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sCoutLock.<span class="built_in">lock</span>();</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Transfer failed, &quot;</span></span><br><span class="line">           &lt;&lt; accountA-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; has only &quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getMoney</span>() &lt;&lt; <span class="string">&quot;, but &quot;</span></span><br><span class="line">           &lt;&lt; randomMoney &lt;&lt; <span class="string">&quot; required&quot;</span> &lt;&lt; endl;</span><br><span class="line">      sCoutLock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>请思考一下两处<code>lock</code>和<code>unlock</code>调用，并考虑为什么不在<code>while(true)</code>下面写一次整体的加锁和解锁。</p></blockquote><h2 id="通用锁定算法">通用锁定算法</h2><ul><li>主要 API</li></ul><table><thead><tr class="header"><th>API</th><th>C++ 标准</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>lock</td><td>C++11</td><td>锁定指定的互斥体，若任何一个不可用则阻塞</td></tr><tr class="even"><td>try_lock</td><td>C++11</td><td>试图通过重复调用 try_lock 获得互斥体的所有权</td></tr></tbody></table><p>要避免死锁，需要仔细的思考和设计业务逻辑。</p><p>有一个比较简单的原则可以避免死锁，即：对所有的锁进行排序，每次一定要按照顺序来获取锁，不允许乱序。例如：要获取某个玩具，一定要先拿到锁A，再拿到锁 B，才能玩玩具。这样就不会死锁了。</p><p>这个原则虽然简单，但却不容易遵守。因为数据常常是分散在很多地方的。</p><p>不过好消息是，C++ 11标准中为我们提供了一些工具来避免因为多把锁而导致的死锁。我们只要直接调用这些接口就可以了。这个就是上面提到的两个函数。它们都支持传入多个<ahref="https://en.cppreference.com/w/cpp/named_req/Lockable">Lockable</a>对象。</p><p>接下来我们用它来改造之前死锁的转账系统：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10_improved_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">transferMoney</span><span class="params">(Account* accountA, Account* accountB, <span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">lock</span>(*accountA-&gt;<span class="built_in">getLock</span>(), *accountB-&gt;<span class="built_in">getLock</span>());    <span class="comment">// ①</span></span><br><span class="line">  <span class="function">lock_guard <span class="title">lockA</span><span class="params">(*accountA-&gt;getLock(), adopt_lock)</span></span>;  <span class="comment">// ②</span></span><br><span class="line">  <span class="function">lock_guard <span class="title">lockB</span><span class="params">(*accountB-&gt;getLock(), adopt_lock)</span></span>;  <span class="comment">// ③</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (amount &gt; accountA-&gt;<span class="built_in">getMoney</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  accountA-&gt;<span class="built_in">changeMoney</span>(-amount);</span><br><span class="line">  accountB-&gt;<span class="built_in">changeMoney</span>(amount);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只改动了 3 行代码。</p><ol type="1"><li>这里通过<code>lock</code>函数来获取两把锁，标准库的实现会保证不会发生死锁。</li><li><code>lock_guard</code>在下面我们还会详细介绍。这里只要知道它会在自身对象生命周期的范围内锁定互斥体即可。创建<code>lock_guard</code>的目的是为了在<code>transferMoney</code>结束的时候释放锁，<code>lockB</code>也是一样。但需要注意的是，这里传递了<code>adopt_lock</code>表示：现在是已经获取到互斥体了的状态了，不用再次加锁（如果不加<code>adopt_lock</code>就是二次锁定了）。</li></ol><p>运行一下这个改造后的程序，其输出如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">17.5974</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">59.2104</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">49.6379</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">63.6373</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">51.8742</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">50.0081</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">86.1041</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">51.3278</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">66.5754</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">32.1867</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">62.0039</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">98.7819</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">27.046</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">62.9155</span> required</span><br><span class="line">Transfer <span class="number">98.8478</span> from Moira to Paul, Bank totalMoney: <span class="number">200</span></span><br><span class="line">Transfer <span class="number">80.0722</span> from Moira to Paul, Bank totalMoney: <span class="number">200</span></span><br><span class="line">Transfer <span class="number">73.7035</span> from Moira to Paul, Bank totalMoney: <span class="number">200</span></span><br><span class="line">Transfer <span class="number">34.4476</span> from Moira to Paul, Bank totalMoney: <span class="number">200</span></span><br><span class="line">Transfer failed, Moira has only $<span class="number">10.0142</span>, but <span class="number">61.3033</span> required</span><br><span class="line">Transfer failed, Moira has only $<span class="number">10.0142</span>, but <span class="number">24.5595</span> required</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>现在这个转账程序会一直运行下去，不会再死锁了。输出也是正常的了。</p><h2 id="通用互斥管理">通用互斥管理</h2><ul><li>主要 API</li></ul><table><thead><tr class="header"><th>API</th><th>C++ 标准</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>lock_guard</td><td>C++11</td><td>实现严格基于作用域的互斥体所有权包装器</td></tr><tr class="even"><td>unique_lock</td><td>C++11</td><td>实现可移动的互斥体所有权包装器</td></tr><tr class="odd"><td>shared_lock</td><td>C++14</td><td>实现可移动的共享互斥体所有权封装器</td></tr><tr class="even"><td>scoped_lock</td><td>C++17</td><td>用于多个互斥体的免死锁 RAII 封装器</td></tr></tbody></table><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>锁定策略</th><th>C++ 标准</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>defer_lock</td><td>C++11</td><td>类型为 <code>defer_lock_t</code>，不获得互斥的所有权</td></tr><tr class="even"><td>try_to_lock</td><td>C++11</td><td>类型为<code>try_to_lock_t</code>，尝试获得互斥的所有权而不阻塞</td></tr><tr class="odd"><td>adopt_lock</td><td>C++11</td><td>类型为<code>adopt_lock_t</code>，假设调用方已拥有互斥的所有权</td></tr></tbody></table><p>互斥体（<code>mutex</code>相关类）提供了对于资源的保护功能，但是手动的锁定（调用<code>lock</code>或者<code>try_lock</code>）和解锁（调用<code>unlock</code>）互斥体是要耗费比较大的精力的，我们需要精心考虑和设计代码才行。因为我们需要保证，在任何情况下，解锁要和加锁配对，因为假设出现一条路径导致获取锁之后没有正常释放，就会影响整个系统。如果考虑方法还可以会抛出异常，这样的代码写起来会很费劲。</p><p>鉴于这个原因，标准库就提供了上面的这些 API。它们都使用了叫做 RAII的编程技巧，来简化我们手动加锁和解锁的“体力活”。</p><p>请看下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://en.cppreference.com/w/cpp/thread/lock_guard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> g_i = <span class="number">0</span>;</span><br><span class="line">std::mutex g_i_mutex;  <span class="comment">// ①</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_i_mutex)</span></span>;  <span class="comment">// ②</span></span><br><span class="line">  ++g_i;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="comment">// ③</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(safe_increment)</span></span>; <span class="comment">// ④</span></span><br><span class="line">  <span class="function">std::thread <span class="title">t2</span><span class="params">(safe_increment)</span></span>;</span><br><span class="line"> </span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line"> </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中：</p><ol type="1"><li>全局的互斥体<code>g_i_mutex</code>用来保护全局变量<code>g_i</code></li><li>这是一个设计为可以被多线程环境使用的方法。因此需要通过互斥体来进行保护。这里没有调用<code>lock</code>方法，而是直接使用<code>lock_guard</code>来锁定互斥体。</li><li>在方法结束的时候，局部变量<code>std::lock_guard&lt;std::mutex&gt; lock</code>会被销毁，它对互斥体的锁定也就解除了。</li><li>在多个线程中使用这个方法。</li></ol><h3 id="raii">RAII</h3><p>上面的几个类（<code>lock_guard</code>，<code>unique_lock</code>，<code>shared_lock</code>，<code>scoped_lock</code>）都使用了一个叫做RAII 的编程技巧。</p><p>RAII 全称是 Resource Acquisition IsInitialization，直译过来就是：资源获取即初始化。</p><p>RAII 是一种<ahref="http://www.stroustrup.com/bs_faq2.html#finally">C++编程技术</a>，它将必须在使用前请求的资源（例如：分配的堆内存、执行线程、打开的套接字、打开的文件、锁定的互斥体、磁盘空间、数据库连接等——任何存在受限供给中的事物）的生命周期与一个对象的生存周期相绑定。RAII保证资源可用于任何会访问该对象的函数。它亦保证所有资源在其控制对象的生存期结束时，以获取顺序的逆序释放。类似地，若资源获取失败（构造函数以异常退出），则为已构造完成的对象和基类子对象所获取的所有资源，会以初始化顺序的逆序释放。这有效地利用了语言特性以消除内存泄漏并保证异常安全。</p><p>RAII 可总结如下：</p><ul><li>将每个资源封装入一个类，其中：<ul><li>构造函数请求资源，并建立所有类不变式，或在它无法完成时抛出异常，</li><li>析构函数释放资源并决不抛出异常；</li></ul></li><li>始终经由 RAII 类的实例使用满足要求的资源，该资源<ul><li>自身拥有自动存储期或临时生存期，或</li><li>具有与自动或临时对象的生存期绑定的生存期</li></ul></li></ul><p>回想一下上文中的<code>transferMoney</code>方法中的三行代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lock</span>(*accountA-&gt;<span class="built_in">getLock</span>(), *accountB-&gt;<span class="built_in">getLock</span>());</span><br><span class="line"><span class="function">lock_guard <span class="title">lockA</span><span class="params">(*accountA-&gt;getLock(), adopt_lock)</span></span>;</span><br><span class="line"><span class="function">lock_guard <span class="title">lockB</span><span class="params">(*accountB-&gt;getLock(), adopt_lock)</span></span>;</span><br></pre></td></tr></table></figure><p>如果使用<code>unique_lock</code>这三行代码还有一种等价的写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_lock <span class="title">lockA</span><span class="params">(*accountA-&gt;getLock(), defer_lock)</span></span>;</span><br><span class="line"><span class="function">unique_lock <span class="title">lockB</span><span class="params">(*accountB-&gt;getLock(), defer_lock)</span></span>;</span><br><span class="line"><span class="built_in">lock</span>(*accountA-&gt;<span class="built_in">getLock</span>(), *accountB-&gt;<span class="built_in">getLock</span>());</span><br></pre></td></tr></table></figure><p>请注意这里<code>lock</code>方法的调用位置。这里先定义<code>unique_lock</code>指定了<code>defer_lock</code>，因此实际没有锁定互斥体，而是到第三行才进行锁定。</p><p>最后，借助<code>scoped_lock</code>，我们可以将三行代码合成一行，这种写法也是等价的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">scoped_lock <span class="title">lockAll</span><span class="params">(*accountA-&gt;getLock(), *accountB-&gt;getLock())</span></span>;</span><br></pre></td></tr></table></figure><p><code>scoped_lock</code>会在其生命周期范围内锁定互斥体，销毁的时候解锁。同时，它可以锁定多个互斥体，并且避免死锁。</p><p>目前，只还有<code>shared_lock</code>我们没有提到。它与其他几个类的区别在于：它是以共享的方式锁定互斥体。</p><h2 id="条件变量">条件变量</h2><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>API</th><th>C++ 标准</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>condition_variable</td><td>C++ 11</td><td>提供与 std::unique_lock 关联的条件变量</td></tr><tr class="even"><td>condition_variable_any</td><td>C++ 11</td><td>提供与任何锁类型关联的条件变量</td></tr><tr class="odd"><td>notify_all_at_thread_exit</td><td>C++ 11</td><td>安排到在此线程完全结束时对 notify_all 的调用</td></tr><tr class="even"><td>cv_status</td><td>C++ 11</td><td>列出条件变量上定时等待的可能结果</td></tr></tbody></table><p>至此，我们还有一个地方可以改进。那就是：转账金额不足的时候，程序直接返回了<code>false</code>。这很难说是一个好的策略。因为，即便虽然当前账号金额不足以转账，但只要别的账号又转账进来之后，当前这个转账操作也许就可以继续执行了。</p><p>这在很多业务中是很常见的一个需求：每一次操作都要正确执行，如果条件不满足就停下来等待，直到条件满足之后再继续。而不是直接返回。</p><p>条件变量提供了一个可以让多个线程间同步协作的功能。这对于<ahref="https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem">生产者- 消费者模型</a>很有意义。在这个模型下：</p><ul><li>生产者和消费者共享一个工作区。这个区间的大小是有限的。</li><li>生产者总是产生数据放入工作区中，当工作区满了。它就停下来等消费者消费一部分数据，然后继续工作。</li><li>消费者总是从工作区中拿出数据使用。当工作区中的数据全部被消费空了之后，它也会停下来等待生产者往工作区中放入新的数据。</li></ul><p>从上面可以看到，无论是生产者还是消费者，当它们工作的条件不满足时，它们并不是直接报错返回，而是停下来等待，直到条件满足。</p><p>下面我们就借助于条件变量，再次改造之前的银行转账系统。</p><p>这个改造主要在于账号类。我们重点是要调整<code>changeMoney</code>方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 11_bank_transfer_wait_notify.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Account</span>(string name, <span class="type">double</span> money): <span class="built_in">mName</span>(name), <span class="built_in">mMoney</span>(money) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">changeMoney</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_lock <span class="title">lock</span><span class="params">(mMoneyLock)</span></span>; <span class="comment">// ②</span></span><br><span class="line">    mConditionVar.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>, amount] &#123; <span class="comment">// ③</span></span><br><span class="line">      <span class="keyword">return</span> mMoney + amount &gt; <span class="number">0</span>; <span class="comment">// ④</span></span><br><span class="line">    &#125;);</span><br><span class="line">    mMoney += amount;</span><br><span class="line">    mConditionVar.<span class="built_in">notify_all</span>(); <span class="comment">// ⑤</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMoney;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string mName;</span><br><span class="line">  <span class="type">double</span> mMoney;</span><br><span class="line">  mutex mMoneyLock;</span><br><span class="line">  condition_variable mConditionVar; <span class="comment">// ①</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这几处改动说明如下：</p><ol type="1"><li>这里声明了一个条件变量，用来在多个线程之间协作。</li><li>这里使用的是<code>unique_lock</code>，这是为了与条件变量相配合。因为条件变量会解锁和重新锁定互斥体。</li><li>这里是比较重要的一个地方：通过条件变量进行等待。此时：会通过后面的lambda表达式判断条件是否满足。如果满足则继续；如果不满足，则<strong>此处会解锁互斥体，并让当前线程等待</strong>。<strong>解锁</strong>这一点非常重要，因为只有这样，才能让其他线程获取互斥体。</li><li>这里是条件变量等待的条件。如果你不熟悉 lambda表达式，请自行网上学习，或者阅读<ahref="https://paul.pub/cpp-lambda-function-bind/">我之前写的文章</a>。</li><li>此处也很重要。当金额发生变动之后，我们需要通知所有在条件变量上等待的其他线程。此时所有调用<code>wait</code>线程都会再次唤醒，然后尝试获取锁（当然，只有一个能获取到）并再次判断条件是否满足。除了<code>notify_all</code>还有<code>notify_one</code>，它只通知一个等待的线程。<code>wait</code>和<code>notify</code>就构成了线程间互相协作的工具。</li></ol><p>请注意：<code>wait</code> 和 <code>notify_all</code>虽然是写在一个函数中的，但是在运行时它们是在多线程环境中执行的，因此对于这段代码，需要能够从不同线程的角度去思考代码的逻辑。这也是开发并发系统比较难的地方。</p><p>有了上面的改动之后，银行的转账方法实现起来就很简单了，不用再考虑数据保护的问题了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 11_bank_transfer_wait_notify.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bank::transferMoney</span><span class="params">(Account* accountA, Account* accountB, <span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">    accountA-&gt;<span class="built_in">changeMoney</span>(-amount);</span><br><span class="line">    accountB-&gt;<span class="built_in">changeMoney</span>(amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，转账逻辑也会变得简单，不用再管转账失败的情况发生。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 11_bank_transfer_wait_notify.cpp</span></span><br><span class="line"></span><br><span class="line">mutex sCoutLock;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">randomTransfer</span><span class="params">(Bank* bank, Account* accountA, Account* accountB)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">double</span> randomMoney = ((<span class="type">double</span>)<span class="built_in">rand</span>() / RAND_MAX) * <span class="number">100</span>;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">lock_guard <span class="title">guard</span><span class="params">(sCoutLock)</span></span>;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Try to Transfer &quot;</span> &lt;&lt; randomMoney</span><br><span class="line">           &lt;&lt; <span class="string">&quot; from &quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getMoney</span>()</span><br><span class="line">           &lt;&lt; <span class="string">&quot;) to &quot;</span> &lt;&lt; accountB-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; accountB-&gt;<span class="built_in">getMoney</span>()</span><br><span class="line">           &lt;&lt; <span class="string">&quot;), Bank totalMoney: &quot;</span> &lt;&lt; bank-&gt;<span class="built_in">totalMoney</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    bank-&gt;<span class="built_in">transferMoney</span>(accountA, accountB, randomMoney);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完之后的程序运行输出如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Try to Transfer <span class="number">13.72</span> <span class="function">from <span class="title">Moira</span><span class="params">(<span class="number">10.9287</span>)</span> to <span class="title">Paul</span><span class="params">(<span class="number">189.071</span>)</span>, Bank totalMoney: <span class="number">200</span></span></span><br><span class="line"><span class="function">Try to Transfer <span class="number">28.6579</span> from Paul(<span class="number">189.071</span>) to Moira(<span class="number">10.9287</span>), Bank totalMoney: <span class="number">200</span></span></span><br><span class="line"><span class="function">Try to Transfer <span class="number">91.8049</span> from Paul(<span class="number">160.413</span>) to Moira(<span class="number">39.5866</span>), Bank totalMoney: <span class="number">200</span></span></span><br><span class="line"><span class="function">Try to Transfer <span class="number">5.56383</span> from Paul(<span class="number">82.3285</span>) to Moira(<span class="number">117.672</span>), Bank totalMoney: <span class="number">200</span></span></span><br><span class="line"><span class="function">Try to Transfer <span class="number">11.3594</span> from Paul(<span class="number">76.7646</span>) to Moira(<span class="number">123.235</span>), Bank totalMoney: <span class="number">200</span></span></span><br><span class="line"><span class="function">Try to Transfer <span class="number">16.9557</span> from Paul(<span class="number">65.4053</span>) to Moira(<span class="number">134.595</span>), Bank totalMoney: <span class="number">200</span></span></span><br><span class="line"><span class="function">Try to Transfer <span class="number">74.998</span> from Paul(<span class="number">48.4495</span>) to Moira(<span class="number">151.55</span>), Bank totalMoney: <span class="number">200</span></span></span><br><span class="line"><span class="function">Try to Transfer <span class="number">65.3005</span> from Moira(<span class="number">151.55</span>) to Paul(<span class="number">48.4495</span>), Bank totalMoney: <span class="number">200</span></span></span><br><span class="line"><span class="function">Try to Transfer <span class="number">90.6084</span> from Moira(<span class="number">86.25</span>) to Paul(<span class="number">113.75</span>), Bank totalMoney: <span class="number">125.002</span></span></span><br><span class="line"><span class="function">Try to Transfer <span class="number">99.6425</span> from Moira(<span class="number">70.6395</span>) to Paul(<span class="number">129.36</span>), Bank totalMoney: <span class="number">200</span></span></span><br><span class="line"><span class="function">Try to Transfer <span class="number">55.2091</span> from Paul(<span class="number">129.36</span>) to Moira(<span class="number">70.6395</span>), Bank totalMoney: <span class="number">200</span></span></span><br><span class="line"><span class="function">Try to Transfer <span class="number">92.259</span> from Paul(<span class="number">74.1513</span>) to Moira(<span class="number">125.849</span>), Bank totalMoney: <span class="number">200</span></span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure><p>这下比之前都要好了。</p><p>但是细心的读者会发现，Bank totalMoney 的输出有时候是200，有时候不是。但不管怎样，即便这一次不是，下一次又是了。关于这一点，请读者自行思考一下为什么，以及如何改进。</p><h2 id="future">future</h2><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>API</th><th>C++ 标准</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>async</td><td>C++11</td><td>异步运行一个函数，并返回保有其结果的<code>std::future</code></td></tr><tr class="even"><td>future</td><td>C++11</td><td>等待被异步设置的值</td></tr><tr class="odd"><td>packaged_task</td><td>C++11</td><td>打包一个函数，存储其返回值以进行异步获取</td></tr><tr class="even"><td>promise</td><td>C++11</td><td>存储一个值以进行异步获取</td></tr><tr class="odd"><td>shared_future</td><td>C++11</td><td>等待被异步设置的值（可能为其他 future 所引用）</td></tr></tbody></table><p>这一小节中，我们来熟悉更多的可以在并发环境中使用的工具，它们都位于<code>&lt;future&gt;</code>头文件中。</p><h2 id="async">async</h2><p>很多语言都提供了异步的机制。异步使得耗时的操作不影响当前主线程的执行流。</p><p>在 C++11中，<code>async</code>便是完成这样的功能的。下面是一个代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 12_async_task.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX = <span class="number">10e8</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">auto</span> f1 = <span class="built_in">async</span>(worker, <span class="number">0</span>, MAX);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Async task triggered&quot;</span> &lt;&lt; endl;</span><br><span class="line">  f1.<span class="built_in">wait</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Async task finish, result: &quot;</span> &lt;&lt; sum &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这仍然是我们之前熟悉的例子。这里有两个地方需要说明：</p><ol type="1"><li>这里以异步的方式启动了任务。它会返回一个<code>future</code>对象。<code>future</code>用来存储异步任务的执行结果，关于<code>future</code>我们在后面<code>packaged_task</code>的例子中再详细说明。在这个例子中我们仅仅用它来等待任务执行完成。</li><li>此处是等待异步任务执行完成。</li></ol><p>需要注意的是，默认情况下，<code>async</code>是启动一个新的线程，还是以同步的方式（不启动新的线程）运行任务，这一点标准是没有指定的，由具体的编译器决定。如果希望一定要以新的线程来异步执行任务，可以通过<code>launch::async</code>来明确说明。<code>launch</code>中有两个常量：</p><ul><li><code>async</code>：运行新线程，以异步执行任务。</li><li><code>deferred</code>：调用方线程上第一次请求其结果时才执行任务，即惰性求值。</li></ul><p>除了通过函数来指定异步任务，还可以 lambda表达式的方式来指定。如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 12_async_task.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> result = <span class="number">0</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Async task with lambda triggered, thread: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">auto</span> f2 = <span class="built_in">async</span>(launch::async, [&amp;result]() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Lambda task in thread: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= MAX; i++) &#123;</span><br><span class="line">      result += <span class="built_in">sqrt</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  f2.<span class="built_in">wait</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Async task with lambda finish, result: &quot;</span> &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段代码中，我们使用一个 lambda表达式来编写异步任务的逻辑，并通过<code>launch::async</code>明确指定要通过独立的线程来执行任务，同时我们打印出了线程的id。</p><p>这段代码输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Async task with lambda triggered, thread: 0x11290d5c0</span><br><span class="line">Lambda task <span class="keyword">in</span> thread: 0x700007aa1000</span><br><span class="line">Async task with lambda finish, result: 2.10819e+13</span><br></pre></td></tr></table></figure><p>对于面向对象编程来说，很多时候肯定希望以对象的方法来指定异步任务。下面是一个示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 12_async_task.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Worker</span>(<span class="type">int</span> min, <span class="type">int</span> max): <span class="built_in">mMin</span>(min), <span class="built_in">mMax</span>(max) &#123;&#125; <span class="comment">// ①</span></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">work</span><span class="params">()</span> </span>&#123; <span class="comment">// ②</span></span><br><span class="line">    mResult = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = mMin; i &lt;= mMax; i++) &#123;</span><br><span class="line">      mResult += <span class="built_in">sqrt</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mResult;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mResult;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> mMin;</span><br><span class="line">  <span class="type">int</span> mMax;</span><br><span class="line">  <span class="type">double</span> mResult;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Worker <span class="title">w</span><span class="params">(<span class="number">0</span>, MAX)</span></span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Task in class triggered&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">auto</span> f3 = <span class="built_in">async</span>(&amp;Worker::work, &amp;w); <span class="comment">// ③</span></span><br><span class="line">  f3.<span class="built_in">wait</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Task in class finish, result: &quot;</span> &lt;&lt; w.<span class="built_in">getResult</span>() &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有三处需要说明：</p><ol type="1"><li>这里通过一个类来描述任务。这个类是对前面提到的任务的封装。它包含了任务的输入参数，和输出结果。</li><li><code>work</code>函数是任务的主体逻辑。</li><li>通过<code>async</code>执行任务：这里指定了具体的任务函数以及相应的对象。请注意这里是<code>&amp;w</code>，因此传递的是对象的指针。如果不写<code>&amp;</code>将传入<code>w</code>对象的临时复制。</li></ol><h2 id="packaged_task">packaged_task</h2><p>在一些业务中，我们可能会有很多的任务需要调度。这时我们常常会设计出任务队列和线程池的结构。此时，就可以使用<code>packaged_task</code>来包装任务。</p><blockquote><p>如果你了解设计模式，你应该会知道<ahref="https://en.wikipedia.org/wiki/Command_pattern">命令模式</a>。</p></blockquote><p><code>packaged_task</code>绑定到一个函数或者可调用对象上。当它被调用时，它就会调用其绑定的函数或者可调用对象。并且，可以通过与之相关联的<code>future</code>来获取任务的结果。调度程序只需要处理<code>packaged_task</code>，而非各个函数。</p><p><code>packaged_task</code>对象是一个可调用对象，它可以被封装成一个<code>std::fucntion</code>，或者作为线程函数传递给<code>std::thread</code>，或者直接调用。</p><p>下面是一个代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 13_packaged_task.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">concurrent_worker</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">concurrent_task</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">  vector&lt;future&lt;<span class="type">double</span>&gt;&gt; results; <span class="comment">// ①</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> concurrent_count = thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">  min = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; concurrent_count; i++) &#123; <span class="comment">// ②</span></span><br><span class="line">    <span class="function">packaged_task&lt;<span class="title">double</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(concurrent_worker)</span></span>; <span class="comment">// ③</span></span><br><span class="line">    results.<span class="built_in">push_back</span>(task.<span class="built_in">get_future</span>()); <span class="comment">// ④</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> range = max / concurrent_count * (i + <span class="number">1</span>);</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(std::move(task), min, range)</span></span>; <span class="comment">// ⑤</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    min = range + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;threads create finish&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : results) &#123;</span><br><span class="line">    sum += r.<span class="built_in">get</span>(); <span class="comment">// ⑥</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> start_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> r = <span class="built_in">concurrent_task</span>(<span class="number">0</span>, MAX);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> end_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> ms = chrono::<span class="built_in">duration_cast</span>&lt;chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed, Result: &quot;</span> &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中：</p><ol type="1"><li>首先创建一个集合来存储<code>future</code>对象。我们将用它来获取任务的结果。</li><li>同样的，根据 CPU 的情况来创建线程的数量。</li><li>将任务包装成<code>packaged_task</code>。请注意，由于<code>concurrent_worker</code>被包装成了任务，我们无法直接获取它的<code>return</code>值。而是要通过<code>future</code>对象来获取。</li><li>获取任务关联的<code>future</code>对象，并将其存入集合中。</li><li>通过一个新的线程来执行任务，并传入需要的参数。</li><li>通过<code>future</code>集合，逐个获取每个任务的计算结果，将其累加。这里<code>r.get()</code>获取到的就是每个任务中<code>concurrent_worker</code>的返回值。</li></ol><p>为了简单起见，这里的示例只使用了我们熟悉的例子和结构。但在实际上的工程中，调用关系通常更复杂，你可以借助于<code>packaged_task</code>将任务组装成队列，然后通过<ahref="https://en.wikipedia.org/wiki/Thread_pool">线程池</a>的方式进行调度：</p><p><img data-src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/Thread_pool.svg" /></p><h2 id="promise-与-future">promise 与 future</h2><p>在上面的例子中，<code>concurrent_task</code>的结果是通过<code>return</code>返回的。但在一些时候，我们可能不能这么做：在得到任务结果之后，可能还有一些事情需要继续处理，例如清理工作。</p><p>这个时候，就可以将<code>promise</code>与<code>future</code>配对使用。这样就可以将返回结果和任务结束两个事情分开。</p><p>下面是对上面代码示例的改写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 14_promise_future.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">concurrent_worker</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">concurrent_task</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, promise&lt;<span class="type">double</span>&gt;* result)</span> </span>&#123; <span class="comment">// ①</span></span><br><span class="line">  vector&lt;future&lt;<span class="type">double</span>&gt;&gt; results;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> concurrent_count = thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">  min = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; concurrent_count; i++) &#123;</span><br><span class="line">    <span class="function">packaged_task&lt;<span class="title">double</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(concurrent_worker)</span></span>;</span><br><span class="line">    results.<span class="built_in">push_back</span>(task.<span class="built_in">get_future</span>()); </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> range = max / concurrent_count * (i + <span class="number">1</span>);</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(std::move(task), min, range)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    min = range + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;threads create finish&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : results) &#123;</span><br><span class="line">    sum += r.<span class="built_in">get</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  result-&gt;<span class="built_in">set_value</span>(sum); <span class="comment">// ②</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;concurrent_task finish&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> start_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  promise&lt;<span class="type">double</span>&gt; sum; <span class="comment">// ③</span></span><br><span class="line">  <span class="built_in">concurrent_task</span>(<span class="number">0</span>, MAX, &amp;sum);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> end_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> ms = chrono::<span class="built_in">duration_cast</span>&lt;chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed.&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; sum.<span class="built_in">get_future</span>().<span class="built_in">get</span>() &lt;&lt; endl; <span class="comment">// ④</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码和上面的示例在很大程度上是一样的。只有小部分内容做了改动：</p><ol type="1"><li><code>concurrent_task</code>不再直接返回计算结果，而是增加了一个<code>promise</code>对象来存放结果。</li><li>在任务计算完成之后，将总结过设置到<code>promise</code>对象上。一旦这里调用了<code>set_value</code>，其相关联的<code>future</code>对象就会就绪。</li><li>这里是在<code>main</code>中创建一个<code>promoise</code>来存放结果，并以指针的形式传递进<code>concurrent_task</code>中。</li><li>通过<code>sum.get_future().get()</code>来获取结果。第 2点中已经说了：一旦调用了<code>set_value</code>，其相关联的<code>future</code>对象就会就绪。</li></ol><p>需要注意的是，<code>future</code>对象只有被一个线程获取值。并且在调用<code>get()</code>之后，就没有可以获取的值了。如果从多个线程调用<code>get()</code>会出现数据竞争，其结果是未定义的。</p><p>如果真的需要在多个线程中获取<code>future</code>的结果，可以使用<code>shared_future</code>。</p><h2 id="并行算法">并行算法</h2><p>从 C++17 开始。<ahref="https://en.cppreference.com/w/cpp/algorithm"><algorithm></a>和<ahref="https://en.cppreference.com/w/cpp/numeric#Numeric_algorithms"><numeric></a>头文件的中的很多算法都添加了一个新的参数：<code>sequenced_policy</code>。</p><p>借助这个参数，开发者可以直接使用这些算法的并行版本，不用再自己创建并发系统和划分数据来调度这些算法。</p><p><code>sequenced_policy</code>可能的取值有三种，它们的说明如下：</p><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th>变量</th><th>类型</th><th>C++ 版本</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>execution::seq</td><td>execution::sequenced_policy</td><td>C++17</td><td>要求并行算法的执行可以不并行化</td></tr><tr class="even"><td>execution::par</td><td>execution::parallel_policy</td><td>C++17</td><td>指示并行算法的执行可以并行化</td></tr><tr class="odd"><td>execution::par_unseq</td><td>execution::parallel_unsequenced_policy</td><td>C++17</td><td>指示并行算法的执行可以并行化、向量化</td></tr></tbody></table><blockquote><p>注意：<a href="#id-测试环境">本文的前面</a>已经提到，目前 clang编译器还不支持这个功能。因此想要编译这部分代码，你需要使用 gcc 9.0或更高版本，同时还需要安装<a href="https://github.com/intel/tbb">IntelThreading Building Blocks</a>。</p></blockquote><p>下面还是通过一个示例来进行说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 15_parallel_algorithm.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generateRandomData</span><span class="params">(vector&lt;<span class="type">double</span>&gt;&amp; collection, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  random_device rd;</span><br><span class="line">  <span class="function">mt19937 <span class="title">mt</span><span class="params">(rd())</span></span>;</span><br><span class="line">  <span class="function">uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">dist</span><span class="params">(<span class="number">1.0</span>, <span class="number">100.0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    collection.<span class="built_in">push_back</span>(<span class="built_in">dist</span>(mt));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">double</span>&gt; collection;</span><br><span class="line">  <span class="built_in">generateRandomData</span>(collection, <span class="number">10e6</span>); <span class="comment">// ①</span></span><br><span class="line"></span><br><span class="line">  <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">copy1</span><span class="params">(collection)</span></span>; <span class="comment">// ②</span></span><br><span class="line">  <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">copy2</span><span class="params">(collection)</span></span>;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">copy3</span><span class="params">(collection)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> time1 = chrono::steady_clock::<span class="built_in">now</span>(); <span class="comment">// ③</span></span><br><span class="line">  <span class="built_in">sort</span>(execution::seq, copy1.<span class="built_in">begin</span>(), copy1.<span class="built_in">end</span>()); <span class="comment">// ④</span></span><br><span class="line">  <span class="keyword">auto</span> time2 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> duration = chrono::<span class="built_in">duration_cast</span>&lt;chrono::milliseconds&gt;(time2 - time1).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Sequenced sort consuming &quot;</span> &lt;&lt; duration &lt;&lt; <span class="string">&quot;ms.&quot;</span> &lt;&lt; endl; <span class="comment">// ⑤</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> time3 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="built_in">sort</span>(execution::par, copy2.<span class="built_in">begin</span>(),copy2.<span class="built_in">end</span>()); <span class="comment">// ⑥</span></span><br><span class="line">  <span class="keyword">auto</span> time4 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  duration = chrono::<span class="built_in">duration_cast</span>&lt;chrono::milliseconds&gt;(time4 - time3).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Parallel sort consuming &quot;</span> &lt;&lt; duration &lt;&lt; <span class="string">&quot;ms.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> time5 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="built_in">sort</span>(execution::par_unseq, copy2.<span class="built_in">begin</span>(),copy2.<span class="built_in">end</span>()); <span class="comment">// ⑦</span></span><br><span class="line">  <span class="keyword">auto</span> time6 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  duration = chrono::<span class="built_in">duration_cast</span>&lt;chrono::milliseconds&gt;(time6 - time5).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Parallel unsequenced sort consuming &quot;</span> &lt;&lt; duration &lt;&lt; <span class="string">&quot;ms.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很简单：</p><ol type="1"><li>通过一个函数生成 1000,000 个随机数。</li><li>将数据拷贝 3 份，以备使用。</li><li>接下来将通过三个不同的<code>parallel_policy</code>参数来调用同样的<code>sort</code>算法。每次调用记录开始和结束的时间。</li><li>第一次调用使用<code>std::execution::seq</code>参数。</li><li>输出本次测试所使用的时间。</li><li>第二次调用使用<code>std::execution::par</code>参数。</li><li>第三次调用使用<code>std::execution::par_unseq</code>参数。</li></ol><p>该程序的输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sequenced sort consuming 4464ms.</span><br><span class="line">Parallel sort consuming 459ms.</span><br><span class="line">Parallel unsequenced sort consuming 168ms.</span><br></pre></td></tr></table></figure><p>可以看到，性能最好的和最差的相差了超过 26 倍。</p><h2 id="结束语">结束语</h2><p>在本篇文章中，我们介绍了 C++ 语言中新增的并发编程API。虽然这部分内容已经不少（大部分人很难一次性搞懂所有这些内容，包括我自己），但实际上还有一个很重要的话题我们没有触及，那就是“内存模型”。</p><p>C++ 内存模型是 C++11标准中最重要的特性之一。它是多线程环境能够可靠工作的基础。考虑到这部分内容还需要比较多的篇幅来说明，因此我们会在下一篇文章中继续讨论。</p><h2 id="参考资料与推荐读物">参考资料与推荐读物</h2><ul><li><ahref="https://www.amazon.com/C-Concurrency-Action-Anthony-Williams/dp/1617294691/">C++Concurrency in Action 2nd</a></li><li><a href="http://wikipedia.org/">Wikipedia</a></li><li><a href="https://en.cppreference.com/w/cpp/thread">cpprefernce:Thread support library</a></li><li><ahref="https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996">EffectiveModern C++: 42 Specific Ways to Improve Your Use of C++11 andC++14</a></li><li><ahref="https://www.hpl.hp.com/techreports/2004/HPL-2004-209.pdf">ThreadsCannot be Implemented as a Library</a></li><li><ahref="https://www.modernescpp.com/index.php/i-m-proud-to-present-modern-c-concurrency-is-available-as-interactive-course">I’mProud to Present: Modern C++ Concurrency is available as interactivecourse</a></li><li><ahref="https://intellij-support.jetbrains.com/hc/en-us/community/posts/115000682210-How-do-I-enable-C-17-">Howdo I enable C++17?</a></li><li><ahref="https://solarianprogrammer.com/2019/05/09/cpp-17-stl-parallel-algorithms-gcc-intel-tbb-linux-macos/">C++17STL Parallel Algorithms - with GCC 9.1 and Intel TBB on Linux andmacOS</a></li><li><ahref="https://medium.com/@george.shuklin/how-to-install-packages-from-a-newer-distribution-without-installing-unwanted-6584fa93208f">Howto install packages from a newer distribution without installingunwanted</a></li></ul>]]></content>
    
    
    <summary type="html">C++11 到 C++17 对多线程的支持</summary>
    
    
    
    <category term="C++" scheme="https://xinransix.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://xinransix.github.io/tags/C/"/>
    
    <category term="Thread" scheme="https://xinransix.github.io/tags/Thread/"/>
    
    <category term="Concurrency" scheme="https://xinransix.github.io/tags/Concurrency/"/>
    
    <category term="Synchronize" scheme="https://xinransix.github.io/tags/Synchronize/"/>
    
    <category term="Lock" scheme="https://xinransix.github.io/tags/Lock/"/>
    
    <category term="Mutex" scheme="https://xinransix.github.io/tags/Mutex/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程——函数式编程术语</title>
    <link href="https://xinransix.github.io/2024/07/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%9C%AF%E8%AF%AD/"/>
    <id>https://xinransix.github.io/2024/07/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%9C%AF%E8%AF%AD/</id>
    <published>2024-07-23T01:51:29.000Z</published>
    <updated>2024-08-02T05:02:37.424Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>译者注：本项目译自 <ahref="https://github.com/hemanth/functional-programming-jargon">functional-programing-jargon</a>，专业术语居多，如有错误，可以提pr 更正。除了术语翻译，针对每项术语，也有代码示例，位于 /demos目录下。另外，这里也有几份不错的文章和仓库。 + <ahref="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html">函数式编程入门教程</a>+ <ahref="https://github.com/MostlyAdequate/mostly-adequate-guide">mostly-adequate-guide(10749 stars)</a> + <ahref="https://github.com/llh911001/mostly-adequate-guide-chinese">mostly-adequate-guide-chinese(602 stars)</a> + <ahref="https://github.com/fantasyland/fantasy-land">fantasy-land</a></p></blockquote><p>函数式编程有许多优势，由此越来越受欢迎。然而每个编程范式 (paradigm)都有自己唯一的术语，函数式编程也不例外。我们提供一张术语表，希望使你学习函数式编程变得容易些。</p><p>示例均为 javascript (ES2015)。<ahref="https://github.com/hemanth/functional-programming-jargon/wiki/Why-JavaScript%3F">为什么使用JavaScript?</a></p><p><em>尚在 WIP 阶段，欢迎 pr。</em></p><p>如果适用，本篇文档使用定义在 <ahref="https://github.com/fantasyland/fantasy-land">Fantasy Land spec</a>中的术语。</p><p><strong>目录</strong></p><ul><li><a href="#arity">Arity</a></li><li><a href="#高阶函数-higher-order-function--hof">高阶函数(Higher-Order Function / HOF)</a></li><li><a href="#闭包-closure">闭包 (Closure)</a></li><li><a href="#偏函数应用-partial-application">偏函数应用 (PartialApplication)</a></li><li><a href="#柯里化-currying">柯里化 (Currying)</a></li><li><a href="#自动柯里化-auto-currying">自动柯里化 (Auto Currying)</a><ul><li><a href="#进一步阅读">进一步阅读</a></li></ul></li><li><a href="#函数组合-function-composition">函数组合 (FunctionComposition)</a></li><li><a href="#continuation-后续">Continuation (后续)</a></li><li><a href="#纯函数-purity">纯函数 (Purity)</a></li><li><a href="#副作用-side-effects">副作用 (Side effects)</a></li><li><a href="#幂等-idempotent">幂等 (Idempotent)</a></li><li><a href="#point-free-风格-point-free-style">Point-Free 风格(Point-Free Style)</a></li><li><a href="#断定-predicate">断定 (Predicate)</a></li><li><a href="#契约-contracts">契约 (Contracts)</a></li><li><a href="#范畴-category">范畴 (Category)</a><ul><li><a href="#进一步阅读-1">进一步阅读</a></li></ul></li><li><a href="#值-value">值 (Value)</a></li><li><a href="#常量-constant">常量 (Constant)</a></li><li><a href="#函子-functor">函子 (Functor)</a><ul><li><a href="#一致性-preserves-identity">一致性 (Preservesidentity)</a></li><li><a href="#组合性-composable">组合性 (Composable)</a></li><li><a href="#指向函子-pointed-functor">指向函子 (PointedFunctor)</a></li></ul></li><li><a href="#抬升-lift">抬升 (Lift)</a></li><li><a href="#引用透明性-referential-transparency">引用透明性(Referential Transparency)</a></li><li><a href="#等式推理-equational-reasoning">等式推理 (EquationalReasoning)</a></li><li><a href="#lambda">Lambda</a></li><li><a href="#lambda演算-lambda-calculus">Lambda演算 (LambdaCalculus)</a></li><li><a href="#惰性求值-lazy-evaluation">惰性求值 (Lazyevaluation)</a></li><li><a href="#幺半群-monoid">幺半群 (Monoid)</a></li><li><a href="#单子-monad">单子 (Monad)</a></li><li><a href="#余单子-comonad">余单子 (Comonad)</a></li><li><a href="#应用函子-applicative-functor">应用函子 (ApplicativeFunctor)</a></li><li><a href="#态射-morphism">态射 (Morphism)</a><ul><li><a href="#endomorphism-自同态">Endomorphism (自同态)</a></li><li><a href="#isomorphism-同构">Isomorphism (同构)</a></li><li><a href="#homomorphism-同态">Homomorphism (同态)</a></li><li><a href="#catamorphism">Catamorphism</a></li><li><a href="#anamorphism">Anamorphism</a></li><li><a href="#hylomorphism">Hylomorphism</a></li><li><a href="#paramorphism">Paramorphism</a></li><li><a href="#apomorphism">Apomorphism</a></li></ul></li><li><a href="#setoid">Setoid</a></li><li><a href="#半群-semigroup">半群 (Semigroup)</a></li><li><a href="#可折叠性-foldable">可折叠性 (Foldable)</a></li><li><a href="#透镜-lens">透镜 (Lens)</a></li><li><a href="#类型签名-type-signatures">类型签名 (TypeSignatures)</a></li><li><a href="#代数数据类型-algebraic-data-type">代数数据类型 (Algebraicdata type)</a><ul><li><a href="#和类型-sum-type">和类型 (Sum type)</a></li><li><a href="#product-type">Product type</a></li></ul></li><li><a href="#可选类型-option">可选类型 (Option)</a></li><li><a href="#function">Function</a></li><li><a href="#偏函数-partial-function">偏函数 (Partial function)</a><ul><li><a href="#处理偏函数">处理偏函数</a></li></ul></li><li><a href="#在-js-中的函数式编程库">在 js 中的函数式编程库</a></li></ul><div id="arity"></div><h2 id="arity">Arity</h2><p>函数参数的个数。来自于单词 unary(一元), binary(二元), ternary(三元)等等。这个单词是由 -ary 与 -ity两个后缀拼接而成。例如，加法函数有两个参数，因此它被定义为二元函数(<code>binary function</code>)，或者说它的<code>arity</code> 是2。它也被那些更喜欢希腊词根而非拉丁词根的人称为<code>dyadic</code>。同样地，带有可变数量的参数的函数被称为<code>variadic</code>，而二元函数只能且必须带两个参数，尽管有柯里化(currying)和偏函数应用(partialapplication)的存在(见下文)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">a, b</span>) =&gt; a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arity = sum.<span class="property">length</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arity)        <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数sum的arity为2。</span></span><br></pre></td></tr></table></figure><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/arity.js">示例</a></p><div id="higher-order-functions-hof"></div><h2 id="高阶函数-higher-order-function-hof">高阶函数 (Higher-OrderFunction / HOF)</h2><p>以函数为参数或/和返回值的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">filter</span> = (<span class="params">predicate, xs</span>) =&gt; xs.<span class="title function_">filter</span>(predicate)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">is</span> = (<span class="params">type</span>) =&gt; <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="title class_">Object</span>(x) <span class="keyword">instanceof</span> type</span><br><span class="line"></span><br><span class="line"><span class="title function_">filter</span>(<span class="title function_">is</span>(<span class="title class_">Number</span>), [<span class="number">0</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">2</span>, <span class="literal">null</span>]) <span class="comment">// 0, 2</span></span><br></pre></td></tr></table></figure><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/hoc.js">示例</a></p><div id="closure"></div><h2 id="闭包-closure">闭包 (Closure)</h2><p>闭包是访问在其作用域外的变量的一种方式。正式地说，闭包是一种用于实现词法作用域命名绑定的技术。它是存储一个函数和它的环境的一种方法。</p><p>闭包是一个作用域，它会捕获函数的局部变量，因此即使执行过程已经移出了定义它的那个代码块，也可以访问它们。也就是说，它们允许在声明变量的代码块已经执行完成之后，还是可以引用这个作用域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">addTo</span> = x =&gt; <span class="function"><span class="params">y</span> =&gt;</span> x + y;</span><br><span class="line"><span class="keyword">var</span> addToFive = <span class="title function_">addTo</span>(<span class="number">5</span>);</span><br><span class="line"><span class="title function_">addToFive</span>(<span class="number">3</span>); <span class="comment">//返回 8</span></span><br></pre></td></tr></table></figure><p>函数<code>addTo()</code>返回了一个函数(在内部调用了<code>add()</code>)，我们将它保存在了一个叫做<code>addToFive</code>的变量中，并且柯里化地用一个参数5来调用它。</p><p>理想情况下，当函数<code>addTo</code>执行完成后，它的作用域，包括本地变量add(即+)，x，y，都应该无法访问了。但是，<code>addToFive()</code>的调用返回了8。这说明，<code>addTo</code>函数的状态被保存了，即使在代码块已经完成执行之后。否则，就不会知道<code>addTo</code>曾经被<code>addTo(5)</code>这样调用过，且x的值被设为了5。</p><p>词法作用域(lexicalscoping)是它能找到x和add这两个已经完成执行的父级私有变量的原因。这个值就称为闭包。</p><p>栈和函数的词法作用域被以父函数的引用的形式存储。这可以防止闭包和底层的变量被垃圾回收(因为至少有一个对它的有效引用)。</p><p>Lambda Vs闭包：Lambda本质上是一个内联定义的函数，而不是声明函数的标准方法。Lambda经常可以作为对象被传递。</p><p>闭包是通过引用其主体外部的字段来将其周围的状态包裹进来的函数。被包裹的状态在闭包调用期间保持不变。</p><div id="partial-application"></div><h2 id="偏函数应用-partial-application">偏函数应用 (PartialApplication)</h2><p>"部分地"应用一个函数，即预设原始函数的部分参数来创建一个新的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建偏函数，固定一些参数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">partial</span> = (<span class="params">f, ...args</span>) =&gt;</span><br><span class="line">  <span class="comment">// 返回一个带有剩余参数的函数</span></span><br><span class="line">  <span class="function">(<span class="params">...moreArgs</span>) =&gt;</span></span><br><span class="line">    <span class="comment">// 调用原始函数</span></span><br><span class="line">    <span class="title function_">f</span>(...args, ...moreArgs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add3</span> = (<span class="params">a, b, c</span>) =&gt; a + b + c <span class="comment">// (c) =&gt; 2 + 3 + c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分地将`2`和`3`应用于`add3`，得到一个只有一个参数的函数</span></span><br><span class="line"><span class="keyword">const</span> fivePlus = <span class="title function_">partial</span>(add3, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">fivePlus</span>(<span class="number">4</span>)  <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><p>也可以使用 <code>Function.prototype.bind</code> 实现偏函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add1More = add3.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// (c) =&gt; 2 + 3 + c</span></span><br></pre></td></tr></table></figure><p>偏函数应用通过对复杂的函数填充一部分数据来构成一个简单的函数。柯里化就是自动实现的偏函数。</p><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/partial.js">示例</a></p><div id="currying"></div><h2 id="柯里化-currying">柯里化 (Currying)</h2><p>将一个多元函数转变为一元函数的过程。每当函数被调用时，它仅仅接收一个参数并且返回带有一个参数的函数，直到传递完所有的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">a, b</span>) =&gt; a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">curriedSum</span> = (<span class="params">a</span>) =&gt; <span class="function">(<span class="params">b</span>) =&gt;</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="title function_">curriedSum</span>(<span class="number">3</span>)(<span class="number">4</span>)         <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add2 = <span class="title function_">curriedSum</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">add2</span>(<span class="number">10</span>)     <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/curry.js">示例</a></p><div id="auto-currying"></div><h2 id="自动柯里化-auto-currying">自动柯里化 (Auto Currying)</h2><p>将一个包含多个参数的函数转换成另一个函数，这个函数如果被给到的参数少于正确的数量，就会返回一个接受剩余参数的函数。</p><p>lodash &amp; Ramda 有一个<code>curry</code>函数可以做到这一点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">x, y</span>) =&gt; x + y</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curriedAdd = _.<span class="title function_">curry</span>(add)</span><br><span class="line"></span><br><span class="line"><span class="title function_">curriedAdd</span>(<span class="number">1</span>, <span class="number">2</span>)   <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">curriedAdd</span>(<span class="number">1</span>)(<span class="number">2</span>)   <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">curriedAdd</span>(<span class="number">1</span>)      <span class="comment">// (y) =&gt; 1 + y</span></span><br></pre></td></tr></table></figure><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/curry2.js">示例</a></p><h4 id="进一步阅读">进一步阅读</h4><ul><li><a href="http://fr.umio.us/favoring-curry/">Favoring Curry</a></li><li><a href="https://www.youtube.com/watch?v=m3svKOdZijA">HeyUnderscore, You're Doing It Wrong!</a></li></ul><div id="function-composition"></div><h2 id="函数组合-function-composition">函数组合 (FunctionComposition)</h2><p>把两个函数放在一起形成第三个函数的行为，一个函数的输入为另一个函数的输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">compose</span> = (<span class="params">f, g</span>) =&gt; <span class="function">(<span class="params">a</span>) =&gt;</span> <span class="title function_">f</span>(<span class="title function_">g</span>(a))    <span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">const</span> floorAndToString = <span class="title function_">compose</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> val.<span class="title function_">toString</span>(), <span class="title class_">Math</span>.<span class="property">floor</span>) <span class="comment">// 使用</span></span><br><span class="line"><span class="title function_">floorAndToString</span>(<span class="number">12.12</span>)   <span class="comment">// &#x27;12&#x27;</span></span><br></pre></td></tr></table></figure><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/compose.js">示例</a></p><div id="continuation"></div><h2 id="continuation-后续">Continuation (后续)</h2><p>在一个程序执行的任意时刻，尚未执行的代码称为 Continuation。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">printAsString</span> = (<span class="params">num</span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Given <span class="subst">$&#123;num&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addOneAndContinue</span> = (<span class="params">num, cc</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> result = num + <span class="number">1</span></span><br><span class="line">  <span class="title function_">cc</span>(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addOneAndContinue</span>(<span class="number">2</span>, printAsString) <span class="comment">// &#x27;Given 3&#x27;</span></span><br></pre></td></tr></table></figure><p>Continuation在异步编程中很常见，比如当程序需要接收到数据才能够继续执行。请求的响应通常作为代码的剩余执行部分，一旦接收到数据，对数据的处理被作为Continuation。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">continueProgramWith</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 继续执行程序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">readFileAsync</span>(<span class="string">&#x27;path/to/file&#x27;</span>, <span class="function">(<span class="params">err, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">continueProgramWith</span>(response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><div id="purity"></div><h2 id="纯函数-purity">纯函数 (Purity)</h2><p>输出仅由输入决定，且不产生副作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">greet</span> = (<span class="params">name</span>) =&gt; <span class="string">`hello, <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&#x27;world&#x27;</span>)</span><br></pre></td></tr></table></figure><p>以下代码不是纯函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;Brianne&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">greet</span> = (<span class="params"></span>) =&gt; <span class="string">`Hi, <span class="subst">$&#123;<span class="variable language_">window</span>.name&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>() <span class="comment">// &quot;Hi, Brianne&quot;</span></span><br></pre></td></tr></table></figure><p>以上示例中，函数输出基于在函数外部存储的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">greet</span> = (<span class="params">name</span>) =&gt; &#123;</span><br><span class="line">    greeting = <span class="string">`Hi, <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&#x27;Brianne&#x27;</span>)</span><br><span class="line">greeting <span class="comment">// &quot;Hi, Brianne&quot;</span></span><br></pre></td></tr></table></figure><p>以上示例中，函数修改了外部状态。</p><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/purity.js">示例</a></p><div id="side-effects"></div><h2 id="副作用-side-effects">副作用 (Side effects)</h2><p>如果一个函数或者表达式除了返回一个值之外，还与外部可变状态进行了交互（读取或写入），则它是有副作用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> differentEveryTime = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;IO就是一种副作用!&#x27;</span>)</span><br></pre></td></tr></table></figure><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/sideEffect.js">示例</a></p><div id="idempotent"></div><h2 id="幂等-idempotent">幂等 (Idempotent)</h2><p>如果一个函数执行多次皆返回相同的结果，则它是幂等的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">f</span>(<span class="title function_">f</span>(x)) ≍ <span class="title function_">f</span>(x)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">sort</span>(<span class="title function_">sort</span>(<span class="title function_">sort</span>([<span class="number">2</span>, <span class="number">1</span>])))</span><br></pre></td></tr></table></figure><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/idempotent.js">示例</a></p><div id="point-free-style"></div><h2 id="point-free-风格-point-free-style">Point-Free 风格 (Point-FreeStyle)</h2><p>定义函数时，不显式地指出函数所带参数。这种风格通常需要柯里化或者高阶函数。也叫Tacit programming。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已知：</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">map</span> = (<span class="params">fn</span>) =&gt; <span class="function">(<span class="params">list</span>) =&gt;</span> list.<span class="title function_">map</span>(fn)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a</span>) =&gt; <span class="function">(<span class="params">b</span>) =&gt;</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非Points-Free —— number 是显式参数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">incrementAll</span> = (<span class="params">numbers</span>) =&gt; <span class="title function_">map</span>(<span class="title function_">add</span>(<span class="number">1</span>))(numbers)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Points-Free —— list 是隐式参数</span></span><br><span class="line"><span class="keyword">const</span> incrementAll2 = <span class="title function_">map</span>(<span class="title function_">add</span>(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p><code>incrementAll</code> 识别并且使用了 <code>numbers</code>参数，因此它不是 Point-Free 风格的。 <code>incrementAll2</code>仅连接函数与值，并不提及它所使用的参数，因为它是 Point-Free 风格的。</p><p>Point-Free 风格的函数就像平常的赋值，不使用 <code>function</code>或者 <code>=&gt;</code>。</p><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/pointFree.js">示例</a></p><div id="predicate"></div><h2 id="断定-predicate">断定 (Predicate)</h2><p>根据输入返回 true 或 false。通常用在 array filter 的回调函数中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">predicate</span> = (<span class="params">a</span>) =&gt; a &gt; <span class="number">2</span></span><br><span class="line"></span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_">filter</span>(predicate)</span><br></pre></td></tr></table></figure><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/predicate.js">示例</a></p><div id="contracts"></div><h2 id="契约-contracts">契约 (Contracts)</h2><p>契约规定了函数或表达式在运行时的行为的职责和保障。它表现为一组规则，这些规则是对函数或表达式的输入和输出的期望。当违反契约时，将抛出一个错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义的contract: int -&gt; boolean</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">contract</span> = (<span class="params">input</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> input === <span class="string">&#x27;number&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Contract Violated: expected int -&gt; int&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addOne</span> = (<span class="params">num</span>) =&gt; <span class="title function_">contract</span>(num) &amp;&amp; num + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">addOne</span>(<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">addOne</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// 违反了contract: int -&gt; boolean</span></span><br></pre></td></tr></table></figure><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/contracts.js">示例</a></p><div id="category"></div><h2 id="范畴-category">范畴 (Category)</h2><p>在范畴论中，范畴是指对象集合及它们之间的态射(morphism)。在编程中，数据类型作为对象，函数作为态射。</p><p>一个有效的范畴遵从以下三个原则：</p><ol type="1"><li>必有一个同一态射（identity morphism）将一个对象映射到它自身。即当<code>a</code> 是范畴里的一个对象时，必有一个函数使<code>a -&gt; a</code>。</li><li>态射必是可组合的。<code>a</code>，<code>b</code>，<code>c</code>是范畴里的对象，<code>f</code> 是态射<code>a -&gt; b</code>，<code>g</code> 是 <code>b -&gt; c</code>态射。<code>g(f(x))</code> 一定与 <code>(g • f)(x)</code>是等价的。</li><li>组合满足结合律。<code>f • (g • h)</code> 与 <code>(f • g) • h</code>是等价的。</li></ol><p>由于这些准则是在非常抽象的层面控制着组合方式，因此范畴论对于发现组合的新方法来说是伟大的。</p><h4 id="进一步阅读-1">进一步阅读</h4><ul><li><ahref="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">CategoryTheory for Programmers</a></li></ul><div id="value"></div><h2 id="值-value">值 (Value)</h2><p>任何可以赋给变量的东西叫做值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;)</span><br><span class="line">;<span class="function">(<span class="params">a</span>) =&gt;</span> a</span><br><span class="line">;[<span class="number">1</span>]</span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/value.js">示例</a></p><div id="constant"></div><h2 id="常量-constant">常量 (Constant)</h2><p>一旦被定义之后就不可以被重新赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> five = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> john = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;)</span><br></pre></td></tr></table></figure><p>常量是<ahref="#referential-transparency">引用透明</a>的，也就是说，它们可以被它们所代表的值替代而不影响结果。</p><p>对于以上两个常量，以下语句总会返回 true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john.<span class="property">age</span> + five === (&#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;).<span class="property">age</span> + (<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/constant.js">示例</a></p><div id="functor"></div><h2 id="函子-functor">函子 (Functor)</h2><p>函子是一个实现了 <code>map</code> 函数的对象。<code>map</code>函数会遍历对象中的每个值并生成一个新的对象，遵守两个准则:</p><div id="preserves-identity"></div><h3 id="一致性-preserves-identity">一致性 (Preserves identity)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x) ≍ object</span><br></pre></td></tr></table></figure><div id="composable"></div><h3 id="组合性-composable">组合性 (Composable)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.<span class="title function_">map</span>(<span class="title function_">compose</span>(f, g)) ≍ object.<span class="title function_">map</span>(g).<span class="title function_">map</span>(f)  <span class="comment">// f, g 为任意函数</span></span><br></pre></td></tr></table></figure><p>(<code>f</code>, <code>g</code> 是任意的函数)</p><p>在 javascript 中一个常见的函子是 Array,因为它遵守因子的两个准则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = x =&gt; x + <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">g</span> = x =&gt; x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="title function_">f</span>(<span class="title function_">g</span>(x)))</span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(g).<span class="title function_">map</span>(f)</span><br></pre></td></tr></table></figure><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/functor.js">示例</a></p><div id="pointed-functor"></div><h3 id="指向函子-pointed-functor">指向函子 (Pointed Functor)</h3><p>一个对象，拥有一个<code>of</code>函数，可以将一个任何值放入它自身。</p><p>ES2015 添加了 <code>Array.of</code>，使 Array 成为了 PointedFunctor。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><div id="lift"></div><h2 id="抬升-lift">抬升 (Lift)</h2><p>抬升是指将一个值放进一个对象（如<ahref="#functor">函子</a>）中。如果你将一个函数抬升到一个<ahref="#applicative-functor">应用函子</a>中，那么就可以将它作用于该函子中的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">liftA2</span> = (<span class="params">f</span>) =&gt; <span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="title function_">map</span>(f).<span class="title function_">ap</span>(b) <span class="comment">// 注意这里是 ap 而不是 map.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mult</span> = a =&gt; <span class="function"><span class="params">b</span> =&gt;</span> a * b</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> liftedMult = <span class="title function_">liftA2</span>(mult) <span class="comment">// 这个函数现在可以作用于函子，如Array</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">liftedMult</span>([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>]) <span class="comment">// [3, 6]</span></span><br><span class="line"><span class="title function_">liftA2</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="function"><span class="params">b</span> =&gt;</span> a + b)([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]) <span class="comment">// [4, 5, 5, 6]</span></span><br></pre></td></tr></table></figure><p>抬升并应用一个单参数的函数的作用等同于 <code>map</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params">x</span>) =&gt; x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">lift</span>(increment)([<span class="number">2</span>]) <span class="comment">// [3]</span></span><br><span class="line">;[<span class="number">2</span>].<span class="title function_">map</span>(increment) <span class="comment">// [3]</span></span><br></pre></td></tr></table></figure><div id="referential-transparency"></div><h2 id="引用透明性-referential-transparency">引用透明性 (ReferentialTransparency)</h2><p>如果一个表达式能够被它的值替代而不改变程序的行为，则它是引用透明的。</p><p>例如我们有 greet 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">greet</span> = (<span class="params"></span>) =&gt; <span class="string">&#x27;hello, world.&#x27;</span></span><br></pre></td></tr></table></figure><p>任何对 <code>greet()</code> 的调用都可以被替换为<code>Hello World!</code>, 因此 greet 是引用透明的。</p><div id="equational-reasoning"></div><h2 id="等式推理-equational-reasoning">等式推理 (EquationalReasoning)</h2><p>当一个应用程序由表达式组成并且没有副作用时，我们可以从这些组成部分中得知系统的真相。</p><div id="lambda"></div><h2 id="lambda">Lambda</h2><p>一种可以被视作一个值的匿名函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="keyword">function</span> (<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">;<span class="function">(<span class="params">a</span>) =&gt;</span> a + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>Lambda 通常作为参数被传递给高阶函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">a</span>) =&gt;</span> a + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>可以把 Lambda 赋值给一个变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add1</span> = (<span class="params">a</span>) =&gt; a + <span class="number">1</span></span><br></pre></td></tr></table></figure><div id="lambda-calculus"></div><h2 id="lambda演算-lambda-calculus">Lambda演算 (Lambda Calculus)</h2><p>数学的一个分支，使用函数创造 <ahref="https://en.wikipedia.org/wiki/Lambda_calculus">通用计算模型</a></p><div id="lazy-evaluation"></div><h2 id="惰性求值-lazy-evaluation">惰性求值 (Lazy evaluation)</h2><p>惰性求值是一种按需调用的求值机制，它将表达式的求值延迟到需要它的值为止，在函数式语言中，允许类似无限列表这样的结构存在，而这在非常重视命令顺序的命令式语言中通常是不可用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rand = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title class_">Math</span>.<span class="title function_">random</span>()  </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> randIter = <span class="title function_">rand</span>()</span><br><span class="line">randIter.<span class="title function_">next</span>() <span class="comment">// 每次执行产生一个随机值，表达式会在需要时求值。</span></span><br></pre></td></tr></table></figure><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/functor.js">示例</a></p><div id="monoid"></div><h2 id="幺半群-monoid">幺半群 (Monoid)</h2><p>一个对象，它拥有一个函数，这个函数用来与另一个相同类型的对象"结合"。对象的类型（<ahref="#semigroup">半群</a>）必须具有一个"identity"值。</p><p>数值加法是一个简单的幺半群:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">1</span>   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>以上示例中，数是对象而 <code>+</code> 是函数。</p><p>当任何一个值与"identity"值结合时，结果一定是原始的值。"identity"也是可换位的（即排列次序不影响结果）。</p><p>加法的特征值是 0。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">0</span>   <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>操作的组合不会影响结果（必须满足结合律）:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + (<span class="number">2</span> + <span class="number">3</span>) === (<span class="number">1</span> + <span class="number">2</span>) + <span class="number">3</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>数组的结合也是幺半群:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;[<span class="number">1</span>, <span class="number">2</span>].<span class="title function_">concat</span>([<span class="number">3</span>, <span class="number">4</span>]) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p><code>identity</code> 值为空数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;[<span class="number">1</span>, <span class="number">2</span>].<span class="title function_">concat</span>([])</span><br></pre></td></tr></table></figure><p>减法作为一个反例，不形成幺半群，因为不存在可以换位的"identity"值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> - <span class="number">4</span> === <span class="number">4</span> - <span class="number">0</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/monoid.js">示例</a></p><div id="monad"></div><h2 id="单子-monad">单子 (Monad)</h2><p>拥有 <code>of</code> 和 <code>chain</code>函数的对象即为单子。<code>chain</code> 很像 <code>map</code>，不同的是它可以展平嵌套数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">chain</span> = <span class="keyword">function</span> (<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, it</span>) =&gt;</span> acc.<span class="title function_">concat</span>(<span class="title function_">f</span>(it)), [])  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">;<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="string">&#x27;cat,dog&#x27;</span>, <span class="string">&#x27;fish,bird&#x27;</span>).<span class="title function_">chain</span>(<span class="function"><span class="params">s</span> =&gt;</span> s.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)) <span class="comment">// [&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;fish&#x27;, &#x27;bird&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 和 map 相比</span></span><br><span class="line">;<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="string">&#x27;cat,dog&#x27;</span>, <span class="string">&#x27;fish,bird&#x27;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">s</span> =&gt;</span> s.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)) <span class="comment">// [[&#x27;cat&#x27;, &#x27;dog&#x27;], [&#x27;fish&#x27;, &#x27;bird&#x27;]]</span></span><br></pre></td></tr></table></figure><p>在有些函数式语言中，<code>of</code> 也称为<code>return</code>，<code>chain</code> 也称为 <code>flatmap</code> 与<code>bind</code>。</p><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/monad.js">示例</a></p><div id="comonad"></div><h2 id="余单子-comonad">余单子 (Comonad)</h2><p>拥有 <code>extract</code> 与 <code>extend</code> 函数的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">CoIdentity</span> = (<span class="params">v</span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">val</span>: v,</span><br><span class="line">  extract () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">val</span>  </span><br><span class="line">  &#125;,</span><br><span class="line">  extend (f) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">CoIdentity</span>(<span class="title function_">f</span>(<span class="variable language_">this</span>))  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Extract 将值从余单子中取出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">CoIdentity</span>(<span class="number">1</span>).<span class="title function_">extract</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>Extends在余单子上运行一个函数。这个函数会返回和余单子相同的类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">CoIdentity</span>(<span class="number">1</span>).<span class="title function_">extend</span>(<span class="function"><span class="params">x</span> =&gt;</span> x.<span class="title function_">extract</span>() + <span class="number">1</span>) <span class="comment">// CoIdentity(2)</span></span><br></pre></td></tr></table></figure><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/comonad.js">示例</a></p><div id="applicative-functor"></div><h2 id="应用函子-applicative-functor">应用函子 (ApplicativeFunctor)</h2><p>一个拥有 <code>ap</code> 函数的对象称为应用函子。<code>ap</code>将对象中的函数应用于另一个同样类型的对象中的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">ap</span> = <span class="keyword">function</span> (<span class="params">xs</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, f</span>) =&gt;</span> acc.<span class="title function_">concat</span>(xs.<span class="title function_">map</span>(f)), [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">;[<span class="function">(<span class="params">a</span>) =&gt;</span> a + <span class="number">1</span>].<span class="title function_">ap</span>([<span class="number">1</span>]) <span class="comment">// [2]</span></span><br></pre></td></tr></table></figure><p>如果你有两个对象，并需要对他们的元素执行一个二元函数，这将会很有用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 你想要组合的两个数组</span></span><br><span class="line"><span class="keyword">const</span> arg1 = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> arg2 = [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合函数 - 必须要柯里化</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">x</span>) =&gt; <span class="function">(<span class="params">y</span>) =&gt;</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> partiallyAppliedAdds = [add].<span class="title function_">ap</span>(arg1) <span class="comment">// [(y) =&gt; 1 + y, (y) =&gt; 3 + y]</span></span><br></pre></td></tr></table></figure><p>由此得到了一个函数数组，并且可以调用 <code>ap</code>函数得到结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">partiallyAppliedAdds.<span class="title function_">ap</span>(arg2) <span class="comment">// [5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/applicativeFunctor.js">示例</a></p><div id="morphism"></div><h2 id="态射-morphism">态射 (Morphism)</h2><p>一个变形函数。</p><div id="endomorphism"></div><h3 id="endomorphism-自同态">Endomorphism (自同态)</h3><p>输入输出是相同类型的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uppercase :: String -&gt; String</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">uppercase</span> = (<span class="params">str</span>) =&gt; str.<span class="title function_">toUpperCase</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// decrement :: Number -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params">x</span>) =&gt; x - <span class="number">1</span></span><br></pre></td></tr></table></figure><div id="isomorphism"></div><h3 id="isomorphism-同构">Isomorphism (同构)</h3><p>两个不用类型的对象之间的变换，保持结构并且不丢失数据。</p><p>例如，一个二维坐标既可以表示为数组<code>[2, 3]</code>，也可以表示为对象 <code>&#123;x: 2, y: 3&#125;</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供函数在两种类型间互相转换</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">pairToCoords</span> = (<span class="params">pair</span>) =&gt; (&#123;<span class="attr">x</span>: pair[<span class="number">0</span>], <span class="attr">y</span>: pair[<span class="number">1</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">coordsToPair</span> = (<span class="params">coords</span>) =&gt; [coords.<span class="property">x</span>, coords.<span class="property">y</span>]</span><br><span class="line"></span><br><span class="line"><span class="title function_">coordsToPair</span>(<span class="title function_">pairToCoords</span>([<span class="number">1</span>, <span class="number">2</span>])) <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">pairToCoords</span>(<span class="title function_">coordsToPair</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;)) <span class="comment">// &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure><div id="homomorphism"></div><h3 id="homomorphism-同态">Homomorphism (同态)</h3><p>同态只是一个保持结构的映射，实际上，函子只是<ahref="#category">范畴</a>之间的同态，因为它在映射下保持了原范畴的结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.<span class="title function_">of</span>(f).<span class="title function_">ap</span>(A.<span class="title function_">of</span>(x)) == A.<span class="title function_">of</span>(<span class="title function_">f</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="title class_">Either</span>.<span class="title function_">of</span>(_.<span class="property">toUpper</span>).<span class="title function_">ap</span>(<span class="title class_">Either</span>.<span class="title function_">of</span>(<span class="string">&quot;oreos&quot;</span>)) == <span class="title class_">Either</span>.<span class="title function_">of</span>(_.<span class="title function_">toUpper</span>(<span class="string">&quot;oreos&quot;</span>))</span><br></pre></td></tr></table></figure><div id="catamorphism"></div><h3 id="catamorphism">Catamorphism</h3><p>一个 <code>reduceRight</code>函数，它应用于累加器(accumulator)和数组中的每个值（从右到左），来将其缩减为一个单一的值。</p><div id="anamorphism"></div><h3 id="anamorphism">Anamorphism</h3><p>一个 <code>unfold</code> 函数。<code>unfold</code> 是<code>fold</code>（<code>ruduce</code>）的反面。它从一个值生成一个列表。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">unfold</span> = (<span class="params">f, seed</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">go</span>(<span class="params">f, seed, acc</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="title function_">f</span>(seed);</span><br><span class="line">    <span class="keyword">return</span> res ? <span class="title function_">go</span>(f, res[<span class="number">1</span>], acc.<span class="title function_">concat</span>([res[<span class="number">0</span>]])) : acc;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">go</span>(f, seed, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">countDown</span> = n =&gt; <span class="title function_">unfold</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> n &lt;= <span class="number">0</span> ? <span class="literal">undefined</span> : [n, n - <span class="number">1</span>]</span><br><span class="line">&#125;, n)</span><br><span class="line"></span><br><span class="line"><span class="title function_">countDown</span>(<span class="number">5</span>) <span class="comment">// [5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure><div id="hylomorphism"></div><h3 id="hylomorphism">Hylomorphism</h3><p>Anamorphism 和 catamorphism 的结合。</p><div id="paramorphism"></div><h3 id="paramorphism">Paramorphism</h3><p>一类类似于 <code>reduceRight</code> 的函数，不过还是有区别的：</p><p>在Paramorphism中，reducer的参数是当前的值、所有先前的值的缩减(reduction，即reduce的结果)、以及形成该缩减的值的列表。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含 undefined 对于列表来说显然是不安全的，</span></span><br><span class="line"><span class="comment">// 但是足以说明问题。</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">para</span> = (<span class="params">reducer, accumulator, elements</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (elements.<span class="property">length</span> === <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> accumulator</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> head = elements[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> tail = elements.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">reducer</span>(head, tail, <span class="title function_">para</span>(reducer, accumulator, tail))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">suffixes</span> = list =&gt; <span class="title function_">para</span>(</span><br><span class="line">  <span class="function">(<span class="params">x, xs, suffxs</span>) =&gt;</span> [xs, ... suffxs],</span><br><span class="line">  [],</span><br><span class="line">  list</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="title function_">suffixes</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) <span class="comment">// [[2, 3, 4, 5], [3, 4, 5], [4, 5], [5], []]</span></span><br></pre></td></tr></table></figure><p>上面的例子中的reducer（<code>[x, ... xs]</code>）的第三个参数有点像一个"如何达到你当前的acc 值"的历史记录。</p><div id="apomorphism"></div><h3 id="apomorphism">Apomorphism</h3><p>paramorphism 的反面。就像 anamorphism 是 catamorphism的反面一样。对于paramorphism，我们结合了对累加器的访问和已经累加的东西，而apomorphism让我们可以unfold（展开）并且具有提早return的可能性。</p><div id="setoid"></div><h2 id="setoid">Setoid</h2><p>拥有 <code>equals</code> 函数的对象。<code>equals</code>可以用来和其它相同类型的对象比较。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">equals</span> = <span class="keyword">function</span> (<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> len = <span class="variable language_">this</span>.<span class="property">length</span></span><br><span class="line">  <span class="keyword">if</span> (len !== arr.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>[i] !== arr[i]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>].<span class="title function_">equals</span>([<span class="number">1</span>, <span class="number">2</span>])   <span class="comment">// true</span></span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>].<span class="title function_">equals</span>([<span class="number">3</span>, <span class="number">4</span>])   <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/setoid.js">示例</a></p><div id="semigroup"></div><h2 id="半群-semigroup">半群 (Semigroup)</h2><p>一个拥有 <code>concat</code> 函数的对象。<code>concat</code>可以连接相同类型的两个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;[<span class="number">1</span>].<span class="title function_">concat</span>([<span class="number">2</span>]) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/semigroup.js">示例</a></p><div id="foldable"></div><h2 id="可折叠性-foldable">可折叠性 (Foldable)</h2><p>一个拥有 <code>reduce</code>函数的对象具有可折叠性。<code>reduce</code>可以把一种类型的对象转化为另一种类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">list</span>) =&gt; list.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc + val, <span class="number">0</span>)</span><br><span class="line"><span class="title function_">sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])        <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><div id="lens"></div><h2 id="透镜-lens">透镜 (Lens)</h2><p>Lens是一种结构（通常是一个对象或者函数），他为其他数据结构对 getter和非可变的 setter 进行配对。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 [Ramda&#x27;s lens](http://ramdajs.com/docs/#lens)</span></span><br><span class="line"><span class="keyword">const</span> nameLens = R.<span class="title function_">lens</span>(</span><br><span class="line">  <span class="comment">// 一个对象的 name 属性的 getter</span></span><br><span class="line">  <span class="function">(<span class="params">obj</span>) =&gt;</span> obj.<span class="property">name</span>,</span><br><span class="line">  <span class="comment">// name 属性的 setter</span></span><br><span class="line">  <span class="function">(<span class="params">val, obj</span>) =&gt;</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj, &#123;<span class="attr">name</span>: val&#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>为给定的数据结构设置 <code>get</code> 和 <code>set</code>可以实现一些关键特性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;Gertrude Blanch&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 getter</span></span><br><span class="line">R.<span class="title function_">view</span>(nameLens, person) <span class="comment">// &#x27;Gertrude Blanch&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 setter</span></span><br><span class="line">R.<span class="title function_">set</span>(nameLens, <span class="string">&#x27;Shafi Goldwasser&#x27;</span>, person) <span class="comment">// &#123;name: &#x27;Shafi Goldwasser&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将函数应用于结构中的值</span></span><br><span class="line">R.<span class="title function_">over</span>(nameLens, uppercase, person) <span class="comment">// &#123;name: &#x27;GERTRUDE BLANCH&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>lens也是可以组合的。这让我们可以对深度嵌套的数据进行简单的不可变更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个 lens 关注一个非空数组中的第一个元素</span></span><br><span class="line"><span class="keyword">const</span> firstLens = R.<span class="title function_">lens</span>(</span><br><span class="line">  <span class="comment">// 获取数组的第一个元素</span></span><br><span class="line">  <span class="function"><span class="params">xs</span> =&gt;</span> xs[<span class="number">0</span>],</span><br><span class="line">  <span class="comment">// 数组的第一个元素的非可变 setter</span></span><br><span class="line">  <span class="function">(<span class="params">val, [__, ...xs]</span>) =&gt;</span> [val, ...xs]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> people = [&#123;<span class="attr">name</span>: <span class="string">&#x27;Gertrude Blanch&#x27;</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&#x27;Shafi Goldwasser&#x27;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无论你怎么想，lens 是从左到右合成的</span></span><br><span class="line">R.<span class="title function_">over</span>(<span class="title function_">compose</span>(firstLens, nameLens), uppercase, people) <span class="comment">// [&#123;&#x27;name&#x27;: &#x27;GERTRUDE BLANCH&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;Shafi Goldwasser&#x27;&#125;]</span></span><br></pre></td></tr></table></figure><p>其他实现:</p><p><ahref="https://github.com/calmm-js/partial.lenses">partial.lenses</a> -"好吃"的语法糖和很多强大功能</p><p><a href="http://www.kovach.me/nanoscope/">nanoscope</a> -流畅接口</p><div id="type-signatures"></div><h2 id="类型签名-type-signatures">类型签名 (Type Signatures)</h2><p>通常 js 中的函数会在注释中指出参数与返回值的类型。</p><p>在整个社区内存在很大的差异，但通常遵循以下模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functionName :: firstArgType -&gt; secondArgType -&gt; returnType</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add :: Number -&gt; Number -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">x</span>) =&gt; <span class="function">(<span class="params">y</span>) =&gt;</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment">// increment :: Number -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params">x</span>) =&gt; x + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果函数接受其他函数作为参数，那么这个函数需要用括号括起来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call :: (a -&gt; b) -&gt; a -&gt; b</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">call</span> = (<span class="params">f</span>) =&gt; <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="title function_">f</span>(x)</span><br></pre></td></tr></table></figure><p>字符 <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>表明参数可以是任意类型。以下版本的 <code>map</code> 的函数类型的参数<code>f</code>，把一种类型 <code>a</code> 的数组转化为另一种类型<code>b</code> 的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map :: (a -&gt; b) -&gt; [a] -&gt; [b]</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">map</span> = (<span class="params">f</span>) =&gt; <span class="function">(<span class="params">list</span>) =&gt;</span> list.<span class="title function_">map</span>(f)</span><br></pre></td></tr></table></figure><p>进一步阅读：</p><ul><li><ahref="https://github.com/ramda/ramda/wiki/Type-Signatures">Ramda's typesignatures</a></li><li><ahref="https://stackoverflow.com/questions/399312/what-is-hindley-milner/399392#399392">Whatis Hindley-Milner?</a> on Stack Overflow</li></ul><div id="algebraic-data-type"></div><h2 id="代数数据类型-algebraic-data-type">代数数据类型 (Algebraic datatype)</h2><p>一种由其他类型组合而成的复合类型。两种常见的代数类型是<ahref="#sum-type">sum</a>和<a href="#product-type">product</a>。</p><div id="sum-type"></div><h3 id="和类型-sum-type">和类型 (Sum type)</h3><p>和类型是将两种类型组合成另一种类型。之所以称为和，是因为结果类型的可能的值的数目是两种输入类型的值的数目的和。</p><p>js 中没有这种类型，但是我们可以用 set 来假装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 想象这些不是 set，而是仅包含这些值的某种类型。</span></span><br><span class="line"><span class="keyword">const</span> bools = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="literal">true</span>, <span class="literal">false</span>])</span><br><span class="line"><span class="keyword">const</span> halfTrue = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;half-true&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 weakLogic 类型包含 bools 类型和 halfTrue 类型的和。</span></span><br><span class="line"><span class="keyword">const</span> weakLogicValues = <span class="keyword">new</span> <span class="title class_">Set</span>([...bools, ...halfTrue])</span><br></pre></td></tr></table></figure><p>和类型有时也称作联合类型（union type）、区分联合（discriminatedunion）或标记联合（tagged unions）。</p><p>JS中有一些库可以帮助定义和使用联合类型。</p><p>流（flow）包括联合类型，而TypeScript具有提供相同能力的枚举（enum）。</p><div id="product-type"></div><h3 id="product-type">Product type</h3><p>用一种你可能更熟悉的方式把数据类型联合起来:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// point :: (Number, Number) -&gt; &#123;x: Number, y: Number&#125;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">point</span> = (<span class="params">x, y</span>) =&gt; (&#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;)</span><br></pre></td></tr></table></figure><p>之所以称之为积，是因为数据结构的总的可能值是不同值的乘积。许多语言都有tuple 类型，这是积类型的最简单形式。</p><p>另见 <a href="https://en.wikipedia.org/wiki/Set_theory">Settheory</a></p><div id="option"></div><h2 id="可选类型-option">可选类型 (Option)</h2><p>Option 是一种联合类型，它有两种情况，<code>Some</code> 或者<code>None</code>。</p><p>Option对于一些可能不会返回值的组合函数非常有用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Some</span> = (<span class="params">v</span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">val</span>: v,</span><br><span class="line">  map (f) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Some</span>(<span class="title function_">f</span>(<span class="variable language_">this</span>.<span class="property">val</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">  chain (f) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">f</span>(<span class="variable language_">this</span>.<span class="property">val</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">None</span> = (<span class="params"></span>) =&gt; (&#123;</span><br><span class="line">  map (f) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;,</span><br><span class="line">  chain (f) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// maybeProp :: (String, &#123;a&#125;) -&gt; Option a</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">maybeProp</span> = (<span class="params">key, obj</span>) =&gt; <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;undefined&#x27;</span> ? <span class="title class_">None</span>() : <span class="title class_">Some</span>(obj[key])</span><br></pre></td></tr></table></figure><p>使用 <code>chain</code> 可以序列化返回 <code>Option</code>的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getItem :: Cart -&gt; Option CartItem</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getItem</span> = (<span class="params">cart</span>) =&gt; <span class="title function_">maybeProp</span>(<span class="string">&#x27;item&#x27;</span>, cart)</span><br><span class="line"></span><br><span class="line"><span class="comment">// getPrice :: Item -&gt; Option Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getPrice</span> = (<span class="params">item</span>) =&gt; <span class="title function_">maybeProp</span>(<span class="string">&#x27;price&#x27;</span>, item)</span><br><span class="line"></span><br><span class="line"><span class="comment">// getNestedPrice :: cart -&gt; Option a</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getNestedPrice</span> = (<span class="params">cart</span>) =&gt; <span class="title function_">getItem</span>(obj).<span class="title function_">chain</span>(getPrice)</span><br><span class="line"></span><br><span class="line"><span class="title function_">getNestedPrice</span>(&#123;&#125;) <span class="comment">// None()</span></span><br><span class="line"><span class="title function_">getNestedPrice</span>(&#123;<span class="attr">item</span>: &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;&#125;) <span class="comment">// None()</span></span><br><span class="line"><span class="title function_">getNestedPrice</span>(&#123;<span class="attr">item</span>: &#123;<span class="attr">price</span>: <span class="number">9.99</span>&#125;&#125;) <span class="comment">// Some(9.99)</span></span><br></pre></td></tr></table></figure><p>在其它的一些地方，<code>Option</code> 也称为<code>Maybe</code>，<code>Some</code> 也称为<code>Just</code>，<code>None</code> 也称为 <code>Nothing</code>。</p><p><ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/option.js">示例option.js</a> <ahref="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/maybe.js">示例maybe.js</a></p><div id="function"></div><h2 id="function">Function</h2><p>一个函数 <code>f :: A =&gt; B</code> 是一个表达式，通常称为 arrow或者 lambda 表达式——只能有<strong>一个</strong>（这点是不可变的）的<code>A</code> 类型参数和<strong>一个</strong> <code>B</code>类型返回值。该返回值完全取决于参数，使函数独立于上下文，或者说<ahref="#referential-transparency">引用透明</a>。这里暗示的是一个函数不能产生任何隐藏的<ahref="#side-effects">副作用</a>——根据定义，函数总是<ahref="#purity">纯</a>的。这些属性使函数易于使用：它们是完全确定的，因此也是可以预测的。函数可以将代码作为数据进行处理，对行为进行抽象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// times2 :: Number -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">times2</span> = n =&gt; n * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(times2) <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure><div id="partial-function"></div><h2 id="偏函数-partial-function">偏函数 (Partial function)</h2><p>偏函数是没有为全部参数定义的函数——它可能返回意料之外的结果或者永远不会终止。偏函数增加了认知开销，它们更难推理，并可能导致运行时错误。一些例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1: 列表的和</span></span><br><span class="line"><span class="comment">// sum :: [Number] -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = arr =&gt; arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line"><span class="title function_">sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">sum</span>([]) <span class="comment">// TypeError: Reduce of empty array with no initial value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2: 获取列表的第一个值</span></span><br><span class="line"><span class="comment">// first :: [A] -&gt; A</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">first</span> = a =&gt; a[<span class="number">0</span>]</span><br><span class="line"><span class="title function_">first</span>([<span class="number">42</span>]) <span class="comment">// 42</span></span><br><span class="line"><span class="title function_">first</span>([]) <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 甚至更糟: </span></span><br><span class="line"><span class="title function_">first</span>([[<span class="number">42</span>]])[<span class="number">0</span>] <span class="comment">// 42</span></span><br><span class="line"><span class="title function_">first</span>([])[<span class="number">0</span>] <span class="comment">// Uncaught TypeError: Cannot read property &#x27;0&#x27; of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例3: 将函数重复 N 次</span></span><br><span class="line"><span class="comment">// times :: Number -&gt; (Number -&gt; Number) -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">times</span> = n =&gt; <span class="function"><span class="params">fn</span> =&gt;</span> n &amp;&amp; (<span class="title function_">fn</span>(n), <span class="title function_">times</span>(n - <span class="number">1</span>)(fn))</span><br><span class="line"><span class="title function_">times</span>(<span class="number">3</span>)(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="title function_">times</span>(-<span class="number">1</span>)(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line"><span class="comment">// RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure><h3 id="处理偏函数">处理偏函数</h3><p>偏函数是危险的，它们需要被非常谨慎地对待。你可能会得到意料之外的（错误的）结果或遇到运行时错误。有时偏函数可能根本不会返回。意识到并相应地处理所有这些边缘情况可能会变得非常乏味。幸运的是，部分函数可以转换为常规函数。我们可以提供默认值或使用guard 来处理偏函数未定义的输入。利用 option类型，我们可以在可能会出现意外行为的地方使用 yield<code>Some(value)</code> 或 <code>None</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1: 列表的和</span></span><br><span class="line"><span class="comment">// 我们可以提供默认值，使它总会返回结果</span></span><br><span class="line"><span class="comment">// sum :: [Number] -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = arr =&gt; arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>)</span><br><span class="line"><span class="title function_">sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">sum</span>([]) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2: 获取列表的第一个值</span></span><br><span class="line"><span class="comment">// 将结果改为 Option</span></span><br><span class="line"><span class="comment">// first :: [A] -&gt; A</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">first</span> = a =&gt; a.<span class="property">length</span> ? <span class="title class_">Some</span>(a[<span class="number">0</span>]) : <span class="title class_">None</span>()</span><br><span class="line"><span class="title function_">first</span>([<span class="number">42</span>]).<span class="title function_">map</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a)) <span class="comment">// 42</span></span><br><span class="line"><span class="title function_">first</span>([]).<span class="title function_">map</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a)) <span class="comment">// console.log 不会执行</span></span><br><span class="line"><span class="comment">//我们之前的糟糕情况</span></span><br><span class="line"><span class="title function_">first</span>([[<span class="number">42</span>]]).<span class="title function_">map</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="number">0</span>])) <span class="comment">// 42</span></span><br><span class="line"><span class="title function_">first</span>([]).<span class="title function_">map</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="number">0</span>])) <span class="comment">// 不会执行，所以不会有 error</span></span><br><span class="line"><span class="comment">// 更重要的是，通过返回类型 (Option) ，我们会知道：</span></span><br><span class="line"><span class="comment">// 我们应该使用 .map 方法来访问数据，所以我们不会忘记检查输入，</span></span><br><span class="line"><span class="comment">// 因为这样的检查会被内建在函数中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例3: 将函数重复 N 次</span></span><br><span class="line"><span class="comment">// 我们需要通过改变条件来确保函数总会终止: </span></span><br><span class="line"><span class="comment">// times :: Number -&gt; (Number -&gt; Number) -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">times</span> = n =&gt; <span class="function"><span class="params">fn</span> =&gt;</span> n &gt; <span class="number">0</span> &amp;&amp; (<span class="title function_">fn</span>(n), <span class="title function_">times</span>(n - <span class="number">1</span>)(fn))</span><br><span class="line"><span class="title function_">times</span>(<span class="number">3</span>)(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="title function_">times</span>(-<span class="number">1</span>)(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line"><span class="comment">// 不会再执行</span></span><br></pre></td></tr></table></figure><p>将偏函数改成全函数可以防止此类运行时错误。总是返回一个"值"也会使得代码更容易维护和推理。</p><div id="functional-programing-libraries-in-javascript"></div><h2 id="在-js-中的函数式编程库">在 js 中的函数式编程库</h2><ul><li><a href="https://github.com/swannodette/mori">mori</a></li><li><ahref="https://github.com/facebook/immutable-js/">Immutable</a></li><li><a href="https://github.com/immerjs/immer">Immer</a></li><li><a href="https://github.com/ramda/ramda">Ramda</a></li><li><ahref="https://github.com/char0n/ramda-adjunct">ramda-adjunct</a></li><li><a href="http://folktalejs.org">Folktale</a></li><li><a href="https://cwmyers.github.io/monet.js/">monet.js</a></li><li><a href="https://github.com/lodash/lodash">lodash</a></li><li><ahref="https://github.com/jashkenas/underscore">Underscore.js</a></li><li><a href="https://github.com/dtao/lazy.js">Lazy.js</a></li><li><ahref="https://github.com/sjsyrek/maryamyriameliamurphies.js">maryamyriameliamurphies.js</a></li><li><a href="https://github.com/casualjavascript/haskell-in-es6">Haskellin ES6</a></li><li><ahref="https://github.com/sanctuary-js/sanctuary">Sanctuary</a></li><li><a href="https://github.com/evilsoft/crocks">Crocks</a></li><li><a href="https://github.com/fluture-js/Fluture">Fluture</a></li><li><a href="https://github.com/gcanti/fp-ts">fp-ts</a></li></ul>]]></content>
    
    
    <summary type="html">介绍函数式编程中的一些术语（基于 JavaScript)</summary>
    
    
    
    <category term="函数式编程" scheme="https://xinransix.github.io/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="函数式编程" scheme="https://xinransix.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="范畴论" scheme="https://xinransix.github.io/tags/%E8%8C%83%E7%95%B4%E8%AE%BA/"/>
    
    <category term="JavaScript" scheme="https://xinransix.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>石蒜模拟器——为 Next 主题加上🐟吧~</title>
    <link href="https://xinransix.github.io/2024/02/23/%E7%9F%B3%E8%92%9C%E6%A8%A1%E6%8B%9F%E5%99%A8-%E4%B8%BA-Next-%E4%B8%BB%E9%A2%98%E5%8A%A0%E4%B8%8A%F0%9F%90%9F%E5%90%A7/"/>
    <id>https://xinransix.github.io/2024/02/23/%E7%9F%B3%E8%92%9C%E6%A8%A1%E6%8B%9F%E5%99%A8-%E4%B8%BA-Next-%E4%B8%BB%E9%A2%98%E5%8A%A0%E4%B8%8A%F0%9F%90%9F%E5%90%A7/</id>
    <published>2024-02-23T10:58:03.000Z</published>
    <updated>2024-02-24T04:37:34.011Z</updated>
    
    <content type="html"><![CDATA[<p>Next 主题添加<ahref="https://github.com/itorr/sakana">石蒜模拟器</a>还是很 easy滴~。根据 Next 文档，只需在主题配置文件中配置<code>custom_file_path</code> 选项即可，具体的配置如下：</p><span id="more"></span><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define custom file paths.</span></span><br><span class="line"><span class="comment"># Create your custom files in site directory `source/_data` and uncomment needed files below.</span></span><br><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment"># head: source/_data/head.swig</span></span><br><span class="line">  <span class="comment"># header: source/_data/header.swig</span></span><br><span class="line">  <span class="comment"># sidebar: source/_data/sidebar.swig</span></span><br><span class="line">  <span class="comment"># postMeta: source/_data/post-meta.swig</span></span><br><span class="line">  <span class="comment"># postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class="line">  <span class="attr">footer:</span> <span class="string">source/_data/footer.swig</span></span><br><span class="line">  <span class="comment"># bodyEnd: source/_data/body-end.swig</span></span><br><span class="line">  <span class="comment"># variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment"># mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="comment"># style: source/_data/styles.styl</span></span><br></pre></td></tr></table></figure><p>然后再在 <code>source/_data</code> 目录下新建 <code>footer.njk</code>文件，内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">  <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/sakana-widget@2.7.0/lib/sakana.min.css&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;sakana-widget&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: fixed; bottom: 10px; right: 20px; z-index: 999;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">initSakanaWidget</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">SakanaWidget</span>().<span class="title function_">mount</span>(<span class="string">&#x27;#sakana-widget&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">  <span class="attr">async</span></span></span><br><span class="line"><span class="tag">  <span class="attr">onload</span>=<span class="string">&quot;initSakanaWidget()&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/sakana-widget@2.7.0/lib/sakana.min.js&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样就 OK 了，重新部署 Hexo，就可以看到 Sakana了。其他的主题也可使用类似的方法来实现。如果你的主题没有<code>custom_file_path</code> 选项，可以直接在主题的 <code>layout</code>文件中添加上面的代码。</p><h2 id="参考">参考</h2><ul><li><ahref="https://kanochi.cn/archives/7/">石蒜模拟器-为你的博客或网站加上🐟吧~</a></li><li><ahref="https://www.naokuoteng.cn/posts/e5482ed2.html">给友链页面添加一个Sakana~</a></li><li><a href="https://zero617.top/2022/09/2e7c2ba499b6.html">快来为你的Hexo 博客添加可爱的石蒜模拟器吧！</a></li><li><a href="https://github.com/itorr/sakana">itorr/sakana |GitHub</a></li><li><ahref="https://github.com/dsrkafuu/sakana-widget">dsrkafuu/sakana-widget| GitHub</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Next 主题添加&lt;a
href=&quot;https://github.com/itorr/sakana&quot;&gt;石蒜模拟器&lt;/a&gt;还是很 easy
滴~。根据 Next 文档，只需在主题配置文件中配置
&lt;code&gt;custom_file_path&lt;/code&gt; 选项即可，具体的配置如下：&lt;/p&gt;</summary>
    
    
    
    
    <category term="Hexo" scheme="https://xinransix.github.io/tags/Hexo/"/>
    
    <category term="NexT" scheme="https://xinransix.github.io/tags/NexT/"/>
    
    <category term="リコリス・リコイル" scheme="https://xinransix.github.io/tags/%E3%83%AA%E3%82%B3%E3%83%AA%E3%82%B9%E3%83%BB%E3%83%AA%E3%82%B3%E3%82%A4%E3%83%AB/"/>
    
    <category term="石蒜模拟器" scheme="https://xinransix.github.io/tags/%E7%9F%B3%E8%92%9C%E6%A8%A1%E6%8B%9F%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>四元数与 3D 旋转</title>
    <link href="https://xinransix.github.io/2024/02/17/%E5%9B%9B%E5%85%83%E6%95%B0%E4%B8%8E3%E7%BB%B4%E6%97%8B%E8%BD%AC/"/>
    <id>https://xinransix.github.io/2024/02/17/%E5%9B%9B%E5%85%83%E6%95%B0%E4%B8%8E3%E7%BB%B4%E6%97%8B%E8%BD%AC/</id>
    <published>2024-02-17T08:48:08.000Z</published>
    <updated>2024-02-26T03:22:34.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="矩阵表示旋转">矩阵表示旋转</h2><p>绕着 <span class="math inline">\(x\)</span> 轴旋转：</p><p><span class="math display">\[R_x\left(\alpha\right)=\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; \cos \alpha &amp; -\sin \alpha &amp; 0 \\0 &amp; \sin \alpha &amp; \cos \alpha &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p><p>绕着 <span class="math inline">\(y\)</span> 轴旋转：</p><p><span class="math display">\[R_y\left(\beta\right)=\begin{bmatrix}\cos \beta &amp; 0 &amp; \sin \beta &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 \\-\sin \beta &amp; 0 &amp; \cos \beta &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p><p>绕着 <span class="math inline">\(z\)</span> 轴旋转：</p><p><span class="math display">\[R_z\left(\gamma\right)=\begin{bmatrix}\cos \gamma &amp; -\sin \gamma &amp; 0 &amp; 0 \\\sin \gamma &amp; \cos \gamma &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p><h2 id="复数">复数</h2><h3 id="定义">定义</h3><p>复数域使用 <span class="math inline">\(\mathbb{C}\)</span>表示，<span class="math inline">\(\forall z \in\mathbb{C}\)</span>，都可以表示成 <spanclass="math inline">\(z=a+b\mathrm{i}\)</span>，其中 <spanclass="math inline">\(\mathrm{i}^2 = -1\)</span>，<spanclass="math inline">\(a, b \in \mathbb{R}\)</span>。<spanclass="math inline">\(a\)</span> 称为复数 <spanclass="math inline">\(z\)</span> 的<strong>实部</strong>（RealPart），<span class="math inline">\(b\)</span> 称为复数 <spanclass="math inline">\(z\)</span> 的<strong>虚部</strong>（ImaginaryPart）。<span class="math inline">\(a\)</span> 可表示为 <spanclass="math inline">\(\mathrm{Re}z\)</span>，<spanclass="math inline">\(b\)</span> 可以表示为 <spanclass="math inline">\(\mathrm{Im}z\)</span>。</p><p><span class="math inline">\(z = a+b\mathrm{i}\)</span> 实际上是对<span class="math inline">\(\left\{1,\mathrm{i}\right\}\)</span>这个<strong>基</strong>（Basis）的<strong>线性组合</strong>（LinearCombination），可以使用二维向量来表示复数：</p><p><span class="math display">\[z=\begin{bmatrix}a   \\b  \end{bmatrix}\]</span></p><p>既然是一个二维向量，就我们可以非常轻松地把它在平面直角坐标系上画出来：</p><figure><img data-src="https://github.com/XinranSix/computer-graphics/assets/62458905/28207773-fe34-47c2-8ddf-279efe8f5f79"alt="复数可视化" /><figcaption aria-hidden="true">复数可视化</figcaption></figure><h3 id="复数的运算">复数的运算</h3><h4 id="加减法">加减法</h4><p>设 <span class="math inline">\(z_1 = a + b \mathrm{i}\)</span>，<spanclass="math inline">\(z_2=c+d\mathrm{i}\)</span>，则：</p><p><span class="math display">\[z_1 \pm z_2=\left(a\pm c\right)+\left(b\pm d\right)\mathrm{i}\]</span></p><h4 id="乘法">乘法</h4><p>设 <span class="math inline">\(z_1 = a + b \mathrm{i}\)</span>，<spanclass="math inline">\(z_2=c+d\mathrm{i}\)</span>，则：</p><p><span class="math display">\[\begin{align*}    z_1z_2 &amp;=\left(a+b\mathrm{i}\right)\left(c+d\mathrm{i}\right)\\     &amp; =ac+ad\mathrm{i}+bc\mathrm{i}+bd\mathrm{i}^2 \\        &amp; =\left(ac-bd\right)+\left(bc+ad\right)\mathrm{i}\end{align*}\]</span></p><p>瞪眼法发现，fuck，这不就是矩阵乘法吗？所以，我们可以把复数看成是一个<span class="math inline">\(2\times 2\)</span>的矩阵作用于一个向量。即：</p><p><span class="math display">\[\begin{align*}    z_1z_2 &amp;=\left(ac-bd\right)+\left(bc+ad\right)\mathrm{i}\\    &amp;= \begin{bmatrix}    a &amp; -b \\    b &amp; a    \end{bmatrix}\begin{bmatrix}     c  \\d    \end{bmatrix}\end{align*}\]</span></p><p>右侧的 <span class="math inline">\(\begin{bmatrix} c\\d\end{bmatrix}\)</span> 是 <span class="math inline">\(z_2\)</span>的向量形式，而左侧的 <span class="math inline">\(\begin{bmatrix}a &amp;-b \\b &amp; a \end{bmatrix}\)</span> 则是 <spanclass="math inline">\(z_1\)</span> 的矩阵形式。</p><p>可以看到，复数的乘法，于矩阵 <spanclass="math inline">\(\begin{bmatrix}a &amp; -b \\b &amp; a\end{bmatrix}\)</span>表示的变换是等价的（复数于矩阵的关系不止如此）。</p><p>如果 <span class="math inline">\(z_1\)</span>、<spanclass="math inline">\(z_2\)</span>都使用矩阵形式来表示的话，复数的乘法可以就变成了矩阵的乘法，得到的结果矩阵表示<span class="math inline">\(z_2\)</span>、<spanclass="math inline">\(z_1\)</span> 的表示的变换的复合变换。即：</p><p><span class="math display">\[\begin{align*}z_1z_2 &amp;= \begin{bmatrix}a &amp;-b  \\b&amp;a  \end{bmatrix}\begin{bmatrix}c &amp;-d  \\d&amp;c  \end{bmatrix}\\&amp;= \begin{bmatrix}ac-bd &amp;-(bc+ad)  \\bc+ad &amp; ac-bd  \end{bmatrix}\end{align*}\]</span></p><blockquote><p>注意：复数的乘法是满足交换律的，矩阵的乘法一般是不可交换的，显然复数的矩阵形式也是可以交换的。</p></blockquote><p>来看一些特殊的复数的矩阵形式：</p><p><span class="math display">\[\begin{align*}1 &amp;= \begin{bmatrix}1 &amp; 0 \\0 &amp; 1\end{bmatrix} = I \\\mathrm{i} &amp;= \begin{bmatrix}0 &amp; -1 \\1 &amp; 0\end{bmatrix} .\end{align*}\]</span></p><p>即：实数单位 <span class="math inline">\(1\)</span>与单位矩阵是等价的，虚数单位 <spanclass="math inline">\(\mathrm{i}\)</span> 与矩阵 <spanclass="math inline">\(\begin{bmatrix}0 &amp; -1 \\1 &amp; 0\end{bmatrix}\)</span> 是等价的。</p><p>我们都知道，<span class="math inline">\(\mathrm{i}^2 =-1\)</span>，用矩阵形式表示就说：</p><p><span class="math display">\[\mathrm{i}^2 = \begin{bmatrix}0 &amp; -1\\1&amp; 0\end{bmatrix}  \begin{bmatrix}0 &amp; -1\\1&amp; 0 \end{bmatrix} =\begin{bmatrix}-1 &amp; 0\\0&amp; -1 \end{bmatrix} = -I = -1\]</span></p><p>可以矩阵形式也满足 <span class="math inline">\(\mathrm{i}^2 =-1\)</span>.</p><h4 id="模长与共轭">模长与共轭</h4><p>设复数 <span class="math inline">\(z=a+b\mathrm{i}\)</span>，则 <spanclass="math inline">\(z\)</span>的<strong>模长</strong>（Magnitude）定义为：</p><p><span class="math display">\[\|z\|=\sqrt{a^2+b^2}\]</span></p><p><span class="math inline">\(z\)</span>的<strong>共轭</strong>（Conjugate）定义为：</p><p><span class="math display">\[\overline{z}=a-b\mathrm{i}\]</span></p><p>可以发现：</p><p><span class="math display">\[z\overline{z}=\left(a+b\mathrm{i}\right)\left(a-b\mathrm{i}\right)=a^2+b^2=\|z\|^2\]</span></p><p>所以：</p><p><span class="math display">\[\|z\|=\sqrt{z\overline{z}}\]</span></p><p>同时我们发现：</p><p><span class="math display">\[a = \frac{z+\overline{z}}{2}, b = \frac{z-\overline{z}}{2\mathrm{i}}\]</span></p><h3 id="复数的指数形式">复数的指数形式</h3><p>根据<ahref="https://en.wikipedia.org/wiki/Euler%27s_formula">欧拉公式</a>：</p><p><span class="math display">\[\mathrm{e}^{\mathrm{i}\theta}=\cos \theta + \mathrm{i}\sin \theta\]</span></p><p>可以得到复数的指数形式。</p><p>设复数 <spanclass="math inline">\(z=a+b\mathrm{i}\)</span>，则其复数矩阵形式和复数形式为：</p><p><span class="math display">\[\begin{align*}z &amp;= \|z\|\begin{bmatrix}\cos \theta &amp; -\sin \theta  \\\sin \theta &amp;  \cos \theta\end{bmatrix} \\&amp;= \|z\|\left(\cos \theta + \mathrm{i}\sin \theta\right) \\&amp;= \|z\|\mathrm{e}^{\mathrm{i}\theta}\end{align*}\]</span></p><p>其中： <span class="math display">\[\theta =\mathrm{atan2}\left(\frac{b}{a}\right)\]</span></p><p>我们可以得到：</p><p><span class="math display">\[\sin x =\frac{\mathrm{e}^{\mathrm{i}x}-\mathrm{e}^{-\mathrm{i}x}}{2\mathrm{i}},\cosx = \frac{\mathrm{e}^{\mathrm{i}x}+\mathrm{e}^{-\mathrm{i}x}}{2}\]</span></p><p>如果使用复数的指数形式，复数的乘法就变得非常简单，设 <spanclass="math inline">\(z_1=r_1\mathrm{e}^{\mathrm{i}\theta_1}\)</span>，<spanclass="math inline">\(z_2=r_2\mathrm{e}^{\mathrm{i}\theta_2}\)</span>，则：</p><p><span class="math display">\[z_1z_2=r_1r_2\mathrm{e}^{\mathrm{i}\left(\theta_1+\theta_2\right)}\]</span></p><p>使用三角函数的复数形式可以很方便地证明三角函数的一些公式。</p><h3 id="复数与-2d-旋转">复数与 2D 旋转</h3><p>前面讨论了复数的矩阵形式，复数 <spanclass="math inline">\(z=a+b\mathrm{i}\)</span> 的矩阵形式为 <spanclass="math inline">\(\begin{bmatrix}a &amp; -b \\b &amp; a\end{bmatrix}\)</span>.</p><p>将这个矩阵稍微变形一下：</p><p><span class="math display">\[\begin{align*}    \begin{bmatrix}a &amp; -b \\b &amp; a \end{bmatrix} &amp;=\sqrt{a^2+b^2}\begin{bmatrix}\frac{a}{\sqrt{a^2+b^2}} &amp; \frac{-b}{\sqrt{a^2+b^2}} \\\frac{b}{\sqrt{a^2+b^2}} &amp; \frac{a}{\sqrt{a^2+b^2}}  \end{bmatrix}\\ &amp;= \|z\|\begin{bmatrix}    \cos \theta &amp; -\sin\theta  \\\sin \theta &amp;  \cos \theta \end{bmatrix}  \\&amp;= \begin{bmatrix}\|z\|  &amp; 0 \\0  &amp;  \|z\|\end{bmatrix}\begin{bmatrix}    \cos \theta &amp; -\sin \theta  \\\sin \theta &amp;  \cos \theta \end{bmatrix}\end{align*}\]</span></p><p>哦~，原来这个矩阵表示是一个旋转矩阵和一个缩放矩阵的复合啊（实际上我早就看出来了）。</p><p>即：复数 <span class="math inline">\(z=a+b\mathrm{i}\)</span>可以表示一个平面上的旋转和缩放变换。缩放因子为：<spanclass="math inline">\(\|z\|\)</span>，旋转角度为：<spanclass="math inline">\(\mathrm{atan2}\left(\frac{b}{a}\right)\)</span>（CCW）。</p><p>如果 <span class="math inline">\(\|z\|=1\)</span>，即 <spanclass="math inline">\(a^2+b^2=1\)</span> 当如何，即 <spanclass="math inline">\(z\)</span>是一个单位复数，那么这个变换就是一个纯粹的旋转变换：</p><p><span class="math display">\[z=\begin{bmatrix}\cos \theta &amp;  -\sin \theta\\\sin \theta &amp;  \cos \theta\end{bmatrix}\]</span></p><p>如果我们想旋转一个二维向量，可以使用矩阵进行变换：</p><p><span class="math display">\[\mathbf{v}&#39;=\begin{bmatrix}\cos \theta &amp;  -\sin \theta\\\sin \theta &amp;  \cos \theta\end{bmatrix}\mathbf{v}\]</span></p><p>矩阵 <span class="math inline">\(\begin{bmatrix} \cos \theta &amp;-\sin \theta\\ \sin \theta &amp; \cos \theta \end{bmatrix}\)</span>的复数形式为：<span class="math inline">\(\cos \theta +\mathrm{i}\sin\theta\)</span>.</p><p>将向量 <span class="math inline">\(\mathbf{v}=\begin{bmatrix} x \\ y\end{bmatrix}\)</span> 看成一个复数 <spanclass="math inline">\(v=x+y\mathrm{i}\)</span>，我们可以构造一个复数<span class="math inline">\(z=\cos \theta + \mathrm{i} \sin\theta\)</span>，那么可以使用复数的乘法来表示旋转变换：</p><p><span class="math display">\[v&#39;=zv=\left(\cos \theta + \mathrm{i} \sin \theta \right) v\]</span></p><p>我们还可以使用复数的指数形式来表示旋转变换：</p><p><span class="math display">\[v&#39;=r\mathrm{e}^{\mathrm{i}\theta}v\]</span></p><p>当然 <spanclass="math inline">\(r\mathrm{e}^{\mathrm{i}\theta}\)</span>表示一个旋转和缩放的复合，如果只需要表示旋转，可以使 <spanclass="math inline">\(r=1\)</span>.</p><h3 id="旋转的复合">旋转的复合</h3><p>假设有两个表示 2D 旋转的单位复数 <span class="math inline">\(z_1=\cos\theta + \mathrm{i} \sin \theta\)</span>、<spanclass="math inline">\(z_2=\cos \phi + \mathrm{i} \sin\phi\)</span>，那么这两个旋转的复合变换可以表示为：</p><p><span class="math display">\[\begin{align*}z_1z_2 &amp;= \left(\cos \theta + \mathrm{i} \sin\theta\right)\left(\cos \phi + \mathrm{i} \sin \phi\right)\\&amp;= \left(\cos \theta \cos \phi - \sin \theta \sin \phi\right) +\mathrm{i}\left(\cos \theta \sin \phi + \sin \theta \cos \phi\right)\\&amp;= \cos \left(\theta + \phi\right) + \mathrm{i} \sin \left(\theta +\phi\right)\end{align*}\]</span></p><h2 id="d-空间中的旋转">3D 空间中的旋转</h2><blockquote><p>这里讨论的是绕 3D 空间某一条过原点的轴旋转指定角度。</p><p>如果这个轴不过原点咋办？我们可以先将轴平移到原点，然后旋转，最后再平移回去。</p></blockquote><p>假设我们有一个过原点的旋转轴 <spanclass="math inline">\(\mathbf{u}\)</span>，我们希望将一个向量 <spanclass="math inline">\(\mathbf{v}\)</span> 绕这个轴旋转 <spanclass="math inline">\(\theta\)</span> 角度，得到 <spanclass="math inline">\(\mathbf{v}&#39;\)</span>：</p><figure><img data-src="https://github.com/XinranSix/comment/assets/62458905/0937c561-2f42-4716-a604-1ca94ea08173"alt="绕特定轴旋转" /><figcaption aria-hidden="true">绕特定轴旋转</figcaption></figure><blockquote><p>以下讨论默认为右手坐标系。</p></blockquote><p>我们发现，如果使用轴 <span class="math inline">\(\mathbf{u}\)</span>和 角度 <span class="math inline">\(\theta\)</span>来表示一个旋转，这我们一共有 4个自由度，但如果使用欧拉角来表示旋转，显然只有 3个自由度。捏是什么回事。</p><p>实际上这是因为向量既有大小，又有方向。但如果我们只考虑旋转，则向量的大小无所谓。例如，绕着<span class="math inline">\(\left[0,0,1\right]^{\mathrm{T}}\)</span>旋转和绕着 <spanclass="math inline">\(\left[0,0,2\right]^{\mathrm{T}}\)</span>有什么区别吗？绕着 <spanclass="math inline">\(\left[x,y,z\right]^{\mathrm{T}}\)</span>旋转和绕着 <spanclass="math inline">\(k\left[x,y,z\right]^{\mathrm{T}}\)</span>有什么区别吗？显然没有。</p><p>实际上在 3D空间中定义一个方向只需要两个量就可以了（想想球坐标系或经纬度）。</p><p>既然向量的长度没有影响，若无特殊说明，后面讨论的向量 <spanclass="math inline">\(\mathrm{u}\)</span> 都为单位向量，即：</p><p><span class="math display">\[\|\mathbf{u}\| = \sqrt{x^2+y^2+z^2} = 1\]</span></p><blockquote><p>在编程时，拿到的 <span class="math inline">\(\mathbf{u}\)</span>很有可能不是单位向量，所以在使用前需要先将其归一化：</p><p><span class="math display">\[\mathbf{\hat{u}} = \frac{\mathbf{u}}{\|\mathbf{u}\|}\]</span></p></blockquote><h3 id="旋转的分解">旋转的分解</h3><p>可以将 <span class="math inline">\(\mathbf{v}\)</span>分解为平行于旋转轴 <span class="math inline">\(\mathbf{u}\)</span>和正交与旋转轴 <span class="math inline">\(\mathbf{u}\)</span>的两个分量 <span class="math inline">\(\mathbf{v}_{\parallel}\)</span>和 <span class="math inline">\(\mathbf{v}_{\perp}\)</span></p><p><span class="math display">\[\mathbf{v}=\mathbf{v}_{\parallel}+\mathbf{v}_{\perp}\]</span></p><figure><img data-src="https://github.com/XinranSix/comment/assets/62458905/42933dab-ad4a-4bfa-b3dd-4388a9a0b613"alt="向量的正交分解" /><figcaption aria-hidden="true">向量的正交分解</figcaption></figure><p>分别旋转这两部分，在将它们的旋转结果加起来就可以的得到旋转后的向量：</p><p><span class="math display">\[\mathbf{v}&#39;=\mathbf{v}&#39;_{\parallel}+\mathbf{v}&#39;_{\perp}\]</span></p><p><span class="math inline">\(\mathbf{v}_{\parallel}\)</span> 实际上就<span class="math inline">\(\mathbf{v}\)</span> 在 <spanclass="math inline">\(\mathbf{u}\)</span>上的投影，那我们就快点把他算出来吧：</p><p><span class="math display">\[\mathbf{v}_{\parallel} = \mathrm{proj}_{\mathbf{u}} \mathbf{v} =\left(\mathbf{u} \cdot \mathbf{v}\right) \mathbf{u}\]</span></p><blockquote><p>向量 <span class="math inline">\(\mathbf{a}\)</span> 在向量 <spanclass="math inline">\(\mathbf{b}\)</span> 上的投影为：</p><p><span class="math display">\[\mathrm{proj}_{\mathbf{b}} \mathbf{a} = \frac{\mathbf{a} \cdot\mathbf{b}}{\| \mathbf{b} \|^2} \mathbf{b}\]</span></p><p>如果 <span class="math inline">\(\| \mathbf{b}\|=1\)</span>，则：</p><p><span class="math display">\[\mathrm{proj}_{\mathbf{b}} \mathbf{a} = \left(\mathbf{a} \cdot\mathbf{b} \right) \mathbf{b}\]</span></p></blockquote><p>因为 <spanclass="math inline">\(\mathbf{v}=\mathbf{v}_{\parallel}+\mathbf{v}_{\perp}\)</span>，那么：</p><p><span class="math display">\[\begin{align*}    \mathbf{v}_{\perp}&amp;=\mathbf{v}-\mathbf{v}_{\parallel}\\     &amp;=\left(\mathbf{u} \cdot \mathbf{v}\right) \mathbf{u}\end{align*}\]</span></p><p>接下来只需分别讨论 <spanclass="math inline">\(\mathbf{v}_{\parallel}\)</span> 和 <spanclass="math inline">\(\mathbf{v}_{\perp}\)</span> 的旋转即可。</p><h3 id="mathbfv_parallel-的旋转"><spanclass="math inline">\(\mathbf{v}_{\parallel}\)</span> 的旋转</h3><p>显然：</p><p><span class="math display">\[\mathbf{v}_{\parallel}&#39;=\mathbf{v}_{\parallel}\]</span></p><h3 id="mathbfv_perp-的旋转"><spanclass="math inline">\(\mathbf{v}_{\perp}\)</span> 的旋转</h3><p><span class="math inline">\(\mathbf{v}_{\perp}\)</span> 正交于 <spanclass="math inline">\(\mathbf{u}\)</span>，所以这个旋转实际上在一个平面内。因为旋转不改变向量的长度，所以路径是一个圆，如下图所示：</p><figure><img data-src="https://github.com/XinranSix/comment/assets/62458905/12a9a2ee-2721-45e5-9d6f-d6110d40cb62"alt="旋转示意图" /><figcaption aria-hidden="true">旋转示意图</figcaption></figure><p>再构造一个向量 <span class="math inline">\(\mathbf{w} = \mathbf{u}\times \mathbf{v}_{\perp}\)</span>.</p><p>实际上向量 <span class="math inline">\(\mathbf{w}\)</span> 是向量<span class="math inline">\(\mathbf{v}_{\perp}\)</span> 逆时针旋转 <spanclass="math inline">\(\pi / 2\)</span> 之后得到的结果。可以发现：</p><p><span class="math display">\[\begin{align*}    \|\mathbf{w}\| &amp;=\|\mathbf{u} \times \mathbf{v}_{\perp}\|\\    &amp;= \|\mathbf{u}\|  \|\mathbf{v}_{\perp}\| \sin \frac{\pi}{2} \\    &amp;= \|\mathbf{v}_{\perp}\|\end{align*}\]</span></p><p>也就是说，<spanclass="math inline">\(\|\mathbf{w}\|=\|\mathbf{v}_{\perp}\|\)</span>，即<span class="math inline">\(\mathbf{w}\)</span> 也在圆上。所以：</p><p><span class="math display">\[\begin{align*}    \mathbf{v}_{\perp}&#39; &amp;= \mathbf{v}_{\perp} \cos \theta\ +\mathbf{w} \sin \theta \\    &amp;= \mathbf{v}_{\perp} \cos \theta\ + \left(\mathbf{u}\times\mathbf{\mathbf{v}_{\perp}}\right) \sin \theta\end{align*}\]</span></p><h3 id="mathbfv-的旋转"><span class="math inline">\(\mathbf{v}\)</span>的旋转</h3><p>根据上面的讨论：</p><p><span class="math display">\[\begin{align*}    \mathbf{v}&#39;&amp;=\mathbf{v}_{\parallel}&#39;+\mathbf{v}_{\perp}&#39;\\    &amp;= \mathbf{v}_{\parallel} + \mathbf{v}_{\perp} \cos \theta\ +\left(\mathbf{u}\times \mathbf{\mathbf{v}_{\perp}}\right) \sin \theta\end{align*}\]</span></p><p>叉乘具有结合律：</p><p><span class="math display">\[\begin{align*}    \mathbf{u}\times \mathbf{\mathbf{v}_{\perp}}&amp;= \mathbf{u}\times\left(\mathbf{v}-\mathbf{v}_{\parallel}\right)\\    &amp;=\mathbf{u}\times \mathbf{v} - \mathbf{u}\times\mathbf{v}_{\parallel}\\    &amp;= \mathbf{u}\times \mathbf{v}\end{align*}\]</span></p><p>最后，将 <span class="math inline">\(\mathbf{v}_{\parallel} =\left(\mathbf{u}\cdot \mathbf{v}\right)\mathbf{u}\)</span> 和 <spanclass="math inline">\(\mathbf{v}_{\perp} = \mathbf{v} -\left(\mathbf{u}\cdot \mathbf{v}\right)\mathbf{u}\)</span> 带入得：</p><p><span class="math display">\[\begin{align*}    \mathbf{v}&#39;&amp;= \left(\mathbf{u}\cdot\mathbf{v}\right)\mathbf{u} + \left(\mathbf{v} - \left(\mathbf{u}\cdot\mathbf{v}\right)\mathbf{u}\right) \cos \theta\ + \left(\mathbf{u}\times\mathbf{\mathbf{v}}\right) \sin \theta\\    &amp;= \mathbf{v} \cos \theta + \left(1- \cos \theta\right)\left(\mathbf{u}\cdot \mathbf{v}\right)\mathbf{u} +\left(\mathbf{u}\times \mathbf{v}\right) \sin \theta\end{align*}\]</span></p><p>即 3D 空间中任意一个向量 <spanclass="math inline">\(\mathbf{v}\)</span> 沿单位向量 <spanclass="math inline">\(\mathbf{u}\)</span> 旋转 <spanclass="math inline">\(\theta\)</span> 之后得到的 <spanclass="math inline">\(\mathbf{v}&#39;\)</span> 为：</p><p><span class="math display">\[\mathbf{v}&#39;=\mathbf{v} \cos \theta + \left(1- \cos \theta\right)\left(\mathbf{u}\cdot \mathbf{v}\right)\mathbf{u} +\left(\mathbf{u}\times \mathbf{v}\right) \sin \theta\]</span></p><p>这个公式叫做 Rodrigues' rotation formula.</p><h2 id="四元数">四元数</h2><p>四元数与复数像，不同的是，复数只有 1 个虚部，而四元数有 3个虚部。</p><p>四元数的定义为：</p><p><span class="math display">\[q = a + b \mathrm{i} + c \mathrm{j} + d \mathrm{k}\]</span></p><p>其中 <spanclass="math inline">\(\mathrm{i}^2=\mathrm{j}^2=\mathrm{k}^2=\mathrm{i}\mathrm{j}\mathrm{k}=-1\)</span>，且<span class="math inline">\(a,b,c,d\in \mathbb{R}\)</span>.</p><p>四元数的集合用 <span class="math inline">\(\mathbb{H}\)</span>表示，即：<span class="math inline">\(q\in \mathbb{H}\)</span>.</p><p>与复数类似，四元数是对 <spanclass="math inline">\(\left\{1,\mathrm{i},\mathrm{j},\mathrm{k}\right\}\)</span>这个基的线性组合，四元数可以写成向量形式：</p><p><span class="math display">\[q=\begin{bmatrix}a\\b\\c\\d\end{bmatrix}\]</span></p><p>还可以将四元数的实部和虚部分开，用一个三维的向量来表示虚部，将四元数表示为标量和向量的有序对：</p><p><span class="math display">\[q = \left[s, \mathbf{v}\right]\]</span></p><p>其中：<spanclass="math inline">\(\mathbf{v}=\left[x,y,z\right]^{\mathrm{T}}\)</span>，且<span class="math inline">\(s,x,y,z \in \mathbb{R}\)</span>.</p><h3 id="四元数的运算与性质">四元数的运算与性质</h3><h4 id="模长">模长</h4><p>设四元数 <spanclass="math inline">\(q=a+b\mathrm{i}+c\mathrm{j}+d\mathrm{k}\)</span>，则<span class="math inline">\(q\)</span> 的模长定义为：</p><p><span class="math display">\[\|q\|=\sqrt{a^2+b^2+c^2+d^2}\]</span></p><p>如果使用标量向量的形式来表示的话，设 <spanclass="math inline">\(q=\left[s,\mathbf{v}\right]\)</span>，则：</p><p><span class="math display">\[\|q\|=\sqrt{s^2+\|\mathbf{v}\|^2}\]</span></p><h4 id="加减法-1">加减法</h4><p>设 <span class="math inline">\(q_1 = a + b \mathrm{i} + c \mathrm{j}+ d \mathrm{k}\)</span>、<spanclass="math inline">\(q_2=e+f\mathrm{i}+g\mathrm{j}+h\mathrm{k}\)</span>，则：</p><p><span class="math display">\[q_1 \pm q_2=\left(a\pm e\right)+\left(b\pm f\right)\mathrm{i}+\left(c\pmg\right)\mathrm{j}+\left(d\pm h\right)\mathrm{k}\]</span></p><p>使用标量向量有序对形式表示，设 <spanclass="math inline">\(q_1=\left[s_1,\mathbf{v}_1\right]\)</span>、<spanclass="math inline">\(q_2=\left[s_2,\mathbf{v}_2\right]\)</span>，则：</p><p><span class="math display">\[q_1 \pm q_2=\left[s_1\pm s_2,\mathbf{v}_1\pm \mathbf{v}_2\right]\]</span></p><h4 id="数乘">数乘</h4><p>设四元数 <spanclass="math inline">\(q=a+b\mathrm{i}+c\mathrm{j}+d\mathrm{k}\)</span>，<spanclass="math inline">\(k\in \mathbb{R}\)</span>，则：</p><p><span class="math display">\[kq=ka+kb\mathrm{i}+kc\mathrm{j}+kd\mathrm{k}\]</span></p><blockquote><p>四元数的数乘是可交换的，即：<spanclass="math inline">\(kq=qk\)</span>，其中 <spanclass="math inline">\(k\in \mathbb{R}\)</span> 且 <spanclass="math inline">\(q\in \mathbb{H}\)</span>.</p></blockquote><h4 id="四元数乘法">四元数乘法</h4><p>四元数乘法是不可交换的。即，一般情况下，对于 <spanclass="math inline">\(q_1,q_2\in \mathbb{H}\)</span>，一般情况下 <spanclass="math inline">\(q_1q_2\neq q_2q_1\)</span>.</p><p>对于 <span class="math inline">\(q_1q_2\)</span>，称之为「<spanclass="math inline">\(q_2\)</span> 左乘以 <spanclass="math inline">\(q_1\)</span>」，对于 <spanclass="math inline">\(q_2q_1\)</span>，称之为「<spanclass="math inline">\(q_2\)</span> 右乘以 <spanclass="math inline">\(q_1\)</span>」。</p><p>虽然四元数乘法不可交换，但是满足结合律和分配律。</p><p>设 $q_1=a+b + c +d , <span class="math inline">\(q_2=e+f \mathrm{i} +g \mathrm{j}+h \mathrm{k}\)</span>$，则：</p><p><span class="math display">\[\begin{align*}q_1 q_2= &amp; (a+b \mathrm{i}+c \mathrm{j}+d \mathrm{k})(e+f\mathrm{i}+g \mathrm{j}+h \mathrm{k}) \\= &amp; a e+a f \mathrm{i}+a g \mathrm{j}+a h \mathrm{k}+ \\&amp; b e \mathrm{i}+b f \mathrm{i}^2+b g \mathrm{i} \mathrm{j}+b h\mathrm{i} \mathrm{k}+ \\&amp; c e \mathrm{j}+c f \mathrm{j} \mathrm{i}+c g \mathrm{j}^2+c h\mathrm{j} \mathrm{k}+ \\&amp; d e \mathrm{k}+d f \mathrm{k} \mathrm{i}+d g \mathrm{k}\mathrm{j}+d h \mathrm{k}^2\end{align*}\]</span></p><p>根据以下表格对上述公式进行简化：</p><p><span class="math display">\[\begin{array}{|c|c|c|c|c|}\hline \times &amp; 1 &amp; \mathrm{i} &amp; \mathrm{j} &amp; \mathrm{k}\\\hline 1 &amp; 1 &amp; \mathrm{i} &amp; \mathrm{j} &amp; \mathrm{k} \\\hline \mathrm{i} &amp; \mathrm{i} &amp; -1 &amp; \mathrm{k} &amp;-\mathrm{j} \\\hline \mathrm{j} &amp; \mathrm{j} &amp; -\mathrm{k} &amp; -1 &amp;\mathrm{i} \\\hline \mathrm{k} &amp; \mathrm{k} &amp; \mathrm{j} &amp; -\mathrm{i}&amp; -1 \\\hline\end{array}\]</span></p><p>化简后得：</p><p><span class="math display">\[\begin{align*}q_1 q_2= &amp; (a e-b f-c g-d h)+ \\&amp; (b e+a f-d g+c h) \mathrm{i}+ \\&amp; (c e+d f+a g-b h) \mathrm{j}+ \\&amp; (d e-c f+b g+a h)\mathrm{k}\end{align*}\]</span></p><h4 id="四元数乘法的矩阵形式">四元数乘法的矩阵形式</h4><p>类似于复数的乘法，四元数的乘法也可以使用矩阵来表示。</p><p>设 <spanclass="math inline">\(q_1=a+b\mathrm{i}+c\mathrm{j}+d\mathrm{k}\)</span>，<spanclass="math inline">\(q_2=e+f\mathrm{i}+g\mathrm{j}+h\mathrm{k}\)</span>，则：</p><p><span class="math display">\[q_1q_2=\begin{bmatrix}a &amp; -b &amp; -c &amp; -d \\b &amp; a &amp; -d &amp; c \\c &amp; d &amp; a &amp; -b \\d &amp; -c &amp; b &amp; a\end{bmatrix}  \begin{bmatrix}e \\f \\g \\h \end{bmatrix}\]</span></p><p>注意：这个矩阵表示左乘 <span class="math inline">\(q_1\)</span>，右乘<span class="math inline">\(q_1\)</span> 的矩阵表示为：</p><p><span class="math display">\[q_2 q_1=\begin{bmatrix}a &amp; -b &amp; -c &amp; -d \\b &amp; a &amp; d &amp; -c \\c &amp; -d &amp; a &amp; b \\d &amp; c &amp; -b &amp; a\end{bmatrix} \begin{bmatrix}e \\f \\g \\h\end{bmatrix}\]</span></p><h4 id="grassmann-积">Grassmann 积</h4><p>前面已经得到：</p><p><span class="math display">\[\begin{align*}q_1 q_2= &amp; (a e-b f-c g-d h)+ \\&amp; (b e+a f-d g+c h) \mathrm{i}+ \\&amp; (c e+d f+a g-b h) \mathrm{j}+ \\&amp; (d e-c f+b g+a h)\mathrm{k}\end{align*}\]</span></p><p>我们都知道，如果 <spanclass="math inline">\(\mathbf{v}=[b,c,d]^{\mathrm{T}}\)</span>，<spanclass="math inline">\(\mathbf{u}=[f,g,h]^{\mathrm{T}}\)</span>，则：</p><p><span class="math display">\[\begin{align*}\mathbf{v} \cdot \mathbf{u} &amp;= b f + c g + d h \\\mathbf{v} \times \mathbf{u} &amp;= \begin{bmatrix}\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\b &amp; c &amp; d \\f &amp; g &amp; h\end{bmatrix}\end{align*}\]</span></p><p>所以：</p><p><span class="math display">\[q_1q_2=ae - \mathbf{v} \cdot \mathbf{u} + a \mathbf{u} + e \mathbf{v} +\mathbf{v} \times \mathbf{u}\]</span></p><p>如果 <span class="math inline">\(q_1 = \left[s_1,\mathbf{v}_1\right]\)</span>，<span class="math inline">\(q_2 =\left[s_2, \mathbf{v}_2\right]\)</span>，则：</p><p><span class="math display">\[q_1q_2=\left[s_1s_2 - \mathbf{v}_1 \cdot \mathbf{v}_2, s_1\mathbf{v}_2 +s_2\mathbf{v}_1 + \mathbf{v}_1 \times \mathbf{v}_2\right]\]</span></p><p>这个结果叫做 Grassmann 积 (Grassmann Product)</p><h4 id="纯四元数">纯四元数</h4><p>如果一个四元数的实部为 0，那么这个四元数就是一个纯四元数。即如果<span class="math inline">\(v=\left[0,\mathbf{v}\right]\)</span>，则 v是一个纯四元数。</p><p>我们可以将一个纯四元数和一个 3D 向量等价起来。</p><p>在后文中，如果 <span class="math inline">\(\mathbf{v}\)</span>表示一个向量，则使用 <span class="math inline">\(v\)</span> 表示 <spanclass="math inline">\(\mathbf{v}\)</span> 对于的纯四元数，即：<spanclass="math inline">\(v=\left[0,\mathbf{v}\right]\)</span>.</p><h4 id="逆和共轭">逆和共轭</h4><p>对于四元数 <spanclass="math inline">\(q=a+b\mathrm{i}+c\mathrm{j}+d\mathrm{k}\)</span>，其共轭定义为：</p><p><span class="math display">\[q^{\star}=a-b\mathrm{i}-c\mathrm{j}-d\mathrm{k}\]</span></p><p>四元数 <span class="math inline">\(q\)</span> 的逆记为：<spanclass="math inline">\(q^{-1}\)</span>. 它要满足：</p><p><span class="math display">\[qq^{-1}=q^{-1}q=1\]</span></p><blockquote><p>只有当 <span class="math inline">\(q \neq 0\)</span> 时才可逆。</p></blockquote><p>设 <span class="math inline">\(q = \left[s,\mathbf{v}\right]\)</span>，则 <span class="math inline">\(q^{\star} =\left[s, -\mathbf{v}\right]\)</span>，那么：</p><p><span class="math display">\[\begin{align*}qq^{\star} &amp;= \left[s, \mathbf{v}\right]\left[s, -\mathbf{v}\right]\\&amp;=  \left[s^2 + \mathbf{v} \cdot \mathbf{v}, 0\right]\end{align*}\]</span></p><p>且：</p><p><span class="math display">\[\begin{align*}q^{\star}q &amp;= \left[s, -\mathbf{v}\right]\left[s, \mathbf{v}\right]\\&amp;=  \left[s^2 + \mathbf{v} \cdot \mathbf{v}, 0\right]\end{align*}\]</span></p><p>那么：</p><p><span class="math display">\[\begin{align*}qq^{-1}&amp;=1\\q^{\star}qq^{-1}&amp;=q^{\star}\\\|q\|^2 q^{-1}&amp;=q^{\star}\\q^{-1}&amp;=\frac{q^{\star}}{\|q\|^2}\end{align*}\]</span></p><p>这样就求得了四元数的逆。</p><p>如果 <span class="math inline">\(\|q\|=1\)</span>，则 <spanclass="math inline">\(q\)</span> 是一个单位四元数，那么：</p><p><span class="math display">\[q^{-1} = \frac{q^{\star}}{\|1\|^2} = q^{\star}\]</span></p><h3 id="四元数与-3d-旋转">四元数与 3D 旋转</h3><p>在前面以后讨论过如何将一个向量 <spanclass="math inline">\(\mathbf{v}\)</span> 绕一个用单位向量表示的旋转轴<span class="math inline">\(\mathbf{u}\)</span> 逆时针旋转旋转 <spanclass="math inline">\(\theta\)</span> 度，即：将 <spanclass="math inline">\(\mathbf{v}\)</span> 分解成平行于 <spanclass="math inline">\(\mathbf{u}\)</span> 的向量 <spanclass="math inline">\(\mathbf{v}_{\parallel}\)</span> 和正交于 <spanclass="math inline">\(\mathbf{u}\)</span> 的向量 <spanclass="math inline">\(\mathbf{v}_{\perp}\)</span>，然后分别旋转这两部分，得到<span class="math inline">\(\mathbf{v}&#39;_{\parallel}\)</span> 和<spanclass="math inline">\(\mathbf{v}&#39;_{\perp}\)</span>，最后将这两部分加起来得到<span class="math inline">\(\mathbf{v}&#39;\)</span>.</p><p>我们可以将这些向量定义为纯四元数：</p><p><span class="math display">\[\begin{align*}v &amp;= \left[0, \mathbf{v}\right] \\v_{\parallel}&amp;= \left[0, \mathbf{v}_{\parallel}\right] \\v_{\perp}&amp;= \left[0, \mathbf{v}_{\perp}\right] \\v&#39; &amp;= \left[0, \mathbf{v&#39;}\right] \\v&#39;_{\parallel}&amp;= \left[0, \mathbf{v}&#39;_{\parallel}\right] \\v&#39;_{\perp}&amp;= \left[0, \mathbf{v}&#39;_{\perp}\right] \\u&amp;= \left[0, \mathbf{u}\right]\end{align*}\]</span></p><p>那么有：</p><p><span class="math display">\[\begin{align*}v &amp;= v_{\parallel} + v_{\perp} \\v&#39; &amp;= v&#39;_{\parallel} + v&#39;_{\perp}\end{align*}\]</span></p><p>下面分别讨论 <span class="math inline">\(v_{\parallel}\)</span> 和<span class="math inline">\(v_{\perp}\)</span>.</p><h4 id="v_parallel-的旋转"><spanclass="math inline">\(v_{\parallel}\)</span> 的旋转</h4><p>显然：</p><p><span class="math display">\[v&#39;_{\parallel}=v_{\parallel}\]</span></p><h4 id="v_perp-的旋转"><span class="math inline">\(v_{\perp}\)</span>的旋转</h4><p>我们正确推到过：</p><p><span class="math display">\[\mathbf{v}_{\perp}&#39; = \mathbf{v}_{\perp} \cos \theta\ +\left(\mathbf{u}\times \mathbf{\mathbf{v}_{\perp}}\right) \sin \theta\]</span></p><p>我们可以非常容易地将 <spanclass="math inline">\(\mathbf{v}&#39;_{\perp}\)</span> 和 <spanclass="math inline">\(\mathbf{v}_{\perp}\)</span> 替换为 <spanclass="math inline">\(v&#39;_{\perp}\)</span> 和 <spanclass="math inline">\(v_{\perp}\)</span>，但 <spanclass="math inline">\(\mathbf{u}\times\mathbf{\mathbf{v}_{\perp}}\)</span> 又当如何？实际上也很 easy啦，下面给出推导。</p><p>前面已经得到，对于纯四元数 <spanclass="math inline">\(v=\left[0,\mathbf{v}\right]\)</span> 和 <spanclass="math inline">\(u=\left[0,\mathbf{u}\right]\)</span>，有：<spanclass="math inline">\(vu=\left[-\mathbf{v}\cdot \mathbf{u},\mathbf{v}\times \mathbf{u}\right]\)</span>。那么</p><p><span class="math display">\[\begin{align*}uv_{\perp}&amp;= \left[-\mathbf{u}\cdot \mathbf{v}_{\perp},\mathbf{u}\times \mathbf{v}_{\perp} \right]\\&amp;=\left[0, \mathbf{u}\times \mathbf{v}_{\perp}\right]\\&amp;=\mathbf{u}\times \mathbf{v}_{\perp}\end{align*}\]</span></p><p>注意：<span class="math inline">\(uv_{\perp}\)</span>也是一个纯四元数。</p><p>那么我们就可以得到：</p><p><span class="math display">\[\begin{align*}v&#39;_{\perp} &amp;= v_{\perp} \cos \theta\ + uv_{\perp} \sin \theta\\&amp;= \left(\cos \theta +u \sin \theta\right)v_{\perp}\end{align*}\]</span></p><p>我们可以将 <span class="math inline">\(\cos \theta +u \sin\theta\)</span> 看做为一个四元数。令 <span class="math inline">\(q=\cos\theta +u \sin \theta\)</span>，则：</p><p><span class="math display">\[v&#39;_{\perp}=qv_{\perp}\]</span></p><p>对 <span class="math inline">\(q\)</span> 稍微变形：</p><p><span class="math display">\[\begin{align*}q&amp;=\cos \theta +u \sin \theta\\&amp;=\left[\cos \theta, 0\right] + \left[0, \mathbf{u} \sin\theta\right] \\&amp;=\left[\cos \theta, \mathbf{u} \sin \theta\right]\end{align*}\]</span></p><p>也就是说，如果 <spanclass="math inline">\(\mathbf{u}=\begin{bmatrix}u_x, u_y, u_z\end{bmatrix}^{\mathrm{T}}\)</span>，旋转角为 <spanclass="math inline">\(\theta\)</span>，那么完全这一旋转所需的四元数<span class="math inline">\(q\)</span> 为：</p><p><span class="math display">\[q=\cos \theta +  u_{x} \sin \theta \mathrm{i} + u_{y} \sin\theta  \mathrm{j} + u_{z} \sin \theta  \mathrm{k}\]</span></p><p>即，对于正交于旋转轴 <span class="math inline">\(\mathbf{u}\)</span>的向量 <span class="math inline">\(\mathbf{v}_{\perp}\)</span>，旋转<span class="math inline">\(\theta\)</span> 角度之后得到 <spanclass="math inline">\(\mathbf{v}&#39;_{\perp}\)</span>，令 <spanclass="math inline">\(v_{\perp}=\left[0,\mathbf{v}_{\perp}\right]\)</span>，<spanclass="math inline">\(q=\left[\cos \theta,\mathbf{u}\sin\theta\right]\)</span>，那么：</p><p><span class="math display">\[v&#39;_{\perp}=qv_{\perp}\]</span></p><p>我们可以发现：</p><p><span class="math display">\[\|q\|= 1\]</span></p><blockquote><p>一个普通的四元数表示一个旋转变换和一个缩放变换的复合，而单位四元数表示一个纯粹的旋转变换，这一点和复数非常类似。</p></blockquote><h4 id="v-的旋转"><span class="math inline">\(v\)</span> 的旋转</h4><p><span class="math display">\[\begin{align*}v&#39;&amp;=v&#39;_{\parallel}+v&#39;_{\perp}\\&amp;=v_{\parallel}+qv_{\perp}\end{align*}\]</span></p><p>其中 <spanclass="math inline">\(q=\left[\cos\theta,\mathbf{u}\sin\theta\right]\)</span>.</p><p>接下来要对上面的公式进行简化，在简化之前像给出两个引理。</p><p>引理 1：如果 <spanclass="math inline">\(q=\left[\cos\theta,\mathbf{u}\sin\theta\right]\)</span>，且<span class="math inline">\(\|\mathbf{u}\|=1\)</span>，那么：</p><p><span class="math display">\[q^2=qq=\left[\cos 2\theta,\mathbf{u}\sin 2\theta\right]\]</span></p><p>在证明之前我们可以简单思考一下，<spanclass="math inline">\(q\)</span> 表示绕 <spanclass="math inline">\(\mathbf{u}\)</span> 旋转 <spanclass="math inline">\(\theta\)</span>，那么 <spanclass="math inline">\(q^2\)</span> 表示绕 <spanclass="math inline">\(\mathbf{u}\)</span> 旋转 <spanclass="math inline">\(2\theta\)</span>，这是不是很合理？</p><p>证明：</p><p><span class="math display">\[\begin{align*}q^2 &amp; =[\cos \theta,  \mathbf{u}\sin \theta] [\cos\theta,  \mathbf{u}\sin \theta] \\&amp; =\left[\cos ^2\theta-(\mathbf{u}\sin \theta)  \cdot (\mathbf{u}\sin \theta ),(\cos \theta \sin \theta+\sin \theta \cos \theta)\mathbf{u}+(\sin \theta \mathbf{u}) \times (\sin \theta\mathbf{u})\right] \\&amp; =\left[\cos ^2\theta-\|\mathbf{u}\|^2\sin ^2\theta, 2\mathbf{u}\sin \theta \cos \theta +\mathbf{0}\right] \\&amp; =\left[\cos ^2\theta-\sin ^2\theta, 2 \mathbf{u} \sin \theta \cos\theta \right] \\&amp; =[\cos 2 \theta, \mathbf{u} \sin 2 \theta ]\end{align*}\]</span></p><p>接下来利用上面的引理，我们可以对 <spanclass="math inline">\(v&#39;\)</span> 进行简化，先令 <spanclass="math inline">\(p=\left[\cos \frac{\theta}{2}, \mathbf{u} \sin\frac{\theta}{2}\right]\)</span>，显然 <span class="math inline">\(q =p^2\)</span> 且 <span class="math inline">\(\|p\|=1\)</span>，即 <spanclass="math inline">\(p^{-1}=p^{\star}\)</span> 那么：</p><p><span class="math display">\[\begin{align*}v&#39;&amp;=v_{\parallel}+qv_{\perp}\\&amp;=pp^{-1}v_{\parallel} + ppv_{\perp}\\&amp;=pp^{\star}v_{\parallel} + ppv_{\perp}\end{align*}\]</span></p><p>继续简化之前来看第二个引理：</p><p>引理 2：对于平行于 <span class="math inline">\(\mathbf{u}\)</span>的向量 <spanclass="math inline">\(\mathbf{v}_{\parallel}\)</span>，其四元数为：<spanclass="math inline">\(v_{\parallel}=\left[0,\mathbf{v}_{\parallel}\right]\)</span>，且<span class="math inline">\(\|\mathbf{u}\|=1\)</span>。设 <spanclass="math inline">\(q=\left[\alpha,\beta\mathbf{u}\right]\)</span>，那么：<spanclass="math inline">\(qv_{\parallel}=v_{\parallel}q\)</span></p><p>证明：</p><p><span class="math display">\[\begin{align*}\text{LHS}  &amp;= qv_{\parallel} \\&amp;= \left[\alpha,\beta\mathbf{u}\right]\left[0,\mathbf{v}_{\parallel}\right]\\&amp;= \left[-\beta \mathbf{u}\cdot \mathbf{v}_{\parallel}, \alpha\mathbf{v}_{\parallel}\right]\end{align*}\]</span></p><p><span class="math display">\[\begin{align*}\text{RHS}  &amp;= v_{\parallel}q \\&amp;= \left[0,\mathbf{v}_{\parallel}\right]\left[\alpha,\beta\mathbf{u}\right]\\&amp;= \left[-\beta \mathbf{u}\cdot \mathbf{v}_{\parallel}, \alpha\mathbf{v}_{\parallel}\right]\end{align*}\]</span></p><p>引理 3：对于正交于 <span class="math inline">\(\mathbf{u}\)</span>的向量 <spanclass="math inline">\(\mathbf{v}_{\perp}\)</span>，其四元数为：<spanclass="math inline">\(v_{\perp}=\left[0,\mathbf{v}_{\perp}\right]\)</span>，且<span class="math inline">\(\|\mathbf{u}\|=1\)</span>。设 <spanclass="math inline">\(q=\left[\alpha,\beta\mathbf{u}\right]\)</span>，那么：<spanclass="math inline">\(qv_{\perp}=v_{\perp}q^{\star}\)</span></p><p>证明：</p><p><span class="math display">\[\begin{align*}\text { LHS } &amp; =q v_{\perp} \\&amp; =[\alpha, \beta \mathbf{u}] \left[0, \mathbf{v}_{\perp}\right] \\&amp; =\left[0-\beta \mathbf{u} \cdot \mathbf{v}_{\perp}, \alpha\mathbf{v}_{\perp}+\mathbf{0}+\beta \mathbf{u} \times\mathbf{v}_{\perp}\right] \\&amp; =\left[0, \alpha \mathbf{v}_{\perp}+\beta \mathbf{u} \times\mathbf{v}_{\perp}\right]\end{align*}\]</span></p><p><span class="math display">\[\begin{align*}\mathrm{RHS} &amp; =v_{\perp} q^{\star} \\&amp; =\left[0, \mathbf{v}_{\perp}\right][\alpha,-\beta \mathbf{u}] \\&amp; =\left[0+\mathbf{v}_{\perp} \cdot \beta \mathbf{u},\mathbf{0}+\alpha \mathbf{v}_{\perp}+\mathbf{v}_{\perp} \times(-\beta\mathbf{u})\right]  \\&amp; =\left[0, \alpha \mathbf{v}_{\perp}+\mathbf{v}_{\perp}\times(-\beta \mathbf{u})\right] \\&amp; =\left[0, \alpha \mathbf{v}_{\perp}-(-\beta \mathbf{u}) \times\mathbf{v}_{\perp}\right]  \\&amp; =\left[0, \alpha \mathbf{v}_{\perp}+\beta \mathbf{u} \times\mathbf{v}_{\perp}\right]\end{align*}\]</span></p><p>现在，我们就能对之前的公式做出最后的变形了：</p><p><span class="math display">\[\begin{align*}v&#39; &amp; =p p^{\star} v_{\|}+p p v_{\perp} \\&amp; =p v_{\|} p^*+p v_{\perp} p^{\star} \\&amp; =p\left(v_{\|}+v_{\perp}\right) p^{\star}\\&amp;= pvp^{\star}\end{align*}\]</span></p><p>到这里终于导出了四元数与 3D 旋转的关系，即：</p><p>任意向量 <span class="math inline">\(\mathbf{v}\)</span>绕以单位向量定义的旋转轴 <span class="math inline">\(\mathbf{u}\)</span>旋转 <span class="math inline">\(theta\)</span> 度之后得到的 <spanclass="math inline">\(\mathbf{v}&#39;\)</span> 可以用四元数来表示。令<span class="math inline">\(v=\left[0,\mathbf{0}\right]\)</span>，<spanclass="math inline">\(q=\left[\cos\frac{\theta}{2},\mathbf{u}\sin\frac{\theta}{2}\right]\)</span>，则：</p><p><span class="math display">\[v&#39;=q v q^{\star}=q v q^{-1}\]</span></p><p>这个公式非常简介，比矩阵形式的旋转变换要简单很多。</p><p>如果 <spanclass="math inline">\(q==\left[\cos\theta,\mathbf{u}\sin\theta\right]\)</span>，那么<span class="math inline">\(q v q^{\star}\)</span> 表示 <spanclass="math inline">\(\mathbf{v}\)</span> 绕着 <spanclass="math inline">\(\mathbf{u}\)</span> 旋转 <spanclass="math inline">\(2\theta\)</span> 度。</p><p>再来看看这个公式，稍微变形下：</p><p><span class="math display">\[v&#39;=q v q^{\star}=qq^{\star}v_{\parallel}+qqv_{\perp}= v_{\parallel}+ q^2v_{\perp}\]</span></p><p>也就是说，<span class="math inline">\(q v q^{\star}\)</span>这个变换实际上对平行于旋转轴的分量 <spanclass="math inline">\(v_{\parallel}\)</span> 做的变换为 <spanclass="math inline">\(qq^{\star}\)</span>，相当于啥也没做。而对于正交于旋转轴的分量<span class="math inline">\(v_{\perp}\)</span> 则是做了两次变换 <spanclass="math inline">\(q^2=qq\)</span>，即旋转了 <spanclass="math inline">\(\frac{\theta}{2}+\frac{\theta}{2}=\theta\)</span>度。</p><p>实际上：</p><p><span class="math display">\[qvq^{\star}=\left[0,\mathbf{v}\cos\theta + (1-\cos\theta)(\mathbf{u}\cdot \mathbf{v})\mathbf{u}+\left(\mathbf{u}\times\mathbf{v}\right) \sin \theta \right]\]</span></p><blockquote><p>证明上述公式可能会用到：<spanclass="math inline">\(\mathbf{a}\times\left(\mathbf{b}\times\mathbf{c}\right)=\left(\mathbf{a}\cdot\mathbf{c}\right)\mathbf{b}-\left(\mathbf{a}\cdot\mathbf{b}\right)\mathbf{c}\)</span></p></blockquote><p>如果有一个单位四元数 <spanclass="math inline">\(q=\left[a,\mathbf{b}\right]\)</span>，我们像获取它对应的旋转角度和旋转轴，可以直接得到：</p><p>$$ <span class="math display">\[\begin{align*}\frac{\theta}{2}&amp;=\arccos a\\\mathbf{u}&amp;=\frac{\mathbf{b}}{\sin\frac{\theta}{2}}=\frac{\mathbf{b}}{\sin \arccos a}\end{align*}\]</span> $$</p><h3 id="d-旋转的矩阵形式">3D 旋转的矩阵形式</h3><p>在实际的应用中，我们可能会需要将旋转与平移和缩放进行复合，所以需要用到四元数旋转的矩阵形式。前面讨论过，左乘一个四元数 <spanclass="math inline">\(q=a+b \mathrm{i} + c \mathrm{j} + d\mathrm{k}\)</span> 等同于下面这个矩阵：</p><p><span class="math display">\[L\left(q\right)=\begin{bmatrix}a &amp; -b &amp; -c &amp; -d \\b &amp; a &amp; -d &amp; c \\c &amp; d &amp; a &amp; -b \\d &amp; -c &amp; b &amp; a \\\end{bmatrix}\]</span></p><p>而右乘 <span class="math inline">\(q\)</span> 等价于：</p><p><span class="math display">\[R\left(q\right)=\begin{bmatrix}a &amp; -b &amp; -c &amp; -d \\b &amp; a &amp; d &amp; -c \\c &amp; -d &amp; a &amp; -b \\d &amp; c &amp; -b &amp; a \\\end{bmatrix}\]</span></p><p>所以，我们可以利用这两个公式将 <spanclass="math inline">\(v&#39;=qvq^{\star}\)</span> 写成矩阵形式。设 <spanclass="math inline">\(a=\cos \frac{\theta}{2}\)</span>、<spanclass="math inline">\(b=u_x\sin\frac{\theta}{2}\)</span>、<spanclass="math inline">\(c=u_y\sin\frac{\theta}{2}\)</span>、<spanclass="math inline">\(d=u_z\sin\frac{\theta}{2}\)</span>、<spanclass="math inline">\(q=a+b \mathbf{i} + c \mathbf{j} + d\mathbf{k}\)</span> 则：</p><p><span class="math display">\[\begin{align*}q v q^{\star}&amp;=L(q) R\left(q^*\right) v  \\&amp; =\begin{bmatrix}a &amp; -b &amp; -c &amp; -d \\b &amp; a &amp; -d &amp; c \\c &amp; d &amp; a &amp; -b \\d &amp; -c &amp; b &amp; a\end{bmatrix}\begin{bmatrix}a &amp; b &amp; c &amp; d \\-b &amp; a &amp; -d &amp; c \\-c &amp; d &amp; a &amp; -b \\-d &amp; -c &amp; b &amp; a\end{bmatrix} v \\&amp; =\begin{bmatrix}a^2+b^2+c^2+d^2 &amp; a b-a b-c d+c d &amp; a c+b d-a c-b d &amp; a d-bc+b c-a d \\a b-a b+c d-c d &amp; b^2+a^2-d^2-c^2 &amp; b c-a d-a d+b c &amp; b d+ac+b d+a c \\a c-b d-a c+b d &amp; b c+a d+a d+b c &amp; c^2-d^2+a^2-b^2 &amp; c d+cd-a b-a b \\a d+b c-b c-a d &amp; b d-a c+b d-a c &amp; c d+c d+a b+a b &amp;d^2-c^2-b^2+a^2\end{bmatrix}v  \\\end{align*}\]</span></p><p>将 <spanclass="math inline">\(a^2+b^2+c^2+d^2=1\)</span>，带入化简得：</p><p><span class="math display">\[q v q^{\star}=\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 1-2 c^2-2 d^2 &amp; 2 b c-2 a d &amp; 2 a c+2 b d \\0 &amp; 2 b c+2 a d &amp; 1-2 b^2-2 d^2 &amp; 2 c d-2 a b \\0 &amp; 2 b d-2 a c &amp; 2 a b+2 c d &amp; 1-2 b^2-2 c^2\end{bmatrix} v\]</span></p><p>我们就得到了矩阵形式得旋转公式：</p><p>任意向量 <span class="math inline">\(\mathbf{v}\)</span>绕以单位向量定义的旋转轴 <span class="math inline">\(\mathbf{u}\)</span>旋转 <span class="math inline">\(\theta\)</span> 角度之后得 <spanclass="math inline">\(\mathbf{v}&#39;\)</span>可以使用矩阵乘法来表示。令 <span class="math inline">\(a=\cos\frac{\theta}{2}\)</span>、<spanclass="math inline">\(b=u_x\sin\frac{\theta}{2}\)</span>、<spanclass="math inline">\(c=u_y\sin\frac{\theta}{2}\)</span>、<spanclass="math inline">\(d=u_z\sin\frac{\theta}{2}\)</span>，则：</p><p><span class="math display">\[\mathbf{v}&#39;=\begin{bmatrix}1-2 c^2-2 d^2 &amp; 2 b c-2 a d &amp; 2 a c+2 b d \\2 b c+2 a d &amp; 1-2 b^2-2 d^2 &amp; 2 c d-2 a b \\2 b d-2 a c &amp; 2 a b+2 c d &amp; 1-2 b^2-2 c^2\end{bmatrix} \mathbf{v}\]</span></p><p>这就是 3D 旋转得矩阵形式。</p><h3 id="旋转的复合-1">旋转的复合</h3><p>假设有两个表示旋转的四元数 <spanclass="math inline">\(q_1\)</span>、<spanclass="math inline">\(q_2\)</span>，先对 <spanclass="math inline">\(v\)</span> 进行 <spanclass="math inline">\(q_1\)</span> 变换，在对 <spanclass="math inline">\(v\)</span> 进行 <spanclass="math inline">\(q_2\)</span> 变换，变换的结果是什么？</p><p>先进行 <span class="math inline">\(q_1\)</span> 变换得到 <spanclass="math inline">\(v&#39;\)</span>：</p><p><span class="math display">\[v&#39;=q_1vq_1^{\star}\]</span></p><p>在进行 <span class="math inline">\(q_2\)</span> 变换得到 <spanclass="math inline">\(v&#39;&#39;\)</span>：</p><p><span class="math display">\[\begin{align*}v&#39;&#39;&amp;=q_2v&#39;q_2^{\star}\\&amp;=q_2q_1vq_1^{\star}q_2^{\star}\end{align*}\]</span></p><p>考虑到对于四元数 <span class="math inline">\(q_1\)</span> 和 <spanclass="math inline">\(q_2\)</span>，有</p><p><span class="math display">\[q_1^{\star}q_2^{\star}=\left(q_2q_1\right)^{\star}\]</span></p><p>这个证明非常简单，只需把两边的 Grassmann积算出来即可，这里就不证明了。</p><p>所以：</p><p><span class="math display">\[v&#39;&#39;=\left(q_2q_1v\right)\left(q_2q_1\right)^{\star}\]</span></p><p>也就是说，两次旋转可以先计算两个四元数的乘积，然后再对 <spanclass="math inline">\(v\)</span> 进行变换。</p><p>需要注意的是，<span class="math inline">\(q_2q_1\)</span>这个旋转变换不是分别沿着 <span class="math inline">\(q_1\)</span> 和<span class="math inline">\(q_2\)</span>两个旋转轴旋转两次，而是沿着一个全新的旋转轴进行一次旋转，不过结果是一样的</p><p>同样地，进行三次旋转：</p><p><span class="math display">\[v&#39;&#39;&#39;=\left(q_3q_2q_1v\right)\left(q_3q_2q_1\right)^{\star}\]</span></p><h3 id="双倍覆盖">双倍覆盖</h3><p>四元数与 3D 旋转的关系不是一一对应的。例如，四元数 <spanclass="math inline">\(q\)</span> 和 <spanclass="math inline">\(-q\)</span> 表示同一个旋转。如果 <spanclass="math inline">\(q\)</span> 表示绕着旋转轴 <spanclass="math inline">\(\mathbf{u}\)</span> 旋转 <spanclass="math inline">\(\theta\)</span> 度，则 <spanclass="math inline">\(-q\)</span> 表示沿着旋转轴 <spanclass="math inline">\(-\mathbf{u}\)</span> 旋转 <spanclass="math inline">\(2\pi-\theta\)</span> 度。</p><p><span class="math display">\[\begin{align*}-q&amp;=\left[-\cos\frac{\theta}{2},-\mathbf{u}\sin\frac{\theta}{2}\right]\\&amp;=\left[\cos\left(\pi-\frac{\theta}{2}\right),(-\mathbf{u})\sin\left(\pi-\frac{\theta}{2}\right)\right]\end{align*}\]</span></p><p>即：这个四元数旋转角度为：<spanclass="math inline">\(2\left(\pi-\frac{\theta}{2}\right)=2\pi-\theta\)</span>，从下图可以看出，<spanclass="math inline">\(q\)</span> 和 <spanclass="math inline">\(-q\)</span> 表示同一个旋转。</p><figure><img data-src="https://github.com/XinranSix/comment/assets/62458905/185b146f-0185-48c0-b197-6b7ec0ff2cd6"alt="双倍覆盖" /><figcaption aria-hidden="true">双倍覆盖</figcaption></figure><p>其实从四元数的旋转公式也能到初同样的结果：</p><p><span class="math display">\[(-q)v(-q)^{\star}=(-1)^2qvq^{\star}=qvq^{\star}\]</span></p><p>所以，单位四元数与 3D 旋转有一个「2 对 1 SurjectiveHomomorphism）」的关系，或者说单位四元数双倍覆盖了 3D 旋转。</p><h3 id="指数形式">指数形式</h3><p>类似与复数，四元数也有指数形式。如果 <spanclass="math inline">\(\mathbf{u}\)</span>是一个单位向量，那么对单位四元数 <spanclass="math inline">\(u=\left[0,\mathbf{u}\right]\)</span>，有：</p><p><span class="math display">\[\mathrm{e}^{u\theta}=\cos\theta+u\sin\theta=\cos\theta+\mathbf{u}\sin\theta\]</span></p><p>也就是说，四元数 <spanclass="math inline">\(q=\left[\cos\theta,\mathbf{u}\sin\theta\right]\)</span>可以使用指数表示为：<spanclass="math inline">\(\mathrm{e}^{u\theta}\)</span>.</p><p>那么任意向量 <span class="math inline">\(v\)</span> 绕以单位向量<span class="math inline">\(\mathbf{u}\)</span> 旋转 <spanclass="math inline">\(\theta\)</span> 角度之后得到的 <spanclass="math inline">\(v&#39;\)</span> 可以使用四元数的指数表示。设 <spanclass="math inline">\(v=\left[0,\mathbf{v}\right]\)</span>、<spanclass="math inline">\(u=\left[0,\mathbf{u}\right]\)</span>，则：</p><p><span class="math display">\[v&#39;=\mathrm{e}^{u\theta}v\mathrm{e}^{-u\theta}\]</span></p><p>有了四元数的指数定义，我们就可以定义四元数的更多运算了。首先是自然对数，对于任意单位四元数<spanclass="math inline">\(q=\left[\cos\theta,\mathbf{u}\sin\theta\right]\)</span>：</p><p><span class="math display">\[\ln q=\ln(\mathrm{e}^{u\theta})=\left[0,\mathbf{u}\theta\right]\]</span></p><p>也可以定义四元数的幂运算：</p><p><span class="math display">\[q^t=\left(\mathrm{e}^{u\theta}\right)^t=\mathrm{e}^{u(\thetat)}=\left[\cos t\theta,\mathbf{u}\sin t\theta\right]\]</span></p><h2 id="四元数插值">四元数插值</h2><p><span class="math display">\[q_t=\mathrm{Slerp}\left(q_0,q_1,y\right) =\left(q_1q_0^{\star}\right)^tq_0\]</span></p><blockquote><p>先就这样吧，更多细节以后再补充。</p></blockquote><h2 id="参考">参考</h2><ul><li><a href="https://en.wikipedia.org/wiki/Quaternion">Quaternion |Wikipedia</a></li><li><a href="https://zhuanlan.zhihu.com/p/157721160">四元数指数映射 |知乎</a></li></ul>]]></content>
    
    
    <summary type="html">四元数与 3D 旋转</summary>
    
    
    
    <category term="计算机图形学" scheme="https://xinransix.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="https://xinransix.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="四元数" scheme="https://xinransix.github.io/tags/%E5%9B%9B%E5%85%83%E6%95%B0/"/>
    
    <category term="旋转" scheme="https://xinransix.github.io/tags/%E6%97%8B%E8%BD%AC/"/>
    
    <category term="欧拉角" scheme="https://xinransix.github.io/tags/%E6%AC%A7%E6%8B%89%E8%A7%92/"/>
    
  </entry>
  
  <entry>
    <title>SymPy 的简单使用</title>
    <link href="https://xinransix.github.io/2024/02/13/SymPy%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://xinransix.github.io/2024/02/13/SymPy%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2024-02-13T15:03:41.000Z</published>
    <updated>2024-02-24T05:30:21.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sympy-库简介"><code>SymPy</code> 库简介</h2><p><a href="https://www.sympy.org/en/index.html">SymPy</a>是一个用于符号数学的 <code>Python</code> 库。</p><p>可以用来代替 Mathematica 和 Maple 等数学软件，同时可以结合<code>Python</code> 其他库来拓展功能。</p><h2 id="加载-sympy-库">加载 <code>SymPy</code> 库</h2><p>使用如下代码加载 <code>SymPy</code> 库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy <span class="keyword">as</span> sp</span><br><span class="line">sp.init_printing()</span><br></pre></td></tr></table></figure><p>当然，你要先使用 <code>pip</code> 安装 <code>sympy</code> 库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install sympy</span><br></pre></td></tr></table></figure><blockquote><p>注意：调用 <code>init_printing()</code>可能会使代码执行时间过长甚至出现卡死的情况，可以不调用该函数。</p></blockquote><h2 id="四则运算">四则运算</h2><div class="tabs" id="sympy四则运算"><ul class="nav-tabs"><li class="tab active"><a href="#sympy四则运算-1">加法</a></li><li class="tab"><a href="#sympy四则运算-2">减法</a></li><li class="tab"><a href="#sympy四则运算-3">乘法</a></li><li class="tab"><a href="#sympy四则运算-4">除法</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sympy四则运算-1"><p><span class="math display">\[3 + 2\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> + <span class="number">2</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="sympy四则运算-2"><p><span class="math display">\[3 - 2\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> - <span class="number">2</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="sympy四则运算-3"><p><span class="math display">\[3 * 2\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> * <span class="number">2</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="sympy四则运算-4"><p><span class="math display">\[\frac{3}{2}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> / <span class="number">2</span></span><br></pre></td></tr></table></figure></div></div></div><p>使用如下代码处理分数：</p><div class="tabs" id="sympy分数"><ul class="nav-tabs"><li class="tab active"><a href="#sympy分数-1">分数</a></li><li class="tab"><a href="#sympy分数-2">分母</a></li><li class="tab"><a href="#sympy分数-3">分子</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sympy分数-1"><p><span class="math display">\[\frac{3}{2}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.Rational(<span class="number">3</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="sympy分数-2"><p><span class="math display">\[\frac{3}{2}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.denom(sp.Rational(<span class="number">3</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="sympy分数-3"><p><span class="math display">\[\frac{3}{2}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.numer(sp.Rational(<span class="number">3</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure></div></div></div><h2 id="幂阶乘">幂、阶乘</h2><div class="tabs" id="sympy幂和阶乘"><ul class="nav-tabs"><li class="tab active"><a href="#sympy幂和阶乘-1">幂</a></li><li class="tab"><a href="#sympy幂和阶乘-2">阶乘</a></li><li class="tab"><a href="#sympy幂和阶乘-3">双阶乘</a></li><li class="tab"><a href="#sympy幂和阶乘-4">平方根</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sympy幂和阶乘-1"><p><span class="math display">\[3^2\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> ** <span class="number">2</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="sympy幂和阶乘-2"><p><span class="math display">\[50!\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.factorial(<span class="number">50</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="sympy幂和阶乘-3"><p><span class="math display">\[50!!\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.factorial2(<span class="number">50</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="sympy幂和阶乘-4"><p><span class="math display">\[\sqrt{50}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.sqrt(<span class="number">50</span>)</span><br></pre></td></tr></table></figure></div></div></div><h2 id="常数">常数</h2><div class="tabs" id="sympy中的常数"><ul class="nav-tabs"><li class="tab active"><a href="#sympy中的常数-1">圆周率</a></li><li class="tab"><a href="#sympy中的常数-2">自然对数的底数</a></li><li class="tab"><a href="#sympy中的常数-3">无穷大</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sympy中的常数-1"><p><span class="math display">\[\pi\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.pi</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="sympy中的常数-2"><p><span class="math display">\[\mathrm{e}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.E</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="sympy中的常数-3"><p><span class="math display">\[\infty\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.oo</span><br></pre></td></tr></table></figure></div></div></div><h2 id="复数">复数</h2><div class="tabs" id="复数"><ul class="nav-tabs"><li class="tab active"><a href="#复数-1">虚数单位</a></li><li class="tab"><a href="#复数-2">共轭复数</a></li><li class="tab"><a href="#复数-3">实部</a></li><li class="tab"><a href="#复数-4">虚部</a></li><li class="tab"><a href="#复数-5">模长</a></li><li class="tab"><a href="#复数-6">幅角</a></li></ul><div class="tab-content"><div class="tab-pane active" id="复数-1"><p><span class="math display">\[\mathrm{i}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.I</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="复数-2"><p><span class="math display">\[\overline{2 + 3\mathrm{i}}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.conjugate(<span class="number">2</span> + <span class="number">3</span> * sp.I)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="复数-3"><p><span class="math display">\[\mathrm{Re}\left(2 + 3\mathrm{i}\right)\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.re(<span class="number">2</span> + sp.I * <span class="number">3</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="复数-4"><p><span class="math display">\[\mathrm{Im}\left(2 + 3\mathrm{i}\right)\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.im(<span class="number">2</span> + sp.I * <span class="number">3</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="复数-5"><p><span class="math display">\[\left|2 + 3\mathrm{i}\right|\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.Abs(<span class="number">2</span> + sp.I * <span class="number">3</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="复数-6"><p><span class="math display">\[\mathrm{Arg} \left(2 + 3\mathrm{i}\right)\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.arg(<span class="number">2</span> + sp.I * <span class="number">3</span>)</span><br></pre></td></tr></table></figure></div></div></div><h2 id="变量">变量</h2><h3 id="声明变量">声明变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, r, s, t, u, v, w, x, y, z = sp.symbols(<span class="string">&#x27;a b c d e f g h i j k l m n o p r s t u v w x y z&#x27;</span>)</span><br><span class="line">A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, R, S, T, U, V, W, X, Y, Z = sp.symbols(<span class="string">&#x27;A B C D E F G H I J K L M N O P R S T U V W X Y Z&#x27;</span>)</span><br><span class="line">alpha, beta, gamma, delta, epsilon, zeta, eta, theta, iota, kappa, lamda, mu, nu, xi, omicron, pi, rho, sigma, tau, upsilon, phi, chi, psi, omega = sp.symbols(<span class="string">&#x27;alpha beta gamma delta epsilon zeta eta theta iota kappa lamda mu nu xi omicron pi rho sigma tau upsilon phi chi psi omega&#x27;</span>)</span><br><span class="line">Alpha, Beta, Gamma, Delta, Epsilon, Zeta, Eta, Theta, Iota, Kappa, Lamda, Mu, Nu, Xi, Omicron, Pi, Rho, Sigma, Tau, Upsilon, Phi, Chi, Psi, Omega = sp.symbols(<span class="string">&#x27;Alpha Beta Gamma Delta Epsilon Zeta Eta Theta Iota Kappa Lamda Mu Nu Xi Omicron Pi Rho Sigma Tau Upsilon Phi Chi Psi Omega&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="算术运算">算术运算</h3><p><span class="math display">\[x+y+x-y\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x + y + x - y</span><br></pre></td></tr></table></figure><p><span class="math display">\[\left(x+y\right)^2\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x + y) ** <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="代数运算">代数运算</h2><h3 id="质因数分解">质因数分解</h3><p><span class="math display">\[10!=2^8 \cdot 3^4 \cdot 5^2 \cdot 7\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.factorint(sp.factorial(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><h3 id="因式分解">因式分解</h3><p><span class="math display">\[x^2 -4x+3 = \left(x-3\right)\left(x-1\right)\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.factor(x ** <span class="number">2</span> - <span class="number">4</span> * x + <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><ahref="https://en.wikipedia.org/wiki/Irreducible_polynomial">不可约多项式</a>在整数上的因式分解：</p><p><span class="math display">\[\left(1+x-x^2\right)\left(1-x-x^2\right)=\left(x^2-x-1\right)\left(x^2+x-1\right)\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.factor((<span class="number">1</span> + x - x ** <span class="number">2</span>) * (<span class="number">1</span> - x - x ** <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p><ahref="https://en.wikipedia.org/wiki/Cyclotomic_polynomial">分圆多项式</a>的不可约因式分解（模5）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.factor((<span class="number">1</span> + x - x ** <span class="number">2</span>) * (<span class="number">1</span> - x - x ** <span class="number">2</span>), modulus=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h3 id="化简">化简</h3><p><span class="math display">\[\frac{x+xy}{x}=y+1\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.simplify((x + x * y) / x)</span><br></pre></td></tr></table></figure><p><span class="math display">\[\frac{\sin x}{\cos x} = \tan x\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.trigsimp(sp.sin(x) / sp.cos(x))</span><br></pre></td></tr></table></figure><p><span class="math display">\[\sin^2x + \cos^2x = 1\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.trigsimp((sp.sin(a)) ** <span class="number">2</span> + (sp.cos(a)) ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><span class="math display">\[\sinh^2a+\cosh^2a = \cosh 2a\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.trigsimp((sp.sinh(a)) ** <span class="number">2</span> + (sp.cosh(a)) ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="部分分式分解">部分分式分解</h3><p><span class="math display">\[\frac{1}{x^2-4x+3} = \frac{1}{2\left(x-3\right)} -\frac{1}{2\left(x-1\right)}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.apart(<span class="number">1</span> / (x ** <span class="number">2</span> - <span class="number">4</span> * x + <span class="number">3</span>))</span><br></pre></td></tr></table></figure><p><span class="math display">\[\frac{1}{x^6-1}=\frac{x-2}{6\left(x^2-x+1\right)}-\frac{x+2}{6\left(x^2+x+1\right)}-\frac{1}{6\left(x+1\right)}+\frac{1}{6\left(x-1\right)}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.apart(<span class="number">1</span> / (x ** <span class="number">6</span> - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h3 id="展开">展开</h3><p><span class="math display">\[\left(x+y\right)^6=x^6+6x^5y+15x^4y^2+20x^3y^3+15x^2y^4+6xy^5+y^6\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.expand((x + y) ** <span class="number">6</span>)</span><br></pre></td></tr></table></figure><p><span class="math display">\[\tan\left(a+b\right)=\frac{\tan a+\tan b}{1-\tan a\tan b}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.simplify(sp.expand(sp.tan(a + b), trig=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure><details class="note "><summary><p>pink fas fa-car-crash simple</p></summary><p>注意：<code>trig=True</code> 表示展开三角函数。</p></details><h3 id="通分">通分</h3><p><span class="math display">\[\frac{2x-2}{\left(x-1\right)^2\left(x-2\right)}=\frac{2}{\left(x-2\right)\left(x-1\right)}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.simplify((<span class="number">2</span> * x - <span class="number">2</span>) / ((x - <span class="number">1</span>) ** <span class="number">2</span> * (x - <span class="number">2</span>)))</span><br></pre></td></tr></table></figure><p><span class="math display">\[\frac{1}{\left(x-1\right)^2}+\frac{1}{\left(x-1\right)\left(x-2\right)}=\frac{2x-3}{\left(x-2\right)\left(x-1\right)^2}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.simplify(<span class="number">1</span> / (x - <span class="number">1</span>) ** <span class="number">2</span> + <span class="number">1</span> / ((x - <span class="number">1</span>) * (x - <span class="number">2</span>)))</span><br></pre></td></tr></table></figure><h3 id="通分展开">通分展开</h3><p><span class="math display">\[\frac{2x-2}{\left(x-1\right)^2\left(x-2\right)}=\frac{2}{x^2-3x+2}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.cancel((<span class="number">2</span> * x - <span class="number">2</span>) / ((x - <span class="number">1</span>) ** <span class="number">2</span> * (x - <span class="number">2</span>)))</span><br></pre></td></tr></table></figure><p><span class="math display">\[\frac{1}{\left(x-1\right)^2}+\frac{1}{\left(x-1\right)\left(x-2\right)}=\frac{2x-3}{x^3-4x^2+5x-2}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.cancel(<span class="number">1</span> / (x - <span class="number">1</span>) ** <span class="number">2</span> + <span class="number">1</span> / ((x - <span class="number">1</span>) * (x - <span class="number">2</span>)))</span><br></pre></td></tr></table></figure><h3 id="系数">系数</h3><p>求</p><p><span class="math display">\[\left(x+y\right)^6\]</span></p><p>的 <span class="math inline">\(x^3\)</span> 的系数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.expand((x + y) ** <span class="number">6</span>).coeff(x, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="代入">代入</h3><p><span class="math display">\[a x^2+b x+c\left.\right|_{x=3}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a * x ** <span class="number">2</span> + b * x + c).subs(x, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><span class="math display">\[ax^2+bx+c\]</span></p><p>where:</p><p><span class="math display">\[x=\frac{-b+\sqrt{-4ac+b^2}}{2a}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.expand((a * x ** <span class="number">2</span> + b * x + c).subs(x, (-b + sp.sqrt(-<span class="number">4</span> * a * c + b ** <span class="number">2</span>)) / (<span class="number">2</span> * a)))</span><br></pre></td></tr></table></figure><h3 id="求和">求和</h3><p><span class="math display">\[\sum_{x=1}^{10}x\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.summation(x, (x, <span class="number">1</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p><span class="math display">\[\sum_{x=1}^{a}x\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.factor(sp.summation(x, (x, <span class="number">1</span>, a)))</span><br></pre></td></tr></table></figure><p><span class="math display">\[\sum_{x=1}^{a}x^3\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.factor(sp.summation(x ** <span class="number">3</span>, (x, <span class="number">1</span>, a)))</span><br></pre></td></tr></table></figure><h3 id="求积">求积</h3><p><span class="math display">\[\prod_{x=1}^{10}x\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.product(x, (x, <span class="number">1</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><h2 id="命题逻辑">命题逻辑</h2><h3 id="真伪判断">真伪判断</h3><div class="tabs" id="真伪判断"><ul class="nav-tabs"><li class="tab active"><a href="#真伪判断-1">例1</a></li><li class="tab"><a href="#真伪判断-2">例2</a></li><li class="tab"><a href="#真伪判断-3">例3</a></li><li class="tab"><a href="#真伪判断-4">例4</a></li><li class="tab"><a href="#真伪判断-5">例5</a></li></ul><div class="tab-content"><div class="tab-pane active" id="真伪判断-1"><p><span class="math display">\[0=\sqrt{2}-2^{\frac{1}{2}} \text { ? }\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> == sp.sqrt(<span class="number">2</span>) - <span class="number">2</span> ** (sp.Rational(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="真伪判断-2"><p><span class="math display">\[0=\sqrt{2}-2^{\frac{1}{3}} \text { ? }\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> == sp.sqrt(<span class="number">2</span>) - <span class="number">2</span> ** (sp.Rational(<span class="number">1</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">False</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="真伪判断-3"><p><span class="math display">\[10!=\prod_{x=1}^{10}x \text { ? }\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.factorial(<span class="number">10</span>) == sp.product(x, (x, <span class="number">1</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="真伪判断-4"><p><span class="math display">\[50!=50!!\times 49!!\text { ? }\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.factorial(<span class="number">10</span>) == sp.product(x, (x, <span class="number">1</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="真伪判断-5"><p>对于公式的处理要小心，例如对于如下判断：</p><p><span class="math display">\[x^2-2x+1=\left(x-1\right)^2 \text {?}\]</span></p><p>结果应该为 <code>True</code>，但如果使用如下代码的话：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x ** <span class="number">2</span> - <span class="number">2</span> * x + <span class="number">1</span> == (x - <span class="number">1</span>) ** <span class="number">2</span></span><br></pre></td></tr></table></figure><p>其结果为<code>False</code>，应该显示的将公式进行展开，然后再进行判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x ** <span class="number">2</span> - <span class="number">2</span> * x + <span class="number">1</span> == sp.expand((x - <span class="number">1</span>) ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>这样就可以得到我们想要的结果。</p></div></div></div><h3 id="逻辑运算">逻辑运算</h3><div class="tabs" id="逻辑运算"><ul class="nav-tabs"><li class="tab active"><a href="#逻辑运算-1">例1</a></li><li class="tab"><a href="#逻辑运算-2">例2</a></li></ul><div class="tab-content"><div class="tab-pane active" id="逻辑运算-1"><p><span class="math display">\[x \wedge y=\text { True ? }\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.satisfiable(x &amp; y)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;x: True, y: True&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="逻辑运算-2"><p><span class="math display">\[x \wedge \neg x=\text { True ? }\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.satisfiable(x &amp; ~x)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">False</span><br></pre></td></tr></table></figure></div></div></div><h2 id="数学分析">数学分析</h2><h3 id="函数定义">函数定义</h3><p><span class="math display">\[f\left(x\right) =\frac{\log\left(x+1\right)}{x}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> sp.log(<span class="number">1</span> + x) / x</span><br><span class="line"></span><br><span class="line">f(x)</span><br></pre></td></tr></table></figure><h3 id="极限">极限</h3><div class="tabs" id="极限"><ul class="nav-tabs"><li class="tab active"><a href="#极限-1">例1</a></li><li class="tab"><a href="#极限-2">例2</a></li><li class="tab"><a href="#极限-3">例3</a></li><li class="tab"><a href="#极限-4">例4</a></li></ul><div class="tab-content"><div class="tab-pane active" id="极限-1"><p><span class="math display">\[\lim _{x \rightarrow 0} \frac{\sin (x)}{x}=1\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.limit(sp.sin(x) / x, x, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="极限-2"><p><span class="math display">\[\lim _{x \rightarrow \infty} x=\infty\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.limit(x, x, sp.oo)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="极限-3"><p><span class="math display">\[\lim _{x \rightarrow \infty} \frac{1}{x}=0\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.limit(<span class="number">1</span> / x, x, sp.oo)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="极限-4"><p><span class="math display">\[\lim _{x \rightarrow 0} x^x=1\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.limit(x ** x, x, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></div></div></div><h3 id="微分">微分</h3><div class="tabs" id="微分"><ul class="nav-tabs"><li class="tab active"><a href="#微分-1">例1</a></li><li class="tab"><a href="#微分-2">例2</a></li><li class="tab"><a href="#微分-3">例3</a></li><li class="tab"><a href="#微分-4">例4</a></li><li class="tab"><a href="#微分-5">例5</a></li></ul><div class="tab-content"><div class="tab-pane active" id="微分-1"><p><span class="math display">\[\frac{\partial}{\partial x}(x+y)^3=3(x+y)^2\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.diff((x + y) ** <span class="number">3</span>, x)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="微分-2"><p><span class="math display">\[\frac{\partial^2}{\partial y^2}(x+y)^3=6(x+y)\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.diff((x + y) ** <span class="number">3</span>, y, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="微分-3"><p><span class="math display">\[\frac{\mathrm{d}}{\mathrm{d} x} \tan (x)=\tan ^2(x)+1\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.diff(sp.tan(x), x)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="微分-4"><p><span class="math display">\[\lim _{y \rightarrow 0} \frac{\tan (x+y)-\tan (x)}{y}=\tan ^2(x)+1\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.limit((sp.tan(x + y) - sp.tan(x)) / y, y, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="微分-5"><p><span class="math display">\[\frac{\mathrm{d}}{\mathrm{d} x} f(x)=\frac{\mathrm{d}}{\mathrm{d} x}\frac{\log (x+1)}{x}=\frac{1}{x(x+1)}-\frac{\log (x+1)}{x^2}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.diff(f(x), x, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></div></div></div><h3 id="级数展开">级数展开</h3><p><span class="math display">\[\frac{1}{\cos (x)}=1+\frac{x^2}{2}+\frac{5x^4}{24}+\Omicron\left(x^6\right)\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.series(sp.cos(x), x)</span><br></pre></td></tr></table></figure><p><span class="math display">\[f(x)=\frac{\log(x+1)}{x}=1-\frac{x}{2}+\frac{x^2}{3}-\frac{x^3}{4}+\frac{x^4}{5}-\frac{x^5}{6}+\frac{x^6}{7}+\Omicron\left(x^7\right)\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.series(f(x), x, <span class="number">0</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure><h3 id="积分">积分</h3><p><span class="math display">\[\int\left(x+y\right)\mathrm{d}x = \frac{x^2}{2}+xy\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.integrate(x + y, x)</span><br></pre></td></tr></table></figure><p><span class="math display">\[\int(2 x+\sinh x) \mathrm{d} x=x^2+\cosh (x)\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.integrate(<span class="number">2</span> * x + sp.sinh(x), x)</span><br></pre></td></tr></table></figure><p><span class="math display">\[\int_0^6(x+y)^3 \mathrm{d} x=6 y^3+54 y^2+216 y+324\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.integrate((x + y) ** <span class="number">3</span>, (x, <span class="number">0</span>, <span class="number">6</span>))</span><br></pre></td></tr></table></figure><p><span class="math display">\[\int_{-\infty}^{\infty} \mathrm{e}^{-x^2} \mathrm{d} x=\sqrt{\pi}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.integrate(sp.exp(-x ** <span class="number">2</span>), (x, -sp.oo, sp.oo))</span><br></pre></td></tr></table></figure><p><span class="math display">\[\int \mathrm{e}^{-x^2} \operatorname{erf}(x) \mathrm{d} x=\frac{\sqrt{x}\operatorname{erf}^2(x)}{4}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.integrate(sp.exp(-x ** <span class="number">2</span>) * sp.erf(x), x)</span><br></pre></td></tr></table></figure><p><span class="math display">\[\int f(x) \mathrm{d}  x=\int \frac{\log (x+1)}{x} \mathrm{d}x=-\operatorname{Li}_2\left(x \mathrm{e}^{i \pi}\right)\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.integrate(f(x), x)</span><br></pre></td></tr></table></figure><h2 id="代数方程">代数方程</h2><h3 id="求解">求解</h3><p>解方程：</p><p><span class="math display">\[x^4-1=0\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.solve(x ** <span class="number">4</span> - <span class="number">1</span>, x)</span><br></pre></td></tr></table></figure><p>解方程组：</p><p><span class="math display">\[\begin{align*}x+5y-2=0\\-3x+6y-15=0\end{align*}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.solve([x + <span class="number">5</span> * y - <span class="number">2</span>, -<span class="number">3</span> * x + <span class="number">6</span> * y - <span class="number">15</span>], [x, y])</span><br></pre></td></tr></table></figure><p><span class="math display">\[\mathrm{e}^x + 1= 0\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.solve(sp.exp(x) + <span class="number">1</span>, x)</span><br></pre></td></tr></table></figure><p><span class="math display">\[ax^2+bx+c=0\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.solve(a * x ** <span class="number">2</span> + b * x + c, x)</span><br></pre></td></tr></table></figure><h3 id="等式">等式</h3><p>解方程 <span class="math display">\[x+1=\frac{x+1}{x^2+x-2}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">equation = sp.Eq(x + <span class="number">1</span>, (x + <span class="number">1</span>) / (x ** <span class="number">2</span> + x - <span class="number">2</span>))</span><br><span class="line">sp.solve(equation, x)</span><br></pre></td></tr></table></figure><p>得到等式右边：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">equation.rhs</span><br></pre></td></tr></table></figure><p>得到等式左边：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">equation.lhs</span><br></pre></td></tr></table></figure><h2 id="线性代数">线性代数</h2><h3 id="矩阵">矩阵</h3><p><span class="math display">\[\begin{bmatrix}1 &amp; x \\y &amp; 1\end{bmatrix}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.Matrix([[<span class="number">1</span>, x], [y, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure><p><span class="math display">\[\begin{bmatrix}1 &amp; x \\y &amp; 1\end{bmatrix}^2=\begin{bmatrix}xy+1 &amp; 2x \\2y &amp; xy+1  \end{bmatrix}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.Matrix([[<span class="number">1</span>, x], [y, <span class="number">1</span>]]) ** <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="阶梯型">阶梯型</h3><p><span class="math display">\[\begin{bmatrix}1 &amp; 0 &amp; 1 &amp; 3 \\2 &amp; 3 &amp; 4 &amp; 7 \\-1 &amp; -3 &amp; -3 &amp; -4\end{bmatrix}\]</span></p><p>的阶梯型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.Matrix([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>], [-<span class="number">1</span>, -<span class="number">3</span>, -<span class="number">3</span>, -<span class="number">4</span>]]).rref()</span><br></pre></td></tr></table></figure><h3 id="零空间">零空间</h3><p><span class="math display">\[\begin{bmatrix}1 &amp; 2 &amp; 3 &amp; 0 &amp; 0\\4 &amp; 10 &amp; 0 &amp; 0 &amp; 1\end{bmatrix}\]</span></p><p>的零空间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.Matrix([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">4</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]]).nullspace()</span><br></pre></td></tr></table></figure><h3 id="列空间">列空间</h3><p><span class="math display">\[\begin{bmatrix}1 &amp; 1 &amp; 2 \\2 &amp; 1 &amp; 3 \\3 &amp; 1 &amp; 4\end{bmatrix}\]</span></p><p>的列空间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.Matrix([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>]]).columnspace()</span><br></pre></td></tr></table></figure><h3 id="特征方程">特征方程</h3><p><span class="math display">\[\begin{bmatrix}3 &amp; -2 &amp; 4 &amp; -2 \\5 &amp; 3 &amp; -3 &amp; -2 \\5 &amp; -2 &amp; 2 &amp; -2 \\5 &amp; -2 &amp; -3 &amp; 3\end{bmatrix}\]</span></p><p>的特征方程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.factor(sp.Matrix([[<span class="number">3</span>, -<span class="number">2</span>, <span class="number">4</span>, -<span class="number">2</span>], [<span class="number">5</span>, <span class="number">3</span>, -<span class="number">3</span>, -<span class="number">2</span>], [<span class="number">5</span>, -<span class="number">2</span>, <span class="number">2</span>, -<span class="number">2</span>], [<span class="number">5</span>, -<span class="number">2</span>, -<span class="number">3</span>, <span class="number">3</span>]]).charpoly())</span><br></pre></td></tr></table></figure><h3 id="特征值和特征向量">特征值和特征向量</h3><p><span class="math display">\[\begin{bmatrix}3 &amp; -2 &amp; 4 &amp; -2 \\5 &amp; 3 &amp; -3 &amp; -2 \\5 &amp; -2 &amp; 2 &amp; -2 \\5 &amp; -2 &amp; -3 &amp; 3\end{bmatrix}\]</span></p><p>的特征值和特征向量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.Matrix([[<span class="number">3</span>, -<span class="number">2</span>, <span class="number">4</span>, -<span class="number">2</span>], [<span class="number">5</span>, <span class="number">3</span>, -<span class="number">3</span>, -<span class="number">2</span>], [<span class="number">5</span>, -<span class="number">2</span>, <span class="number">2</span>, -<span class="number">2</span>], [<span class="number">5</span>, -<span class="number">2</span>, -<span class="number">3</span>, <span class="number">3</span>]]).eigenvects()</span><br></pre></td></tr></table></figure><h3 id="对角化">对角化</h3><p><span class="math display">\[\begin{bmatrix}3 &amp; -2 &amp; 4 &amp; -2 \\5 &amp; 3 &amp; -3 &amp; -2 \\5 &amp; -2 &amp; 2 &amp; -2 \\5 &amp; -2 &amp; -3 &amp; 3\end{bmatrix}\]</span></p><p>对其对角化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P, D = sp.Matrix([[<span class="number">3</span>, -<span class="number">2</span>, <span class="number">4</span>, -<span class="number">2</span>], [<span class="number">5</span>, <span class="number">3</span>, -<span class="number">3</span>, -<span class="number">2</span>], [<span class="number">5</span>, -<span class="number">2</span>, <span class="number">2</span>, -<span class="number">2</span>], [<span class="number">5</span>, -<span class="number">2</span>, -<span class="number">3</span>, <span class="number">3</span>]]).diagonalize()</span><br></pre></td></tr></table></figure><h2 id="微分方程">微分方程</h2><h3 id="定义未知函数">定义未知函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = sp.symbols(<span class="string">&#x27;f&#x27;</span>, cls=sp.Function)</span><br></pre></td></tr></table></figure><h3 id="求解微分方程">求解微分方程</h3><p><span class="math display">\[\frac{\mathrm{d}^2}{\mathrm{d}x^2}f(x)+f(x)=0\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.dsolve(f(x).diff(x, x) + f(x), f(x))</span><br></pre></td></tr></table></figure><p><span class="math display">\[x \frac{\mathrm{d}}{\mathrm{d} x} f(x)+f(x)-f^2(x)=0\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.dsolve(x * f(x).diff(x) + f(x) - f(x) ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><span class="math display">\[x \frac{\mathrm{d}}{\mathrm{d} x} f(x)+f(x)-f^2(x)=0\]</span></p><p>这是一个伯努利类型的微分方程，我们可以暗示它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.dsolve(x * f(x).diff(x) + f(x) - f(x) ** <span class="number">2</span>, f(x), hint=<span class="string">&#x27;Bernoulli&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="输出-latex">输出 LaTex</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">equation = sp.Eq(a * x ** <span class="number">2</span> + b * x + c, <span class="number">0</span>)</span><br><span class="line">solution = sp.solve(equation, x)</span><br><span class="line"><span class="built_in">print</span>(sp.latex(solution))</span><br></pre></td></tr></table></figure><h2 id="小结">小结</h2><p>尝试使用 <code>SymPy</code> 求解下面的积分吧：</p><p><span class="math display">\[\int_0^1\left(x^2+\frac{x}{\sqrt{1+x^2}}\right)\left(1+\frac{x}{\left(1+x^2\right)\sqrt{1+x^2}}\right) \mathrm{d} x\]</span></p><p>参考答案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp.integrate((x ** <span class="number">2</span> + x / sp.sqrt(<span class="number">1</span> + x ** <span class="number">2</span>)) * (<span class="number">1</span> + x / (<span class="number">1</span> + x ** <span class="number">2</span>) / sp.sqrt(<span class="number">1</span> + x ** <span class="number">2</span>)), (x, <span class="number">0</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><ul><li><ahref="https://gochikika.ntt.com/Features/SymPy.html">SymPyの使い方</a></li></ul>]]></content>
    
    
    <summary type="html">简单介绍 SymPy 库</summary>
    
    
    
    <category term="工具" scheme="https://xinransix.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Python" scheme="https://xinransix.github.io/tags/Python/"/>
    
    <category term="SymPy" scheme="https://xinransix.github.io/tags/SymPy/"/>
    
  </entry>
  
  <entry>
    <title>C++ 模板元编程基础</title>
    <link href="https://xinransix.github.io/2023/08/07/CPP%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://xinransix.github.io/2023/08/07/CPP%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2023-08-07T03:16:50.000Z</published>
    <updated>2023-08-07T03:18:30.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="元编程基础">元编程基础</h2><p>元函数较为接近数学的定义为：是一个无副作用的映射或变换，即在输入相同的前提下，多次调用同一个函数，得到的结果也是相同的。</p><p>元函数会在编译器被调用。</p><p>编译阶段，编译器只能构造常量作为中间结果，无法构造并维护可以记录系统状态并随着改变的量，因此编译器可以使用的函数只能是无副作用的函数。</p><p>例如下面这个函数可以作为元函数使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a + <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure><p>而下面的代码不能通过编译：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> call_count = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fun2</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a + (call_count++); &#125;</span><br></pre></td></tr></table></figure><p>从某一角度来看，元函数可以分为数值元函数和类型元函数，上面的<code>fun</code> 视为数组元函数。</p><p>类型元函数用的比数值元函数多。</p><h3 id="类型元函数">类型元函数</h3><p>一个函数（映射）从数学的角度来定义：</p><p><span class="math display">\[y = f\left(x\right)\]</span></p><p>元编程的核心是元函数，元函数的输入、输出的形式可以有很多种，可以是数值类型，也可以将C++ 的数据类型作为函数的输出与输入。</p><p>例如下面的元函数将 <code>int</code> 和 <code>long</code>转换为对应的无符号类型，如果不是这两个类型则直接返回原类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun_</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun_</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun_</span>&lt;<span class="type">long</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">unsigned</span> <span class="type">long</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Fun = <span class="keyword">typename</span> Fun_&lt;T&gt;::type;</span><br><span class="line"></span><br><span class="line">Fun_&lt;<span class="type">int</span>&gt;::type h = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>在上古神作《C++ 模板元编程》一书中（现在有点过时了这书），将类模板<code>Fun_</code> 视为元函数，当输入为 <code>X</code> 时，输出为<code>Fun_&lt;X&gt;::type</code>，同时，该书规定了所讨论的元函数的输入和输出均是类型。</p><p>在《C++ 模板元编程》中，将一个包含了 <code>type</code>声明的类模板视为元函数，这一定义并非不好（统一了接口，带来了设计上的便利性），但过于狭隘。</p><p>将元函数定义为：</p><ul><li>不限制映射的表示方法，例如以 <code>constexpr</code>开头的函数，已经提供内嵌 <code>type</code>类型的模板，以及后文讨论的其他形式的「函数」，只要其无副作用，同时可以在编译器被调用，都可以视为元函数。</li><li>不限制输入与输出的形式，输入与输出可以是数值、类型、模板等等。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Fun = <span class="keyword">typename</span> Fun_&lt;T&gt;::type;</span><br><span class="line"></span><br><span class="line">Fun&lt;<span class="type">int</span>&gt; h = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p><code>Fun</code> 如果按照《C++模板元编程》中的定义，它表示一个标准的元函数，原因在于其没有内嵌类型<code>type</code>，但根据我们的定义，它应该被视为一个元函数。</p><p>在标准库中，也是有这种方式来定义元函数，例如，在 C++ 11中定义了元函数 <code>std::enable_if</code>，而在 C++ 14 引入了 定义<code>std::enable_if_t</code>，它们的关系大致为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">enable_if_t</span> = <span class="keyword">typename</span> enable_if&lt;T&gt;::type</span><br></pre></td></tr></table></figure><blockquote><p>实际上，在 C++ 14 中对 C++ 11 中的元函数做了「增强」，例如<code>std::xxx&lt;X&gt;::type</code> 可以通过<code>std::xxx_t&lt;X&gt;</code>代替，<code>std::xxx&lt;X&gt;::value</code> 可以通过<code>std::xxx_v&lt;X&gt;</code> 代替。</p></blockquote><h3 id="各种各样的元函数">各种各样的元函数</h3><p>一切「无副作用」的、可以在编译器被调用，用于对编译器甚乃至运行期的程序行为产生影响，那么这个映射都可以称为元函数，其表现形式千变万化。</p><p>实际上，一个模板就是一个元函数。例如，下面这个类模板就是一个元函数，它接受一个输入<code>T</code>，输出为 <code>Fun&lt;T&gt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><p>我们可以建立无参元函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参，返回值为 int</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">int</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参，返回值为 10</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用 C++ 14 中对 <code>constexpr</code> 的拓展来构建元函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> a&gt; </span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> fun = a + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>元函数可以有多个返回值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun_</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> reference_type = <span class="type">int</span> &amp;;</span><br><span class="line">    <span class="keyword">using</span> const_reference_type = <span class="type">const</span> <span class="type">int</span> &amp;;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="type">int</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="type_traits">type_traits</h3><p>type_traits 是一个元函数库，由 boost 引入（可参考《C++模板元编程》），C++ 11 被标准吸收，C++ 14 得到加强，需引入头文件<code>type_traits</code>来引入。这个库实现类类型转换、类型比较与判断等功能。</p><p>可参考：https://www.cnblogs.com/gtarcoder/p/4807670.html</p><p>下面几个例子可以参考一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在根据模板参数创建对象时，要注意移除引用：</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">std::<span class="type">remove_reference_t</span>&lt;T&gt; *<span class="title">Create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> U = std::<span class="type">remove_reference_t</span>&lt;T&gt;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">U</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为模板参数可能是引用类型，而创建对象时，需要原始的类型，不能用引用类型，所以需要将可能的引用移除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果给的模板参数是一个带cv描述符的引用类型，要获取它的原始类型，可以使用decay</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">std::<span class="type">decay_t</span>&lt;T&gt; *<span class="title">Create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> U = std::<span class="type">decay_t</span>&lt;T&gt;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">U</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// decay还可以获得函数的指针类型，从而将函数指针变量保存起来，以便在后面延迟调用。</span></span><br><span class="line"><span class="keyword">using</span> F = std::<span class="type">decay_t</span>&lt;<span class="built_in">int</span>(<span class="type">double</span>)&gt;; <span class="comment">// F为一个函数指针类型， int(*)(double)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SimpleFunction</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> FnType = std::<span class="type">decay_t</span>&lt;F&gt;;</span><br><span class="line">    <span class="built_in">SimpleFunction</span>(F &amp;f) : <span class="built_in">m_fn</span>(f)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123; <span class="built_in">m_fn</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    FnType m_fn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="keyword">auto</span> t)</span> </span>&#123; std::cout &lt;&lt; std::boolalpha &lt;&lt; t &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> arvc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; std::is_same&lt;const int, std::add_const&lt;int&gt;::type&gt;::value</span></span><br><span class="line">    <span class="comment">//           &lt;&lt; std::endl; // 结果为true</span></span><br><span class="line">    <span class="comment">// std::cout</span></span><br><span class="line">    <span class="comment">// &lt;&lt; std::is_same&lt;int, std::remove_all_extent&lt;int[2][2][3]&gt;::type&gt;::value</span></span><br><span class="line">    <span class="comment">// &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span>, std::<span class="type">remove_const_t</span>&lt;<span class="type">int</span> <span class="type">const</span>&gt;&gt;);</span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span> <span class="type">const</span>, std::<span class="type">add_const_t</span>&lt;<span class="type">int</span> <span class="type">const</span>&gt;&gt;);</span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span>, std::<span class="type">remove_reference_t</span>&lt;<span class="type">int</span> &amp;&gt;&gt;);</span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span>, std::<span class="type">remove_reference_t</span>&lt;<span class="type">int</span> &amp;&amp;&gt;&gt;);</span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span> &amp;, std::<span class="type">add_lvalue_reference_t</span>&lt;<span class="type">int</span>&gt;&gt;);</span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span> &amp;&amp;, std::<span class="type">add_rvalue_reference_t</span>&lt;<span class="type">int</span>&gt;&gt;);</span><br><span class="line">    <span class="comment">// print(  std::boolalpha &lt;&lt; std::is_same_v&lt;int[3][2],</span></span><br><span class="line">    <span class="comment">// std::remove_all_extent_t&lt;int[3][3][2]&gt;&gt; );</span></span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span>[<span class="number">4</span>][<span class="number">5</span>], std::<span class="type">remove_extent_t</span>&lt;<span class="type">int</span>[<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>]&gt;&gt;);</span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span>, std::<span class="type">remove_pointer_t</span>&lt;<span class="type">int</span> *&gt;&gt;);</span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span> **, std::<span class="type">add_pointer_t</span>&lt;<span class="type">int</span> *&gt;&gt;);</span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span>, std::<span class="type">decay_t</span>&lt;<span class="type">int</span> <span class="type">const</span>&gt;&gt;);</span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span>, std::<span class="type">decay_t</span>&lt;<span class="type">int</span> <span class="keyword">volatile</span>&gt;&gt;);</span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span> *, std::<span class="type">decay_t</span>&lt;<span class="type">int</span>[]&gt;&gt;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> T = std::<span class="type">common_type_t</span>&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">bool</span>, <span class="type">float</span>&gt;;</span><br><span class="line"></span><br><span class="line">    T a&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    T b&#123;<span class="number">1.0</span>&#125;;</span><br><span class="line">    T c&#123;<span class="literal">true</span>&#125;;</span><br><span class="line">    T d&#123;<span class="number">1.0f</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命名约定：如果元函数的返回值要用某种依赖性的名称表示，那么函数将被命名为<code>XXX_</code>的形式；反之，如果元函数的返回值可以字节用某种非依赖性的名称表示，那么元函数的名称将不包含下划线形式的后缀，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> a, <span class="type">int</span> b&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Add_</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">int</span> value = a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> a, <span class="type">int</span> b&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> Add = a + b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> x1 = Add_&lt;<span class="number">2</span>, <span class="number">3</span>&gt;::value;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> x2 = Add&lt;<span class="number">2</span>, <span class="number">3</span>&gt;;</span><br></pre></td></tr></table></figure><h3 id="模板型模板参数">模板型模板参数</h3><h4 id="模板作为容器的输入">模板作为容器的输入</h4><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun_</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> T1&lt;T2&gt;::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">using</span> Fun = <span class="keyword">typename</span> Fun_&lt;T1, T2&gt;::type;</span><br><span class="line"></span><br><span class="line">Fun&lt;std::remove_reference, <span class="type">int</span>&amp;&gt; h = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h4 id="模板作为元函数的输出">模板作为元函数的输出</h4><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> AddOrRemoveRef&gt; <span class="keyword">struct</span> <span class="title class_">Fun_</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun_</span>&lt;<span class="literal">true</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">using</span> type = std::add_lvalue_reference&lt;T&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun_</span>&lt;<span class="literal">false</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">using</span> type = std::remove_reference&lt;T&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> AddOrRemove&gt;</span><br><span class="line"><span class="keyword">using</span> Fun = <span class="keyword">typename</span> Fun_&lt;AddOrRemove&gt;::<span class="keyword">template</span> type&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Res_ = Fun&lt;<span class="literal">false</span>&gt;;</span><br><span class="line"></span><br><span class="line">Res_&lt;<span class="type">int</span>&amp;&gt;::type h = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="容器模板">容器模板</h3><p>我们的容器也仅能保存一种类别的操作数，比如一个仅能保存数值的容器，或者仅能保存类型的容器，或者仅能保存模板的容器。</p><p>使用 C++ 11 中引入的变参数模板，可以很容易实现我们想要的功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span>... Vals&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">InContainer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span>... Vals&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BoolContainer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeContainer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span>... T&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TemplateCont</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>...&gt; <span class="keyword">class</span>...T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TemplateCont2</span>;</span><br></pre></td></tr></table></figure><blockquote><p>元编程中有一个惯用法，就是仅在必要时才引入定义。</p></blockquote><h3 id="顺序分支与循环代码的编写">顺序、分支与循环代码的编写</h3><h4 id="顺序执行的代码">顺序执行的代码</h4><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RemoveReferenceConst_</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> inter_type = std::<span class="type">remove_reference_t</span>&lt;T&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> type = std::<span class="type">remove_const_t</span>&lt;inter_type&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> RemoveReferenceConst = <span class="keyword">typename</span> RemoveReferenceConst_&lt;T&gt;::type;</span><br><span class="line"></span><br><span class="line">RemoveReferenceConst&lt;<span class="type">const</span> <span class="type">int</span>&amp;&gt; h = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h4 id="分支执行的代码">分支执行的代码</h4><p>使用模板特化或部分特化来实现分支，是一种非常常见的手段，当然也有些其他手段。</p><p><strong>使用 <code>std::conditional</code> 与<code>std::conditional_t</code> 实现分支</strong></p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::conditional&lt;<span class="literal">true</span>, <span class="type">int</span>, <span class="type">float</span>&gt;::type x = <span class="number">3</span>;</span><br><span class="line">std::conditional_y&lt;<span class="literal">false</span>, <span class="type">int</span>, <span class="type">float</span>&gt; y = <span class="number">1.0f</span>;</span><br></pre></td></tr></table></figure><p>这种方法只能实现简单的分支。</p><p><strong>使用（部分）特化实现分支</strong></p><p>特化天生就是来引入差异的，因此，使用它来实现分支也十分自然。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun_</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">size_t</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun_</span>&lt;A&gt; &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">size_t</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun_</span>&lt;B&gt; &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">size_t</span> value = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> h = Fun_&lt;B&gt;::value;</span><br></pre></td></tr></table></figure><p>再例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> Fun = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> Fun&lt;A&gt; = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> Fun&lt;B&gt; = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> h = Fun&lt;B&gt;;</span><br></pre></td></tr></table></figure><blockquote><p>注意，在非完全特化的类模板中引入完全特化的代码是非法的，例如：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TW&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Fun_</span> &#123;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">size_t</span> value = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Fun_</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">size_t</span> value = <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>酱紫的代码是不行的，我们可以酱紫修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TW&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> TDummy = <span class="type">void</span>&gt;</span><br><span class="line">    <span class="keyword">struct</span> Fun_ &#123;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">size_t</span> value = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TDummy&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Fun_</span>&lt;<span class="type">int</span>, TDummy&gt; &#123;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">size_t</span> value = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>std::enable_if</code> 与<code>std::enable_if_t</code> 实现分支</strong></p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> IsFeedbackOut, <span class="keyword">typename</span> T, std::<span class="type">enable_if_t</span>&lt;IsFeedbackOut&gt;* = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">FeedbackOut_</span>(T&amp;&amp;) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> IsFeedbackOut, <span class="keyword">typename</span> T, std::<span class="type">enable_if_t</span>&lt;!IsFeedbackOut&gt;* = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">FeedbackOut_</span>(T&amp;&amp;) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>当 <code>FeedbackOut_</code>为真时，<code>std::enable_if_t&lt;IsFeedbackOut&gt;::type</code>是有意义的，这使得第一个函数匹配成功；与之对应的，第二个函数匹配是失败的。反之，当<code>FeedbackOut_</code>为假时，<code>std::enable_if_t&lt;!IsFeedbackOut&gt;::type</code>是有意义的，这就使得第二个函数匹配成功，第一个函数匹配失败。</p><p><strong>编译期分支与多种返回类型</strong></p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">wrap1</span><span class="params">(<span class="type">bool</span> Check)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Check) &#123;</span><br><span class="line">        (<span class="type">int</span>) <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> (<span class="type">double</span>) <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是编译不过去的，我们可以酱紫做：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> Check, std::<span class="type">enable_if_t</span>&lt;Check&gt;* = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">fun</span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> (<span class="type">int</span>) <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> Check, std::<span class="type">enable_if_t</span>&lt;!Check&gt;* = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">fun</span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> (<span class="type">double</span>) <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> Check&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">wrap2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fun</span>&lt;Check&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="built_in">wrap2</span>&lt;<span class="literal">true</span>&gt;() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用 C++ 17 引入的 <code>if constexpr</code> 来简化代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> Check&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(Check)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> (<span class="type">double</span>) <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="built_in">fun</span>&lt;<span class="literal">true</span>&gt;() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行循环的代码</strong></p><p>在编译器，我们往往使用递归来实现循环。</p><p>例如，给定一个无符号整数，求该整数所对应的二进制中 1 的个数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> Input&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> OnesCount = (Input % <span class="number">2</span>) + OnesCount&lt;Input / <span class="number">2</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> OnesCount&lt;<span class="number">0</span>&gt; = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> res = OnesCount&lt;<span class="number">45</span>&gt;;</span><br></pre></td></tr></table></figure><p>下面是处理数组的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">szie_t</span>...Inputs&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> Accumulate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> CurInput, <span class="type">size_t</span>...Inputs&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> Accumulate&lt;CurInput, Inputs...&gt; = CurInput + Accumulate&lt;Inputs...&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> = res = Accumulate&lt;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&gt;;</span><br></pre></td></tr></table></figure><p>或者使用 C++ 17 引入的折叠表达式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> values&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span> + ... + values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> res = <span class="built_in">fun</span>&lt;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&gt;();</span><br></pre></td></tr></table></figure><h3 id="分支选择与短路逻辑">分支选择与短路逻辑</h3><p>减少编译器实例化的另外一种主要的技术就是引入短路逻辑，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> is_odd = ((N % <span class="number">2</span>) == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AllOdd_</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> is_cur_odd = is_odd&lt;N&gt;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> is_pre_odd = AllOdd_&lt;N<span class="number">-1</span>&gt;::value;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> value = is_cur_odd &amp;&amp; is_pre_odd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AllOdd_</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> value = is_odd&lt;<span class="number">0</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改进版本如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> cur, <span class="keyword">typename</span> TNext&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> AndValue = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TNext&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> AndValue&lt;<span class="literal">true</span>, TNext&gt; = TNext::value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> is_odd = ((N % <span class="number">2</span>) == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AllOdd_</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> is_cur_odd = is_odd&lt;N&gt;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> value = AndValue&lt;is_cur_odd, AllOdd_&lt;N - <span class="number">1</span>&gt;&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AllOdd_</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> value = is_odd&lt;<span class="number">0</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="奇特的递归模板">奇特的递归模板</h3><p>CRTP是一种派生类的什么方式，其「奇特」之处在于：派生类会将本身作为模板参数传递给其基类，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> D&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;Derived&gt; &#123; <span class="comment">/*...*/</span> &#125;;</span><br></pre></td></tr></table></figure><p>CRTP 的典型应用场景是模拟虚函数，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> D&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(<span class="type">const</span> T1&amp; input)</span> </span>&#123;</span><br><span class="line">        D* ptr = <span class="built_in">static_cast</span>&lt;D*&gt;(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">Imp</span>(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> Derive : <span class="keyword">public</span> Base&lt;Derive&gt; &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1&gt; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Imp</span><span class="params">(T1 <span class="type">const</span>&amp; input)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; input &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个代码中，基类 <code>Base&lt;D&gt;</code>会假定派生类实现类一个接口 <code>Imp</code>，会在其函数 <code>Fun</code>中调用这个接口。如果采用面向对象的编程方法，我们需要引入虚函数<code>Imp</code>。但是，<code>Imp</code>是一个函数模板，无法被声明为虚函数，这里可以借助 <code>CRTP</code>技术实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> D&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        D::<span class="built_in">Imp</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base&lt;Derive&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Imp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Implementation from derive class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Derive:<span class="built_in">Fun</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">介绍 C++ 元编程相关概念和基本方法</summary>
    
    
    
    <category term="元编程" scheme="https://xinransix.github.io/categories/%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="https://xinransix.github.io/tags/C/"/>
    
    <category term="模板" scheme="https://xinransix.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="元编程" scheme="https://xinransix.github.io/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
    <category term="元函数" scheme="https://xinransix.github.io/tags/%E5%85%83%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>ARM 汇编</title>
    <link href="https://xinransix.github.io/2023/07/24/ARM%E6%B1%87%E7%BC%96/"/>
    <id>https://xinransix.github.io/2023/07/24/ARM%E6%B1%87%E7%BC%96/</id>
    <published>2023-07-24T09:52:28.000Z</published>
    <updated>2024-03-04T01:56:49.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置知识">前置知识</h2><p>计算机的指令集一般可分为 4 种：</p><ul><li>复杂指令集（CISC）</li><li>精简指令集 （ RISC）</li><li>显式并行指令集 （ EPIC ）</li><li>超长指令字指令集（VLIW）</li></ul><p>我们在嵌入式学习和工作中需要经常打交道的是 RISC 指令集。RISC指令集相对于 CISC 指令集，主要有以下特点：</p><ul><li>Load / Store架构，CPU 不能直接处理内存中的数据，要先将内存中的数据Load（加载）到寄存器中才能操作，然后将处理结果Store（存储）到内存中。</li><li>固定的指令长度、单周期指令。</li><li>倾向于使用更多的寄存器来存储数据，而不是使用内存中的堆栈，效率更高。</li></ul><p>ARM 指令集虽然属于 RISC，但是和原汁原味的 RISC 相比，还是有一些差异的，具体如下：</p><ul><li>ARM 有桶型移位寄存器，单周期内可以完成数据的各种移位操作。</li><li><strong>并不是所有的 ARM 指令都是单周期的。</strong></li><li>ARM 有 16 位的 Thumb 指令集，是 32 位 ARM指令集的压缩形式，提高了代码密度。</li><li>条件执行：通过指令组合，减少了分支指令数目，提高了代码密度。</li><li>增加了 DSP、SIMD / NEON 等指令。</li></ul><p>ARM 处理器有多种工作模式，如下图所示。应用程序正常运行时，ARM处理器工作在用户模式（User mode），当程序运行出错或有中断发生时，ARM处理器就会切换到对应的特权工作模式。用户模式属于普通模式，有些特权指令是运行不了的，需要切换到特权模式下才能运行。在ARM处理器中，除了用户模式是普通模式，剩下的几种工作模式都属于特权模式。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/7059623d-ec4c-473f-b6dd-cc592303c1b7"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>在 ARM处理器内部，除了基本的算术运算单元、逻辑运算单元、浮点运算单元和控制单元，还有一系列寄存器，包括各种通用寄存器、状态寄存器、控制寄存器，用来控制处理器的运行，保存程序运行时的各种状态和临时结果，如下图所示：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/2fbec729-8e2e-477d-9f8b-a5bb2804262f"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>ARM 处理器中的寄存器可分为通用寄存器和专用寄存器两种。寄存器 R0～R12属于通用寄存器，除了 FIQ工作模式，在其他工作模式下这些寄存器都是共用、共享的：R0～R3通常用来传递函数参数，R4～R11用来保存程序运算的中间结果或函数的局部变量等，R12常用来作为函数调用过程中的临时寄存器。ARM处理器有多种工作模式，除了这些在各个模式下通用的寄存器，还有一些寄存器在各自的工作模式下是独立存在的，如R13、R14、R15、CPSP、SPSR寄存器，在每个工作模式下都有自己单独的寄存器。R13寄存器又称为堆栈指针寄存器（StackPointer，SP），用来维护和管理函数调用过程中的栈帧变化，R13总是指向当前正在运行的函数的栈帧，一般不能再用作其他用途。R14寄存器又称为链接寄存器（LinkRegister，LR），在函数调用过程中主要用来保存上一级函数调用者的返回地址。寄存器R15 又称为程序计数器（Program Counter，PC），CPU从内存取指令执行，就是默认从 PC 保存的地址中取的，每取一次指令，PC寄存器的地址值自动增加。CPU一条一条不停地取指令，程序也就源源不断地一直运行下去。在 ARM三级流水线中，PC 指针的值等于当前正在运行的指令地 +8，后续的 32位处理器虽然流水线的级数不断增加，但为了简化编程，PC指针的值继续延续了这种计算方式。</p><p>当前处理器状态寄存器（Current Processor StateRegister，CPSR）主要用来表征当前处理器的运行状态。除了各种状态位、标志位，CPSR寄存器里也有一些控制位，用来切换处理器的工作模式和中断使能控制。CPSR寄存器各个标志位、控制位的详细说明下图所示：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/0e3f3e48-8ce0-46aa-9d89-f212df6b883b"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>在每种工作模式下，都有一个单独的程序状态保存寄存器（Saved ProcessorState Register，SPSR）。当 ARM 处理器切换工作模式或发生异常时，SPSR用来保存当前工作模式下的处理器现场，即将 CPSR寄存器的值保存到当前工作模式下的 SPSR 寄存器。当 ARM处理器从异常返回时，就可以从 SPSR寄存器中恢复原先的处理器状态，切换到原来的工作模式继续运行。</p><p>在 ARM 所有的工作模式中，有一种工作模式比较特殊，即 FIQ模式。为了快速响应中断，减少中断现场保护带来的时间开销，在 FIQ工作模式下，ARM处理器有自己独享的 R8～R12 寄存器。</p><h2 id="arm-汇编指令">ARM 汇编指令</h2><p>一个完整的 ARM 指令通常由<strong>操作码 +操作数</strong>组成，指令的编码格式如下：</p><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;opcode&gt; &#123;&lt;<span class="meta">code</span>&gt; &#123;S&#125; &lt;Rd&gt;, &lt;Rn&gt; &#123;, &lt;operand2&gt;&#125;&#125;</span><br></pre></td></tr></table></figure><p>这是一个完整的 ARM指令需要遵循的格式规则，指令格式的具体说明如下：</p><ul><li>使用 <code>&lt;&gt;</code> 标起来的是必选项，使用 <code>&#123;&#125;</code>标起来的是可选项。</li><li><code>&lt;opcode&gt;</code> 是二进制机器指令的操作码助记符，如<code>MOV</code>、<code>ADD</code>这些汇编指令都是操作码的指令助记符。</li><li><code>cond</code>：执行条件，ARM 为减少分支跳转指令个数，允许类似<code>BEQ</code>、<code>BNE</code> 等形式的组合指令。</li><li><code>S</code>：是否影响 CPSR 寄存器中的标志位，如 SUBS 指令会影响CPSR 寄存器中的 N、Z、C、V 标志位，而 SUB 指令不会。</li><li><code>Rd</code>：目标寄存器。</li><li><code>Rn</code>：第一个操作数的寄存器。</li><li><code>operand2</code>：第二个可选操作数，灵活使用第二个操作数可以提高代码效率。</li></ul><h3 id="存储访问指令">存储访问指令</h3><p>ARM 指令集属于 RISC 指令集，RISC处理器采用典型的加载/存储体系结构，CPU无法对内存里的数据直接操作，只能通 Load / Store指令来实现：当我们需要对内存中的数据进行操作时，要首先将这个数据从内存加载到寄存器，然后在寄存器中对数据进行处理，最后将结果重新存储到内存中。</p><p>ARM处理器属于冯·诺依曼架构，程序和数据都存储在同一存储器上，内存空间和 I/O空间统一编址，ARM 处理器对程序指令、数据、I/O空间中外设寄存器的访问都要通过 Load/Store 指令来完成。ARM处理器中经常使用的 Load/Store 指令的使用方法如下。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/2ff6eaef-147d-4815-b1e5-51014f28cfe5"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>在 ARM 存储访问指令中，我们经常使用的是 LDR/STR、LDM/STM这两对指令。LDR/STR 指令是 ARM汇编程序中使用频率最高的一对指令，每一次数据的处理基本上都离不开它们。LDM/STM指令常用来加载或存储一组寄存器到一片连续的内存，通过和堆栈格式符组合使用，LDM/STM指令还可以用来模拟堆栈操作。LDM/STM 指令常和下表的堆栈格式组合使用：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/4a6e20a4-2630-4466-9765-6d8660b4d6c3"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>如图3-3所示，在一个堆栈内存结构中，如果堆栈指针 SP总是指向栈顶元素，那么这个栈就是满栈；如果堆栈指针 SP指向的是栈顶元素的下一个空闲的存储单元，那么这个栈就是空栈。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/24b7757d-999b-4056-938e-8333a9a4816d"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>每入栈一个元素，栈指针 SP都会往栈增长的方向移动一个存储单元。如果栈指针 SP从高地址往低地址移动，那么这个栈就是递减栈；如果栈指针 SP从低地址往高地址移动，那么这个栈就是递增栈。ARM处理器使用的一般都是满递减堆栈，在将一组寄存器入栈，或者从栈中弹出一组寄存器时，我们可以使用下面的指令。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/f8a0c6d1-ad66-466f-86e1-9b6b63046408"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>这里需要注意的一个细节是，在入栈和出栈过程中要留意栈中各个元素的入栈出栈顺序。栈的特点是先入后出（FirstIn Last Out，FILO），栈元素在入栈操作时，STMFD 会根据大括号<code>&#123;&#125;</code>中寄存器列表中各个寄存器的顺序，从左往右依次压入堆栈。在上面的例子中，R0会先入栈，接着 R1、R2 入栈，最后 R14 入栈，入栈操作完成后，栈指针 SP在内存中的位置如图 3-4左侧所示。栈元素在出栈操作时，顺序刚好相反，栈中的元素先弹出到 R14寄存器中，接着是 R2、R1、R0。将栈中的元素依次弹出到 R14、R2寄存器后，堆栈指针在内存中的位置如图3-4右侧所示。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/4f3d58b9-a7d2-43a9-b930-12d616bd6e69"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>除此之外，ARM 还专门提供了 PUSH 和 POP指令来执行栈元素的入栈和出栈操作。PUSH 和 POP 指令的使用方法如下：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/44cfc5d7-eb03-41a3-8721-a95305014d7f"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="数据传送指令">数据传送指令</h3><p>LDR/STR指令用来在寄存器和内存之间输送数据。如果我们想要在寄存器之间传送数据，则可以使用MOV 指令。MOV 指令的格式如下：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/14355230-5433-48e6-927e-deab72902f19"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>其中，<code>&#123;cond&#125;</code> 为条件指令可选项，<code>&#123;S&#125;</code>用来表示是否影响 CPSR 寄存器的值，如 MOVS 指令就会影响寄存器 CPSR的值，而 MOV 则不会。</p><p>MVN 指令用来将操作数 operand2 按位取反后传送到目标寄存器 Rd。操作数operand2 可以是一个立即数，也可以是一个寄存器。</p><p>MOV 和 MVN 指令的一般使用方法如下：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/6f681bd5-7e86-4a23-842f-c4e142b2b6af"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="算术逻辑运算指令">算术逻辑运算指令</h3><p>算术运算指令包括基本的加、减、乘、除，逻辑运算指令包括与、或、非、异或、清除等。指令格式如下。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/79a6eaa2-57c2-491b-ba21-f9490fdd0038"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>算术逻辑运算指令的基本使用方法及说明如下。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/e023cb2e-fa28-44a2-9bbd-9c67e3285d0b"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="操作数operand2-详解">操作数：operand2 详解</h3><p>ARM 指令的可选项很多，操作数也很灵活。很多 ARM 指令会使用第 2 个参数operand2：可以是一个常数，也可以是寄存器+偏移的形式。</p><p>操作数 operand2 在汇编程序中经常出现的两种格式如下：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/670567f6-0f40-4adf-85f8-388b78e29cc9"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>第一种格式比较简单，操作数是一个立即数，第二种格式可以直接使用寄存器的值作为操作数。</p><p><code>ADD</code>、<code>SUB</code>、<code>AND</code>指令示例中，第二个操作数要么是一个常数，要么是一个寄存器。在第二种格式中，通过<code>&#123;，shift&#125;</code>可选项，我们还可以通过多种移位或循环移位的方式，构建更加灵活的操作数。可选项<code>&#123;，shift&#125;</code> 可以选择的移位方式如下。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/9ed294d1-cd66-46da-9be7-09329c8228e0"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>可选性指令的使用示例及说明如下：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/e01e4b37-f585-4cff-aa7e-1aae71d5ebf0"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="比较指令">比较指令</h3><p>比较指令用来比较两个数的大小，或比较两个数是否相等。比较指令的运算结果会影响CPSR 寄存器的 N、Z、C、V 标志位，具体的标志、位说明可参考前面的 CPSR寄存器介绍。</p><p>比较指令的格式如下：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/d1a40e26-faa9-441c-a003-6a5d35cf36e6"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>比较指令的使用示例及说明如下：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/33bee05a-a3d9-4a07-afd5-2e1f2756a303"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>比较指令的运行结果 Z=1 时，表示运算结果为零，两个数相等；N=1表示运算结果为负，N=0 表示运算结果为非负，即运算结果为正或者为零。</p><h3 id="条件执行指令">条件执行指令</h3><p>为了提高代码密度，减少 ARM 指令的数量，几乎所有的 ARM 指令都可以根据CPSR 寄存器中的标志位，通过指令组合实现条件执行。如无条件跳转指令B，我们可以在后面加上条件码组成 BEQ、BNE 组合指令。</p><p>BEQ 指令表示两个数比较，结果相等时跳转；BNE指令则表示结果不相等时跳转。CPSR寄存器中的标志位根据需要可以任意搭配成不同的条件码，和 ARM指令一起组合使用。</p><p>ARM 指令的条件码如表3-3所示：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/08284c0f-d520-44bc-9aa3-02dfa66f44c8"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>条件执行经常出现在跳转或循环的程序结构中。如下面的汇编程序，通过循环结构，我们可以实现数据块的搬运功能。我们可以将无条件跳转指令B 和条件码 NE 组合在一起使用，构成一个循环程序结构。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/f2266b5e-6b35-435a-ad37-7fa42974b0c4"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="跳转指令">跳转指令</h3><p>在函数调用的场合，以及循环结构、分支结构的程序中经常会用到跳转指令。ARM 指令集提供了<code>B</code>、<code>BL</code>、<code>BX</code>、`BLX``等跳转指令，每个指令都有各自的用武之地和使用场景。</p><p>跳转指令的格式如下：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/3962c140-0876-473d-a460-87be2dc695a6"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h4 id="b-label">B label</h4><p>跳转到标号 label 处，B跳转指令的跳转范围大小为[0，32MB]，可以往前跳，也可以往后跳。无条件跳转指令B 主要用在循环、分支结构的汇编程序中，使用示例如下：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/c4a44fc3-65d4-4900-b669-f30e6d35a612"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h4 id="bl-label">BL label</h4><p>BL 跳转指令表示带链接的跳转。</p><p>在跳转之前，BL 指令会先将当前指令的下一条指令地址（即返回地址）保存到LR 寄存器中，然后跳转到 label 处执行。</p><p>BL指令一般用在函数调用的场合，主函数在跳转到子函数执行之前，会先将返回地址，即当前跳转指令的下一条指令地址保存到LR 寄存器中；子函数执行结束后，LR 寄存器中的地址被赋值给PC，处理器就可以返回到原来的主函数中继续运行了。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/32056188-99a5-4044-aa38-df9a7d06a043"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h4 id="bx-rm">BX Rm</h4><p>BX 表示带状态切换的跳转。</p><p>Rm 寄存器中保存的是跳转地址，要跳转的目标地址处可能是 ARM指令，也可能是 Thumb 指令。处理器根据 Rm[0] 位决定是切换到 ARM状态还是切换到 Thumb 状态。</p><ul><li>0：表示目标地址处是 ARM 指令，在跳转之前要先切换至 ARM 状态。</li><li>1：表示目标地址处是 Thumb 指令，在跳转之前要先切换至 Thumb 状态。BLX指令是 BL 指令和 BX指令的综合，表示带链接和状态切换的跳转，使用方法和上面相同，不再赘述。</li></ul><h2 id="arm-寻址方式">ARM 寻址方式</h2><p>ARM 属于 RISC 体系架构，一个 ARM汇编程序中的大部分汇编指令，基本上都和数据传输有关：在内存-寄存器、内存-内存、寄存器-寄存器之间来回传输数据。不同的ARM指令又有不同的寻址方式，比较常见的寻址方式有寄存器寻址、立即寻址、寄存器偏移寻址、寄存器间接寻址、基址寻址、多寄存器寻址、相对寻址等。</p><h3 id="寄存器寻址">寄存器寻址</h3><p>寄存器寻址比较简单，操作数保存在寄存器中，通过寄存器名就可以直接对寄存器中的数据进行读写。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/eb0bf15a-0c26-41bf-a569-73a632ea5a66"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="立即数寻址">立即数寻址</h3><p>在立即数寻址中，ARM 指令中的操作数为一个常数。立即数以 ＃ 为前缀，0x前缀表示该立即数为十六进制，不加前缀默认是十进制。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/84c6864e-7512-4e11-8ab4-aaa9f408dac5"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="寄存器偏移寻址">寄存器偏移寻址</h3><p>寄存器偏移寻址可以看作寄存器寻址的一种特例，通过第二个操作数 operand2的灵活配置，我们可以将第二个操作数做各种左移和右移操作，作为新的操作数使用。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/6d9f7d6d-7229-4461-a85a-448cfe7471c0"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>常见的移位操作有逻辑移位和算术移位，两者的区别是：逻辑移位无论是左移还是右移，空缺位一律补0；而算术移位则不同，左移时空缺位补 0，右移时空缺位使用符号位填充。</p><h3 id="寄存器间接寻址">寄存器间接寻址</h3><p>寄存器间接寻址主要用来在内存和寄存器之间传输数据。寄存器中保存的是数据在内存中的存储地址，我们通过这个地址就可以在寄存器和内存之间传输数据。C语言中的指针操作，在汇编层次其实就是使用寄存器间接寻址实现的。寄存器间接寻址的使用示例及说明如下所示。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/06d0cfd1-8274-4523-9777-b2772ae8ccf9"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="基址寻址">基址寻址</h3><p>基址寻址其实也属于寄存器间接寻址。两者的不同之处在于，基址寻址将寄存器中的地址与一个偏移量相加，生成一个新地址，然后基于这个新地址去访问内存。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/d107f147-5f08-46fd-aacc-2f6d1f2bde0c"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>基址寻址一般用在查表、数组访问、函数的栈帧管理等场合。根据偏移量的正负，基址寻址又可以分为向前索引寻址和向后索引寻址，如上面的第1 条和第 3 条指令，就是向后索引寻址，而第6条指令则为向前索引寻址。</p><h3 id="多寄存器寻址">多寄存器寻址</h3><p>STM/LDM 指令就属于多寄存器寻址，一次可以传输多个寄存器的值。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/5d43bfe1-a2e3-4017-bbc2-65b23e668453"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>在多寄存器寻址中，用大括号 <code>&#123;&#125;</code>括起来的是寄存器列表，寄存器之间用逗号隔开，如果是连续的寄存器，还可以使用连接符-连接，如R0-R3，就表示 R0、R1、R2、R3 这 4 个寄存器。</p><p>LDM/STM 指令一般和 IA、IB、DA、DB 组合使用，分别表示 IncreaseAfter、Increase Before、Decrease After、Decrease Before。</p><p>LDM/STM 指令也可以和 FD、ED、FA、EA 组合使用，用于堆栈操作。</p><p>栈是程序运行过程中非常重要的一段内存空间，栈是 C语言运行的基础，函数内的局部变量、函数调用过程中要传递的参数、函数的返回值一般都是保存在栈中的。</p><p>ARM 没有专门的入栈和出栈指令，ARM 中的栈操作其实就是通过上面所讲的STM/LDM 指令和栈指针 SP 配合操作完成的。栈一般可以分为以下 4 类：</p><ul><li>递增栈 A：入栈时，SP 栈指针从低地址往高地址方向增长。</li><li>递减栈 D：入栈时，SP 栈指针从高地址往低地址方向增长。</li><li>满栈 F：SP 栈指针总是指向栈顶元素。</li><li>空栈 E：SP 栈指针总是指向栈顶元素的下一个空闲存储单元。</li></ul><p>ARM 默认使用满递减堆栈，通过 STMFD/LDMFD指令配对使用，完成堆栈的入栈和出栈操作。</p><p>ARM 中的 PUSH 和 POP 指令其实就是 LDM/STM 的同义词，是 LDMFD 和 STMFD组合指令的助记符。</p><p>PUSH 指令和 POP 指令的使用示例如下：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/1f106995-cf0d-46bf-999a-c5ccd62a135d"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="相对寻址">相对寻址</h3><p>相对寻址其实也属于基址寻址，只不过它是基址寻址的一种特殊情况。特殊在什么地方呢？它是以 PC指针作为基地址进行寻址的，以指令中的地址差作为偏移，两者相加后得到的就是一个新地址，然后可以对这个地址进行读写操作。</p><p>ARM 中的 B、BL、ADR 指令其实都是采用相对寻址的。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/682acaa6-6c3b-40e5-b9c2-4c695eb0f3d2"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>在上面的示例代码中，B LOOP 指令其实就等价于：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/6bb5563d-7e93-4cfa-a329-d08c6b51de46"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>除此之外，很多与位置无关的代码，如动态链接共享库，其在汇编代码层次的实现其实也是采用相对寻址的。程序中使用相对寻址访问的好处是不需要重定位，将代码加载到内存中的任何地址都可以直接运行。</p><h2 id="arm-伪指令">ARM 伪指令</h2><p>ARM 伪指令并不是 ARM指令集中定义的标准指令，而是为了编程方便，各家编译器厂商自定义的一些辅助指令。</p><p>伪指令有点类似 C 语言中的预处理命令，在程序编译时，这些伪指令会被翻译为一条或多条 ARM 标准指令。</p><p>常见的 ARM 伪指令主要有 4个：ADR、ADRL、LDR、NOP，它们的使用示例如下：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/4a12f423-5440-4198-a6b1-5b1a9f978f31"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>NOP 伪指令比较简单，其实就相当于 MOV R0，R0。</p><p>在以后的学习和工作中，大家在 ARM 汇编程序中经常看到的就是 LDR伪指令。</p><h3 id="ldr-伪指令">LDR 伪指令</h3><p>LDR 伪指令通常会让很多朋友感到迷惑，容易和加载指令 LDR 混淆。</p><p>LDR 伪指令的主要用途是将一个 32 位的内存地址保存到寄存器中。</p><p>在寄存器之间传递数据可以使用 MOV 指令，但是当传递的一个内存地址是 32位的立即数时，MOV 指令就应付不了了，如下面的第 2 条指令。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/a8d5ce2d-05b6-4136-8cce-a66f082ad0e6"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>当我们往寄存器传递的地址是一个 32 位的常数时，为什么不能使用MOV，而要使用 LDR 伪指令呢？这还得从 ARM 指令的编码格式说起。</p><p>RISC 指令的特点是单周期指令，指令的长度一般都是固定的。在一个 32位的系统中，一条指令通常是 32位的，指令中包括操作码和操作数，如图3-5所示：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/8cf1c334-6199-4c1f-be9d-a97b7c49add8"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>指令中的操作码和操作数共享 32位的存储空间：一般前面的操作码要占据几个比特位，剩下来的留给操作数的编码空间就小32 位了。</p><p>当编译器遇到 <code>MOV R0，＃0x30008000</code>这条指令时，因为后面的操作数是 32位，编译器就无法对这条指令进行编码了。为了解决这个难题，编译器提供了一个LDR 伪指令来完成上面的功能。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/dbbce217-c541-488c-b905-d2d0e2030e43"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>在上面的示例代码中，LDR 不是普通的 ARM加载指令，而是一个伪指令。为了与 ARM 指令集中的加载指令 LDR区别开来，<strong>LDR伪指令中的操作数前一般会有一个等于号=</strong>，用来表示该指令是个伪指令。</p><p>通过 LDR 伪指令，编译器就解决了向一个寄存器传送 32位的立即数时指令无法编码的难题。</p><p>因为伪指令并不是 ARM 指令集中定义的标准指令，所以 CPU硬件译码电路并不支持直接运行这些伪指令。</p><p>在程序编译期间，这些伪指令会被标准的 ARM 指令替代。</p><p>编译器在处理伪指令时，根据伪指令中的操作数大小，会使用不同的 ARM标准指令替代。</p><p>如当 LDR 伪指令中的操作数小于 8 位时，LDR 伪指令一般会被 MOV指令替代。下面的两行汇编指令其实是等价的：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/076072b8-7b10-421c-8d29-9da2ad9c1d0f"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>当 LDR 伪指令中的操作数大于 8 位时，LDR 指令会被编译器转换为<code>LDR 标准指令+文字池</code> 的形式。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/f6505634-6ec4-41cf-92c7-1906d46ac9fc"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>在上面的示例代码中，当 LDR 伪指令中的操作数为一个 32位的立即数时，编译器会首先在内存中分配一个 4字节大小的存储单元，然后将这个 32 位的地址 0x30008000存放到该存储单元中，该存储单元通常也 叫作文字池（literal pool）。</p><p>接着编译器计算出该存储单元到 LDR 伪指令之间的偏移OFFSET，然后使用寄存器相对寻址，就可以将这个 32 位的立即数送到 R0寄存器中。偏移量 OFFSET 的大小一般要小于4KB，所以在分析汇编代码时你会看到，存放这些 32位地址常量的文字池一般紧挨着当前指令的代码段，直接放置在当前代码段的后面。</p><h3 id="adr-伪指令">ADR 伪指令</h3><p>ADR 伪指令的功能与 LDR 伪指令类似，将基于 PC相对偏移的地址值读取到寄存器中。</p><p>ADR为小范围的地址读取伪指令，底层使用相对寻址来实现，因此可以做到代码与位置无关。</p><p>ADR 伪指令的使用示例代码如下：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/10a60acb-927d-41fb-85c2-c17e30cf5143"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>在上面的示例代码中，ADR 伪指令的作用是将标号 LOOP表征的内存地址送到寄存器 R0 中。</p><p>编译器在编译 ADR 伪指令时，会首先计算出当前正在执行的 ADR伪指令地址与标号 LOOP 之间的地址偏移 OFFSET，然后使用 ARM指令集中的一条标准指令代替之，如使用 ADD 指令将标号表征的地址送到寄存器R0 中。</p><h2 id="arm-汇编程序设计">ARM 汇编程序设计</h2><h3 id="arm-汇编程序格式">ARM 汇编程序格式</h3><p>ARM 汇编程序是以段（section）为单位进行组织的。</p><p>在一个汇编文件中，可以有不同的section，分为代码段、数据段等，各个段之间相互独立，一个 ARM汇编程序至少要有一个代码段。</p><p>我们可以使用 AREA 伪操作来标识一个段的起始、段名和段的读写属性。</p><p>我们使用分号；来注释代码。</p><h3 id="符号与标号">符号与标号</h3><p>在 ARM汇编程序中，我们可以使用符号来标识一个地址、变量或数字常量。</p><p>当用符号来标识一个地址时，这个符号通常又被称为标号。</p><p>符号的命名规则和 C语言的标识符命名规则一样：由字母、数字和下画线组成，符号的开头不能使用数字，但标号除外。标号比较任性，标号的开头不仅可以是数字，甚至整个标号可以是一个纯数字。</p><p>符号的命名在其作用域内必须唯一，不能与系统内部或系统预定义的符号同名，不能与指令助记符、伪指令同名。</p><p>有时候我们会直接通过数字 [0，99]而不是使用字符来进行地址引用，我们称这种数字为局部标号。局部标号的作用域为当前段，在汇编程序中，我们可以使用下面的格式来引用局部标号。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/07151451-7548-407c-8645-5ce2ee7b0321"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>在局部标号的引用格式中，由大括号 <code>&#123;&#125;</code>括起来的部分是可选项，N 表示局部标号，其余的参数说明如下。</p><ul><li>%：引用符号，对一个局部标号产生引用。</li><li>F：指示编译器只向前搜索。</li><li>B：指示编译器只向后搜索。</li><li>A：指示编译器搜索宏的所有宏命令层。</li><li>T：指示编译器搜索宏的当前层。</li><li>N：局部标号的名字。</li><li>routename：局部标号作用范围名称，使用 ROUT 定义。</li></ul><p>若 B、F 没有指定，编译器将默认先向后搜索，然后向前搜索。若 A、T都没指定，则汇编程序默认搜索从当前层到最顶层的所有宏命令，但不搜索较低层的宏命令。如果在标签中或者对一个标签的引用中指定了routename，则汇编程序将其与最近的一个前 ROUT指令的名称进行比较，如果不匹配，则汇编程序会生成一条错误消息，汇编失败。</p><p>在汇编代码中，使用局部标号的示例程序如下：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/7b12ddc0-45c4-4f7d-899e-b8bcf8458b8d"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="伪操作">伪操作</h3><p>在 C 语言中，为了编程方便，编译器会定义一系列预处理命令，并用 #来标识，如 #include、#define、#if、#else、#end 等。</p><p>在汇编语言中，为了编程方便，汇编器也定义了一些特殊的指令助记符，以方便对汇编程序做各种处理。如使用AREA 来定义一个段（section），使用 GBLA 来定义一个数据，使用 ENTRY来指定汇编程序的执行入口等，这些指令助记符统称为伪指令或伪操作。</p><p>伪操作一般用在符号定义、数据定义、汇编程序结构控制等场合。在一个汇编程序中经常使用的伪操作如下：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/58ee7a2b-2622-4872-881f-86526cec3feb"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>关于数据定义，常用的伪操作有DCD、DCB、SPACE、DATA，这些伪操作的使用方法如下所示。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/31f36818-6281-4977-b2bf-b3ccb8fd0b1f"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>除此之外，还有一些其他常用的伪操作，如用来标识程序的入口地址、程序的结束地址、用来定义段的属性等，具体如表3-4所示。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/012659fa-3f6b-4dad-a32b-7a2dd01b8030"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>有了这些伪操作辅助，我们就可以设计出更加灵活、功能更加复杂的程序结构，也可以定义一个个汇编子程序，然后在主程序中分别去调用它们，实现汇编语言的模块化编程。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/131643eb-cbfc-4dcc-a3a1-11a955b3005c"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>SUM_ASM 汇编子程序自身又调用了其他子程序 sum，这个 sum子程序可以是一个汇编子程序，也可以是一个使用 C语言定义的函数。在调用之前我们要先使用 IMPORT 伪操作把 sum子程序导入进来，然后就可以直 接使用 BL指令跳转过去运行了。只要遵循一些约定的规则，C程序和汇编程序其实是可以相互调用的，从汇编指令的层面上看，它们之间并无本质的区别。</p><h2 id="c-语言和汇编语言混合编程">C 语言和汇编语言混合编程</h2><h3 id="atpcs-规则">ATPCS 规则</h3><p>ATPCS 的全称是 ARM-Thumb Procedure CallStandard，其核心内容就是定义了 ARM子程序调用的基本规则及堆栈的使用约定等。</p><p>ATPCS最重要的内容是定义了子程序调用的具体规则，无论是程序员编写程序，还是编译器开发商开发编译器工具，一般都要遵守它。规则的主要内容如下：</p><ul><li>子程序间要通过寄存器 R0～R3（可记作a0～a3）传递参数，当参数个数大于4 时，剩余的参数使用堆栈来传递。</li><li>子程序通过 R0～R1 返回结果。</li><li>子程序中使用 R4～R11（可记作 v1～v8）来保存局部变量。</li><li>R12 作为调用过程中的临时寄存器，一般用来保存函数的栈帧基址，记作FP。</li><li>R13 作为堆栈指针寄存器，一般记作 SP。</li><li>R14 作为链接寄存器，用来保存函数调用者的返回地址，记作 LR。</li><li>R15 作为程序计数器，总是指向当前正在运行的指令，记作 PC。</li></ul><h3 id="在-c-程序中内嵌汇编代码">在 C 程序中内嵌汇编代码</h3><p>为了能在 C 程序中内嵌汇编代码，ARM 编译器在 ANSI C标准的基础上扩展了一个关键字<code>__asm</code>。通过这个关键字，我们就可以在 C 程序中内嵌 ARM汇编代码。</p><p>在 C 程序中内嵌汇编代码的格式如下：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/8f570a61-88e5-4952-b79c-d82214b14038"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="在汇编程序中调用-c-程序">在汇编程序中调用 C 程序</h3><p>在 C 程序中可以内嵌汇编代码，在汇编程序中同样也可以调用 C 程序。</p><p>在调用的时候，我们要注意根据 ATPCS 规则来完成参数的传递，并配置好 C程序传递参数和保存局部变量所依赖的堆栈环境，然后使用 BL指令直接跳转即可。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/02259172-1ab3-47b0-978a-15adc003ba33"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="gnu-arm-汇编语言">GNU ARM 汇编语言</h2><p>在 ARM平台下从事嵌入式软件开发，大家会遇到各种不同的集成开发环境和编译器，如IAR、ADS1.2、RVDS、Keil MDK、RealView MDK、ARM 交叉编译器 arm-linux-gcc等。</p><p>如果将这些不同的 IDE 归类，一般可以分为两大类：一类 IDE 内部集成了ARM 编译器，另一类则使用开源的 GNU GCC for ARM编译器，为了方便，在后续的文字中我们就简称为 GNU ARM 编译器。</p><p>一套完整的编译工具集主要包括以下几部分：</p><ul><li>编译器：用来将 C 源文件编译成汇编文件。</li><li>汇编器：用来将汇编文件汇编成目标文件。</li><li>链接器：用来将目标文件组装成可执行文件。</li><li>二进制转化工具：objdump、objcopy、strip 等。</li><li>库打包工具：ar.</li><li>调试工具：gdb、nm.</li><li>库/头文件：根据 C 语言标准定义的 API 实现的 C标准库及对应的头文件。</li></ul><h3 id="gnu-arm-编译器的伪操作">GNU ARM 编译器的伪操作</h3><p>不同的 ARM 编译器之间的伪操作差别还是蛮大的。以 ARM 编译器和 GNU ARM编译器为例，我们可以对比一下它们在数据定义、程序结构方面的差别，如表3-5所示。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/a7aa4969-e9d8-4f5e-a3ae-6fa5a4e59eb1"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>在后面的内容中，我们会经常使用 ARM 反汇编代码来分析 C语言的底层运行机制。为了能看懂反汇编代码，我们还需要熟悉一下在一个反汇编文件中经常看到的各种GNU ARM 伪指令操作，如表3-6所示：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/aba59382-95c7-4fc0-954f-0fe6d326265d"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="gnu-arm-汇编语言中的标号">GNU ARM 汇编语言中的标号</h3><p>汇编语言中的符号定义规则，和 C语言中标识符的定义规则类似：由字母、数字和下画线构成。</p><p>GNU ARM编译器除了遵循标识符的一般规则，还有一些特殊的地方需要注意：GNU ARM汇编语言中的标识符可以由字母、数字、下画线和“.”构成，局部标号可以由纯数字构成。</p><p>GNU 格式的局部标号由数字 N 组成，在引用时使用 Nf 或 Nb的形式，分别表示向前搜索或向后搜索。除此之外，GNU ARM 汇编语言使用标号<code>_start</code>作为汇编程序的入口，如果你希望该标号被其他文件引用，只要在定义的地方使用<code>.global</code> 伪操作声明一下就可以了。</p><h3 id="section-伪操作">section 伪操作</h3><p>在 GNU ARM 汇编语言中，用户可以使用 <code>.section</code>伪操作自定义一个段，使用格式如下。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/3ac36ade-80c3-40a7-90d2-6e3c46fbdb33"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>在使用伪操作 <code>.section</code>定义一个段时，每个段以段名开始，以下一个段名或文件结尾作为结束标记。</p><p>在定义段名时，注意不要和系统预留的段名冲突，如<code>.text</code>、<code>.data</code>、<code>.bss</code>、<code>.rodata</code>都是编译器系统预留的段名，分别表示代码段、数据段、BSS段、只读数据段。我们可以通过readelf命令来查看系统预留的段名。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/e183e122-8678-49f8-8b72-a028d05dea23"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="基本数据格式">基本数据格式</h3><p>二进制数据通常以 0B 或 0b 开头，八进制数据以 0 开头，十六进制数据以0x 开头，十进制数据则以非 0 数字开头。负数前面加 “-”，取补用“～”，不相等用“&lt;&gt;”，其他运算符号如+、-、*、%、&lt;、&lt;&lt;、&gt;、&gt;&gt;、|、&amp;、^、！、==、&gt;=、&amp;&amp;与 C 语言语法相似。</p><p>字符串常量要用双引号 <code>""</code> 括起来。使用 <code>.ascii</code>定义字符串时要自行在结尾加 <code>'\0'</code>，<code>.string</code>伪操作可以定义多个字符串，使用 <code>.asciz</code> 伪操作可以定义一个以<code>NULL</code> 字符结尾的字符串，使用 <code>.rept</code>伪操作可以重复定义数据。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/2eeeef5f-5a09-42ea-aa04-19ef4adbc8c9"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="数据定义">数据定义</h3><p>在 GNU ARM汇编程序中，如果我们想定义一个浮点数，那么可以使用下面的伪操作来定义：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/5043e05e-22cd-46bd-9437-2260e8eb59c7"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>我们可以使用 <code>.float</code> 伪操作定义一个浮点数f，并初始化为3.14。如果你想将这个浮点数重新赋值为3.1415，则可以通过<code>.equ</code> 伪操作来完成。</p><p><code>.equ</code>伪操作除了给数据赋值，还可以把常量定义在代码段中，然后在代码中直接引用。这一点有点类似C 语言中的 <code>#define</code> 宏定义。</p><figure><img data-src="/image/illustrations/0ba8b357a0694ce59173d2d7dcd455b3.jpg"alt="alt text" /><figcaption aria-hidden="true">alt text</figcaption></figure><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(\displaystyle \int k \mathrm{d} x = kx +C\)</span></th><th></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(\displaystyle \int x^{\alpha} \mathrm{d}x=\frac{x^{\alpha+1}}{\alpha+1}+C(\alpha \neq -1)\)</span></td><td><span class="math inline">\(\displaystyle \int \frac{\mathrm{d}x}{x} = \ln \lvert x \rvert + C\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(\displaystyle\int \frac{\mathrm{d} x}{1 + x^{2}} =\arctan x + C\)</span></td><td><span class="math inline">\(\displaystyle\int \frac{\mathrm{d}x}{\sqrt{1 - x^{2}}} = \arcsin x + C\)</span></td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(\displaystyle\int \cos x \mathrm{d} x = \sin x+C\)</span></td><td><span class="math inline">\(\displaystyle\int \sin x \mathrm{d} x =-\cos x + C\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(\displaystyle\int \frac{\mathrm{d} x}{\cos^{2} x}= \int {\sec}^{2} x \mathrm{d} x = \tan x + C\)</span></td><td><span class="math inline">\(\displaystyle\int \frac{\mathrm{d}x}{\sin^{2} x} = \int {\csc}^{2} \mathrm{d} x = -\cot x +C\)</span></td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(\displaystyle\int \sec x \tan x \mathrm{d} x =\sec x + C\)</span></td><td><span class="math inline">\(\displaystyle\int \csc x \cot x\mathrm{d} x = -\csc x + C\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(\displaystyle\int \mathrm{e}^{x} \mathrm{d} x =\mathrm{e}^{x} + C\)</span></td><td><span class="math inline">\(\displaystyle\int a^{x} = \frac{a^x}{\lna} + C\)</span></td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(\displaystyle\int \mathrm{sh} x \mathrm{d} x =\int \mathrm{ch} x + C\)</span></td><td><span class="math inline">\(\displaystyle\int \mathrm{ch} x\mathrm{d} x = \mathrm{sh} x + C\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(\displaystyle\int\tan x \mathrm{d} x = -\lvert\cos x \rvert + C\)</span></td><td><span class="math inline">\(\displaystyle\int \cot x \mathrm{d} x =\ln \lvert \sin x \rvert + C\)</span></td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(\displaystyle\int \sec x \mathrm{d} x = \ln \lvert\sec x + \tan x \rvert + C\)</span></td><td><span class="math inline">\(\displaystyle\int \csc \mathrm{d} x =\ln \lvert \csc x - \cot x \rvert + C\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(\displaystyle\int \frac{\mathrm{d} x}{a^{2} +x^{2}} = \frac{1}{a} \arctan \frac{x}{a} + C\)</span></td><td><span class="math inline">\(\displaystyle\int \frac{\mathrm{d}x}{a^{2} - x^{2}} = \arcsin \frac{x}{a} + C\)</span></td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(\displaystyle\int \frac{\mathrm{d} x}{\sqrt{x^2 +a^2}} = \ln{(x + \sqrt{x^{2} + a^{2}})} + C\)</span></td><td><span class="math inline">\(\displaystyle\int \frac{\mathrm{d}x}{\sqrt{x^{2}-a^{2}}} = \ln \lvert x+ \sqrt{x^{2}-a^{2}} \rvert +C\)</span></td></tr></tbody></table><img data-src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyODlweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjUxM3B4O2hlaWdodDoyODlweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA1MTMgMjg5IiB3aWR0aD0iNTEzcHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48IS0tZW50aXR5IEFkbWluLS0+PGcgaWQ9ImVsZW1fQWRtaW4iPjxlbGxpcHNlIGN4PSIyODIuOTU3NyIgY3k9IjE0IiBmaWxsPSIjRjFGMUYxIiByeD0iOCIgcnk9IjgiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjxwYXRoIGQ9Ik0yODIuOTU3NywyMiBMMjgyLjk1NzcsNDkgTTI2OS45NTc3LDMwIEwyOTUuOTU3NywzMCBNMjgyLjk1NzcsNDkgTDI2OS45NTc3LDY0IE0yODIuOTU3Nyw0OSBMMjk1Ljk1NzcsNjQgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI4Mi43MzU0IiB4PSIyNDEuNTkiIHk9Ijc4LjQ5NTEiPk1haW4gQWRtaW48L3RleHQ+PC9nPjxnIGlkPSJlbGVtX1VzZSI+PGVsbGlwc2UgY3g9IjE0NS45NTg3IiBjeT0iMjYyLjE5OTciIGZpbGw9IiNGMUYxRjEiIHJ4PSI4Ny4xNDg3IiByeT0iMTkuODI5NyIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTM1LjI1NTkiIHg9Ijc4LjMzMDciIHk9IjI2NS4wNDY0Ij5Vc2UgdGhlIGFwcGxpY2F0aW9uPC90ZXh0PjwvZz48IS0tZW50aXR5IFVzZXItLT48ZyBpZD0iZWxlbV9Vc2VyIj48ZWxsaXBzZSBjeD0iMjEuOTU1MSIgY3k9IjE0IiBmaWxsPSIjRjFGMUYxIiByeD0iOCIgcnk9IjgiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjxwYXRoIGQ9Ik0yMS45NTUxLDIyIEwyMS45NTUxLDQ5IE04Ljk1NTEsMzAgTDM0Ljk1NTEsMzAgTTIxLjk1NTEsNDkgTDguOTU1MSw2NCBNMjEuOTU1MSw0OSBMMzQuOTU1MSw2NCAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjMxLjkxMDIiIHg9IjYiIHk9Ijc4LjQ5NTEiPlVzZXI8L3RleHQ+PC9nPjxnIGlkPSJlbGVtX1N0YXJ0Ij48ZWxsaXBzZSBjeD0iMTIwLjk1NTUiIGN5PSI0My42NTMyIiBmaWxsPSIjRjFGMUYxIiByeD0iMzUuNjk1NSIgcnk9IjE0LjUzMzIiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjM0LjIwMDIiIHg9IjEwMi45MTU5IiB5PSI0Ni44MzEyIj5TdGFydDwvdGV4dD48L2c+PGcgaWQ9ImVsZW1fR01OOSI+PHBhdGggZD0iTTM1OS41MiwzMS4wOCBMMzU5LjUyLDM5LjY1IEwzMjQuNTYsNDMuNjUgTDM1OS41Miw0Ny42NSBMMzU5LjUyLDU2LjIxMjggQTAsMCAwIDAgMCAzNTkuNTIsNTYuMjEyOCBMNTA2LjM4NzcsNTYuMjEyOCBBMCwwIDAgMCAwIDUwNi4zODc3LDU2LjIxMjggTDUwNi4zODc3LDQxLjA4IEw0OTYuMzg3NywzMS4wOCBMMzU5LjUyLDMxLjA4IEEwLDAgMCAwIDAgMzU5LjUyLDMxLjA4ICIgZmlsbD0iI0ZFRkZERCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7Ii8+PHBhdGggZD0iTTQ5Ni4zODc3LDMxLjA4IEw0OTYuMzg3Nyw0MS4wOCBMNTA2LjM4NzcsNDEuMDggTDQ5Ni4zODc3LDMxLjA4ICIgZmlsbD0iI0ZFRkZERCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTI1Ljg2NzciIHg9IjM2NS41MiIgeT0iNDguMTQ2OSI+VGhpcyBpcyBhbiBleGFtcGxlLjwvdGV4dD48L2c+PGcgaWQ9ImVsZW1fR01OMTIiPjxwYXRoIGQ9Ik0yNjguMjMsMjQyLjA2IEwyNjguMjMsMjU4LjIgTDIzMy40OCwyNjIuMiBMMjY4LjIzLDI2Ni4yIEwyNjguMjMsMjgyLjMyNTYgQTAsMCAwIDAgMCAyNjguMjMsMjgyLjMyNTYgTDQxMS42ODksMjgyLjMyNTYgQTAsMCAwIDAgMCA0MTEuNjg5LDI4Mi4zMjU2IEw0MTEuNjg5LDI1Mi4wNiBMNDAxLjY4OSwyNDIuMDYgTDI2OC4yMywyNDIuMDYgQTAsMCAwIDAgMCAyNjguMjMsMjQyLjA2ICIgZmlsbD0iI0ZFRkZERCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7Ii8+PHBhdGggZD0iTTQwMS42ODksMjQyLjA2IEw0MDEuNjg5LDI1Mi4wNiBMNDExLjY4OSwyNTIuMDYgTDQwMS42ODksMjQyLjA2ICIgZmlsbD0iI0ZFRkZERCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTAwLjIzNTgiIHg9IjI3NC4yMyIgeT0iMjU5LjEyNjkiPkEgbm90ZSBjYW4gYWxzbzwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMjIuNDU5IiB4PSIyNzQuMjMiIHk9IjI3NC4yNTk3Ij5iZSBvbiBzZXZlcmFsIGxpbmVzPC90ZXh0PjwvZz48ZyBpZD0iZWxlbV9OMiI+PHBhdGggZD0iTTYyLjEsMTQxLjggTDYyLjEsMTgyLjA2NTYgTDIyOS44MDcsMTgyLjA2NTYgTDIyOS44MDcsMTUxLjggTDIxOS44MDcsMTQxLjggTDYyLjEsMTQxLjggIiBmaWxsPSIjRkVGRkREIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiLz48cGF0aCBkPSJNMjE5LjgwNywxNDEuOCBMMjE5LjgwNywxNTEuOCBMMjI5LjgwNywxNTEuOCBMMjE5LjgwNywxNDEuOCAiIGZpbGw9IiNGRUZGREQiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE0Ni43MDciIHg9IjY4LjEiIHk9IjE1OC44NjY5Ij5UaGlzIG5vdGUgaXMgY29ubmVjdGVkPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjExOS42NjYiIHg9IjY4LjEiIHk9IjE3My45OTk3Ij50byBzZXZlcmFsIG9iamVjdHMuPC90ZXh0PjwvZz48IS0tbGluayBVc2VyIHRvIFN0YXJ0LS0+PGcgaWQ9ImxpbmtfVXNlcl9TdGFydCI+PHBhdGggZD0iTTM4LjIsNDMuNjUgQzUzLjgyLDQzLjY1IDYzLjQ1LDQzLjY1IDc5LjA3LDQzLjY1ICIgZmlsbD0ibm9uZSIgaWQ9IlVzZXItdG8tU3RhcnQiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwb2x5Z29uIGZpbGw9IiMxODE4MTgiIHBvaW50cz0iODUuMDcsNDMuNjUsNzYuMDcsMzkuNjUsODAuMDcsNDMuNjUsNzYuMDcsNDcuNjUsODUuMDcsNDMuNjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjwvZz48IS0tbGluayBVc2VyIHRvIFVzZS0tPjxnIGlkPSJsaW5rX1VzZXJfVXNlIj48cGF0aCBkPSJNMjEuMDYsODIuMTQgQzIxLjk3LDExMS4yOCAyNi45MiwxNTEuNyA0NC45NiwxODIuMDYgQzYwLjg4LDIwOC44OCA4NC40NTYsMjI2Ljk0MTQgMTA3LjIwNiwyNDAuNjAxNCAiIGZpbGw9Im5vbmUiIGlkPSJVc2VyLXRvLVVzZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBvbHlnb24gZmlsbD0iIzE4MTgxOCIgcG9pbnRzPSIxMTIuMzUsMjQzLjY5LDEwNi42OTMyLDIzNS42Mjc3LDEwOC4wNjM0LDI0MS4xMTYxLDEwMi41NzUsMjQyLjQ4NjQsMTEyLjM1LDI0My42OSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PC9nPjwhLS1saW5rIEFkbWluIHRvIFVzZS0tPjxnIGlkPSJsaW5rX0FkbWluX1VzZSI+PHBhdGggZD0iTTI3OS42OCw4Mi4yOSBDMjc1LjY1LDExMS41MSAyNjYuNzIsMTUxLjk3IDI0Ni45NiwxODIuMDYgQzIyOS43MSwyMDguMzIgMjA1LjkyNTcsMjI2LjUwODQgMTgzLjQ1NTcsMjQwLjM3ODQgIiBmaWxsPSJub25lIiBpZD0iQWRtaW4tdG8tVXNlIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cG9seWdvbiBmaWxsPSIjMTgxODE4IiBwb2ludHM9IjE3OC4zNSwyNDMuNTMsMTg4LjEwOTUsMjQyLjIwNjQsMTgyLjYwNDcsMjQwLjkwMzcsMTgzLjkwNzQsMjM1LjM5ODksMTc4LjM1LDI0My41MyIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PC9nPjwhLS1saW5rIFN0YXJ0IHRvIE4yLS0+PGcgaWQ9ImxpbmtfU3RhcnRfTjIiPjxwYXRoIGQ9Ik0xMjMuOTIsNTguNDUgQzEyOC4zNCw3OS4wMiAxMzYuNjksMTE3Ljg0IDE0MS43NCwxNDEuMzQgIiBmaWxsPSJub25lIiBpZD0iU3RhcnQtTjIiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wO3N0cm9rZS1kYXNoYXJyYXk6Ny4wLDcuMDsiLz48L2c+PCEtLWxpbmsgTjIgdG8gVXNlLS0+PGcgaWQ9ImxpbmtfTjJfVXNlIj48cGF0aCBkPSJNMTQ1Ljk2LDE4Mi4zNSBDMTQ1Ljk2LDE5OS42OCAxNDUuOTYsMjI0LjkzIDE0NS45NiwyNDIuMTYgIiBmaWxsPSJub25lIiBpZD0iTjItVXNlIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjcuMCw3LjA7Ii8+PC9nPjwhLS1TUkM9W05PeW4zaThtMzROdGRFQWhLcGxHZU1DN2YxdzBCaTM2dWhRNjFnTEViS0k4dXZFYTVLWDhLVkJ6XzZ0N3hPY3FlOWlNQkl0OFJxZ0xMeXk4Q3VGTXJVWUhXaFBJZk5IQUw0aDVzLTVtSDdhRXY0QXJubWJpLVRtYldYeUg2blhFRi1PMFV6LWNlQ0xiclh4bmE4M1ZqQW82d3RfaExXenFvN29DTFpCVUhaOG1oQzNwWW5xUDYydGk1U2tLVk5rTjhXXzhDaHdaNVU0bnk3SUpPQi01VGRYNndFaVl4VFN0UWp5OVRQc1lsYWFZVi04M10tLT48L2c+PC9zdmc+'>]]></content>
    
    
    <summary type="html">ARM 汇编入门笔记</summary>
    
    
    
    <category term="汇编" scheme="https://xinransix.github.io/categories/%E6%B1%87%E7%BC%96/"/>
    
    
    <category term="ARM" scheme="https://xinransix.github.io/tags/ARM/"/>
    
    <category term="汇编" scheme="https://xinransix.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础命令</title>
    <link href="https://xinransix.github.io/2023/07/17/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>https://xinransix.github.io/2023/07/17/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</id>
    <published>2023-07-17T06:12:38.000Z</published>
    <updated>2023-07-17T06:14:17.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="终端提示符">终端提示符</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yaojie@yaojie-virtual-machine:~$ </span><br><span class="line">yaojie: 用户名</span><br><span class="line">yaojie-virtual-machine: 主机名</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~: 家目录</span><br><span class="line">/: 根目录</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$: 普通用户权限</span><br><span class="line"><span class="comment">#: 管理员权限</span></span><br></pre></td></tr></table></figure><h2 id="命令帮助信息">命令帮助信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令 --help</span><br></pre></td></tr></table></figure><blockquote><p>注意：并不是所有的命令都有帮助信息。</p></blockquote><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/ddd040ff-025a-4674-b58a-cf33e3184e24"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="man-命令">man 命令</h3><p>man 命令是 linux提供的帮助手册，可以查询命令、函数或者特殊的文件，这个手册有很多个章节。</p><p>第一章中放的是命令的帮助信息。</p><p>第二章中放的是系统调用。</p><p>第三章中放的是库函数的帮助信息。</p><p>使用 <code>man man</code> 查看 man 命令的帮助信息：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/3ded45a7-de5d-41f8-9b3d-3f59fa945f3a"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">man 章节 查找信息</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">man 1 <span class="built_in">ls</span> 或者 man <span class="built_in">ls</span></span><br><span class="line">man 2 open</span><br></pre></td></tr></table></figure><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/262e202c-0379-4fb5-8945-6a2d8fe1e02e"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="命令常用的技巧">命令常用的技巧</h2><h3 id="自动补全">自动补全</h3><p>输入命令的一部分，按 <kbd>tab</kbd>键，会可以自动补全命令，如果匹配到了多个命令，按两次<kbd>tab</kbd>，会在终端打印所有可用的命令。</p><p>文件和目录也可以使用如上操作进行补全。</p><h3 id="历史命令">历史命令</h3><p>可以通过<strong>上下方向键</strong>将以前输入过的命令调出来，敲回车再次执行和做修改后执行。</p><h3 id="重定向">重定向</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令 &gt; 目的文件 <span class="comment"># 先清空原本文件内容，然后将命令的输出结果写入文件</span></span><br><span class="line">命令 &gt;&gt; 目的文件 <span class="comment"># 以追加的方式将命令的输出结果写入文件</span></span><br></pre></td></tr></table></figure><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/3acef1f4-1c41-4965-8d40-607529f00ddf"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="管道">管道</h3><p>将一个程序的输出作为另外一个程序的输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> --<span class="built_in">help</span> | more <span class="comment"># 以每页的方式查看ls命令的帮助信息</span></span><br><span class="line"><span class="built_in">ls</span> /etc | <span class="built_in">wc</span> w <span class="comment"># 统计根目录下的etc目录中的文件数</span></span><br></pre></td></tr></table></figure><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/7e3f7021-9de4-4573-af31-55793882d017"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="ls"><code>ls</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> <span class="comment">#查看当前目录下的文件名</span></span><br><span class="line"><span class="built_in">ls</span> 目录名 <span class="comment">#查看指定目录下的文件名</span></span><br><span class="line"><span class="built_in">ls</span> / <span class="comment">#查看根目录下的文件名</span></span><br><span class="line"><span class="built_in">ls</span> -a <span class="comment">#查看当前目录下的所有文件名，包括隐藏文件</span></span><br><span class="line"><span class="built_in">ls</span> -l <span class="comment">#查看当前目录下文件的详细信息（以列表的显示输出）</span></span><br><span class="line"><span class="built_in">ls</span> -al <span class="comment">#查看当前目录下所有文件的详细信息</span></span><br><span class="line"><span class="built_in">ls</span> -hl <span class="comment">#详细信息中的字节数可以带单位的显示</span></span><br><span class="line"><span class="built_in">ls</span> -d <span class="comment">#只列出目录</span></span><br><span class="line"><span class="built_in">ls</span> -r <span class="comment">#倒序显示文件和目录</span></span><br><span class="line"><span class="built_in">ls</span> -R <span class="comment">#递归显示目录中的所有文件和子目录</span></span><br><span class="line"><span class="built_in">ls</span> -t <span class="comment">#按修改时间排序，最新的文件在最前面</span></span><br><span class="line"><span class="built_in">ls</span> -A <span class="comment">#同 &quot;-a&quot;，但不列出 &quot;.&quot; 和 &quot;..&quot;</span></span><br><span class="line"><span class="built_in">ls</span> -F <span class="comment">#在列出的文件名称后加一符号；例如可执行档则加 &quot;*&quot;, 目录则加 &quot;/&quot;</span></span><br></pre></td></tr></table></figure><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/76da838f-68bb-420b-a4c9-328006bd8293"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x  20 root root       4096  6月  7 15:12 .</span><br><span class="line">d：文件类型，linux里面不以后缀名作为文件类型的区分</span><br><span class="line">linux里面一共有其中文件类型bcd-lsp，linux里面一切皆文件</span><br><span class="line">    b：块设备文件</span><br><span class="line">    c：字符设备文件</span><br><span class="line">    d：目录文件</span><br><span class="line">    -：普通文件</span><br><span class="line">    l：软链接文件</span><br><span class="line">    s：套接字文件</span><br><span class="line">    p：管道文件</span><br><span class="line">rwxr-xr-x：文件权限，以三个为一组，分别表示用户主、用户组以及其他用户对文件的操作权限，r：读权限，w：写权限，x：可执行权限，如果是-，就表示没有这个权限</span><br><span class="line">20：链接文件的个数</span><br><span class="line">root：用户名</span><br><span class="line">root：用户组名</span><br><span class="line">4096：文件大小，默认以字节为单位</span><br><span class="line">6月  7 15:12：时间戳，文件的最后修改时间</span><br><span class="line">.：文件名</span><br></pre></td></tr></table></figure><h2 id="tree"><code>tree</code></h2><p>以树状结构显示目录信息。</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/978079cd-598c-4112-a24b-066af2214d7b"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree -L 层数 <span class="comment"># 用于显示指定的层数</span></span><br></pre></td></tr></table></figure><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/2e1ec8ac-82f4-47da-aef5-dd805bc7bf2e"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="clear"><code>clear</code></h2><p>清屏。</p><h2 id="cd"><code>cd</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 当前目录下的目录名 <span class="comment">#进入指定的目录</span></span><br><span class="line"><span class="built_in">cd</span> / <span class="comment">#进入根目录</span></span><br><span class="line"><span class="built_in">cd</span> ~ <span class="comment">#进入家目录</span></span><br><span class="line"><span class="built_in">cd</span> .. <span class="comment">#进入当前目录的上一级目录</span></span><br><span class="line"><span class="built_in">cd</span> - <span class="comment">#返回到上一次的路径</span></span><br></pre></td></tr></table></figure><h2 id="pwd"><code>pwd</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span> <span class="comment">#显示当前路径的绝对路径</span></span><br></pre></td></tr></table></figure><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/985fd7a6-2383-4925-acdd-87f6c853130c"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="cat"><code>cat</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 文件名 <span class="comment">#显示文件的内容</span></span><br><span class="line"><span class="built_in">cat</span> -n 文件名 <span class="comment">#带行号的显示文件的内容</span></span><br></pre></td></tr></table></figure><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/dbbfe639-6755-49ad-805d-74421f89b169"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="rm"><code>rm</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> 文件名 <span class="comment">#删除指定的文件</span></span><br><span class="line"><span class="built_in">rm</span> -rf 目录文件名 <span class="comment">#删除指定的目录文件</span></span><br></pre></td></tr></table></figure><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/e89c9545-9582-43a4-b8e8-086aa2cefcd2"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="cp"><code>cp</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> 文件名 目录名 <span class="comment">#将文件复制到目录中</span></span><br><span class="line"><span class="built_in">cp</span> 目录1 目录2 -a <span class="comment">#将目录1复制到目录2中</span></span><br><span class="line"><span class="built_in">cp</span> 文件名1 文件名2 <span class="comment">#如果文件2不是目录，则文件1复制一份为文件2，如果文件2存在且不是一个目录，则直接将内容替换传文件1的</span></span><br></pre></td></tr></table></figure><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/590f369d-0beb-4655-b094-de8792eabef8"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="mv"><code>mv</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> 文件名 目录名 <span class="comment">#将文件移动到指定的目录中</span></span><br><span class="line"><span class="built_in">mv</span> 目录1 目录2 <span class="comment">#将目录1移动到目录2中</span></span><br><span class="line"><span class="built_in">mv</span> 文件1 文件2 <span class="comment">#如果文件2不存在，则功能为重命名</span></span><br></pre></td></tr></table></figure><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/80561c5d-d60f-4225-b78d-5b3f749bcd70"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="mkdir"><code>mkdir</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> 目录名 <span class="comment">#创建一个目录文件</span></span><br><span class="line"><span class="built_in">mkdir</span> 目录1 目录2 ... <span class="comment">#创建多个目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p 目录1/目录2/目录3/... <span class="comment">#嵌套的创建多个文件</span></span><br></pre></td></tr></table></figure><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/17230b5f-42b5-46aa-a898-d9fefbf90a42"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="touch"><code>touch</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> 文件名 <span class="comment">#创建一个文件</span></span><br><span class="line"><span class="comment">#注意：如果文件已经存在，则touch会修改当前时间的时间戳</span></span><br></pre></td></tr></table></figure><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/c99c60dd-fb89-4b43-b4cf-5306b95aa39d"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p><code>touch</code> 创建的文件默认情况下是 664 的权限。</p><h2 id="find"><code>find</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find 路径 -name 文件名 <span class="comment">#在指定的路径下查找指定的文件，会从指定路径下包括所有的子目录中寻找</span></span><br></pre></td></tr></table></figure><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/22dc10dc-17c9-4171-b0ce-23ab6ea161be"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="grep"><code>grep</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep 查找信息 文件名  <span class="comment">#在指定的文件中查找指定的内容，将查找到的内容整行输出并高亮显示查找的内容</span></span><br><span class="line">grep 查找信息 文件名 -n <span class="comment">#在指定的文件中查找指定的内容，将查找到的内容整行且带行号输出并高亮显示查找的内容</span></span><br><span class="line">grep 查找信息 * -R -n <span class="comment">#从当前目录以及子目录中的文件中查找指定信息</span></span><br></pre></td></tr></table></figure><h2 id="ln"><code>ln</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> 源文件名 链接文件名 -s <span class="comment">#创建一个链接文件（类似windows的快捷方式）</span></span><br><span class="line"><span class="built_in">ln</span> 源文件名 链接文件名 -sfn <span class="comment">#创建一个链接文件，如果之前存在则覆盖（类似windows的快捷方式）</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>不管对源文件还是链接文件进行修改，双方的内容都会改变。</li><li>如果删除链接文件，对源文件没有任何影响。</li><li>如果删除源文件，则链接文件失效</li><li>硬链接无需带任何选项</li></ul></blockquote><h2 id="more-和-less"><code>more</code> 和 <code>less</code></h2><h2 id="chmod"><code>chmod</code></h2><p><code>Linux</code> 文件调用权限分为 3级：文件拥有者（Owner）、用户组（Group）、其他用户（Other Users）。</p><figure><img data-src="https://www.runoob.com/wp-content/uploads/2014/08/file-permissions-rwx.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>只有文件所有者和超级用户可以修改文件或目录的权限。可以使用绝对模式（八进制数字模式），符号模式指定文件的权限。</p><figure><img data-src="https://www.runoob.com/wp-content/uploads/2014/08/rwx-standard-unix-permission-bits.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> [-cfvR] [--<span class="built_in">help</span>] [--version] mode file...</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><p><code>mode</code>：权限设定字串，格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ugoa...][[+-=][rwxX]...][,...]</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>u</code> 表示该文件的拥有者，g表示与该文件的拥有者属于同一个组的用户，<code>o</code>表示其他以外的人，<code>a</code> 表示这三者皆是。</li><li><code>+</code> 表示增加权限、<code>-</code>表示取消权限、<code>=</code> 表示唯一设定权限。</li><li><code>r</code> 表示可读取，<code>w</code> 表示可写入，<code>x</code>表示可执行，<code>X</code>表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</li></ul><p>其他参数说明：</p><ul><li><code>-c</code>：若该文件权限确实已经更改，才显示其更改动作</li><li><code>-f</code>：若该文件权限无法被更改也不要显示错误讯息</li><li><code>-v</code> ：显示权限变更的详细资料</li><li><code>-R</code>：对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)</li><li><code>--help</code>：显示辅助说明</li><li><code>--version</code>：显示版本</li></ul><p><strong>符号模式：</strong></p><p>使用符号模式可以设置多个项目：who（用户类型），operator（操作符）和permission（权限），每个项目的设置可以用逗号隔开。 命令<code>chmod</code> 将修改 who指定的用户类型对文件的访问权限，用户类型由一个或者多个字母在 who的位置来说明，如 who 的符号模式表所示：</p><table><thead><tr class="header"><th style="text-align: center;">who</th><th style="text-align: center;">用户类型</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>u</code></td><td style="text-align: center;">user</td><td style="text-align: center;">文件所有者</td></tr><tr class="even"><td style="text-align: center;"><code>g</code></td><td style="text-align: center;">group</td><td style="text-align: center;">文件所有者所在组</td></tr><tr class="odd"><td style="text-align: center;"><code>o</code></td><td style="text-align: center;">others</td><td style="text-align: center;">所有其他用户</td></tr><tr class="even"><td style="text-align: center;"><code>a</code></td><td style="text-align: center;">all</td><td style="text-align: center;">所有用户, 相当于 ugo</td></tr></tbody></table><p>operator 的符号模式表：</p><table><thead><tr class="header"><th style="text-align: center;">Operator</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>+</code></td><td style="text-align: center;">为指定的用户类型增加权限</td></tr><tr class="even"><td style="text-align: center;"><code>-</code></td><td style="text-align: center;">去除指定用户类型的权限</td></tr><tr class="odd"><td style="text-align: center;"><code>=</code></td><tdstyle="text-align: center;">设置指定用户权限的设置，即将用户类型的所有权限重新设置</td></tr></tbody></table><p>permission 的符号模式表：</p><table><colgroup><col style="width: 5%" /><col style="width: 15%" /><col style="width: 78%" /></colgroup><thead><tr class="header"><th style="text-align: center;">模式</th><th style="text-align: center;">名字</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>r</code></td><td style="text-align: center;">读</td><td style="text-align: center;">设置为可读权限</td></tr><tr class="even"><td style="text-align: center;"><code>w</code></td><td style="text-align: center;">写</td><td style="text-align: center;">设置为可写权限</td></tr><tr class="odd"><td style="text-align: center;"><code>x</code></td><td style="text-align: center;">执行权限</td><td style="text-align: center;">设置为可执行权限</td></tr><tr class="even"><td style="text-align: center;"><code>X</code></td><td style="text-align: center;">特殊执行权限</td><tdstyle="text-align: center;">只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行</td></tr><tr class="odd"><td style="text-align: center;"><code>s</code></td><td style="text-align: center;">setuid/gid</td><td style="text-align: center;">当文件被执行时，根据 who参数指定的用户类型设置文件的 setuid 或者 setgid 权限</td></tr><tr class="even"><td style="text-align: center;"><code>t</code></td><td style="text-align: center;">粘贴位</td><tdstyle="text-align: center;">设置粘贴位，只有超级用户可以设置该位，只有文件所有者u 可以使用该位</td></tr></tbody></table><p><strong>八进制语法：</strong></p><table><thead><tr class="header"><th style="text-align: center;">#</th><th style="text-align: center;">权限</th><th style="text-align: center;">rwx</th><th style="text-align: center;">二进制</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">7</td><td style="text-align: center;">读 + 写 + 执行</td><td style="text-align: center;">rwx</td><td style="text-align: center;">111</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">读 + 写</td><td style="text-align: center;">rw-</td><td style="text-align: center;">110</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">读 + 执行</td><td style="text-align: center;">r-x</td><td style="text-align: center;">101</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">只读</td><td style="text-align: center;">r--</td><td style="text-align: center;">100</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">写 + 执行</td><td style="text-align: center;">-wx</td><td style="text-align: center;">011</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">只写</td><td style="text-align: center;">-w-</td><td style="text-align: center;">010</td></tr><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">只执行</td><td style="text-align: center;">--x</td><td style="text-align: center;">001</td></tr><tr class="even"><td style="text-align: center;">0</td><td style="text-align: center;">无</td><td style="text-align: center;">---</td><td style="text-align: center;">000</td></tr></tbody></table><p><strong>实例：</strong></p><p>将文件 file1.txt 设为所有人皆可读取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> ugo+r file1.txt</span><br></pre></td></tr></table></figure><p>将文件 file1.txt 设为所有人皆可读取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> a+r file1.txt</span><br></pre></td></tr></table></figure><p>将文件 file1.txt 与 file2.txt设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> ug+w,o-w file1.txt file2.txt</span><br></pre></td></tr></table></figure><p>为 ex1.py 文件拥有者增加可执行权限:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+x ex1.py</span><br></pre></td></tr></table></figure><p>将目前目录下的所有文件与子目录皆设为任何人可读取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -R a+r *</span><br></pre></td></tr></table></figure><p>此外 <code>chmod</code> 也可以用数字来表示权限如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 file</span><br></pre></td></tr></table></figure><p>语法为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> abc file</span><br></pre></td></tr></table></figure><p>其中 a、b、c 各为一个数字，分别表示 User、Group、及 Other的权限。</p><p>r=4，w=2，x=1</p><ul><li>若要 rwx 属性则 4+2+1=7；</li><li>若要 rw- 属性则 4+2=6；</li><li>若要 r-x 属性则 4+1=5。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> a=rwx file</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 file</span><br></pre></td></tr></table></figure><p>效果相同</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> ug=rwx,o=x file</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 771 file</span><br></pre></td></tr></table></figure><p>效果相同</p><p>若用 <code>chmod 4755 filename</code> 可使此程序具有 root的权限。</p><p><strong>更多说明：</strong></p><table><colgroup><col style="width: 41%" /><col style="width: 58%" /></colgroup><thead><tr class="header"><th style="text-align: center;">命令</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>chmod a+r file</code></td><td style="text-align: center;">给file的所有用户增加读权限</td></tr><tr class="even"><td style="text-align: center;"><code>chmod a-x file</code></td><td style="text-align: center;">删除file的所有用户的执行权限</td></tr><tr class="odd"><td style="text-align: center;"><code>chmod a+rw file</code></td><td style="text-align: center;">给file的所有用户增加读写权限</td></tr><tr class="even"><td style="text-align: center;"><code>chmod +rwx file</code></td><td style="text-align: center;">给file的所有用户增加读写执行权限</td></tr><tr class="odd"><td style="text-align: center;"><code>chmod u=rw,go= file</code></td><tdstyle="text-align: center;">对file的所有者设置读写权限，清空该用户组和其他用户对file的所有权限（空格代表无权限）</td></tr><tr class="even"><td style="text-align: center;"><code>chmod -R u+r,go-r docs</code></td><tdstyle="text-align: center;">对目录docs和其子目录层次结构中的所有文件给用户增加读权限，而对用户组和其他用户删除读权限</td></tr><tr class="odd"><td style="text-align: center;"><code>chmod 664 file</code></td><td style="text-align: center;">对file的所有者和用户组设置读写权限,为其其他用户设置读权限</td></tr><tr class="even"><td style="text-align: center;"><code>chmod 0755 file</code></td><tdstyle="text-align: center;">相当于<code>u=rwx (4+2+1),go=rx (4+1 &amp; 4+1)</code>。<code>0</code>没有特殊模式。</td></tr><tr class="odd"><td style="text-align: center;"><code>chmod 4755 file</code></td><tdstyle="text-align: center;"><code>4</code>设置了设置用户ID位，剩下的相当于u=rwx (4+2+1), go=rx (4+1 &amp; 4+1)。</td></tr><tr class="even"><tdstyle="text-align: center;"><code>find path/ -type d -exec chmod a-x &#123;&#125; \;</code></td><td style="text-align: center;">删除可执行权限对 <code>path/</code>以及其所有的目录（不包括文件）的所有用户，使用 <code>-type f</code>匹配文件</td></tr><tr class="odd"><tdstyle="text-align: center;"><code>find path/ -type d -exec chmod a+x &#123;&#125; \;</code></td><td style="text-align: center;">允许所有用户浏览或通过目录<code>path/</code></td></tr></tbody></table><h2 id="tar"><code>tar</code></h2><h3 id="gzip-格式">gzip 格式</h3><p><strong>压缩：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar zcvf 压缩包包名 文件1 文件2 文件3 ...</span><br><span class="line"><span class="comment"># 注意：压缩包包名一般以.tar.gz作为后缀名</span></span><br></pre></td></tr></table></figure><p><strong>解压：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf 压缩包包名</span><br><span class="line">tar zxvf 压缩包包名 -C 路径 <span class="comment">#解压到指定的路径</span></span><br></pre></td></tr></table></figure><h3 id="bz2-格式">bz2 格式</h3><p><strong>压缩：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar jcvf 压缩包包名 文件1 文件2 文件3 ... <span class="comment">#注意：压缩包包名一般以.tar.bz2作为后缀名</span></span><br></pre></td></tr></table></figure><p><strong>解压：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar jxvf 压缩包包名</span><br><span class="line">tar jxvf 压缩包包名 -C 路径 解压到指定的路径</span><br></pre></td></tr></table></figure><h2 id="vi">vi</h2><h3 id="安装-vimvi-升级版">安装 vim（vi 升级版）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim <span class="comment"># 安装 vim</span></span><br><span class="line">sudo apt install ctags <span class="comment"># 安装 ctags</span></span><br></pre></td></tr></table></figure><h3 id="vi-的使用">vi 的使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi 文件名 <span class="comment">#在vi编辑器中打开或者创建一个文件，并将光标置于第一行行首</span></span><br><span class="line">vi +n 文件名 <span class="comment">#打开存在文件，并将光标置于第n行行首</span></span><br></pre></td></tr></table></figure><h3 id="vi-的三种模式">vi 的三种模式</h3><ol type="1"><li>插入模式：这种模式可以直接编辑文档</li><li>编辑模式：在编辑模式下可以执行一些命令，执行复制、剪切、粘贴等功能。</li><li>命令模式：在此模式下可以保存文件，退出 vi.</li></ol><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/fb96ef4d-e48e-4800-a772-2b5700375c15"alt="vim-vi-workmodel" /><figcaption aria-hidden="true">vim-vi-workmodel</figcaption></figure><blockquote><p>编辑模式进入插入模式可使用<code>i</code>、<code>a</code>、<code>o</code>、<code>a</code>，分别表示在光标处插入、在光标后一个字符插入，新开启一行插入以及替换一个字符。</p></blockquote><p><strong>命令模式下的一些指令：</strong></p><ul><li><code>w</code>：保存文件</li><li><code>wq</code>：保存并退出</li><li><code>x</code>：保存并退出</li><li><code>q!</code>：强制退出</li><li><code>w finename</code>：能成为 <code>filename</code></li><li><code>set nu</code>：设置显示行号</li><li><code>set nonu</code>：设置取消行号</li></ul><p><strong>编辑模式下的操作：</strong></p><ul><li><code>u</code>：撤销前面多次修改，<code>ctrl</code> 反撤销。</li><li><code>[n]x</code>：删除光标后 n 个字符。</li><li><code>[n]X</code>：删除光标前 n 个字符。</li><li><code>[n]dd</code>：剪切从当前行开始的 n 行。</li><li><code>[n]yy</code>：复制从当前行开始的 n 行（<code>y[n]y</code>也行）。</li><li><code>p</code>：粘贴。</li><li><code>.</code>：执行上一次操作。</li><li><kbd>shift</kbd> + <code>zz</code>：保存退出。</li></ul><p><strong>编辑模式下移动光标：</strong></p><ul><li><code>[n]G</code>：将光标移动到第 n 行开始处。</li><li><code>G</code>：将光标移动到文件尾。</li><li><code>gg</code>：将光标移动到文件开始处。</li></ul><p><strong>编辑模式下的查找：</strong></p><ul><li><code>/字符串</code>：从光标开始处向文件尾查找字符串，<code>n</code>查找下一个，<code>N</code> 查找上一个，在要搜索的字符串之前加<code>\c</code> 可以忽略大小写。</li><li><code>n</code>：同一方向重复上一次查找命令。</li><li><code>N</code>：反方向错误上一次查找命令。</li></ul><h2 id="gcc-编译器">GCC 编译器</h2><p>程序的编译分为四个阶段： 由 <code>.c</code> 到可执行程序：</p><ol type="1"><li>预处理；</li><li>编译；</li><li>汇编；</li><li>链接。</li></ol><p><strong>编译程序：</strong></p><ol type="1"><li>一步到位：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c <span class="comment"># 默认会生成一个名为a.out的可执行文件</span></span><br><span class="line">gcc hello.c -o hello</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/940f33cf-8714-47ba-9475-416d87e4e98b"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><ol start="2" type="1"><li>分步骤完成：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i <span class="comment">#1、预处理</span></span><br><span class="line">gcc -S hello.i -o hello.s <span class="comment">#2、编译</span></span><br><span class="line">gcc -c hello.s -o hello.o <span class="comment">#3、汇编</span></span><br><span class="line">gcc hello.o –o hello <span class="comment">#4、链接</span></span><br></pre></td></tr></table></figure><h2 id="用户操作">用户操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd 用户名</span><br><span class="line">userdel 用户名</span><br></pre></td></tr></table></figure><h2 id="其它">其它</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> </span><br><span class="line">whereis</span><br><span class="line">locate</span><br></pre></td></tr></table></figure><p><code>PWD</code>是一个环境变量，记录了当前目录，引用时要：<code>$PWD</code></p><h2 id="参考">参考</h2><ul><li><a href="https://www.runoob.com/linux/linux-vim.html">Linux vi/vim |菜鸟教程</a></li><li><a href="https://www.runoob.com/linux/linux-comm-chmod.html">Linuxchmod命令 | 菜鸟教程</a></li><li><ahref="https://www.cnblogs.com/mouseleo/p/13326837.html">让Vim查找字符忽略大小写| 博客园</a></li></ul>]]></content>
    
    
    <summary type="html">Linux 的常用命令</summary>
    
    
    
    <category term="Linux" scheme="https://xinransix.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://xinransix.github.io/tags/Linux/"/>
    
    <category term="命令" scheme="https://xinransix.github.io/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="https://xinransix.github.io/2023/07/16/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>https://xinransix.github.io/2023/07/16/%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2023-07-16T02:47:00.000Z</published>
    <updated>2024-02-22T13:57:38.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="位运算介绍">位运算介绍</h2><p>位运算由按位与、按位或、按位取反、按位异或、左移、右移。</p><p><strong>与（&amp;）</strong>：</p><p>与运算的真值表：</p><table><thead><tr class="header"><th style="text-align: center;"><code>a</code></th><th style="text-align: center;"><code>b</code></th><th style="text-align: center;"><code>a &amp; b</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr></tbody></table><blockquote><p>与运算的特点是：有 0 得 0，全 1 得 1.</p></blockquote><p>例：对 35 和 47 进行与运算：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    35:  0 0 1 0 0 0 1 1</span><br><span class="line">  &amp; 47:  0 0 1 0 1 1 1 1</span><br><span class="line">-----------------------</span><br><span class="line">         0 0 1 0 0 0 1 1</span><br></pre></td></tr></table></figure><p><strong>或（|）</strong>：</p><table><thead><tr class="header"><th style="text-align: center;"><code>a</code></th><th style="text-align: center;"><code>b</code></th><th style="text-align: center;"><code>a \| b</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr></tbody></table><blockquote><p>或运算的特点：有 1 得 1，全 0 得 0.</p></blockquote><p>例：对 35 和 47 进行与运算：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    35:  0 0 1 0 0 0 1 1</span><br><span class="line">  | 47:  0 0 1 0 1 1 1 1</span><br><span class="line">-----------------------</span><br><span class="line">         0 0 1 0 1 1 1 1</span><br></pre></td></tr></table></figure><p><strong>取反（~）</strong>：</p><table><thead><tr class="header"><th style="text-align: center;"><code>a</code></th><th style="text-align: center;"><code>~a</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr></tbody></table><blockquote><p>反运算的特点是：1 变 0，0 变 1.</p></blockquote><p><strong>异或（^）</strong>：</p><table><thead><tr class="header"><th style="text-align: center;"><code>a</code></th><th style="text-align: center;"><code>b</code></th><th style="text-align: center;"><code>a ^ b</code></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td></tr></tbody></table><blockquote><p>异或运算的特点是：相同为 0，不同为 1.</p></blockquote><p>异或运算有如下性质：</p><ol type="1"><li>交换律： <span class="math inline">\(a ^{\wedge} b = b ^{\wedge}a\)</span>.</li><li>结合律： <span class="math inline">\((a ^{\wedge} b) ^{\wedge} c = a^{\wedge} (b ^{\wedge} c)\)</span>.</li><li><span class="math inline">\(a_{1} ^{\wedge} a_{2} ^{\wedge} a_{3}^{\wedge} \cdots ^{\wedge} a_{n}\)</span> 的结果与 <spanclass="math inline">\(a_{1}, a_{2}, a_{3}, \cdots ,a_{n}\)</span>的顺序无关。</li><li><code>0 ^ x = x</code>、<code>1 ^ x = ~x</code>.</li></ol><p><strong>右移（&gt;&gt;）</strong>：</p><p>右移有算术右移和逻辑右移两种，对于负数来说，算术右移在最高位补1，逻辑右移在最高位补 0.</p><p><strong>左移（&lt;&lt;）</strong>：</p><p>右移丢弃最高位，在最低位补 0.</p><blockquote><p>右移相当于乘除 2，左移相当于乘 2.</p></blockquote><h2 id="位运算经典应用">位运算经典应用</h2><h3 id="置-1-与置-0">置 1 与置 0</h3><p>把一个 1 字节数据的第 3 位和第 4 位置 0，我们可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> data = <span class="number">0xff</span>;</span><br><span class="line">data &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span> | <span class="number">1</span> &lt;&lt; <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>把一个 1 字节数据的第 5 位和第 6 位置 1，我们可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> data = <span class="number">0xff</span>;</span><br><span class="line">data |= (<span class="number">1</span> &lt;&lt; <span class="number">5</span> | <span class="number">1</span> &lt;&lt; <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>把一个把一个 1 字节数据的第 3 位和第 4 位置 0，第 5 位和第 6 位置1，我们可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> data = <span class="number">0x0f</span>;</span><br><span class="line">data = data &amp; ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span> | <span class="number">1</span> &lt;&lt; <span class="number">4</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">5</span> | <span class="number">1</span> &lt;&lt; <span class="number">6</span>);</span><br></pre></td></tr></table></figure><h3 id="实现加法">实现加法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="type">int</span> temp = a ^ b;</span><br><span class="line">        b = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        a = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h3 id="去掉最后一位-1">去掉最后一位 1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &amp;= (a - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="统计二进制中-1-的个数">统计二进制中 1 的个数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (a) &#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    a &amp;= (a - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断奇偶">判断奇偶</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &amp; <span class="number">1</span> == <span class="number">0</span> <span class="comment">// 为 true 说明是偶数</span></span><br></pre></td></tr></table></figure><h3 id="反转指定位">反转指定位</h3><p>例如翻转 <code>data</code> 的第 3 位：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data ^= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="交换两个数">交换两个数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure><h3 id="lowbit-函数">lowbit 函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span><br></pre></td></tr></table></figure><h3 id="奇数变偶数">奇数变偶数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &amp; -2</span><br></pre></td></tr></table></figure><p>如果 a 是偶数则不变，如果 a 是奇数则变为小 1 的偶数。</p><h2 id="位运算的一些题">位运算的一些题</h2><h3 id="题一">题一</h3><p><strong>题目描述</strong>：一个数组中有一种数出现了奇数次，其他数出现了偶数次，请你求出这个数。</p><p><strong>思路</strong>：把所有的数异或一遍即可。</p><p><strong>参考代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printOddTimesNum</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a : arr) &#123;</span><br><span class="line">        res ^= a;</span><br><span class="line">    &#125;</span><br><span class="line">   std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题二">题二</h3><blockquote><p>本题是题一的进阶题。</p></blockquote><p><strong>题目描述</strong>：一个数组中有两种数出现了奇数次，其他数出现了偶数次，请你求出这两个数</p><p><strong>思路</strong>：先假设所有这两个数为 a 和b，将所有的数异或一遍得到 a ^ b，然后使用 <code>lowbit</code> 函数求出 a或 b的最低位，然后以这个最低位的数据为依据，将数据划分为两部分，将其中一部分全部异或一遍即可的到a 或 b，然后就可以求出另外一个了。</p><p><strong>参考代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printOddTimesNum</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> eor &#123;&#125;;</span><br><span class="line">    <span class="type">int</span> rightOne &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : arr) &#123;</span><br><span class="line">        eor ^= a;</span><br><span class="line">    &#125;</span><br><span class="line">    rightOne = eor &amp; (~eor + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((c &amp; rightOne) == <span class="number">0</span>) &#123;</span><br><span class="line">            a ^= c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    b = a ^ eor;</span><br><span class="line">    std::cout &lt;&lt; std::format(<span class="string">&quot;&#123;&#125; &#123;&#125;\n&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><ul><li><ahref="https://graphics.stanford.edu/~seander/bithacks.html">Stanford |Bit Twiddling Hacks</a></li><li><ahref="https://blog.hufeifei.cn/2017/07/DataStructure/bit-hacks/index.html">【译】位运算的奇技淫巧：BitTwiddling Hacks</a></li></ul>]]></content>
    
    
    <summary type="html">介绍位运算及其应用</summary>
    
    
    
    <category term="算法" scheme="https://xinransix.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="位运算" scheme="https://xinransix.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://xinransix.github.io/2023/07/16/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://xinransix.github.io/2023/07/16/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-07-16T02:45:21.000Z</published>
    <updated>2023-07-17T12:21:46.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序算法概述">排序算法概述</h2><p>对排序严格点得到定义是：假设含有 <spanclass="math inline">\(n\)</span> 个记录的序列为 <spanclass="math inline">\(\left\{r_1, r_2, \cdots,r_n\right\}\)</span>，其相对应的关键字分别为：<spanclass="math inline">\(\left\{k_1, k_2, \cdots,k_n\right\}\)</span>，需确定 <spanclass="math inline">\(1,2,3,\cdots,n\)</span> 的一种排列 <spanclass="math inline">\(p_1,p_2,\cdots,p_n\)</span>，使其相应的关键字满足<span class="math inline">\(k_{p_1} \leqslant k_{p_2} \leqslant \cdots\leqslant k_{p_n}\)</span>非递减（或非递增）关系，即使得序列成为一个按关键字有序的序列：<spanclass="math inline">\(\left\{r_{p_1},r_{p_2},\cdots,r_{p_n}\right\}\)</span>，这样的操作就成为排序。</p><p>排序算法的稳定性：对于一个排序算法，假设 <spanclass="math inline">\(k_i=k_j \left(1\leqslant i \leqslant n, 1\leqslantj\leqslant n,i \neq j\right)\)</span>，且在排序前的序列中 <spanclass="math inline">\(r_i\)</span> 领先于 <spanclass="math inline">\(r_j\)</span>（即 <span class="math inline">\(i \ltj\)</span>）。如果排序后 <span class="math inline">\(r_i\)</span>仍领先于 <spanclass="math inline">\(r_j\)</span>，则称所用的排序算法是稳定的，否则是不稳定的</p><p>排序可分为<strong>内排序</strong>与<strong>外排序</strong>，内排序在排序过程中数据全部放置在内存中，外排序由于数据太对，不能将数据一次性加载在内存中，在排序过程中需要多次在内外存直接交换数据。</p><p>十种常见排序算法可以分为两大类：</p><ul><li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破<span class="math inline">\(\Omicron \left(n \logn\right)\)</span>，因此也称为非线性时间比较类排序。</li><li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</li></ul><p>对于排序算法的评价也是从时间和空间的角度出发，即排序的时间和所用的额外空间。排序算法的时间开销主要由比较和移动产生。额外空间的产生是因为有些算法需要借助辅助空间才能完成。</p><p>本文会介绍冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、桶排序、计数排序和基数排序，其中冒泡排序、选择排序和插入排序是简单的排序算法，希尔排序、归并排序、堆排序、快速快速排序是改进算法。</p><p>排序算法性能总结表：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/71546103-e328-4cbb-ae49-126208452285"alt="排序算法性能" /><figcaption aria-hidden="true">排序算法性能</figcaption></figure><h2 id="冒泡排序">冒泡排序</h2><p>冒泡排序是一种简单的排序算法。它重复地遍历要排序的数组，一次比较两个元素，如果它们逆序就把它们交换过来。遍历数组的工作是重复地进行直到没有再需要交换的相邻元素，也就是说该数组已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢「浮」到数组的后面。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/eb2cea36-58d0-4622-9856-b1bcce77093c"alt="v2-33a947c71ad62b254cab62e5364d2813_b" /><figcaptionaria-hidden="true">v2-33a947c71ad62b254cab62e5364d2813_b</figcaption></figure><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上如果在某一轮中没有进行交换操作，则说明数组已经有序，所以此时可结束排序，可利用这一点进行代码优化，优化后的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度分析：对于改进后的算法，最好的情况是数组本来就是有序的，只是进行了<span class="math inline">\(n - 1\)</span> 次的比较，所以时间复杂度为<span class="math inline">\(\Omicron\left(n\right)\)</span>；最坏的情况就是数组是逆序的时候，此时比较次数为：<span class="math display">\[\sum_{i=2}^{n}\left(i - 1\right) = \frac{n \left(n - 1\right)}{2}\]</span> 比较次数也是相同数量级的，所以时间复杂度为 <spanclass="math inline">\(\Omicron \left(n^2\right)\)</span>.</p><p>在相邻元素相等时，不交换它们的位置可保证算法是稳定的算法。</p><h2 id="选择排序">选择排序</h2><p>选择排序是一种简单直观的排序算法，它也是一种交换排序算法，和冒泡排序有一定的相似度，可以认为选择排序是冒泡排序的一种改进。</p><p>选择排序进行进行 <span class="math inline">\(n - 1\)</span>次遍历，每次遍历从 <span class="math inline">\(\left[i + 1,n\right]\)</span> 这个区间中选出最小值与第 <spanclass="math inline">\(i\)</span> 个元素交换（当然如果第 <spanclass="math inline">\(i\)</span> 个元素是最小的则无需交换）。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/adea5408-a1cb-425b-bc51-9bc2e6970ab8"alt="v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b" /><figcaptionaria-hidden="true">v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b</figcaption></figure><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void selection_sort(int *arr, int n) &#123;</span><br><span class="line">    if (arr == nullptr)</span><br><span class="line">        return;</span><br><span class="line">    if (n &lt;= 1)</span><br><span class="line">        return;</span><br><span class="line">    for (int i = 0; i &lt; n - 1; ++i) &#123;</span><br><span class="line">        int idx = i;</span><br><span class="line">        for (int j = i + 1; j &lt; n; ++j) &#123;</span><br><span class="line">            if (arr[j] &lt; arr[idx]) &#123;</span><br><span class="line">                idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (idx != i) &#123;</span><br><span class="line">            int t = arr[idx];</span><br><span class="line">            arr[idx] = arr[i];</span><br><span class="line">            arr[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度分析：无论什么情况，比较次数是一样多的，第 <spanclass="math inline">\(i\)</span> 趟排序的需要比较 <spanclass="math inline">\(n - i\)</span> 次，比较次数为： <spanclass="math display">\[\sum_{i=1}^{n-1}\left(n - i\right) = \frac{n \left(n - 1\right)}{2}\]</span> 最好情况下交换次数为 <spanclass="math inline">\(0\)</span>，最坏情况下交换次数为 <spanclass="math inline">\(n - 1\)</span>，所以时间复杂度为 <spanclass="math inline">\(\Omicron \left(n^2\right)\)</span>.选择排序的略优于冒泡排序。</p><h2 id="插入排序">插入排序</h2><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/4dd2245a-49a1-40cc-9165-45056a7e931a"alt="insertionSort" /><figcaption aria-hidden="true">insertionSort</figcaption></figure><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = arr[i];</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; tmp &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">            arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：最好情况下做了 <span class="math inline">\(n - 1\)</span>次比较，没有移动操作，时间复杂度为 <span class="math inline">\(\Omicron\left(n^2\right)\)</span>. 最坏的情况下，即数组是逆序的，比较次数为：<span class="math display">\[\sum_{i=2}^{n}i = \frac{\left(n + 2\right)\left(n - 1\right)}{2}\]</span> 移动次数也达到最大值： <span class="math display">\[\sum_{i=2}^{n}\left(i + 1\right) = \frac{\left(n + 4\right)\left(n -1\right)}{2}\]</span> 平均比较和移动次数约为 <spanclass="math inline">\(\frac{n^2}{4}\)</span>. 所以，插入排序的复杂度为<span class="math inline">\(\Omicron \left(n^2\right)\)</span>.</p><p>插入排序优于冒泡排序和选择排序。</p><h2 id="希尔排序">希尔排序</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录「基本有序」时，再对全体记录进行依次直接插入排序。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/ca6c68c6-e779-4c84-928a-b92afed05af9"alt="687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31393430" /><figcaptionaria-hidden="true">687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31393430</figcaption></figure><p>选择一个增量序列 <span class="math inline">\(t_1,t_2，\cdots,t_k\)</span>，其中对于 <span class="math inline">\(i \gtj\)</span>，有 <span class="math inline">\(t_i \gt t_j\)</span>，且<span class="math inline">\(t_k = 1\)</span>。按增量序列个数 <spanclass="math inline">\(k\)</span>，对序列进行 <spanclass="math inline">\(k\)</span> 趟排序；每趟排序，根据对应的增量 <spanclass="math inline">\(t_i\)</span>，将待排序列分割成若干长度为 <spanclass="math inline">\(m\)</span>的子序列，分别对各子表进行直接插入排序。仅增量因子为 1时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shell_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; n / <span class="number">3</span>) &#123;</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= h &amp;&amp; arr[j] &lt; arr[j - h]; j -= h) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j - h];</span><br><span class="line">                arr[j - h] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：对增量的选取很重要，这里增量通过<code>h = 3 * h + 1</code>的方式得到，但迄今为止没有找到一个非常好的增量选取方式。不过大量研究表明，当增量序列为<span class="math inline">\(\text{delta[k]} = 2^{t-k+1}-1\left(0\leqslant k \leqslant \lfloor\log_2{(n+1)}\rfloor\right)\)</span>时，可以获得不错的效果，时间复杂度为 <spanclass="math inline">\(\Omicron\left(n^{\frac{3}{2}}\right)\)</span>，要好于直接插入排序的 <spanclass="math inline">\(\Omicron\left(n^2\right)\)</span>。需要注意的是，增量排序的最好一个增量值必须等于1 才行。由于数据是跳跃式的移动，希尔排序不是稳定的排序算法。</p><blockquote><p>希尔排序是第一个突破 <span class="math inline">\(\Omicron\left(n^2\right)\)</span> 的排序算法。</p></blockquote><h2 id="归并排序">归并排序</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2种方法）；</li><li>自下而上的迭代。</li></ul><p><strong>算法步骤：</strong></p><ol type="1"><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤 3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/463ae480-61e2-42c7-a2dc-5676015516ab"alt="mergeSort" /><figcaption aria-hidden="true">mergeSort</figcaption></figure><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">meger_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> tmp[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">meger_sort</span>(arr, tmp, l, mid);</span><br><span class="line">    <span class="built_in">meger_sort</span>(arr, tmp, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="type">int</span> i = l;</span><br><span class="line">    <span class="type">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">            tmp[k++] = arr[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        tmp[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) &#123;</span><br><span class="line">        tmp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; ++i, ++j) &#123;</span><br><span class="line">        arr[i] = tmp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，我这里给出的代码的区间的边界值都是可以取到的</p></blockquote><p>复杂度分析：递归树的每层的时间为 <span class="math inline">\(\Omicron\left(n\right)\)</span>，树的高度为 <spanclass="math inline">\(\lceil\log_2{(n)}\rceil\)</span>，所以时间复杂度为<span class="math inline">\(\Omicron \left(n \log n \right)\)</span>.这是归并排序最好、最坏和平均时间复杂度。由于归并排序需要递归和借助一个数组，所以空间复杂度为<span class="math inline">\(\Omicron \left(n + \logn\right)\)</span>。可以看出，归并排序是一个稳定的排序算法，是一个比较占用空间但效率较高的算法。</p><p>当然有非递归的归并排序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *a = arr;</span><br><span class="line">    <span class="type">int</span> *b = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i += i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j += i + i) &#123;</span><br><span class="line">            <span class="type">int</span> mid = <span class="built_in">min</span>(i + j, n) - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> k = j;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> l1 = j, r1 = mid;</span><br><span class="line">            <span class="type">int</span> l2 = mid + <span class="number">1</span>, r2 = <span class="built_in">min</span>(j + i + i, n) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (l1 &lt;= r1 &amp;&amp; l2 &lt;= r2) &#123;</span><br><span class="line">                b[k++] = a[l1] &lt; a[l2] ? a[l1++] : a[l2++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l1 &lt;= r1) &#123;</span><br><span class="line">                b[k++] = a[l1++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l2 &lt;= r2) &#123;</span><br><span class="line">                b[k++] = a[l2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> *temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归的归并排序的空间复杂度为 <span class="math inline">\(\Omicron\left(n \right)\)</span>.</p><h2 id="快速排序">快速排序</h2><p>快速排序是由东尼 · 霍尔所发展的一种排序算法。在平均状况下，排序 <spanclass="math inline">\(n\)</span> 个项目要 <spanclass="math inline">\(\Omicron \left(n \log n \right)\)</span>次比较。在最坏状况下则需要 <span class="math inline">\(\Omicron\left(n^2 \right)\)</span>次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 <spanclass="math inline">\(\Omicron \left(n \log n \right)\)</span>算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。</p><p>快速排序的基本思想是：通过一趟排序将待排序记录分隔成独立的两部分，其中一部分记录的关键字均比另外一部分记录关键字小，则可对这两部分记录继续进行排序，以达到整个序列有序的目的。</p><p>快速排序使用分治法策略来把一个串行分为两个子串行。</p><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p><p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然Worst Case 的时间复杂度达到了 <span class="math inline">\(\Omicron\left(n^2\right)\)</span>，但是人家就是优秀，在大多数情况下都比平均时间复杂度为<span class="math inline">\(\Omicron \left(n \log n \right)\)</span>的排序算法表现要更好，可是这是为什么呢，《算法艺术与信息学竞赛》上说：</p><blockquote><p>快速排序的最坏运行情况是 <span class="math inline">\(\Omicron\left(n^2 \right)\)</span>，比如说顺序数列的快排。但它的平摊期望时间是<span class="math inline">\(\Omicron \left(n \log n \right)\)</span>，且<span class="math inline">\(\Omicron \left(n \log n \right)\)</span>记号中隐含的常数因子很小，比复杂度稳定等于 <spanclass="math inline">\(\Omicron \left(n \log n \right)\)</span>的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p></blockquote><p><strong>算法步骤：</strong></p><ol type="1"><li>从数列中挑出一个元素，称为「基准」（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/824c46ec-f579-4e81-8921-b77e4ff1f611"alt="quickSort" /><figcaption aria-hidden="true">quickSort</figcaption></figure><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = arr[(l + r) / <span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[++i] &lt; x)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">while</span> (arr[--j] &gt; x)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，我这里给出的代码的区间的边界值都是可以取到的。</p></blockquote><p>复杂度分析：在最好的情况下，基准值每次划分的很均匀，如果排序 <spanclass="math inline">\(n\)</span> 个关键字，其递归树的深度为 <spanclass="math inline">\(\lfloor\log_2{n} + 1\rfloor\)</span>，需递归 <spanclass="math inline">\(\log_2\)</span> 次，需要的时间为 <spanclass="math inline">\(T\left(n\right)\)</span>的话，第一个划分时需要将整个数组扫描一遍，做 <spanclass="math inline">\(n\)</span>次比较，基准值将数组一分为二，那么各种还需要 <spanclass="math inline">\(T\left(\frac{n}{2}\right)\)</span>的时间。于是乎我们可以得到如下公式： <span class="math display">\[\begin{aligned}T\left(n\right) &amp;\leqslantT\left(\frac{n}{2}\right),T\left(1\right)=0\\T\left(n\right) &amp;\leqslant 2\left(2T\left(\frac{n}{4}\right) +\frac{n}{2}\right) = 4T\left(\frac{n}{4}\right) + 2n\\T\left(n\right) &amp;\leqslant 4\left(2T\left(\frac{n}{8}\right) +\frac{n}{4}\right) = 8T\left(\frac{n}{8}\right) + 3n \\\cdots \\T\left(n\right) &amp;\leqslant nT\left(1\right) + \left(\log_2 n\right)\times n = \Omicron \left(n \log n \right)\end{aligned}\]</span></p><p>也就是说，在最优的情况下，快速排序算法的时间复杂度是 <spanclass="math inline">\(\Omicron \left(n \log n \right)\)</span>.</p><p>在最坏的情况下，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，另外一个为空。把递归树画出来，他就是一颗斜树。此时需要执行<span class="math inline">\(n - 1\)</span> 次递归调用，且第 <spanclass="math inline">\(i\)</span> 次划分需要经过 <spanclass="math inline">\(n - i\)</span> 次关键字的比较才能找到第 <spanclass="math inline">\(i\)</span> 个记录，因此比较次数为： <spanclass="math display">\[\sum_{i=1}^{n - 1}\left(n - i\right) = n  -1 + n - 2 + \cdots + 1 =\frac{n(n - 1)}{2}\]</span> 其最终时间复杂度为 <span class="math inline">\(\Omicron \left(n^2 \right)\)</span>.</p><p>平均情况下，时间复杂度也为 <span class="math inline">\(\Omicron\left(n \log n \right)\)</span>.</p><p>基准值的选取对快速排序的效率较大，我们可以使用随机化算法，每次随机选取一个基准值，以达到更平均的效果。同时，我们也要注意避免不必要的比较。</p><p>在数据量较小的时候，我们可考虑使用直接插入排序。</p><h2 id="堆排序">堆排序</h2><p>如果有一个关键码的集合 <span class="math inline">\(K =\left\{k_0,k_1,k_2,\cdots,k_{n-1}\right\}\)</span>，把它的所有元素按完全二叉树的顺序存储在一个一维数组中，并满足：$k_ik_{2i+1} $ 且 <span class="math inline">\(k_i \leqslant K_{2i =2}\)</span>，则称为小根堆（还有大根堆）。</p><blockquote><p>下面只讨论小根堆。</p></blockquote><p>堆有如下性质：</p><ol type="1"><li>堆中某个节点不大于其父节点的值。</li><li>堆总是一颗完全二叉树（这也是我们能将其放入一个一维数组中的前提）。</li><li>堆以层序遍历的顺序存在数组中，有些文章不使用数组的第 <spanclass="math inline">\(0\)</span>个元素，而从数组的第一个元素开始存，我这里从第 0 个元素开始存。</li><li>对于第 <span class="math inline">\(i\)</span>个元素，其父节点的索引为 <span class="math inline">\(\lfloor \frac{i -1}{2}\rfloor\)</span>，左孩子的索引为 <span class="math inline">\(2i +1\)</span>，右孩子的索引为 <span class="math inline">\(2i+2\)</span>.</li></ol><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/d66bf8bd-2fca-4674-a442-af22c3130f9a"alt="20210125144956737" /><figcaption aria-hidden="true">20210125144956737</figcaption></figure><p>堆的两个重要操作是向上调整算法和向下调整算法。</p><p>向下调整算法：</p><ol type="1"><li>先设定根节点为当前节点（通过下标获取，标记为cur），比较左右子树的值，找出更小的值，用child 来标记。</li><li>比较 child 和 cur 的值，如果 child 比 cur小，则不满足小堆的规则，需要进行交换。</li><li>如果 child 比 cur 大，满足小堆的规则，不需要交换，调整结束。</li><li>处理完一个节点之后，从当前的 child 出发，循环之前的过程。</li></ol><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/dd378c36-fb6b-4602-8c08-00145dfbe44e"alt="20210125150116725" /><figcaption aria-hidden="true">20210125150116725</figcaption></figure><p>向下调整的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n, <span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树</span></span><br><span class="line">    <span class="type">int</span> child = <span class="number">2</span> * cur + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (child &lt; n) &#123;</span><br><span class="line">        <span class="comment">// 比较左右子树，找到较小值</span></span><br><span class="line">        <span class="keyword">if</span> (child + <span class="number">1</span> &lt; n &amp;&amp; arr[child + <span class="number">1</span>] &lt; arr[child]) &#123;</span><br><span class="line">            ++child;</span><br><span class="line">            <span class="comment">// child时刻保存较小值的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[child] &lt; arr[cur]) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> tmp = arr[child];</span><br><span class="line">            arr[child] = arr[cur];</span><br><span class="line">            arr[cur] = tmp;</span><br><span class="line"></span><br><span class="line">            cur = child;</span><br><span class="line">            child = <span class="number">2</span> * cur + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向上调整算法：</p><ol type="1"><li>先设定倒数的第一个叶子节点为当前节点（通过下标获取，标记为cur），找出他的父亲节点，用parent 来标记。</li><li>比较 parent 和 cur 的值，如果 cur 比 parent小，则不满足小堆的规则，需要进行交换。</li><li>如果 cur 比 parent 大，满足小堆的规则，不需要交换，调整结束。</li><li>处理完一个节点之后，从当前的 parent 出发，循环之前的过程。</li></ol><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/485f1d1a-6bba-4170-abac-846f711221f7"alt="20210125151546127" /><figcaption aria-hidden="true">20210125151546127</figcaption></figure><p>向上调整的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n, <span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> parent = (cur - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] &lt; arr[parent]) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> tmp = arr[cur];</span><br><span class="line">            arr[cur] = arr[parent];</span><br><span class="line">            arr[parent] = tmp;</span><br><span class="line"></span><br><span class="line">            cur = parent;</span><br><span class="line">            parent = (cur - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>堆的插入是将数据插入到数组最后，做一次 <code>up()</code>操作；删除堆的数据是删除堆顶的数据，先将堆顶元素与最后一个元素交换，将数组最后一个元素删除，然后堆堆顶元素做一次<code>down()</code> 操作。</p><p>堆排序就是将将数据存储到堆里，然后将一一拿出堆顶的元素，就可以完成排序。</p><p>完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">                                      <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n, <span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树</span></span><br><span class="line">    <span class="type">int</span> child = <span class="number">2</span> * cur + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (child &lt; n) &#123;</span><br><span class="line">        <span class="comment">// 比较左右子树，找到较小值</span></span><br><span class="line">        <span class="keyword">if</span> (child + <span class="number">1</span> &lt; n &amp;&amp; arr[child + <span class="number">1</span>] &lt; arr[child]) &#123;</span><br><span class="line">            ++child;</span><br><span class="line">            <span class="comment">// child时刻保存较小值的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[child] &lt; arr[cur]) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> tmp = arr[child];</span><br><span class="line">            arr[child] = arr[cur];</span><br><span class="line">            arr[cur] = tmp;</span><br><span class="line"></span><br><span class="line">            cur = child;</span><br><span class="line">            child = <span class="number">2</span> * cur + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n, <span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> parent = (cur - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] &lt; arr[parent]) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> tmp = arr[cur];</span><br><span class="line">            arr[cur] = arr[parent];</span><br><span class="line">            arr[parent] = tmp;</span><br><span class="line"></span><br><span class="line">            cur = parent;</span><br><span class="line">            parent = (cur - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">down</span>(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> end = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (end &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> tmp = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[end];</span><br><span class="line">        arr[end] = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">down</span>(arr, end, <span class="number">0</span>);</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>,</span><br><span class="line">                 <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = (<span class="type">int</span>)<span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    <span class="built_in">heapify</span>(arr, len);</span><br><span class="line">    <span class="built_in">heap_sort</span>(arr, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这里使用的是小根堆进行原地排序，所以排序结果是逆序的，如果想要正序的结果，请使用辅助空间、大根堆或者排序之后进行逆序。</p><p>显然，堆排序的时间复杂度为 <span class="math inline">\(\Omicron\left(n \log n \right)\)</span>.</p><h2 id="参考">参考</h2><ul><li><a href="https://en.wikipedia.org/wiki/Sorting_algorithm">Wikipedia| Sorting algorithm</a></li><li><ahref="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">维基百科| 排序算法</a></li><li><a href="https://zhuanlan.zhihu.com/p/42586566">[算法总结]十大排序算法 | vivia</a></li><li><ahref="https://www.cnblogs.com/onepixel/articles/7674659.html">十大经典排序算法（动图演示）|一像素 | 博客园</a></li><li><ahref="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">十大经典排序算法| 菜鸟教程</a></li><li><ahref="https://github.com/MisterBooo/Article">十大经典排序算法动画与解析，看我就够了！（配代码完全版）| Github | MisterBooo</a></li><li><ahref="http://www.x-lab.info/post/sort-algorithm/">十大经典排序算法整理汇总| X-lab</a></li><li><ahref="https://lumingdong.cn/detailed-explanation-of-ten-classic-sorting-algorithms.html">十大经典排序算法详解| 卢明冬 | 卢明冬的博客</a></li><li><ahref="https://blog.csdn.net/SoftpaseFar/article/details/103129395">C++实现计数排序| 赵延超 | CSDN</a></li><li>算法导论</li><li>大话数据结构</li></ul>]]></content>
    
    
    <summary type="html">介绍了 7 种排序算法，不包括基数排序等这类骚操作</summary>
    
    
    
    <category term="算法" scheme="https://xinransix.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="https://xinransix.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Template</title>
    <link href="https://xinransix.github.io/2023/07/16/Template/"/>
    <id>https://xinransix.github.io/2023/07/16/Template/</id>
    <published>2023-07-16T02:43:52.000Z</published>
    <updated>2024-02-10T08:26:51.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模板概述">模板概述</h2><p>类型以参数的形式指定，这样的函数或类称为函数模板或类模板。</p><p>模板的特点：</p><ul><li>模板不可以直接使用，它只是一个框架</li><li>模板的通用并不是万能的</li></ul><h2 id="函数模板">函数模板</h2><h3 id="函数模板语法">函数模板语法</h3><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure><p>解释：</p><p><code>template</code>：声明创建模板</p><p><code>typename</code>：表面其后面的符号是一种数据类型，可以用<code>class</code> 代替</p><p><code>T</code>：通用的数据类型，名称可以替换，通常为大写字母。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mySwap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mySwap</span>&lt;<span class="type">int</span>&gt;(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>使用函数模板有两种方式：自动类型推导、显示指定类类型。</li></ul></blockquote><h3 id="普通函数与函数模板的区别">普通函数与函数模板的区别</h3><ul><li>普通函数调用时可以发生自动类型转换</li><li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li><li>如果利用显示指定类型的方式，可以发生隐式类型转换</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myAdd01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">myAdd01</span>(a, c)</span><br><span class="line">         &lt;&lt; endl; <span class="comment">// 正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">myAdd02</span>&lt;<span class="type">int</span>&gt;(a, c); <span class="comment">// 正确，如果用显示指定类型，可以发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="普通函数与函数模板的调用规则">普通函数与函数模板的调用规则</h3><p>调用规则如下：</p><ol type="1"><li>如果函数模板和普通函数都可以实现，优先调用普通函数</li><li>可以通过空模板参数列表来强制调用函数模板</li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配，优先调用函数模板</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用重载的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">myPrint</span>(a, b);</span><br><span class="line"></span><br><span class="line">    myPrint&lt;&gt;(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">myPrint</span>(a, b, c);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    <span class="built_in">myPrint</span>(c1, c2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/47ba3b3a-f042-419a-b52e-d78264729b1d"alt="输出结果" /><figcaption aria-hidden="true">输出结果</figcaption></figure><blockquote><p>既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p></blockquote><h3 id="模板具体化">模板具体化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line">    string mName;</span><br><span class="line">    <span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三代具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span></span><br><span class="line"><span class="comment">// 具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">mySwap</span>&lt;Person&gt;(Person &amp;p1, Person &amp;p2) &#123;</span><br><span class="line">    string nameTemp;</span><br><span class="line">    <span class="type">int</span> ageTemp;</span><br><span class="line">    nameTemp = p1.mName;</span><br><span class="line">    p1.mName = p2.mName;</span><br><span class="line">    p2.mName = nameTemp;</span><br><span class="line"></span><br><span class="line">    ageTemp = p1.mAge;</span><br><span class="line">    p1.mAge = p2.mAge;</span><br><span class="line">    p2.mAge = ageTemp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">P1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">P2</span><span class="params">(<span class="string">&quot;Jerry&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P1 Name = &quot;</span> &lt;&lt; P1.mName &lt;&lt; <span class="string">&quot; P1 Age = &quot;</span> &lt;&lt; P1.mAge &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P2 Name = &quot;</span> &lt;&lt; P2.mName &lt;&lt; <span class="string">&quot; P2 Age = &quot;</span> &lt;&lt; P2.mAge &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">mySwap</span>(P1, P2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P1 Name = &quot;</span> &lt;&lt; P1.mName &lt;&lt; <span class="string">&quot; P1 Age = &quot;</span> &lt;&lt; P1.mAge &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P2 Name = &quot;</span> &lt;&lt; P2.mName &lt;&lt; <span class="string">&quot; P2 Age = &quot;</span> &lt;&lt; P2.mAge &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/5db85779-39da-4375-b6a0-5df97b9cb032"alt="输出结果" /><figcaption aria-hidden="true">输出结果</figcaption></figure><h2 id="类模板">类模板</h2><h3 id="类模板语法">类模板语法</h3><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure><p>解释：</p><p><code>template</code>：声明创建模板</p><p><code>typename</code>：表明其后面的符号是一种数据类型，可以用<code>class</code> 代替</p><p><code>T</code>：通用的数据类型，名称可以替换，通常为大写字母。</p><h3 id="类模板与函数模板区别">类模板与函数模板区别</h3><p>类模板与函数模板区别主要有两点：</p><ol type="1"><li>类模板没有自动类型推导的使用方式</li><li>类模板在模板参数列表中可以有默认参数</li></ol><h3 id="类模板中成员函数创建时机">类模板中成员函数创建时机</h3><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p><ul><li>普通类中的成员函数一开始就可以创建</li><li>类模板中的成员函数在调用时才创建</li></ul><h3 id="类模板对象做函数参数">类模板对象做函数参数</h3><p>一共有三种传入方式：</p><ol type="1"><li>指定传入的类型：直接显示对象的数据类型</li><li>参数模板化：将对象中的参数变为模板进行传递</li><li>整个类模板化：将这个对象类型 模板化进行传递</li></ol><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(NameType name, AgeType age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NameType mName;</span><br><span class="line">    AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、指定传入的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="type">int</span>&gt; &amp;p)</span> </span>&#123; p.<span class="built_in">showPerson</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、参数模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T &amp;p)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/f5a28448-c050-4ebc-95da-e91de12db7d2"alt="输出结果" /><figcaption aria-hidden="true">输出结果</figcaption></figure><h3 id="类模板与继承">类模板与继承</h3><p>当类模板碰到继承时，需要注意一下几点：</p><ul><li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中 T的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定出父类中 T 的类型，子类也需变为类模板。</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123; Son c; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">public</span> Base&lt;T2&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son2</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123; Son2&lt;<span class="type">int</span>, <span class="type">char</span>&gt; child1; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板成员函数类外实现">类模板成员函数类外实现</h3><blockquote><p>类模板中成员函数类外实现时，需要加上模板参数列表。</p></blockquote><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/520be2b7-fcd8-4fb8-9f36-0a6bd19607d3"alt="输出结果" /><figcaption aria-hidden="true">输出结果</figcaption></figure><h3 id="类模板分文件编写">类模板分文件编写</h3><p>问题：</p><ul><li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li></ul><p>解决：</p><ul><li>解决方式 1：直接包含 <code>.cpp</code> 源文件</li><li>解决方式 2：将声明和实现写到同一个文件中，并更改后缀名为<code>.hpp</code>，<code>hpp</code> 是约定的名称，并不是强制。</li></ul><h3 id="类模板与友元">类模板与友元</h3><p>全局函数类内实现：直接在类内声明友元即可</p><p>全局函数类外实现：需要提前让编译器知道全局函数的存在</p><blockquote><p>建议全局函数做类内实现，用法简单，而且编译器可以直接识别。</p></blockquote><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;类外实现 ---- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp;p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printPerson</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、全局函数在类外实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Jerry&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">C++ 中的模板</summary>
    
    
    
    <category term="C++ 基础" scheme="https://xinransix.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C++" scheme="https://xinransix.github.io/tags/C/"/>
    
    <category term="Template" scheme="https://xinransix.github.io/tags/Template/"/>
    
  </entry>
  
  <entry>
    <title>STL</title>
    <link href="https://xinransix.github.io/2023/07/16/STL/"/>
    <id>https://xinransix.github.io/2023/07/16/STL/</id>
    <published>2023-07-16T02:43:16.000Z</published>
    <updated>2024-02-10T08:36:21.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="stl-概述">STL 概述</h2><ul><li>STL（Standard Template Library，<strong>标准模板库</strong>）</li><li>STL 从广义上分为：<strong>容器、算法、迭代器</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul><p>STL 六大组件：</p><table><colgroup><col style="width: 10%" /><col style="width: 27%" /><col style="width: 62%" /></colgroup><thead><tr class="header"><th style="text-align: center;">名字</th><th style="text-align: center;">别名</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">容器</td><td style="text-align: center;">containers</td><td style="text-align: center;">各种数据结构，如<code>vector</code>、<code>list</code>、<code>deque</code>、<code>set</code>、<code>map</code>等数据结构</td></tr><tr class="even"><td style="text-align: center;">算法</td><td style="text-align: center;">演算法、algorithms</td><tdstyle="text-align: center;">各种常用算法，如：<code>sort</code>、<code>search</code>、<code>cpoy</code>、<code>erase</code>等。</td></tr><tr class="odd"><td style="text-align: center;">迭代器</td><td style="text-align: center;">iterators</td><td style="text-align: center;">扮演了容器与算法之间的胶合剂</td></tr><tr class="even"><td style="text-align: center;">仿函数</td><td style="text-align: center;">仿函式、函数对象、functors</td><td style="text-align: center;">行为类似函数，可作为算法的某种策略</td></tr><tr class="odd"><td style="text-align: center;">适配器</td><td style="text-align: center;">配接器、adapters</td><tdstyle="text-align: center;">一种用来修饰容器或者仿函数或迭代器接口的东西</td></tr><tr class="even"><td style="text-align: center;">空间配置器</td><td style="text-align: center;">配置器、allocators</td><td style="text-align: center;">负责空间的配置与管理</td></tr></tbody></table><h3 id="stl-中容器算法迭代器">STL 中容器、算法、迭代器</h3><blockquote><p><strong>容器</strong>：置物之所也。</p></blockquote><p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来。</p><p>常用的数据结构：<code>array</code>、<code>list</code>、<code>tree</code>、<code>stack</code>、<code>queue</code>、<code>set</code>、<code>map</code>等。</p><p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种：</p><p><strong>序列式容器</strong>：强调值的排序，序列式容器中的每个元素均有固定的位置。​<strong>关联式容器</strong>：二叉树结构，各元素之间没有严格的物理上的顺序关系。</p><blockquote><p><strong>算法</strong>：问题之解法也。</p></blockquote><p>算法分为：<strong>质变算法</strong>和<strong>非质变算法</strong>。</p><p>质变算法：是指运算过程中会更改区间内的元素的内容，如拷贝，替换，删除等等。</p><p>非质变算法：是指运算过程中不会更改区间内的元素内容，如查找、计数、遍历、寻找极值等等。</p><blockquote><p><strong>迭代器</strong>：容器和算法之间粘合剂。</p></blockquote><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>每个容器都有自己专属的迭代器。</p><p>迭代器在使用上非常像指针。</p><p>迭代器种分类：</p><table><colgroup><col style="width: 11%" /><col style="width: 44%" /><col style="width: 44%" /></colgroup><thead><tr class="header"><th style="text-align: center;">种类</th><th style="text-align: center;">功能</th><th style="text-align: center;">支持运算</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">输入迭代器</td><td style="text-align: center;">对数据的只读访问</td><td style="text-align: center;">只读，支持<code>++</code>、<code>==</code>、<code>!=</code></td></tr><tr class="even"><td style="text-align: center;">输出迭代器</td><td style="text-align: center;">对数据的只写访问</td><td style="text-align: center;">只写，支持 <code>++</code></td></tr><tr class="odd"><td style="text-align: center;">前向迭代器</td><td style="text-align: center;">读写操作，并能向前推进迭代器</td><td style="text-align: center;">读写，支持<code>++</code>、<code>==</code>、<code>!=</code></td></tr><tr class="even"><td style="text-align: center;">双向迭代器</td><td style="text-align: center;">读写操作，并能向前和向后操作</td><td style="text-align: center;">读写，支持<code>++</code>、<code>--</code></td></tr><tr class="odd"><td style="text-align: center;">随机访问迭代器</td><tdstyle="text-align: center;">读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td style="text-align: center;">读写，支持<code>++</code>、<code>--</code>、<code>[n]</code>、<code>-n</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code></td></tr></tbody></table><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器。</p><h2 id="常用容器">常用容器</h2><h3 id="string-容器"><code>string</code> 容器</h3><p><code>char *</code> 是 C++ 风格的字符串，而 <code>string</code>本质上是一个类。</p><p><strong><code>string</code> 和 <code>char *</code>的区别：</strong></p><ul><li><code>char *</code> 是一个指针</li><li><code>string</code> 是一个类，类内部封装了<code>char *</code>，管理这个字符串，是一个 <code>char *</code>的容器。</li></ul><p><strong>特点：</strong></p><ul><li><code>string</code> 类内部封装了很多成员方法，例如：查找<code>find</code>，拷贝 <code>copy</code>，删除 <code>delete</code> 替换<code>replace</code>，插入 <code>insert</code>.</li><li><code>string</code> 管理 <code>char *</code>所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责。</li></ul><p><code>string</code> 容器的内置函数。</p><p><strong>构造函数：</strong></p><table><colgroup><col style="width: 31%" /><col style="width: 53%" /><col style="width: 14%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数原型</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>string();</code></td><td style="text-align: center;">创建一个空的字符串</td><td style="text-align: center;"><code>string str;</code></td></tr><tr class="even"><td style="text-align: center;"><code>string(const char* s);</code></td><td style="text-align: center;">使用字符串 s 初始化</td><td style="text-align: center;"></td></tr><tr class="odd"><tdstyle="text-align: center;"><code>string(const string&amp; str);</code></td><td style="text-align: center;">使用一个 <code>string</code>对象初始化另一个 <code>string</code> 对象</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>string(int n, char c);</code></td><td style="text-align: center;">使用 n 个字符 c 初始化</td><td style="text-align: center;"></td></tr></tbody></table><p><code>string</code> 的多种构造方式没有可比性，灵活使用即可。</p><p><strong>string 赋值操作：</strong></p><table style="width:100%;"><colgroup><col style="width: 54%" /><col style="width: 41%" /><col style="width: 4%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数原型</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><code>string&amp; operator=(const char* s);</code></td><td style="text-align: center;"><code>char *</code>类型字符串赋值给当前字符串</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>string&amp; operator=(const string &amp;s);</code></td><td style="text-align: center;">把字符串 s 赋给当前字符串</td><td style="text-align: center;"></td></tr><tr class="odd"><tdstyle="text-align: center;"><code>string&amp; operator=(char c);</code></td><td style="text-align: center;">字符赋值给当前的字符串</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>string&amp; assign(const char *s);</code></td><td style="text-align: center;">把字符串 s 赋给当前的字符串</td><td style="text-align: center;"></td></tr><tr class="odd"><tdstyle="text-align: center;"><code>string&amp; assign(const char *s, int n);</code></td><td style="text-align: center;">把字符串 s 的前 n个字符赋给当前的字符串</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>string&amp; assign(const string &amp;s);</code></td><td style="text-align: center;">把字符串 s 赋给当前字符串</td><td style="text-align: center;"></td></tr><tr class="odd"><tdstyle="text-align: center;"><code>string&amp; assign(int n, char c);</code></td><td style="text-align: center;">用 n 个字符 c 赋给当前字符串</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>string&amp; assign(const string &amp;s, int start, int n);</code></td><td style="text-align: center;">将 s 从 start 开始 n个字符赋值给字符串</td><td style="text-align: center;"></td></tr></tbody></table><blockquote><p><code>string</code> 的赋值方式很多，<code>operator=</code>这种方式是比较实用的。</p></blockquote><p><strong>string 拼接操作：</strong></p><table><colgroup><col style="width: 48%" /><col style="width: 47%" /><col style="width: 3%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数原型</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><code>string&amp; operator+=(const char* str);</code></td><td style="text-align: center;">重载 <code>+=</code> 运算符</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>string&amp; operator+=(const char c);</code></td><td style="text-align: center;">重载 <code>+=</code> 运算符</td><td style="text-align: center;"></td></tr><tr class="odd"><tdstyle="text-align: center;"><code>string&amp; operator+=(const string&amp; str);</code></td><td style="text-align: center;">重载 <code>+=</code> 运算符</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>string&amp; append(const char *s);</code></td><td style="text-align: center;">把字符串 s 连接到当前字符串结尾</td><td style="text-align: center;"></td></tr><tr class="odd"><tdstyle="text-align: center;"><code>string&amp; append(const char *s, int n);</code></td><td style="text-align: center;">把字符串 s 的前 n个字符连接到当前字符串结尾</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>string&amp; append(const string &amp;s);</code></td><td style="text-align: center;">同<code>operator+=(const string&amp; str)</code></td><td style="text-align: center;"></td></tr><tr class="odd"><tdstyle="text-align: center;"><code>string&amp; append(const string &amp;s, int pos, int n);</code></td><td style="text-align: center;">字符串 s 中从 pos 开始的 n个字符连接到字符串结尾</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>string&amp; append(int n, char c);</code></td><td style="text-align: center;">在当前字符串结尾添加 n 个字符 c</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>string 存取字符操作：</strong></p><table><thead><tr class="header"><th style="text-align: center;">函数原型</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><code>char&amp; operator[](int n);</code></td><td style="text-align: center;">通过 <code>[]</code> 方式取字符</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>char&amp; at(int n);</code></td><td style="text-align: center;">通过 <code>at()</code> 函数获取字符</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>string 查找和替换：</strong></p><table><colgroup><col style="width: 54%" /><col style="width: 41%" /><col style="width: 4%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数原型</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><code>int find(const string&amp; str, int pos = 0) const;</code></td><td style="text-align: center;">查找 str 第一次出现位置，从 pos开始查找</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>int find(const char* s, int pos = 0) const;</code></td><td style="text-align: center;">查找 s 第一次出现位置,从 pos开始查找</td><td style="text-align: center;"></td></tr><tr class="odd"><tdstyle="text-align: center;"><code>int find(const char* s, int pos, int n) const;</code></td><td style="text-align: center;">从 pos 位置查找 s 的前 n个字符第一次位置</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>int find(const char c, int pos = 0) const;</code></td><td style="text-align: center;">查找字符 c 第一次出现位置</td><td style="text-align: center;"></td></tr><tr class="odd"><tdstyle="text-align: center;"><code>int rfind(const string&amp; str, int pos = npos) const;</code></td><td style="text-align: center;">查找 str 最后一次位置，从 pos开始查找</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>int rfind(const char* s, int pos = npos) const;</code></td><td style="text-align: center;">查找 s 最后一次出现位置，从 pos开始查找</td><td style="text-align: center;"></td></tr><tr class="odd"><tdstyle="text-align: center;"><code>int rfind(const char* s, int pos, int n) const;</code></td><td style="text-align: center;">从 pos 查找 s 的前 n个字符最后一次位置</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>int rfind(const char c, int pos = 0) const;</code></td><td style="text-align: center;">查找字符 c 最后一次出现位置</td><td style="text-align: center;"></td></tr><tr class="odd"><tdstyle="text-align: center;"><code>string&amp; replace(int pos, int n, const string&amp; str);</code></td><td style="text-align: center;">替换从 pos 开始 n 个字符为字符串str</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>string&amp; replace(int pos, int n, const char* s);</code></td><td style="text-align: center;">替换从 pos 开始的 n 个字符为字符串s</td><td style="text-align: center;"></td></tr></tbody></table><blockquote><ul><li><code>find</code> 查找是从左往后，<code>rfind</code> 从右往左</li><li><code>find</code> 找到字符串后返回查找的第一个字符位置，找不到返回-1</li><li><code>replace</code>在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li></ul></blockquote><p><strong>string 比较：</strong></p><table><thead><tr class="header"><th style="text-align: center;">函数原型</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><code>int compare(const string &amp;s) const;</code></td><td style="text-align: center;">与字符串 s 比较</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>int compare(const char *s) const;</code></td><td style="text-align: center;">与字符串 s 比较</td><td style="text-align: center;"></td></tr></tbody></table><blockquote><p>字符串比较是按字符的 ASCII 码进行对比：</p><ul><li>= 返回 0</li><li>&gt; 返回 1</li><li>&lt; 返回 -1</li></ul></blockquote><p><strong>string 插入和删除：</strong></p><table><colgroup><col style="width: 60%" /><col style="width: 34%" /><col style="width: 5%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数原型</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><code>string&amp; insert(int pos, const char* s);</code></td><td style="text-align: center;">插入字符串</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>string&amp; insert(int pos, const string&amp; str);</code></td><td style="text-align: center;">插入字符串</td><td style="text-align: center;"></td></tr><tr class="odd"><tdstyle="text-align: center;"><code>string&amp; insert(int pos, int n, char c);</code></td><td style="text-align: center;">在指定位置插入 n 个字符 c</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>string&amp; erase(int pos, int n = npos);</code></td><td style="text-align: center;">删除从 Pos 开始的 n 个字符</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>string 子串：</strong></p><table style="width:100%;"><colgroup><col style="width: 53%" /><col style="width: 41%" /><col style="width: 4%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数原型</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><code>string substr(int pos = 0, int n = npos) const;</code></td><td style="text-align: center;">返回从 pos 开始的 n个字符组成的字符串</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>string 和 c-style 字符串转换：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string 转 char*</span></span><br><span class="line">string str = <span class="string">&quot;lxr&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cstr = str.<span class="built_in">c_str</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//char* 转 string</span></span><br><span class="line"><span class="type">char</span>* s = <span class="string">&quot;itcast&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(s)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>在 c++中存在 <code>const char *</code> 到 <code>string</code>的隐式类型转换，不存在从 <code>string</code> 对象到<code>c-string</code> 的自动类型转换。对于 <code>string</code>类型的字符串，可以通过 <code>c_str()</code> 成员函数，返回<code>string</code> 对象对应的 <code>c-string</code>.</p><p>为了修改 <code>string</code> 字符串的内容，可以使用下标操作符 [] 或at，它们都会返回字符的引用，但当字符串的内存被重新分配之后，可能发生错误。</p></blockquote><h3 id="vector-容器"><code>vector</code> 容器</h3><p>vector 数据结构和<strong>数组非常相似</strong>。</p><p><strong>vector与普通数组区别：</strong>不同之处在于数组是静态空间，而<code>vector</code> 可以<strong>动态扩容</strong>。</p><p><strong>动态扩展：</strong>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间。</p><p><code>vector</code> 容器的迭代器是支持随机访问的迭代器。</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/8a08605d-92ee-417a-915f-b16622df34f4"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p><strong>vector 构造函数：</strong></p><table><colgroup><col style="width: 37%" /><col style="width: 57%" /><col style="width: 5%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>vector&lt;T&gt; v;</code></td><td style="text-align: center;">采用模板实现类实现，默认构造函数</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>vector(v.begin(), v.end());</code></td><td style="text-align: center;">将 <code>v[begin(), end())</code>区间中的元素拷贝给本身</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>vector(n, elem);</code></td><td style="text-align: center;">构造函数将 n 个 elem 拷贝给本身</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>vector(const vector &amp;vec);</code></td><td style="text-align: center;">拷贝构造函数</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>vector 赋值操作：</strong></p><table><colgroup><col style="width: 45%" /><col style="width: 49%" /><col style="width: 4%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><code>vector&amp; operator=(const vector &amp;vec);</code></td><td style="text-align: center;">重载等号操作符</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>assign(beg, end);</code></td><td style="text-align: center;">将 <code>[beg, end)</code>区间中的数据拷贝赋值给本身</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>assign(n, elem);</code></td><td style="text-align: center;">将 n 个 elem 拷贝赋值给本身</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>vector 容量和大小：</strong></p><table style="width:100%;"><colgroup><col style="width: 27%" /><col style="width: 68%" /><col style="width: 4%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>size();</code></td><td style="text-align: center;">返回容器中元素的个数</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>empty();</code></td><td style="text-align: center;">判断容器是否为空</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>capacity();</code></td><td style="text-align: center;">容器的容量</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>resize(int num);</code></td><td style="text-align: center;">重新指定容器的长度为num，若容器变长，则以默认值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>resize(int num, elem);</code></td><td style="text-align: center;">重新指定容器的长度为num，若容器变长，则以 elem值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>vector 数据存取操作：</strong></p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>at(int idx);</code></td><td style="text-align: center;">返回索引 idx 所指的数据</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>operator[];</code></td><td style="text-align: center;">返回索引 idx 所指的数据</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>front();</code></td><td style="text-align: center;">返回容器中第一个数据元素</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>back();</code></td><td style="text-align: center;">返回容器中最后一个数据元素</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>vector 插入和删除：</strong></p><table style="width:100%;"><colgroup><col style="width: 53%" /><col style="width: 42%" /><col style="width: 4%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>push_back(ele);</code></td><td style="text-align: center;">尾部插入元素 ele</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>pop_back();</code></td><td style="text-align: center;">删除最后一个元素</td><td style="text-align: center;"></td></tr><tr class="odd"><tdstyle="text-align: center;"><code>insert(const_iterator pos, ele);</code></td><td style="text-align: center;">迭代器指向位置 pos 插入元素 ele</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>insert(const_iterator pos, int count, ele);</code></td><td style="text-align: center;">迭代器指向位置 pos 插入 count 个元素ele</td><td style="text-align: center;"></td></tr><tr class="odd"><tdstyle="text-align: center;"><code>erase(const_iterator pos);</code></td><td style="text-align: center;">删除迭代器指向的元素</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>erase(const_iterator start, const_iterator end);</code></td><td style="text-align: center;">删除迭代器从 start 到 end之间的元素</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>clear();</code></td><td style="text-align: center;">删除容器中所有元素</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>vector 互换容器：</strong></p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>swap(vec);</code></td><td style="text-align: center;">将 vec 与本身的元素互换</td><td style="text-align: center;"></td></tr></tbody></table><blockquote><p><code>swap</code> 可以使两个容器互换，可以达到收缩内存的效果。</p></blockquote><p><strong>vector 预留空间：</strong></p><table><colgroup><col style="width: 23%" /><col style="width: 71%" /><col style="width: 5%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>reserve(int len);</code></td><td style="text-align: center;">容器预留 len个元素长度，预留位置不初始化，元素不可访问。</td><td style="text-align: center;"></td></tr></tbody></table><blockquote><p>如果数据量较大，可以一开始利用 <code>reserve</code> 预留空间。</p></blockquote><h3 id="deque-容器"><code>deque</code> 容器</h3><p>双端数组，可以对头端进行插入删除操作</p><p><strong>deque 与 vector 区别：</strong></p><ul><li><code>vector</code>对于头部的插入删除效率低，数据量越大，效率越低</li><li><code>deque</code> 相对而言，对头部的插入删除速度回比 vector 快</li><li><code>vector</code> 访问元素时的速度会比 deque快，这和两者内部实现有关</li></ul><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/4a454687-deac-4040-8c49-beb1a395e681"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p><code>deque</code> 内部工作原理:</p><p><code>deque</code>内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据，中控器维护的是每个缓冲区的地址，使得使用<code>deque</code> 时像一片连续的内存空间。</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/ced135ee-5483-4f88-97be-3c4d3b530d54"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p><code>deque</code> 容器的迭代器也是支持随机访问的。</p><p><strong>deque 构造函数：</strong></p><table><colgroup><col style="width: 34%" /><col style="width: 60%" /><col style="width: 5%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>deque&lt;T&gt;</code></td><td style="text-align: center;">默认构造形式</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>deque(beg, end);</code></td><td style="text-align: center;">构造函数将 <code>[beg, end)</code>区间中的元素拷贝给本身</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>deque(n, elem);</code></td><td style="text-align: center;">构造函数将 n 个 elem 拷贝给本身</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>deque(const deque &amp;deq);</code></td><td style="text-align: center;">拷贝构造函数</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>deque 赋值操作：</strong></p><table><colgroup><col style="width: 44%" /><col style="width: 50%" /><col style="width: 4%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><code>deque&amp; operator=(const deque &amp;deq);</code></td><td style="text-align: center;">重载等号操作符</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>assign(beg, end);</code></td><td style="text-align: center;">将 <code>[beg, end)</code>区间中的数据拷贝赋值给本身</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>assign(n, elem);</code></td><td style="text-align: center;">将 n 个 elem 拷贝赋值给本身</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>deque 互换容器：</strong></p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>swap(deq);</code></td><td style="text-align: center;">将 deq 与本身的元素互换</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>deque 大小操作：</strong></p><table style="width:100%;"><colgroup><col style="width: 28%" /><col style="width: 66%" /><col style="width: 4%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th>示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>deque.empty();</code></td><td style="text-align: center;">判断容器是否为空</td><td></td></tr><tr class="even"><td style="text-align: center;"><code>deque.size();</code></td><td style="text-align: center;">返回容器中元素的个数</td><td></td></tr><tr class="odd"><td style="text-align: center;"><code>deque.resize(num);</code></td><td style="text-align: center;">重新指定容器的长度为num，若容器变长，则以默认值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除</td><td></td></tr><tr class="even"><tdstyle="text-align: center;"><code>deque.resize(num, elem);</code></td><td style="text-align: center;">重新指定容器的长度为num，若容器变长，则以 elem值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除</td><td></td></tr></tbody></table><p><strong>deque 双端插入和删除操作：</strong></p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>push_back(elem);</code></td><td style="text-align: center;">在容器尾部添加一个数据</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>push_front(elem);</code></td><td style="text-align: center;">在容器头部插入一个数据</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>pop_back();</code></td><td style="text-align: center;">删除容器最后一个数据</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>pop_front();</code></td><td style="text-align: center;">删除容器第一个数据</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>deque 插入和删除操作：</strong></p><table><colgroup><col style="width: 27%" /><col style="width: 67%" /><col style="width: 5%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>insert(pos,elem);</code></td><td style="text-align: center;">在 pos 位置插入一个 elem元素的拷贝，返回新数据的位置</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>insert(pos, n,elem);</code></td><td style="text-align: center;">在 pos 位置插入 n 个 elem数据，无返回值</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>insert(pos,beg,end);</code></td><td style="text-align: center;">在 pos 位置插入 <code>[beg,end)</code>区间的数据，无返回值</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>clear();</code></td><td style="text-align: center;">清空容器的所有数据</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>erase(beg,end);</code></td><td style="text-align: center;">删除 <code>[beg,end)</code>区间的数据，返回下一个数据的位置</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>erase(pos);</code></td><td style="text-align: center;">删除 pos位置的数据，返回下一个数据的位置。</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>deque 数据存取：</strong></p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>at(int idx);</code></td><td style="text-align: center;">返回索引 idx 所指的数据</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>operator[];</code></td><td style="text-align: center;">返回索引 idx 所指的数据</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>front();</code></td><td style="text-align: center;">返回容器中第一个数据元素</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>back();</code></td><td style="text-align: center;">返回容器中最后一个数据元素</td><td style="text-align: center;"></td></tr></tbody></table><h3 id="stack-容器"><code>stack</code> 容器</h3><p><code>stack</code> 没有迭代器。</p><p><strong>stack 构造器：</strong></p><table><colgroup><col style="width: 33%" /><col style="width: 61%" /><col style="width: 5%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>stack&lt;T&gt; stk;</code></td><td style="text-align: center;">stack 采用模板类实现， stack对象的默认构造形式</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>stack(const stack &amp;stk);</code></td><td style="text-align: center;">拷贝构造函数</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>stack 赋值操作：</strong></p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><code>stack&amp; operator=(const stack &amp;stk);</code></td><td style="text-align: center;">重载等号操作符</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>stack 数据存取：</strong></p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>push(elem);</code></td><td style="text-align: center;">向栈顶添加元素</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>pop();</code></td><td style="text-align: center;">从栈顶移除第一个元素</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>top();</code></td><td style="text-align: center;">返回栈顶元素</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>stack 大小操作：</strong></p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>empty();</code></td><td style="text-align: center;">判断栈是否为空</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>size();</code></td><td style="text-align: center;">回栈的大小</td><td style="text-align: center;"></td></tr></tbody></table><h3 id="queue-容器"><code>queue</code> 容器</h3><p>队列是一种 <ahref="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)">FIFO</a>的数据结构。</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/10400176-5ec1-48c4-abd6-56ba7ada0ee7"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>队列容器允许从一端新增元素，从另一端移除元素。</p><p>队列中只有队头和队尾才可以被外界使用，因此队列没有迭代器。</p><p><strong>queue 构造函数：</strong></p><table><colgroup><col style="width: 34%" /><col style="width: 60%" /><col style="width: 5%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>queue&lt;T&gt; que;</code></td><td style="text-align: center;">queue 采用模板类实现，queue对象的默认构造形式</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>queue(const queue &amp;que);</code></td><td style="text-align: center;">拷贝构造函数</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>queue 赋值操作：</strong></p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><code>queue&amp; operator=(const queue &amp;que);</code></td><td style="text-align: center;">重载等号操作符</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>queue 数据存取：</strong></p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>push(elem);</code></td><td style="text-align: center;">往队尾添加元素</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>pop();</code></td><td style="text-align: center;">从队头移除第一个元素</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>back();</code></td><td style="text-align: center;">返回最后一个元素</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>front();</code></td><td style="text-align: center;">返回第一个元素</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>queue 大小操作：</strong></p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>empty();</code></td><td style="text-align: center;">判断堆栈是否为空</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>size();</code></td><td style="text-align: center;">返回栈的大小</td><td style="text-align: center;"></td></tr></tbody></table><h3 id="list-容器"><code>list</code> 容器</h3><p>STL 中的链表是一个双向循环链表</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/6fc56009-08b2-4ca6-95d7-8143e9a1deeb"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>由于链表的存储方式并不是连续的内存空间，因此链表 <code>list</code>中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong>。</p><p><code>list</code> 的优点：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p><code>list</code> 的缺点：</p><ul><li>链表灵活，但是空间和时间额外耗费较大。</li></ul><p><code>list</code> 有一个重要的性质，插入操作和删除操作都不会造成原有<code>list</code> 迭代器的失效。</p><p><strong>list 构造函数：</strong></p><table><colgroup><col style="width: 32%" /><col style="width: 62%" /><col style="width: 5%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>list&lt;T&gt; lst;</code></td><td style="text-align: center;"><code>list</code>采用采用模板类实现，对象的默认构造形式</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>list(beg,end);</code></td><td style="text-align: center;">构造函数将 <code>[beg, end)</code>区间中的元素拷贝给本身</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>list(n,elem);</code></td><td style="text-align: center;">构造函数将 n 个 elem 拷贝给本身</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>list(const list &amp;lst);</code></td><td style="text-align: center;">拷贝构造函数</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>list 赋值和交换：</strong></p><table><colgroup><col style="width: 43%" /><col style="width: 51%" /><col style="width: 4%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>assign(beg, end);</code></td><td style="text-align: center;">将 <code>[beg, end)</code>区间中的数据拷贝赋值给本身</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>assign(n, elem);</code></td><td style="text-align: center;">将 n 个 elem 拷贝赋值给本身</td><td style="text-align: center;"></td></tr><tr class="odd"><tdstyle="text-align: center;"><code>list&amp; operator=(const list &amp;lst);</code></td><td style="text-align: center;">重载等号操作符</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>swap(lst);</code></td><td style="text-align: center;">将 lst 与本身的元素互换</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>list 大小操作：</strong></p><table><colgroup><col style="width: 23%" /><col style="width: 71%" /><col style="width: 4%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>size();</code></td><td style="text-align: center;">返回容器中元素的个数</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>empty();</code></td><td style="text-align: center;">判断容器是否为空</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>resize(num);</code></td><td style="text-align: center;">重新指定容器的长度为num，若容器变长，则以默认值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>resize(num, elem);</code></td><td style="text-align: center;">重新指定容器的长度为num，若容器变长，则以 elem值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>list 插入和删除：</strong></p><table><colgroup><col style="width: 31%" /><col style="width: 63%" /><col style="width: 5%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>push_back(elem);</code></td><td style="text-align: center;">在容器尾部加入一个元素</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>pop_back();</code></td><td style="text-align: center;">删除容器中最后一个元素</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>push_front(elem);</code></td><td style="text-align: center;">在容器开头插入一个元素</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>pop_front();</code></td><td style="text-align: center;">从容器开头移除第一个元素</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>insert(pos, elem);</code></td><td style="text-align: center;">在 pos 位置插 elem元素的拷贝，返回新数据的位置</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>insert(pos, n, elem);</code></td><td style="text-align: center;">在 pos 位置插入 n 个 elem数据，无返回值</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>insert(pos, beg, end);</code></td><td style="text-align: center;">在 pos 位置插入 <code>[beg,end)</code>区间的数据，无返回值</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>clear();</code></td><td style="text-align: center;">移除容器的所有数据</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>erase(beg, end);</code></td><td style="text-align: center;">删除 <code>[beg,end)</code>区间的数据，返回下一个数据的位置</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>erase(pos);</code></td><td style="text-align: center;">删除 pos位置的数据，返回下一个数据的位置</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>remove(elem);</code></td><td style="text-align: center;">删除容器中所有与 elem 值匹配的元素</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>list 数据存取：</strong></p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>front();</code></td><td style="text-align: center;">返回第一个元素</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>back();</code></td><td style="text-align: center;">返回最后一个元素</td><td style="text-align: center;"></td></tr></tbody></table><blockquote><p><code>list</code> 容器中不可以通过 <code>[]</code> 或者<code>at</code> 方式访问数据。</p></blockquote><p><strong>list 反转和排序：</strong></p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>reverse();</code></td><td style="text-align: center;">反转链表</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>sort();</code></td><td style="text-align: center;">链表排序</td><td style="text-align: center;"></td></tr></tbody></table><h3 id="set-multiset-容器"><code>set / multiset</code> 容器</h3><p><code>set</code>：</p><ul><li>所有元素都会根据元素的键值自动被排序</li><li>不允许两个元素有相同的值</li><li>不可以通过 <code>set</code> 的迭代器改变 <code>set</code>元素的值</li><li><code>set</code> 的 <code>iterator</code> 是一种<code>const_iterator</code></li><li>当对容器中的元素进行插入操作或者删除操作的时候，操作之前所有的迭代器，在操作完成之后依然有效。</li></ul><p><code>multiset</code>：特性及用法和 set完全相同，唯一的差别在于它允许键值重复。</p><p><code>set</code> 和 <code>multiset</code> 的底层实现是<ahref="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>。</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/c3db04d9-0269-432a-8082-a50bbe5807aa"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p><strong>set 构造函数：</strong></p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>set&lt;T&gt; st;</code></td><td style="text-align: center;">默认构造函数</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>set(const set &amp;st);</code></td><td style="text-align: center;">拷贝构造函数</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>set 赋值和交换操作：</strong></p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><code>set&amp; operator=(const set &amp;st);</code></td><td style="text-align: center;">重载等号操作符</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>swap(st);</code></td><td style="text-align: center;">交换两个集合容器</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>set 大小操作：</strong></p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>size();</code></td><td style="text-align: center;">返回容器中元素的数目</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>empty();</code></td><td style="text-align: center;">判断容器是否为空</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>swap(st);</code></td><td style="text-align: center;">交换两个集合容器</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>set 插入和删除操作：</strong></p><table><colgroup><col style="width: 23%" /><col style="width: 71%" /><col style="width: 5%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>insert(elem);</code></td><td style="text-align: center;">在容器中插入元素</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>clear();</code></td><td style="text-align: center;">清除所有元素</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>erase(pos);</code></td><td style="text-align: center;">删除 pos迭代器所指的元素，返回下一个元素的迭代器</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>erase(beg, end);</code></td><td style="text-align: center;">删除区间 <code>[beg,end)</code>的所有元素 ，返回下一个元素的迭代器</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>erase(elem);</code></td><td style="text-align: center;">删除容器中值为 elem 的元素</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>set 查找和统计：</strong></p><table><colgroup><col style="width: 26%" /><col style="width: 68%" /><col style="width: 4%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>find(key);</code></td><td style="text-align: center;">查找 key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回<code>set.end();</code></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>count(key);</code></td><td style="text-align: center;">统计 key 的元素个数</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>lower_bound(keyElem);</code></td><td style="text-align: center;">返回第一个 key&gt;=keyElem元素的迭代器</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>upper_bound(keyElem);</code></td><td style="text-align: center;">返回第一个 key&gt;keyElem元素的迭代器。</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>equal_range(keyElem);</code></td><td style="text-align: center;">返回容器中 key 与 keyElem相等的上下限的两个迭代器。</td><td style="text-align: center;"></td></tr></tbody></table><h3 id="pair"><code>pair</code></h3><p><strong>两种创建方式：</strong></p><ul><li><code>pair&lt;type, type&gt; p(value1, value2);</code></li><li><code>pair&lt;type, type&gt; p = make_pair(value1, value2);</code></li></ul><h3 id="map-multimap-容器"><code>map / multimap</code> 容器</h3><ul><li><p>map 中所有元素都是 pair</p></li><li><p>pair 中第一个元素为 key（键值），起到索引作用，第二个元素为value</p></li><li><p>所有元素都会根据元素的键值自动排序</p></li><li><p><code>map / multimap</code>属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</p></li></ul><p><strong>优点：</strong></p><ul><li>可以根据 key 值快速找到 value 值</li></ul><p><code>map</code> 和 <code>multimap</code> <strong>区别</strong>：</p><ul><li><code>map</code> 不允许容器中有重复 key 值元素</li><li><code>multimap</code> 允许容器中有重复 key 值元素</li></ul><p><strong>map 构造函数：</strong></p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>map&lt;T1, T2&gt; mp;</code></td><td style="text-align: center;">默认构造函数</td><td style="text-align: center;"></td></tr><tr class="even"><tdstyle="text-align: center;"><code>map(const map &amp;mp);</code></td><td style="text-align: center;">拷贝构造函数</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>map 赋值操作：</strong></p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><code>map&amp; operator=(const map &amp;mp);</code></td><td style="text-align: center;">重载等号操作符</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>map 大小和交换操作：</strong></p><table><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>size();</code></td><td style="text-align: center;">返回容器中元素的数目</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>empty();</code></td><td style="text-align: center;">判断容器是否为空</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>swap(st);</code></td><td style="text-align: center;">交换两个集合容器</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>map 插入数据元素操作：</strong></p><table><colgroup><col style="width: 24%" /><col style="width: 70%" /><col style="width: 5%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>insert(elem);</code></td><td style="text-align: center;">在容器中插入元素</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>operator[](elem);</code></td><td style="text-align: center;">在容器中插入元素</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>clear();</code></td><td style="text-align: center;">清除所有元素</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>erase(pos);</code></td><td style="text-align: center;">删除 pos迭代器所指的元素，返回下一个元素的迭代器</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>erase(beg, end);</code></td><td style="text-align: center;">删除区间 <code>[beg,end)</code>的所有元素 ，返回下一个元素的迭代器</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>erase(key);</code></td><td style="text-align: center;">删除容器中值为 key 的元素</td><td style="text-align: center;"></td></tr></tbody></table><p><strong>map 查找和统计：</strong></p><table><colgroup><col style="width: 26%" /><col style="width: 68%" /><col style="width: 4%" /></colgroup><thead><tr class="header"><th style="text-align: center;">函数</th><th style="text-align: center;">说明</th><th style="text-align: center;">示例</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>find(key);</code></td><td style="text-align: center;">查找 key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回<code>set.end()</code></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>operator[](key);</code></td><td style="text-align: center;">查找 key是否存在，若存在，返回该键的元素的迭代器；若不存在，返回<code>set.end()</code></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>count(key);</code></td><td style="text-align: center;">统计 key 的元素个数</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><code>lower_bound(keyElem);</code></td><td style="text-align: center;">返回第一个 key&gt;=keyElem元素的迭代器</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><code>upper_bound(keyElem);</code></td><td style="text-align: center;">返回容器中 key 与 keyElem相等的上下限的两个迭代器</td><td style="text-align: center;"></td></tr></tbody></table><h3 id="总结">总结</h3><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/003ac080-8c9e-44b2-b257-dec25f5de084"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/f8665a43-82eb-4b82-a947-233bccaa7151"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="函数对象">函数对象</h2><p>就是重载了 <code>()</code> 运算符类的实例。</p><p>亦称仿函数。</p><p>本质是一个对象，不是一个函数。</p><p>根据重载 <code>operator()</code>时的形参个数可分为：一元仿函数、二元仿函数。</p><p>函数对象在调用时跟普通函数一样。</p><p>函数对象不同于普通函数，函数对象有自己的状态。</p><p>函数对象可作为参数传递。</p><p>函数对象通常不定义构造函数和析构函数，所以在构造和析构时不会发生任何问题，避免了函数调用的运行时问题。</p><p>函数对象可内联编译，性能好，函数指针几乎不可能。</p><p>模版函数对象使函数对象具有通用性。</p><p><strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123; <span class="keyword">return</span> v1 + v2; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyAdd myAdd;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">myAdd</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyPrint</span>() &#123; count = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">        count++; <span class="comment">// 统计使用次数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count; <span class="comment">// 内部自己的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyPrint myPrint;</span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp, string test)</span> </span>&#123; <span class="built_in">mp</span>(test); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyPrint myPrint;</span><br><span class="line">    <span class="built_in">doPrint</span>(myPrint, <span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/c48cbfae-7b10-4b01-952c-be54233c0a2d"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="谓词">谓词</h3><ul><li>返回值类型为 <code>boo</code>l类型的仿函数称为<strong>谓词</strong></li><li>如果 <code>operator()</code> 接受一个参数，为一元谓词</li><li>如果 <code>operator()</code> 接受两个参数，为二元谓词</li></ul><p><strong>一元谓词示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一元谓词</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterFive</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; <span class="keyword">return</span> val &gt; <span class="number">5</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line">    <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/82042860-dc78-4360-9d38-10480f0860e7"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p><strong>二元谓词示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元谓词</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123; <span class="keyword">return</span> num1 &gt; num2; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认从小到大</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> &amp;i) &#123; cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> &amp;i) &#123; cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/a9aff19d-0ea7-49e9-b964-f31bbcf1860f"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="内建函数对象">内建函数对象</h3><ul><li><p>算术仿函数</p></li><li><p>关系仿函数</p></li><li><p>逻辑仿函数</p></li></ul><p><strong>用法：</strong></p><ul><li>这些仿函数所产生的对象，用法和一般函数完全相同</li><li>使用内建函数对象，需要引入头文件<code>#include&lt;functional&gt;</code></li></ul><p><strong>算术仿函数</strong></p><ul><li>实现四则运算</li><li>其中 negate 是一元运算，其他都是二元运算</li></ul><table><thead><tr class="header"><th style="text-align: center;">仿函数原型</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><code>template&lt;class T&gt; T plus&lt;T&gt;</code></td><td style="text-align: center;">加法仿函数</td></tr><tr class="even"><tdstyle="text-align: center;"><code>template&lt;class T&gt; T minus&lt;T&gt;</code></td><td style="text-align: center;">减法仿函数</td></tr><tr class="odd"><tdstyle="text-align: center;"><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code></td><td style="text-align: center;">乘法仿函数</td></tr><tr class="even"><tdstyle="text-align: center;"><code>template&lt;class T&gt; T divides&lt;T&gt;</code></td><td style="text-align: center;">除法仿函数</td></tr><tr class="odd"><tdstyle="text-align: center;"><code>template&lt;class T&gt; T modulus&lt;T&gt;</code></td><td style="text-align: center;">取模仿函数</td></tr><tr class="even"><tdstyle="text-align: center;"><code>template&lt;class T&gt; T negate&lt;T&gt;</code></td><td style="text-align: center;">取反仿函数</td></tr></tbody></table><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// negate</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    negate&lt;<span class="type">int</span>&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">n</span>(<span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// plus</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    plus&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/277d29fc-ef61-4c1c-af40-d4a2cb676650"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p><strong>关系仿函数：</strong></p><table><thead><tr class="header"><th style="text-align: center;">仿函数原型</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code></td><td style="text-align: center;">等于</td></tr><tr class="even"><tdstyle="text-align: center;"><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code></td><td style="text-align: center;">不等于</td></tr><tr class="odd"><tdstyle="text-align: center;"><code>template&lt;class T&gt; bool greater&lt;T&gt;</code></td><td style="text-align: center;">大于</td></tr><tr class="even"><tdstyle="text-align: center;"><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code></td><td style="text-align: center;">大于等于</td></tr><tr class="odd"><tdstyle="text-align: center;"><code>template&lt;class T&gt; bool less&lt;T&gt;</code></td><td style="text-align: center;">小于</td></tr><tr class="even"><td style="text-align: center;">template<class T> boolless_equal<T>`</td><td style="text-align: center;">小于等于</td></tr></tbody></table><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">10</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> &amp;i) &#123; cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> &amp;i) &#123; cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/d2ce0b9f-1791-4eb2-9fe4-59ee568092f5"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p><strong>逻辑仿函数：</strong></p><p>逻辑运算类运算函数，<code>not</code> 为一元运算，其余为二元运算。</p><table><thead><tr class="header"><th style="text-align: center;">仿函数原型</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code></td><td style="text-align: center;">逻辑与</td></tr><tr class="even"><tdstyle="text-align: center;"><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code></td><td style="text-align: center;">逻辑或</td></tr><tr class="odd"><tdstyle="text-align: center;"><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code></td><td style="text-align: center;">逻辑非</td></tr></tbody></table><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; v&#123;<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="type">bool</span> &amp;b) &#123; cout &lt;&lt; b &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span></span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; v2;</span><br><span class="line">    v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), <span class="built_in">logical_not</span>&lt;<span class="type">bool</span>&gt;());</span><br><span class="line"></span><br><span class="line">    for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="type">bool</span> &amp;b) &#123; cout &lt;&lt; b &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/9d50a19b-9eb0-4b86-a91f-29dd562a9586"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="适配器">适配器</h2><p>用来适配参数，扩展参数接口，一般结合仿函数一起使用。</p><h3 id="函数对象适配器">函数对象适配器</h3><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一元继承public unary_function&lt;参数1 ,返回值类型&gt;</span></span><br><span class="line"><span class="comment">// 二元继承public binary_function&lt;int,int,void&gt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Print</span> : <span class="keyword">public</span> binary_function&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> num)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; a + num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定参数 bind2nd</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">Print</span>(), <span class="number">200</span>));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// bind1st</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind1st</span>(<span class="built_in">Print</span>(), <span class="number">200</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/bc636f64-cd86-4c91-9786-ae5067b13651"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="取反适配器">取反适配器</h3><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// not1 一元取反</span></span><br><span class="line">    <span class="comment">// not2 二元取反</span></span><br><span class="line">    <span class="comment">// vector&lt;int&gt;::iterator it = find_if(v.begin(),v.end(), not1(greater2()));</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it =</span><br><span class="line">        <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not2</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()));</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="type">int</span> &amp;a) &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/127acbc6-70b3-4143-900a-9ee582f3d4e9"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="函数指针适配器">函数指针适配器</h3><p>将函数指针适配成函数对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> num)</span> </span>&#123; cout &lt;&lt; a + num &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要将函数指针print适配成函数对象</span></span><br><span class="line">    <span class="comment">// ptr_fun 将函数指针适配成函数对象</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">ptr_fun</span>(print), <span class="number">200</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/af1de132-03f0-41c0-aa99-a6e0fdd293d8"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="成员函数适配器">成员函数适配器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">        m_Name = name;</span><br><span class="line">        m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;成员函数:&quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Plus100</span><span class="params">()</span> </span>&#123; m_Age += <span class="number">100</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;Person *&gt; v1;</span><br><span class="line">    <span class="comment">// 创建数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    v1.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line"></span><br><span class="line">    for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">mem_fun</span>(&amp;Person::ShowPerson));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">    <span class="comment">// mem_fun_ref 将Person的成员函数适配成 普通回调函数</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">mem_fun_ref</span>(&amp;Person::ShowPerson));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/69eff3b3-029c-4124-b556-f2f71a8466b9"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="常用算法">常用算法</h2><ul><li><p>算法主要是由头文件 <code>&lt;algorithm&gt;</code>、<code>&lt;functional&gt;</code>、 <code>&lt;numeric&gt;</code>组成。</p></li><li><p><code>&lt;algorithm&gt;</code> 是所有 STL头文件中最大的一个，范围涉及到比较、交换、查找、遍历操作、复制、修改等等。</p></li><li><p><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数。</p></li><li><p><code>&lt;functional&gt;</code>定义了一些模板类，用以声明函数对象。</p></li></ul><h3 id="常用遍历算法">常用遍历算法</h3><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th style="text-align: center;">算法</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><code>for_each(iterator beg, iterator end, _callback);</code></td><tdstyle="text-align: center;">遍历算法<br /><code>beg</code>：开始迭代器<br /><code>end</code>：结束迭代器<br /><code>callback</code>：回调函数或函数对象<br />返回值：函数对象，即<code>callback</code> 参数指向的函数对象</td></tr><tr class="even"><tdstyle="text-align: center;"><code>transform(iterator beg1, iterator end1, iterator beg2, _callbakc);</code></td><tdstyle="text-align: center;">将指定容器区间元素搬运到另一容器中<br /><code>beg1</code>：源容器开始迭代器<br /><code>end1</code>：源容器结束迭代器<br /><code>beg2</code>：目标容器开始迭代器<br /><code>_callbakc</code>：回调函数或函数对象<br />返回值：返回目标容器迭代器</td></tr></tbody></table><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"></span><br><span class="line">    v1.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), [](<span class="type">const</span> <span class="type">int</span> &amp;a) &#123; <span class="keyword">return</span> a; &#125;);</span><br><span class="line"></span><br><span class="line">    for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="type">int</span> &amp;a) &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/9ee06748-2504-4d1c-9e2b-18c1988de2fa"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="常用查找算法">常用查找算法</h3><table><colgroup><col style="width: 48%" /><col style="width: 51%" /></colgroup><thead><tr class="header"><th style="text-align: center;">算法</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><code>find(iterator beg, iterator end, value);</code></td><tdstyle="text-align: center;">查找元素<br /><code>beg</code>：容器开始迭代器<br /><code>end</code>：容器结束迭代器<br /><code>value</code>：查找的元素<br />返回值：返回查找元素的位置</td></tr><tr class="even"><tdstyle="text-align: center;"><code>find_if(iterator beg, iterator end, _callback);</code></td><tdstyle="text-align: center;">按条件查找元素<br /><code>beg</code>：容器开始迭代器<br /><code>end</code>：容器结束迭代器<br /><code>callback</code>：回调函数或者谓词<br />返回值：找到返回<code>true</code>，否则 <code>false</code></td></tr><tr class="odd"><tdstyle="text-align: center;"><code>adjacent_find(iterator beg, iterator end, _callback);</code></td><tdstyle="text-align: center;">查找相邻重复元素<br /><code>beg</code>：容器开始迭代器<br /><code>end</code>：容器结束迭代器<br /><code>_callback</code>：回调函数或者谓词<br />返回值：返回相邻元素的第一个位置的迭代器</td></tr><tr class="even"><tdstyle="text-align: center;"><code>bool binary_search(iterator beg, iterator end, value);</code></td><tdstyle="text-align: center;">二分查找法<br />注意：在无序序列中不可用<br /><code>beg</code>：容器开始迭代器<br /><code>end</code>：容器结束迭代器<br /><code>value</code>：查找的元素<br />返回值：找到返回<code>true</code>，否则 <code>false</code></td></tr><tr class="odd"><tdstyle="text-align: center;"><code>count(iterator beg, iterator end, value);</code></td><tdstyle="text-align: center;">统计元素个数<br /><code>beg</code>：容器开始迭代器<br /><code>end</code>：容器结束迭代器<br /><code>value</code>：统计的元素<br />返回值：返回元素个数</td></tr><tr class="even"><tdstyle="text-align: center;"><code>count_if(iterator beg, iterator end, _callback);</code></td><tdstyle="text-align: center;">统计元素个数按条件统计元素个数<br /><code>beg</code>：容器开始迭代器<br /><code>end</code>：容器结束迭代器<br /><code>_callback</code>：回调函数或者谓词<br />返回值：返回元素个数</td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">compare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; b % <span class="number">2</span> == <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> a) &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    it = <span class="built_in">adjacent_find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">compare</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">3</span>))</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/87eaeef8-e174-44b5-b0e4-14c4b8cba7cc"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="常用排序算法">常用排序算法</h3><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th style="text-align: center;">算法</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></td><tdstyle="text-align: center;">容器元素合并，并存储到另一容器中<br />注意：两个容器必须是有序的<br /><code>beg1</code>：容器1 开始迭代器<br /><code>end1</code>：容器 1结束迭代器<br /><code>beg2</code>：容器 2开始迭代器<br /><code>end2</code>：容器 2结束迭代器<br /><code>dest</code>：目标容器开始迭代器</td></tr><tr class="even"><tdstyle="text-align: center;"><code>sort(iterator beg, iterator end, _callback);</code></td><td style="text-align: center;">容器元素排序<br /><code>beg</code>：容器1 开始迭代器<br /><code>end</code>：容器 1结束迭代器<br /><code>_callback</code>：回调函数或者谓词</td></tr><tr class="odd"><tdstyle="text-align: center;"><code>random_shuffle(iterator beg, iterator end);</code></td><tdstyle="text-align: center;">对指定范围内的元素随机调整次序<br /><code>beg</code>：容器开始迭代器<br /><code>end</code>：容器结束迭代器</td></tr><tr class="even"><tdstyle="text-align: center;"><code>reverse(iterator beg, iterator end);</code></td><tdstyle="text-align: center;">反转指定范围的元素<br /><code>beg</code>：容器开始迭代器<br /><code>end</code>：容器结束迭代器</td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"></span><br><span class="line">    v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>() + v1.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">merge</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), [](<span class="type">int</span> a) &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// random_shuffle(v.begin(),v.end());</span></span><br><span class="line">    <span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> a) &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/1aaa134a-0a60-465c-bf63-92c42e0723ba"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="常用拷贝和替换算法">常用拷贝和替换算法</h3><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th style="text-align: center;">算法</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><code>copy(iterator beg, iterator end, iterator dest);</code></td><tdstyle="text-align: center;">将容器内指定范围的元素拷贝到另一容器中<br />beg：容器开始迭代器<br />end：容器结束迭代器<br />dest：目标起始迭代器</td></tr><tr class="even"><tdstyle="text-align: center;"><code>replace(iterator beg, iterator end, oldvalue, newvalue);</code></td><tdstyle="text-align: center;">将容器内指定范围的旧元素修改为新元素<br />beg：容器开始迭代器<br />end：容器结束迭代器<br />oldvalue：旧元素<br />newvalue：新元素</td></tr><tr class="odd"><tdstyle="text-align: center;"><code>replace_if(iterator beg, iterator end, _callback, newvalue);</code></td><tdstyle="text-align: center;">将容器内指定范围满足条件的元素替换为新元素<br /><code>beg</code>：容器开始迭代器<br /><code>end</code>：容器结束迭代器<br /><code>callback</code>：函数回调或者谓词<br /><code>newvalue</code>：新元素</td></tr><tr class="even"><tdstyle="text-align: center;"><code>swap(container c1, container c2);</code></td><td style="text-align: center;">互换两个容器的元素<br /><code>c1</code>：容器 1<br /> <code>c1</code>：容器 2</td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">greater10</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a &gt; <span class="number">2</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// copy(v.begin(),v.end(),v2.begin());</span></span><br><span class="line">    <span class="comment">// replace(v.begin(), v.end(), 3, 10);</span></span><br><span class="line">    <span class="built_in">replace_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater10</span>(), <span class="number">10</span>);</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> a) &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(v, v2);</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> a) &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/e7e7c18a-4042-45a0-af61-4b69cb2bc2d3"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="常用算术生成算法">常用算术生成算法</h3><table><colgroup><col style="width: 44%" /><col style="width: 55%" /></colgroup><thead><tr class="header"><th style="text-align: center;">算法</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><code>accumulate(iterator beg, iterator end, value);</code></td><tdstyle="text-align: center;">计算容器元素累计总和<br /><code>beg</code>：容器开始迭代器<br /><code>end</code>：容器结束迭代器<br /><code>value</code>：起始值</td></tr><tr class="even"><tdstyle="text-align: center;"><code>fill(iterator beg, iterator end, value);</code></td><tdstyle="text-align: center;">向容器中添加元素<br /><code>beg</code>：容器开始迭代器<br /><code>end</code>：容器结束迭代器<br /><code>value</code>：填充元素</td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fill</span>(v.<span class="built_in">begin</span>() + <span class="number">2</span>, v.<span class="built_in">end</span>(), <span class="number">20</span>);</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> a) &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/e0d8973f-3518-4031-b2db-3d1e2aedb4a0"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="常用集合算法">常用集合算法</h3><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th style="text-align: center;">算法</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><tdstyle="text-align: center;"><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></td><td style="text-align: center;">求两个 set的交集<br /><code>beg1</code>：容器 1开始迭代器<br /><code>end1</code>：容器 1结束迭代器<br /><code>beg2</code>：容器 2开始迭代器<br /><code>end2</code>：容器 2结束迭代器<br /><code>dest</code>目标容器开始迭代器<br />返回值：目标容器的最后一个元素的迭代器地址</td></tr><tr class="even"><tdstyle="text-align: center;"><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></td><td style="text-align: center;">求两个 set的并集<br /><code>beg1</code>：容器 1开始迭代器<br /><code>end1</code>：容器 1结束迭代器<br /><code>beg2</code>：容器 2开始迭代器<br /><code>end2</code>：容器 2结束迭代器<br /><code>dest</code>：目标容器开始迭代器<br />返回值：目标容器的最后一个元素的迭代器地址</td></tr><tr class="odd"><tdstyle="text-align: center;"><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></td><td style="text-align: center;">求两个 set的差集<br /><code>beg1</code>：容器 1开始迭代器<br /><code>end1</code>：容器 1结束迭代器<br /><code>beg2</code>：容器2开始迭代器<br /><code>end2</code>：容器 2结束迭代器<br /><code>dest</code>：目标容器开始迭代器<br />返回值：目标容器的最后一个元素的迭代器地址</td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>() + v1.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_intersection</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line">    for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), [](<span class="type">int</span> a) &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_union</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line">    for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), [](<span class="type">int</span> a) &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    v2.<span class="built_in">clear</span>();</span><br><span class="line">    v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">set_difference</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line">    for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), [](<span class="type">int</span> a) &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/15d21458-3f7c-46c9-8a43-d23b1d62c122"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><blockquote><ol type="1"><li>求交目标容器开辟空间需要从<strong>两个容器中取小值</strong></li><li>求并目标容器开辟空间需要<strong>两个容器相加</strong></li><li>求差目标容器开辟空间需要从<strong>两个容器取较大值</strong></li></ol></blockquote>]]></content>
    
    
    <summary type="html">C++ 中的 STL</summary>
    
    
    
    <category term="C++ 基础" scheme="https://xinransix.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C++" scheme="https://xinransix.github.io/tags/C/"/>
    
    <category term="STL" scheme="https://xinransix.github.io/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>OOP</title>
    <link href="https://xinransix.github.io/2023/07/16/OOP/"/>
    <id>https://xinransix.github.io/2023/07/16/OOP/</id>
    <published>2023-07-16T02:42:24.000Z</published>
    <updated>2024-02-10T08:39:11.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类和对象">类和对象</h2><p>OOP 的三大特性：封装、继承、多态。</p><p><code>struct</code> 和 <code>class</code> 区别：</p><p>在 C++ 中 <code>struct</code> 和 <code>class</code>唯一的区别就在于：默认的访问权限不同，<code>struct</code>默认权限为公共，<code>class</code> 默认权限为私有。</p><p>相较于 C 中的 <code>struct</code>，C++ 中的 <code>struct</code> 和<code>class</code> 都可以定义自己的成员函数。</p><p><strong>C++ 中的成员权限和继承：</strong></p><table><colgroup><col style="width: 19%" /><col style="width: 25%" /><col style="width: 28%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th style="text-align: center;">继承方式</th><th style="text-align: center;">基类的 <code>public</code> 成员</th><th style="text-align: center;">基类的 <code>protected</code> 成员</th><th style="text-align: center;">基类的 <code>private</code> 成员</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>public</code> 继承</td><td style="text-align: center;">仍为 <code>public</code> 成员</td><td style="text-align: center;">仍为 <code>protected</code> 成员</td><td style="text-align: center;">不可见</td></tr><tr class="even"><td style="text-align: center;"><code>protected</code> 继承</td><td style="text-align: center;">变为 <code>protected</code> 成员</td><td style="text-align: center;">变为 <code>protected</code> 成员</td><td style="text-align: center;">不可见</td></tr><tr class="odd"><td style="text-align: center;"><code>private</code> 继承</td><td style="text-align: center;">变为 <code>private</code> 成员</td><td style="text-align: center;">变为 <code>private</code> 成员</td><td style="text-align: center;">不可见</td></tr></tbody></table><h2 id="对象的初始化和清理">对象的初始化和清理</h2><h3 id="构造函数和析构函数">构造函数和析构函数</h3><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造函数和析构函数，编译器会提供</strong>。编译器提供的构造函数和析构函数是空实现。</p><ul><li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li><li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li></ul><p>构造函数语法：<code>类名() &#123;&#125;</code></p><ol type="1"><li>构造函数，没有返回值也不写 <code>void</code></li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li></ol><p>析构函数语法：<code>~类名() &#123;&#125;</code></p><ol type="1"><li>析构函数，没有返回值也不写 <code>void</code></li><li>函数名称与类名相同，在名称前加上符号 <code>~</code></li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li></ol><h3 id="构造函数的分类及调用">构造函数的分类及调用</h3><p><strong>两种分类方式：</strong></p><ul><li><p>按参数分为： 有参构造和无参构造</p></li><li><p>按类型分为： 普通构造和拷贝构造</p></li></ul><blockquote><p>注意：</p><ol type="1"><li>如果不提供任何函数，编译器会提供至少 4个函数：默认构造函数、拷贝构造函数、析构函数、<code>operator=()</code>.</li><li>如果自定义了一个构造函数，编译器不在提供默认构造函数。</li><li>如果自定义了一个拷贝构造函数，编译器不在提供默认的拷贝构造函数。</li><li>默认的拷贝构造函数是浅拷贝。</li></ol></blockquote><p><strong>三种调用方式：</strong></p><ul><li>括号法</li><li>显示法</li><li>隐式转换法</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123; cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">        age = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p) &#123;</span><br><span class="line">        age = p.age;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123; cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用无参构造函数</span></span><br><span class="line">    Person p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 括号法，常用</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line">    <span class="comment">// Person p2();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式法</span></span><br><span class="line">    Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>);</span><br><span class="line">    Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Person(10)单独写是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐式转换法</span></span><br><span class="line">    Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10);</span></span><br><span class="line">    Person p5 = p4; <span class="comment">// Person p5 = Person(p4);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line">    <span class="comment">// Person p5(p4);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/a01c48d7-61f0-4343-a6ff-f8a637c4d55d"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="拷贝构造函数调用时机">拷贝构造函数调用时机</h3><p>C++ 中拷贝构造函数调用时机通常有三种情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象。</li><li>值传递的方式给函数参数传值。</li><li>以值方式返回局部对象。</li></ul><blockquote><p>即：旧对象初始化新对象。</p><p>以值传递返回局部对象在 GCC 中会有优化，可能看到不同的结果。</p></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        mAge = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        mAge = p.mAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123; cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>;</span><br><span class="line">    Person newman2 = man;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Person newman3;</span></span><br><span class="line">    <span class="comment">// newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    <span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">    cout &lt;&lt; (<span class="type">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/6291335b-6b3b-4eaa-b1be-e8a95717e6d5"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="c-默认增加的函数">C++ 默认增加的函数</h3><p>默认情况下，C++ 编译器至少给一个类添加 3 个函数：</p><p>1．默认构造函数 2．默认析构函数3．默认拷贝构造函数，对属性进行值拷贝</p><p>构造函数调用规则如下：</p><ul><li>如果用户定义有参构造函数，C++不在提供默认无参构造，但是会提供默认拷贝构造。</li><li>如果用户定义拷贝构造函数，C++ 不会再提供其他构造函数。</li></ul><h3 id="深拷贝与浅拷贝">深拷贝与浅拷贝</h3><p>浅拷贝：简单的赋值拷贝操作。</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123; cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age, <span class="type">int</span> height) &#123;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        m_age = age;</span><br><span class="line">        m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_age = p.m_age;</span><br><span class="line">        m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (m_height != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="type">int</span> *m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/24dbcb6b-8bf2-4091-b3c2-7ad1a254a7b3"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><blockquote><p>如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题。</p></blockquote><h3 id="初始化列表">初始化列表</h3><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造函数(): 属性<span class="number">1</span>(值<span class="number">1</span>),属性<span class="number">2</span>(值<span class="number">2</span>)...&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol type="1"><li>初始化列表是先声明，在调用构造函数时定义并初始化，定义初始化的顺序和声明的顺序一致。</li><li>普通的构造函数是先定义，在赋值。</li></ol></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) : <span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/04c95237-ea87-4a09-a521-71b63a5527c5"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="类对象作为类成员">类对象作为类成员</h3><blockquote><ul><li>类中有多个对象时，构造的顺序是先构造里面的对象，再构造外面的对象。</li><li>类中有多个对象时，析构时顺序是先析构外面的对象，再析构里面的对象。</li></ul></blockquote><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Phone</span>(string name) &#123;</span><br><span class="line">        m_PhoneName = name;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Phone</span>() &#123; cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    string m_PhoneName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, string pName) : <span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123; cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string m_Name;</span><br><span class="line">    Phone m_Phone;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/885cb689-998e-4a26-9819-f934feeb7f43"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="静态成员">静态成员</h3><p>静态成员就是在成员变量和成员函数前加上关键字 <code>static</code>.</p><p>静态成员分为：</p><ul><li>静态成员变量<ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存</li><li>类内声明，类外初始化</li></ul></li><li>静态成员函数<ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul><p><strong>示例 1</strong>：静态成员变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、通过对象</span></span><br><span class="line">    Person p1;</span><br><span class="line">    p1.m_A = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Person p2;</span><br><span class="line">    p2.m_A = <span class="number">200</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="comment">// 共享同一份数据</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、通过类名</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/9c1bb88d-dc1b-4ab3-849f-dd2194512563"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p><strong>示例 2</strong>：静态成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态成员函数特点：</span></span><br><span class="line">    <span class="comment">// 1 程序共享一个函数</span></span><br><span class="line">    <span class="comment">// 2 静态成员函数只能访问静态成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">// 静态成员变量</span></span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 静态成员函数也是有访问权限的</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、通过对象</span></span><br><span class="line">    Person p1;</span><br><span class="line">    p1.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、通过类名</span></span><br><span class="line">    Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Person::func2(); //私有权限访问不到</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/e55aee64-5cfc-4e38-9f26-20a53bfbb223"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="explicit"><code>explicit</code></h3><p><code>explicit</code> 修饰的构造函数不能在隐式转换中使用。</p><h2 id="c对象模型">C++对象模型</h2><h3 id="动态对象创建">动态对象创建</h3><p>使用 <code>malloc</code> 和 <code>free</code>函数去动态申请对象和释放申请的对象，不会调用构造函数和析构函数。</p><p>在 C++ 中建议使用 <code>new</code> 运算符和 <code>delete</code>运算符进行动态对象的申请和释放。</p><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">类型 *p = <span class="keyword">new</span> 构造器;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line">类型 *p = <span class="keyword">new</span> 类型[size];</span><br><span class="line"><span class="keyword">delete</span> []p;</span><br></pre></td></tr></table></figure><blockquote><p>不要 <code>delete</code> 万能指针（<code>void *</code>）</p></blockquote><h3 id="const-修饰的静态成员变量"><code>const</code>修饰的静态成员变量</h3><ul><li><code>const</code>修饰的静态成员变量保存在常量区，只读的，在内存中只有一份</li><li><code>const</code> 修饰的静态成员变量可以在类内定义且初始化</li><li><code>const</code> 修饰的静态成员变量可以通过类的作用域访问</li><li><code>const</code> 修饰的静态成员变量可以通过对象访问</li><li>静态成员函数可以访问 <code>const</code> 修饰的静态成员变量</li></ul><h3 id="成员变量和成员函数分开存储">成员变量和成员函数分开存储</h3><ul><li>普通成员变量占用对象空间大小</li><li>静态成员变量不占用对象空间大小</li><li>普通成员函数不占用对象空间大小</li><li>静态成员函数不占用对象空间大小</li></ul><blockquote><p>在 C++中，类内的成员变量和成员函数分开存储，只有非静态成员变量才属于类的对象上</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123; mA = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mA;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> mB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/aadab981-0981-487a-88b1-340ec574b261"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><blockquote><p>一个对象至少占 1 个字节，要不然获取不到其地址。</p></blockquote><h3 id="this-指针"><code>this</code> 指针</h3><p><code>this</code> 指针是一个指向对象自己的指针。</p><h3 id="空指针访问成员函数">空指针访问成员函数</h3><p>C++ 中空指针也是可以调用成员函数的，但是也要注意有没有用到<code>this</code> 指针。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Person *p = <span class="literal">nullptr</span>;</span><br><span class="line">    p-&gt;<span class="built_in">ShowClassName</span>();</span><br><span class="line">    p-&gt;<span class="built_in">ShowPerson</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/abd55810-bb6d-489d-a4bd-624fc10a4f19"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="const-修饰成员函数"><code>const</code> 修饰成员函数</h3><ul><li>在函数后面加上 <code>const</code>，这个是一个常函数</li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字 <code>mutable</code>后，在常函数中依然可以修改</li></ul><blockquote><p>上述规则对于非成员函数和成员变量也适用。</p></blockquote><h2 id="友元">友元</h2><p>友元可以让一个函数、类或者一个类的成员函数访问另外一个类的私有成员。</p><p>有 3 种友元：</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h3 id="全局函数做友元">全局函数做友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building *building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building *building)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问：&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Building b;</span><br><span class="line">    <span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/0fda622a-9f93-4072-8152-18f3e277150a"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="类做友元">类做友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">goodGay</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>() &#123; building = <span class="keyword">new</span> Building; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问：&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    goodGay gg;</span><br><span class="line">    gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/93e20484-9d59-4566-9c63-30e4e770c3a9"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="成员函数做友元">成员函数做友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">goodGay</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>() &#123; building = <span class="keyword">new</span> Building; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    goodGay gg;</span><br><span class="line">    gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/55166aa2-fa3e-4ba6-b7c2-372e51a1e577"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="继承">继承</h2><p>通过继承机制可以利用已有的数据类型来定义新的数据类型，新的类不仅拥有旧类的成员，还拥有新定义的成员。</p><p>一个 B 类继承于 A 类，或称从类 A 派生类 B。这样的话，类 A 成为基类，类 B 成为派生类</p><p>派生类中的成员，包含两大部分：一类是从基类继承过来的，一类是自己增加的成员。从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p><h3 id="继承的语法">继承的语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类 : 继承方式 基类 &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>C++ 中的成员权限和继承方式：</strong></p><table><colgroup><col style="width: 19%" /><col style="width: 25%" /><col style="width: 28%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th style="text-align: center;">继承方式</th><th style="text-align: center;">基类的 <code>public</code> 成员</th><th style="text-align: center;">基类的 <code>protected</code> 成员</th><th style="text-align: center;">基类的 <code>private</code> 成员</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>public</code> 继承</td><td style="text-align: center;">仍为 <code>public</code> 成员</td><td style="text-align: center;">仍为 <code>protected</code> 成员</td><td style="text-align: center;">不可见</td></tr><tr class="even"><td style="text-align: center;"><code>protected</code> 继承</td><td style="text-align: center;">变为 <code>protected</code> 成员</td><td style="text-align: center;">变为 <code>protected</code> 成员</td><td style="text-align: center;">不可见</td></tr><tr class="odd"><td style="text-align: center;"><code>private</code> 继承</td><td style="text-align: center;">变为 <code>private</code> 成员</td><td style="text-align: center;">变为 <code>private</code> 成员</td><td style="text-align: center;">不可见</td></tr></tbody></table><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; age &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> tail_len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承中的对象模型">继承中的对象模型</h3><p>在 C++编译器的内部可以理解为结构体，子类是由父类成员叠加子类新成员而成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Aclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mA;</span><br><span class="line">    <span class="type">int</span> mB;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bclass</span> : <span class="keyword">public</span> Aclass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mC;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cclass</span> : <span class="keyword">public</span> Bclass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mD;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A size:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Aclass) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;B size:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Bclass) &lt;&lt; endl; <span class="comment">// 12</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C size:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Cclass) &lt;&lt; endl; <span class="comment">// 16</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/e2072c43-3580-4473-b2e0-2ac533b5e38e"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="非自动继承的函数">非自动继承的函数</h3><p>子类不会继承父类的构造函数 、析构函数和 <code>operator=</code>函数。</p><h3 id="继承中构造和析构顺序">继承中构造和析构顺序</h3><p>子类对象在创建时会首先调用父类的构造函数，父类构造函数执行完毕后，才会调用子类的构造函数。</p><p>当父类构造函数有参数时，需要在子类初始化列表中显示调用父类构造函数。</p><p>析构函数调用顺序和构造函数相反。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>() &#123; cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">Son</span>() &#123; cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Son s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/564d4c31-3b73-4e47-9383-96fac5b9c26f"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="继承同名成员处理方式">继承同名成员处理方式</h3><p>如果子类和父类有同名的成员变量和成员函数，继承时，父类的成员变量和成员函数会被隐藏</p><ul><li>访问子类同名成员，直接访问即可</li><li>访问父类同名成员，需要加作用域</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; m_A = <span class="number">100</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>() &#123; m_A = <span class="number">200</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Son s;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">func</span>();</span><br><span class="line">    s.Base::<span class="built_in">func</span>();</span><br><span class="line">    s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/410da135-a8cc-4c9b-92fe-00482ee9a60c"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="继承同名静态成员处理方式">继承同名静态成员处理方式</h3><p>继承时，子类和父类有同名的静态成员函数或静态成员变量，父类中的静态成员函数或静态成员变量会被隐藏。</p><ul><li>访问子类同名成员，直接访问即可</li><li>访问父类同名成员，需要加作用域</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过对象访问：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Son s;</span><br><span class="line">    s.<span class="built_in">func</span>();</span><br><span class="line">    s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过类名访问：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Son::<span class="built_in">func</span>();</span><br><span class="line">    Son::Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/cb7f86e7-b6be-48ad-a9ea-8347a6cd2f3e"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="多继承">多继承</h3><p>C++ 允许<strong>一个类继承多个类</strong></p><p>语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 子类 : 继承方式 父类<span class="number">1</span>, 继承方式 父类<span class="number">2.</span>..</span><br></pre></td></tr></table></figure><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分。</p><blockquote><p>实际开发中不建议使用多继承</p></blockquote><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>() &#123; m_A = <span class="number">100</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>() &#123; m_A = <span class="number">200</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>() &#123;</span><br><span class="line">        m_C = <span class="number">300</span>;</span><br><span class="line">        m_D = <span class="number">400</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">    <span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Son s;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/1f762a21-da8b-409f-a31f-c0d139e57c6c"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="菱形继承">菱形继承</h3><p>菱形继承：两个派生类继承同一个基类，又有某个类同时继承者两个派生类，这种继承被称为菱形继承，或者钻石继承。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SheepTuo st;</span><br><span class="line">    st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">    st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt; st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/ce265823-5977-4432-b125-0e3ca2d8247a"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p><strong>虚继承的实现原理：</strong></p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/2d2be114-5ca3-40c2-ae80-bce2ca22c92d"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="多态">多态</h2><h3 id="多态的基本概念">多态的基本概念</h3><p>多态分为两类：</p><ul><li>静态多态：函数重载和运算符重载属于静态多态，复用函数名</li><li>动态多态：派生类和虚函数实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定：编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定：运行阶段确定函数地址</li></ul><p>多态满足条件：</p><ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul><p>多态使用条件：</p><ul><li>父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型、函数名、参数列表完全一致称为重写。</p><h3 id="纯虚函数和抽象类">纯虚函数和抽象类</h3><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 返回值类型 函数名 （参数列表）= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>当类中有了纯虚函数，这个类也称为抽象类。</p><p><strong>抽象类特点</strong>：</p><ul><li>无法实例化对象。</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类。</li></ul><h3 id="虚析构和纯虚析构">虚析构和纯虚析构</h3><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> ~类名()&#123;&#125;;</span><br></pre></td></tr></table></figure><blockquote><ol type="1"><li>虚析构或纯虚析构用来解决通过父类指针释放子类对象。</li><li>如果子类中没有堆区数据，可以不写为虚析构或纯虚析构。</li><li>拥有纯虚析构函数的类也属于抽象类。</li></ol></blockquote>]]></content>
    
    
    <summary type="html">C++ 的面向对象特性</summary>
    
    
    
    <category term="C++ 基础" scheme="https://xinransix.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C++" scheme="https://xinransix.github.io/tags/C/"/>
    
    <category term="OOP" scheme="https://xinransix.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>运算符重载</title>
    <link href="https://xinransix.github.io/2023/07/16/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <id>https://xinransix.github.io/2023/07/16/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</id>
    <published>2023-07-16T02:40:58.000Z</published>
    <updated>2024-02-10T08:42:30.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运算符重载概述">运算符重载概述</h2><blockquote><p>C++允许在同一作用域中的某个<strong>函数</strong>和<strong>运算符</strong>指定多个定义，分别称为<strong>函数重载</strong>和<strong>运算符重载</strong>。</p><p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</p><p>当您调用一个<strong>重载函数</strong>或<strong>重载运算符</strong>时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为<strong>重载决策</strong>。</p></blockquote><h2 id="可重载运算符-不可重载运算符">可重载运算符 / 不可重载运算符</h2><p>下面是可重载的运算符列表：</p><table><colgroup><col style="width: 18%" /><col style="width: 81%" /></colgroup><thead><tr class="header"><th style="text-align: center;">分类</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">双目算术运算符</td><tdstyle="text-align: center;"><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code></td></tr><tr class="even"><td style="text-align: center;">关系运算符</td><tdstyle="text-align: center;"><code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code></td></tr><tr class="odd"><td style="text-align: center;">逻辑运算符</td><tdstyle="text-align: center;"><code>\|\|</code>、<code>&amp;&amp;</code>、<code>!</code></td></tr><tr class="even"><td style="text-align: center;">单目运算符</td><tdstyle="text-align: center;"><code>+</code>、<code>-</code>、<code>*</code>、<code>&amp;</code></td></tr><tr class="odd"><td style="text-align: center;">自增自减运算符</td><td style="text-align: center;"><code>++</code>、<code>--</code></td></tr><tr class="even"><td style="text-align: center;">位运算符</td><tdstyle="text-align: center;"><code>\|</code>、<code>&amp;</code>、<code>~</code>、<code>^</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code></td></tr><tr class="odd"><td style="text-align: center;">赋值运算符</td><tdstyle="text-align: center;"><code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>&amp;=</code>、<code>\|=</code>、<code>^=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code></td></tr><tr class="even"><td style="text-align: center;">空间申请与释放</td><tdstyle="text-align: center;"><code>new</code>、<code>delete</code>、<code>new[]</code>、<code>delete[]</code></td></tr><tr class="odd"><td style="text-align: center;">其他运算符</td><tdstyle="text-align: center;"><code>()</code>、<code>-&gt;</code>、<code>,</code>、<code>[]</code></td></tr></tbody></table><blockquote><p>C++ 智能指针 <code>-&gt;</code> 运算符。</p></blockquote><p>下面是不可重载的运算符列表：</p><ul><li><code>.</code>：成员访问运算符</li><li><code>.</code>、<code>-*</code>：成员指针访问运算符</li><li><code>::</code>：域运算符</li><li><code>sizeof</code>：长度运算符</li><li><code>?:</code>：条件运算符</li><li><code>#</code>： 预处理符号</li></ul><h2 id="重载运算符的一些规则和建议">重载运算符的一些规则和建议</h2><ol type="1"><li>对于<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>这些双目算术运算符和<code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>这些关系运算符来说，既可以使用成员函数的方式重载，也可以使用非成员函数的方式重载，如果是两个相同类型的相加，如一个<code>Person</code> 类型的数据和另外一个 <code>Person</code>类型的数据相加，则哪种方式都可以；但如果是一个 <code>int</code>类型的数据和 <code>Person</code>类型的数据相加，则要使用非成员函数的方式重载。建议：非成员函数的方式重载。</li><li>对于 <code>+</code>、<code>-</code>这两个单目运算符来说，既可以通过成员函数的方式重载，也可以使用非成员函数的方式重载。建议：非成员函数的方式重载。</li><li>对于 <code>++</code>、<code>--</code>这两个运算符来说，必须通过成员函数的方式重载，对于后置的操作符要有一个占位参数。</li><li>对于 <code>&lt;&lt;</code>、<code>&gt;&gt;</code>这两个流操作运算符来说，必须通过非成员函数的方式重载。</li><li>对于<code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>&amp;=</code>、<code>|=</code>、<code>^=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>这些赋值运算符来说，必须通过非成员函数的方式重载。</li><li><code>()</code>、<code>[]</code>、<code>-&gt;</code>必须通过成员函数重载。</li><li>不要重载<code>||</code>、<code>&amp;&amp;</code>、<code>!</code>、<code>&amp;</code>.</li></ol><h2 id="运算符重载的一些例子">运算符重载的一些例子</h2><h3 id="vec2">vec2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file    :   vec2.h</span></span><br><span class="line"><span class="comment"> * @date    :   2023/06/21 12:11:34</span></span><br><span class="line"><span class="comment"> * @author  :   yaojie</span></span><br><span class="line"><span class="comment"> * @version :   1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> VEC2_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VEC2_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vec2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vec2</span>();</span><br><span class="line">    <span class="built_in">Vec2</span>(<span class="type">double</span> x, <span class="type">double</span> y);</span><br><span class="line">    <span class="built_in">Vec2</span>(<span class="type">const</span> Vec2 &amp;v);</span><br><span class="line">    ~<span class="built_in">Vec2</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vec2 &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Vec2 &amp;v);</span><br><span class="line">    Vec2 &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> Vec2 &amp;v);</span><br><span class="line">    Vec2 &amp;<span class="keyword">operator</span>-=(<span class="type">const</span> Vec2 &amp;v);</span><br><span class="line">    Vec2 &amp;<span class="keyword">operator</span>*=(<span class="type">const</span> Vec2 &amp;v);</span><br><span class="line">    Vec2 &amp;<span class="keyword">operator</span>/=(<span class="type">const</span> Vec2 &amp;v);</span><br><span class="line"></span><br><span class="line">    Vec2 &amp;<span class="keyword">operator</span>+();</span><br><span class="line">    Vec2 <span class="keyword">operator</span>-();</span><br><span class="line">    Vec2 &amp;<span class="keyword">operator</span>++();</span><br><span class="line">    Vec2 <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line">    Vec2 &amp;<span class="keyword">operator</span>--();</span><br><span class="line">    Vec2 <span class="keyword">operator</span>--(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>[](std::<span class="type">size_t</span> idx);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> <span class="keyword">operator</span>[](std::<span class="type">size_t</span> idx) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> Vec2 <span class="keyword">operator</span>+(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2);</span><br><span class="line">    <span class="keyword">friend</span> Vec2 <span class="keyword">operator</span>-(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2);</span><br><span class="line">    <span class="keyword">friend</span> Vec2 <span class="keyword">operator</span>*(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2);</span><br><span class="line">    <span class="keyword">friend</span> Vec2 <span class="keyword">operator</span>/(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="type">const</span> Vec2 &amp;v);</span><br><span class="line">    <span class="keyword">friend</span> std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;is, Vec2 &amp;v);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file    :   vec2.cpp</span></span><br><span class="line"><span class="comment"> * @date    :   2023/06/21 12:29:10</span></span><br><span class="line"><span class="comment"> * @author  :   yaojie</span></span><br><span class="line"><span class="comment"> * @version :   1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vec2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line">Vec2::<span class="built_in">Vec2</span>() : <span class="built_in">x</span>(<span class="number">0</span>), <span class="built_in">y</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Vec2::<span class="built_in">Vec2</span>(<span class="type">double</span> x, <span class="type">double</span> y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Vec2::<span class="built_in">Vec2</span>(<span class="type">const</span> Vec2 &amp;v) &#123;</span><br><span class="line">    x = v.x;</span><br><span class="line">    y = v.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2::~<span class="built_in">Vec2</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Vec2::length</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">fsqrt</span>(x * x + y * y); &#125;</span><br><span class="line"></span><br><span class="line">Vec2 &amp;Vec2::<span class="keyword">operator</span>=(<span class="type">const</span> Vec2 &amp;v) &#123;</span><br><span class="line">    x = v.x;</span><br><span class="line">    y = v.y;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 &amp;Vec2::<span class="keyword">operator</span>+=(<span class="type">const</span> Vec2 &amp;v) &#123;</span><br><span class="line">    x += v.x;</span><br><span class="line">    y += v.y;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 &amp;Vec2::<span class="keyword">operator</span>-=(<span class="type">const</span> Vec2 &amp;v) &#123;</span><br><span class="line">    x -= v.x;</span><br><span class="line">    y -= v.y;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 &amp;Vec2::<span class="keyword">operator</span>*=(<span class="type">const</span> Vec2 &amp;v) &#123;</span><br><span class="line">    x *= v.x;</span><br><span class="line">    y *= v.y;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 &amp;Vec2::<span class="keyword">operator</span>/=(<span class="type">const</span> Vec2 &amp;v) &#123;</span><br><span class="line">    x /= v.x;</span><br><span class="line">    y /= v.y;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 &amp;Vec2::<span class="keyword">operator</span>+() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">Vec2 Vec2::<span class="keyword">operator</span>-() <span class="type">const</span> &#123; <span class="keyword">return</span> Vec2&#123;-x, -y&#125;; &#125;</span><br><span class="line"></span><br><span class="line">Vec2 &amp;Vec2::<span class="keyword">operator</span>++() &#123;</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">    y = y + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 Vec2::<span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    Vec2 tmp&#123;x, y&#125;;</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">    y = y + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 &amp;Vec2::<span class="keyword">operator</span>--() &#123;</span><br><span class="line">    x = x - <span class="number">1</span>;</span><br><span class="line">    y = y - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 Vec2::<span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">    Vec2 tmp&#123;x, y&#125;;</span><br><span class="line">    x = x - <span class="number">1</span>;</span><br><span class="line">    y = y - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 <span class="keyword">operator</span>+(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;v1.x + v2.x, v2.x + v2.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 <span class="keyword">operator</span>-(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;v1.x - v2.x, v2.x - v2.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 <span class="keyword">operator</span>*(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;v1.x * v2.x, v2.x * v2.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 <span class="keyword">operator</span>/(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;v1.x / v2.x, v2.x / v2.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(v1.x - v2.x) &lt; <span class="number">0.01</span> &amp;&amp; <span class="built_in">fabs</span>(v1.y - v2.y) &lt; <span class="number">0.01</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2) &#123; <span class="keyword">return</span> !(v1 == v2); &#125;</span><br><span class="line"></span><br><span class="line">std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="type">const</span> Vec2 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; v.x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;is, Vec2 &amp;v) &#123;</span><br><span class="line">    is &gt;&gt; v.x &gt;&gt; v.y;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Vec2::<span class="keyword">operator</span>[](std::<span class="type">size_t</span> idx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;下标越界&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Vec2::<span class="keyword">operator</span>[](std::<span class="type">size_t</span> idx) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;下标越界&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="int">Int</h3><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @FileName       : Int.h</span></span><br><span class="line"><span class="comment"> * @Author         : yaojie</span></span><br><span class="line"><span class="comment"> * @Date           : 2023/6/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Int</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Int();</span><br><span class="line"></span><br><span class="line">    Int(<span class="type">int</span> val);</span><br><span class="line"></span><br><span class="line">    Int(<span class="type">const</span> Int &amp;i);</span><br><span class="line"></span><br><span class="line">    ~Int();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Int &amp;operator+();</span><br><span class="line">    Int operator-();</span><br><span class="line"></span><br><span class="line">    Int &amp;operator++();</span><br><span class="line">    Int operator++(<span class="type">int</span>);</span><br><span class="line">    Int &amp;operator--();</span><br><span class="line">    Int operator--(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    Int &amp;operator=(<span class="type">const</span> Int &amp;i);</span><br><span class="line">    Int &amp;operator+=(<span class="type">const</span> Int &amp;i);</span><br><span class="line">    Int &amp;operator-=(<span class="type">const</span> Int &amp;i);</span><br><span class="line">    Int &amp;operator*=(<span class="type">const</span> Int &amp;i);</span><br><span class="line">    Int &amp;operator/=(<span class="type">const</span> Int &amp;i);</span><br><span class="line">    Int &amp;operator%=(<span class="type">const</span> Int &amp;i);</span><br><span class="line"></span><br><span class="line">    friend Int operator+(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b);</span><br><span class="line">    friend Int operator-(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b);</span><br><span class="line">    friend Int operator*(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b);</span><br><span class="line">    friend Int operator/(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b);</span><br><span class="line">    friend Int operator%(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b);</span><br><span class="line"></span><br><span class="line">    friend <span class="type">bool</span> operator==(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b);</span><br><span class="line">    friend <span class="type">bool</span> operator!=(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b);</span><br><span class="line">    friend <span class="type">bool</span> operator&gt;(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b);</span><br><span class="line">    friend <span class="type">bool</span> operator&lt;(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b);</span><br><span class="line">    friend <span class="type">bool</span> operator&gt;=(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b);</span><br><span class="line">    friend <span class="type">bool</span> operator&lt;=(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b);</span><br><span class="line"></span><br><span class="line">    friend <span class="built_in">std</span>::ostream &amp;operator&lt;&lt;(<span class="built_in">std</span>::ostream &amp;os, <span class="type">const</span> Int i);</span><br><span class="line">    friend <span class="built_in">std</span>::istream &amp;operator&gt;&gt;(<span class="built_in">std</span>::istream &amp;is, Int i);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// INT_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @FileName       : Int.cpp</span></span><br><span class="line"><span class="comment"> * @Author         : yaojie</span></span><br><span class="line"><span class="comment"> * @Date           : 2023/6/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Int.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Int::<span class="built_in">Int</span>() : <span class="built_in">Int</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Int::<span class="built_in">Int</span>(<span class="type">int</span> val) : <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Int::<span class="built_in">Int</span>(<span class="type">const</span> Int &amp;i) &#123; <span class="keyword">this</span>-&gt;val = i.val; &#125;</span><br><span class="line"></span><br><span class="line">Int::~<span class="built_in">Int</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Int &amp;Int::<span class="keyword">operator</span>+() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">Int Int::<span class="keyword">operator</span>-() &#123; <span class="keyword">return</span> &#123;-<span class="keyword">this</span>-&gt;val&#125;; &#125;</span><br><span class="line"></span><br><span class="line">Int &amp;Int::<span class="keyword">operator</span>++() &#123;</span><br><span class="line">    ++<span class="keyword">this</span>-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Int Int::<span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    Int tmp&#123;<span class="keyword">this</span>-&gt;val&#125;;</span><br><span class="line">    <span class="keyword">this</span>-&gt;val++;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Int &amp;Int::<span class="keyword">operator</span>--() &#123;</span><br><span class="line">    --<span class="keyword">this</span>-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Int Int::<span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">    Int tmp&#123;<span class="keyword">this</span>-&gt;val&#125;;</span><br><span class="line">    <span class="keyword">this</span>-&gt;val--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Int &amp;Int::<span class="keyword">operator</span>=(<span class="type">const</span> Int &amp;i) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;val = i.val;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Int &amp;Int::<span class="keyword">operator</span>+=(<span class="type">const</span> Int &amp;i) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;val += i.val;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Int &amp;Int::<span class="keyword">operator</span>-=(<span class="type">const</span> Int &amp;i) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;val -= i.val;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Int &amp;Int::<span class="keyword">operator</span>*=(<span class="type">const</span> Int &amp;i) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;val *= i.val;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Int &amp;Int::<span class="keyword">operator</span>/=(<span class="type">const</span> Int &amp;i) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;val /= i.val;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Int &amp;Int::<span class="keyword">operator</span>%=(<span class="type">const</span> Int &amp;i) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;val %= i.val;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Int <span class="keyword">operator</span>+(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b) &#123; <span class="keyword">return</span> &#123;a.val + b.val&#125;; &#125;</span><br><span class="line">Int <span class="keyword">operator</span>-(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b) &#123; <span class="keyword">return</span> &#123;a.val - b.val&#125;; &#125;</span><br><span class="line">Int <span class="keyword">operator</span>*(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b) &#123; <span class="keyword">return</span> &#123;a.val * b.val&#125;; &#125;</span><br><span class="line">Int <span class="keyword">operator</span>/(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b) &#123; <span class="keyword">return</span> &#123;a.val / b.val&#125;; &#125;</span><br><span class="line">Int <span class="keyword">operator</span>%(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b) &#123; <span class="keyword">return</span> &#123;a.val % b.val&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b) &#123; <span class="keyword">return</span> a.val == b.val; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b) &#123; <span class="keyword">return</span> a.val != b.val; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b) &#123; <span class="keyword">return</span> a.val &gt; b.val; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b) &#123; <span class="keyword">return</span> a.val &lt; b.val; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b) &#123; <span class="keyword">return</span> a.val &gt;= b.val; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b) &#123; <span class="keyword">return</span> a.val &lt;= b.val; &#125;</span><br><span class="line"></span><br><span class="line">std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="type">const</span> Int i) &#123; <span class="keyword">return</span> os &lt;&lt; i.val; &#125;</span><br><span class="line">std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;is, Int i) &#123; <span class="keyword">return</span> is &gt;&gt; i.val; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><ul><li><a href="https://www.runoob.com/cplusplus/cpp-overloading.html">C++重载运算符和重载函数 | 菜鸟教程</a></li><li>C++ Primer</li></ul>]]></content>
    
    
    <summary type="html">运算符重载相关要求和建议</summary>
    
    
    
    <category term="C++ 基础" scheme="https://xinransix.github.io/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C++" scheme="https://xinransix.github.io/tags/C/"/>
    
    <category term="运算符重载" scheme="https://xinransix.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>文件</title>
    <link href="https://xinransix.github.io/2023/07/16/%E6%96%87%E4%BB%B6/"/>
    <id>https://xinransix.github.io/2023/07/16/%E6%96%87%E4%BB%B6/</id>
    <published>2023-07-16T02:38:34.000Z</published>
    <updated>2024-02-10T08:44:47.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件的概念">文件的概念</h2><h3 id="文件的定义">文件的定义</h3><p>磁盘文件：指一组相关数据的有序集合，通常存储在外部介质上，使用时才调入内存。</p><p>设备文件：在操作系统中把每一个与主机相连的输入、输出设备看作是一个文件，把它们的输入、输出等同于对磁盘文件的读和写。</p><p>在 Linux 操作系统中，每一个外部设备都在 /dev目录下对应着一个设备文件，在程序中操作设备，就必须对与其对应的 /dev下的设备文件进行操作。</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/3ec4f64e-8ecb-4f5f-9f2a-848f55c1e693"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>我就豁出去是库函数申请的一段内存，由库函数对其进行操作，程序员没有必要找到存放在哪里，只需要知道对文件操作时的一些缓冲特点即可。</p><p><strong>行缓冲：</strong></p><p>标准 IO 库函数，往标准输出输出东西时是行缓冲的。</p><p>所谓行缓冲就是缓冲区碰到换行符时才刷新缓冲区。。</p><p>如果不刷新缓冲区，无法对文件进行读写操作。</p><p>行缓冲的刷新条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 由于printf函数是一个标准io，所以只有刷新缓冲区才可以将数据输出到终端</span></span><br><span class="line">    <span class="comment">// printf(&quot;hello world&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新缓冲区方法1：使用\n</span></span><br><span class="line">    <span class="comment">// printf(&quot;hello world\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新缓冲区方法2：程序正常结束</span></span><br><span class="line">    <span class="comment">// printf(&quot;hello world&quot;);</span></span><br><span class="line">    <span class="comment">// return 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新缓冲区方法3：使用fflush函数刷新缓冲区</span></span><br><span class="line">    <span class="comment">// printf(&quot;hello world&quot;);</span></span><br><span class="line">    <span class="comment">// fflush：刷新函数。可以刷新指定的缓冲区</span></span><br><span class="line">    <span class="comment">// stdout：标准输出，就是对终端进行写操作</span></span><br><span class="line">    <span class="comment">// fflush(stdout);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新缓冲区方法4：当缓冲区满的时候自动刷新</span></span><br><span class="line">    <span class="comment">// 默认行缓冲的大小为1024个字节</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%03d &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>全缓冲：</strong></p><p>标准 IO库函数，往普通文件读写数据时，是全缓冲的，碰到换行符也不刷新缓冲区，只有缓冲区满了才刷新缓冲区。</p><p>刷新缓冲区的情况：</p><ol type="1"><li>缓冲区满了，刷新缓冲区；</li><li>使用 <code>fflush</code> 函数刷新缓冲区。</li><li>程序正常结束，刷新缓冲区。</li></ol><p><strong>无缓冲：</strong></p><p>在读写文件时通过系统调用 IO对文件进行读写操作，这个时候是无缓冲的，即写数据会立马进入文件，读数据会立马进入内存。</p><p><strong>写文件的流程：</strong></p><p>应用程序空间-&gt;内核空间-&gt;驱动程序-&gt;硬盘</p><p>应用程序和内核程序运行在不同的空间里，目的是为了保护内核。</p><blockquote><p>设置缓存区可以减少进出内核的次数，提高效率。</p></blockquote><h3 id="磁盘文件的分类">磁盘文件的分类</h3><p>一个文件通常是磁盘上一段命名的存储区，计算机的存储在物理上是二进制的。</p><p>物理上所有的磁盘文件本质上都是一样的：以字节为单位进行顺序存储。</p><p>从用户或者操作系统的角度来说把文件分为：</p><ul><li>文本文件：基于字符编码的文件；</li><li>二进制文件：基于值编码的文件。</li></ul><p><strong>文本文件、二进制文件对比：</strong></p><p>译码：文本文件基于字符，译码容易些；二进制文件编码是边长的，译码难一些。（不同的二进制文件有不同的编码方式）</p><p>空间利用率：二进制文件的基本单位是bit，而文本文件的基本单位是字符，所有二进制文件的空间利用率高。</p><p>可读性：文本文件可以用记事本的等软件阅读，二进制文件需要用特定的译码器。</p><h2 id="文件指针">文件指针</h2><p>文件指针用来标识一个文件，所有对文件的操作都是通过对文件指针来完成的。</p><p>定义文件指针的语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *指针名;</span><br></pre></td></tr></table></figure><p>文件指针是一个结构体指针，结构体中包含了与文件相关的很多信息，但在编程时无需结构体的成员，只需使用文件指针即可。</p><p><strong>对文件操作的步骤：</strong></p><ol type="1"><li>对文件进行读写等操作之前要打开文件得到文件指针；</li><li>通过文件指针对文件进行读写操作；</li><li>操作结束后，要关闭文件，关闭文件后，就不能再通过此文件指针对文件进行操作了。</li></ol><p><strong>C 语言中有三个定义好的特殊文件指针：</strong></p><ol type="1"><li><code>stdin</code>：标准输入，使用<code>scanf</code>、<code>getchar</code> 函数默认从 <code>stdin</code>中输入；</li><li><code>stdout</code>：标准输出，使用<code>printf</code>、<code>puts</code> 函数默认输出到<code>stdout</code>；</li><li><code>stderr</code>：标准错误输出，使用 <code>perror</code>函数默认输出到 <code>stderr</code>.</li></ol><h2 id="打开文件-fopen">打开文件 <code>fopen</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line">功能：创建或者打开一个文件</span><br><span class="line">参数：</span><br><span class="line">    path：文件名，如果只写文件名，默认就是当前路径，也可以添加路径</span><br><span class="line">    mode：文件权限</span><br><span class="line">        r 只读，如果文件不存在则报错</span><br><span class="line">        r+ 读写，如果文件不存在则报错</span><br><span class="line">        w 只写，如果文件不存在则创建，如果文件存在则清空</span><br><span class="line">        w+ 读写，如果文件不存在则创建，如果文件存在则清空</span><br><span class="line">        a 只写，如果文件不存在则创建，如果文件存在则追加</span><br><span class="line">        a+ 读写，如果文件不存在则创建，如果文件存在则追加</span><br><span class="line">返回值：</span><br><span class="line">    成功：文件指针</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;./file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to fopen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关闭文件-fclose">关闭文件 <code>fclose</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *stream)</span>;</span><br><span class="line">功能：关闭一个文件指针，无法在对当前文件进行操作</span><br><span class="line">参数：</span><br><span class="line">    stream：指定的文件指针，fopen函数的返回值</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：EOF</span><br><span class="line">注意：注意一个文件只能关闭一次，不能多次关闭。</span><br><span class="line">关闭文件之后就不能再文件指针对文件进行读写等操作了</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;./file.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to fopen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一次读写一个字符">一次读写一个字符</h2><h3 id="fgetc"><code>fgetc</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line">功能：从文件指针标识的文件中读取一个字符</span><br><span class="line">参数：</span><br><span class="line">    stream：指定的文件指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：读取的字符</span><br><span class="line">    失败：EOF</span><br><span class="line">如果文件读取完毕，也会返回EOF</span><br></pre></td></tr></table></figure><p>文件内容：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/db2f7510-086a-4a50-866b-0e4a0eedbb0e"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;./file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to fopen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = fgetc(fp)) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;c = [%c] - %d\n&quot;</span>, c, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/704fa56c-97ab-47b3-8421-67913d928911"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="fputc"><code>fputc</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br><span class="line">功能：向文件指针标识的文件中写入一个字符</span><br><span class="line">参数：</span><br><span class="line">    c：要写入的字符</span><br><span class="line">    stream：指定的文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：要写入的字符</span><br><span class="line">    失败：EOF</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;./file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to fopen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fputc(<span class="string">&#x27;w&#x27;</span>, fp);</span><br><span class="line">    fputc(<span class="string">&#x27;h&#x27;</span>, fp);</span><br><span class="line">    fputc(<span class="string">&#x27;a&#x27;</span>, fp);</span><br><span class="line">    fputc(<span class="string">&#x27;t&#x27;</span>, fp);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, fp);</span><br><span class="line">    fputc(<span class="string">&#x27;o&#x27;</span>, fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/9359f70e-e6cd-4451-a976-6956ca7eac05"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="一次读写一个字符串">一次读写一个字符串</h2><h3 id="fgets"><code>fgets</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> size, FILE *stream)</span>;</span><br><span class="line">功能：从文件中读取内容</span><br><span class="line">参数：</span><br><span class="line">    s：保存读取到的内容</span><br><span class="line">    size：每次读取的最大个数</span><br><span class="line">    stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：读取的数据的首地址</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br><span class="line">    如果文件内容读取完毕，也返回<span class="literal">NULL</span></span><br><span class="line">注意：从stream所指的文件中读取字符，在读取的时候碰到换行符或者是碰到文件的末尾停止读取，或者是读取了size‐<span class="number">1</span>个字节停止读取，在读取的内容后面会加一个\<span class="number">0</span>,作为字符串的结尾</span><br></pre></td></tr></table></figure><p>文件内容：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/bc68401f-ebaf-49a2-9ac4-1d5572b0829a"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;./file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to fopen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    fgets(buf, <span class="number">32</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/408b3cc0-d479-49ba-9140-d2a55b6836ca"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="fputs"><code>fputs</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, FILE *stream)</span>;</span><br><span class="line">功能：向文件写入数据</span><br><span class="line">参数：</span><br><span class="line">    s：要写入的内容</span><br><span class="line">    stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：写入文件内容的字节数</span><br><span class="line">    失败：EOF</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;./file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to fopen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;66666666666666\n&quot;</span>, fp);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;nihao&quot;</span>, fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/e91690c0-d36e-4b12-a405-a2f6c4466460"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="读文件-fread">读文件 <code>fread</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line">功能：从文件中读取数据</span><br><span class="line">参数：</span><br><span class="line">    ptr：保存读取的数据</span><br><span class="line">    size：每次读取的字节数</span><br><span class="line">    nmemb：一共读取的次数</span><br><span class="line">    stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：实际读取的次数（对象数、块数）</span><br><span class="line">    失败：<span class="number">0</span></span><br><span class="line">    如果文件内容读取完毕，返回<span class="number">0</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = fread(str,<span class="number">100</span>,<span class="number">3</span>,fp);</span><br><span class="line">从fp所代表的文件中读取内容存放到str指向的内存中，读取的字节数为 ，每块<span class="number">100</span>个字节，<span class="number">3</span>块。</span><br><span class="line">返回值num，如果读到<span class="number">300</span>个字节返回值num为<span class="number">3</span></span><br><span class="line">如果读到了大于等于<span class="number">200</span>个字节小于<span class="number">300</span>个字节 返回值为<span class="number">2</span></span><br><span class="line">读到的字节数，大于等于<span class="number">100</span>个字节小于<span class="number">200</span>个字节 返回<span class="number">1</span></span><br><span class="line">不到<span class="number">100</span>个字节返回<span class="number">0</span></span><br></pre></td></tr></table></figure><p>文件内容：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/8f7a09bb-0e48-4d41-b33c-f68cc156d116"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(<span class="string">&quot;./file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to fopen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    num = fread(buf, <span class="number">5</span>, <span class="number">4</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/9d0e4d82-9950-4f1a-a57f-5a15e783c1c4"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="写文件-fwrite">写文件 <code>fwrite</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line">功能：向文件中写入数据</span><br><span class="line">参数：</span><br><span class="line">    ptr：要写入的数据</span><br><span class="line">    size：一次写入的字节数</span><br><span class="line">    nmemb：一共写入的次数</span><br><span class="line">    stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：实际写入的次数</span><br><span class="line">    失败：<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125; MSG;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;./file.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to fopen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MSG msg[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="string">&#x27;c&#x27;</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">    fwrite(msg, <span class="keyword">sizeof</span>(MSG), <span class="number">4</span>, fp);</span><br><span class="line">    rewind(fp);</span><br><span class="line">    MSG rcv[<span class="number">4</span>];</span><br><span class="line">    fread(rcv, <span class="keyword">sizeof</span>(MSG), <span class="number">4</span>, fp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d - %d - %c\n&quot;</span>, rcv[i].a, rcv[i].b, rcv[i].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/8189a143-ca58-4d92-9784-c178e2fbf695"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>输出的文件内容：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/09f49c19-e832-485a-ac93-7abe4ab65327"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="格式化读写文件函数">格式化读写文件函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">函数调用:</span><br><span class="line"><span class="built_in">fprintf</span>(文件指针, 格式字符串, 输出表列);</span><br><span class="line"><span class="built_in">fscanf</span>(文件指针, 格式字符串, 输入表列);</span><br><span class="line"></span><br><span class="line">函数功能:</span><br><span class="line">    从磁盘文件中读入或输出字符</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span> 和<span class="built_in">printf</span>函数类似：</span><br><span class="line"><span class="built_in">printf</span>是将数据输出到屏幕上（标准输出），</span><br><span class="line"><span class="built_in">fprintf</span>函数是将数据输出到文件指针所指定的文件中。</span><br><span class="line"></span><br><span class="line"><span class="built_in">fscanf</span>和<span class="built_in">scanf</span> 函数类似：</span><br><span class="line"><span class="built_in">scanf</span>是从键盘（标准输入）获取输入，</span><br><span class="line"><span class="built_in">fscanf</span>是从文件指针所标示的文件中获取输入。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> ch1 = <span class="string">&#x27;a&#x27;</span>, ch2;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">50</span>, num2;</span><br><span class="line">    <span class="type">char</span> string1[<span class="number">20</span>] = <span class="string">&quot;hello&quot;</span>, string2[<span class="number">20</span>];</span><br><span class="line">    <span class="type">float</span> score1 = <span class="number">85.5</span>, score2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">&quot;./file.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to fopen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%c %d %s %f\n&quot;</span>, ch1, num1, string1, score1);</span><br><span class="line">    rewind(fp);</span><br><span class="line">    <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%c %d %s %f\n&quot;</span>, &amp;ch2, &amp;num2, string2, &amp;score2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c %d %s %f\n&quot;</span>, ch2, num2, string2, score2);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/1d4ce40b-4ea8-42b1-b3e2-8492e3d2a93c"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>文件内容：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/6679d044-3000-4abc-b795-44e9b47758f4"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="随机读写">随机读写</h2><h3 id="rewind"><code>rewind</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE *stream)</span>;</span><br><span class="line">    功能：将文件位置定位到起始位置</span><br><span class="line">参数：</span><br><span class="line">    stream：文件指针</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure><h3 id="ftell"><code>ftell</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br><span class="line">功能：获取当前文件的偏移量</span><br><span class="line">参数：</span><br><span class="line">    stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">    获取当前文件的偏移量</span><br></pre></td></tr></table></figure><h3 id="fseek"><code>fseek</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line">功能：设置文件位置指针的偏移量</span><br><span class="line">参数：</span><br><span class="line">    stream：文件指针</span><br><span class="line">    offset：偏移量，可正可负也可为<span class="number">0</span></span><br><span class="line">    whence：相对位置</span><br><span class="line">        SEEK_SET 文件起始位置</span><br><span class="line">        SEEK_CUR 文件当前位置</span><br><span class="line">        SEEK_END 文件末尾位置（最后一个字符后面一个位置）</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：‐<span class="number">1</span></span><br><span class="line"></span><br><span class="line">rewind(fp) &lt;==&gt; fseek(fp, <span class="number">0</span>, SEEK_SET);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">&quot;./file.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to fopen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;123456789\n&quot;</span>, fp);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;abcdefghijklmn&quot;</span>, fp);</span><br><span class="line">    <span class="comment">// 获取当前文件指针的读写位置</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;offset = %ld\n&quot;</span>, ftell(fp));</span><br><span class="line">    <span class="comment">// 将当前文件的读写文件设置到文件的起始位置</span></span><br><span class="line">    <span class="comment">// rewind(fp);</span></span><br><span class="line">    <span class="comment">// fseek(fp, 0, SEEK_SET);</span></span><br><span class="line">    <span class="comment">// 将当前文件的读写位置设置为倒数第五个位置</span></span><br><span class="line">    fseek(fp, <span class="number">-5</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, <span class="number">32</span>, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%s]\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/ed85fbcf-ec37-4964-8754-958e588e4e77"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>文件内容：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/66b1da96-8dc3-4818-a30a-83bb46e30029"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure>]]></content>
    
    
    <summary type="html">介绍 C 语言中对文件的操作</summary>
    
    
    
    <category term="C 语言基础" scheme="https://xinransix.github.io/categories/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C" scheme="https://xinransix.github.io/tags/C/"/>
    
    <category term="文件" scheme="https://xinransix.github.io/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>结构体、共用体、枚举</title>
    <link href="https://xinransix.github.io/2023/07/16/%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E5%85%B1%E7%94%A8%E4%BD%93%E3%80%81%E6%9E%9A%E4%B8%BE/"/>
    <id>https://xinransix.github.io/2023/07/16/%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E5%85%B1%E7%94%A8%E4%BD%93%E3%80%81%E6%9E%9A%E4%B8%BE/</id>
    <published>2023-07-16T02:37:29.000Z</published>
    <updated>2024-02-10T08:43:47.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结构体类型的概念及定义">结构体类型的概念及定义</h2><p>构造类型：不是基本类型的数据结构也不是指针，它是若干个相同或不同类型的数据构成的集合，常用的构造类型有数组、结构体、共用体。</p><p>数组用于保存多个相同类型的数据。</p><p>结构体用于保存多个不同类型的数据。</p><h3 id="结构体的概念">结构体的概念</h3><p>结构体是一种构造类型的数据结构。</p><p>是一种或多种基本类型或构造类型的数据的集合。</p><h3 id="结构体类型的定义">结构体类型的定义</h3><h4id="先定义结构体类型再去定义结构体变量">先定义结构体类型，再去定义结构体变量</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 &#123;</span></span><br><span class="line">    成员;</span><br><span class="line">&#125; 结构体变量<span class="number">1</span>, 结构体变量<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 变量3, 变量4;</span></span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125; lucy, bob, lilei;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">xiaohong</span>, <span class="title">xiaoming</span>;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：一般在全局定义结构体。</p></blockquote><h4 id="无名结构体的定义">无名结构体的定义</h4><p>在定义结构体类型的时候，没有结构体类型名，顺便定义结构体变量，因为没有类型名，所以以后不能再定义相关类型的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    成员列表;</span><br><span class="line">&#125; 变量<span class="number">1</span>, 变量<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125; lucy, bob;</span><br></pre></td></tr></table></figure><h4 id="给结构体类型取别名">给结构体类型取别名</h4><p>这是经常做的事情。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> 结构体名 &#123;</span></span><br><span class="line">    成员列表;</span><br><span class="line">&#125; 别名;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>typedef</code>给结构体起了一个别名，在使用别名定义结构体变量变量时不要加上<code>strcut</code>.</p></blockquote><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125; STU;</span><br></pre></td></tr></table></figure><p><code>STU lucy;</code> 和 <code>struct stu;</code> 是等价的。</p><h2 id="结构体变量的定义初始化及使用">结构体变量的定义初始化及使用</h2><h3 id="结构体变量的定义和初始化">结构体变量的定义和初始化</h3><p>结构体变量，是个变量，这个变量是若干个数据的集合。</p><ol type="1"><li>在定义结构体变量之前首先得有结构体类型。</li><li>在定义结构体变量的时候，可以顺便给结构体变量赋初值。</li><li>结构体变量初始化的时候，各个成员顺序初始化。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 定义结构体变量之定义结构体类型的同时定义结构体变量</span></span><br><span class="line">&#125; zhangsan, lisi = &#123;<span class="number">1002</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用typedef对结构体类型取别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125; MSG;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 定义结构体变量之类型定义完毕之后定义变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">wangwu</span>;</span></span><br><span class="line">    <span class="comment">// 结构体变量的初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">zhaoliu</span> =</span> &#123;<span class="number">1001</span>, <span class="string">&quot;赵六&quot;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    <span class="comment">// 如果使用typedef对结构体类型取别名</span></span><br><span class="line">    <span class="comment">// 就无法在定义类型的同时定义结构体变量</span></span><br><span class="line">    <span class="comment">// 在定义结构体变量的时候不用加struct</span></span><br><span class="line">    MSG msg1, msg2 = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="string">&#x27;w&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体变量的使用">结构体变量的使用</h3><p>结构体变量对成员调用的方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结构体变量.结构体成员</span><br></pre></td></tr></table></figure><p><strong>结构体变量的简单使用：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125; zhangsan, lisi = &#123;<span class="number">1002</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125; MSG;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">wangwu</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">zhaoliu</span> =</span> &#123;<span class="number">1001</span>, <span class="string">&quot;赵六&quot;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    MSG msg1, msg2 = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="string">&#x27;w&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">// 结构体变量的使用</span></span><br><span class="line">    zhangsan.id = <span class="number">1001</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(zhangsan.name, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    zhangsan.sex = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    zhangsan.age = <span class="number">18</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d - %s - %c - %d\n&quot;</span>, zhangsan.id, zhangsan.name, zhangsan.sex,</span><br><span class="line">           zhangsan.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d - %s - %c - %d\n&quot;</span>, lisi.id, lisi.name, lisi.sex, lisi.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d - %s - %c - %d\n&quot;</span>, zhaoliu.id, zhaoliu.name, zhaoliu.sex,</span><br><span class="line">           zhaoliu.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d - %d - %c\n&quot;</span>, msg2.a, msg2.b, msg2.c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/59fbf612-ec92-45ae-ad17-8968adc14597"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p><strong>在结构体中嵌套结构体：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在结构体中嵌套结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125; BD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    BD birthday;</span><br><span class="line">&#125; STU;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    STU xiaoming;</span><br><span class="line">    xiaoming.id = <span class="number">1001</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(xiaoming.name, <span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果结构体中嵌套结构体，赋值时找到最内层的成员再进行赋值</span></span><br><span class="line">    xiaoming.birthday.year = <span class="number">2002</span>;</span><br><span class="line">    xiaoming.birthday.month = <span class="number">12</span>;</span><br><span class="line">    xiaoming.birthday.day = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d - %s - %d-%d-%d\n&quot;</span>, xiaoming.id, xiaoming.name,</span><br><span class="line">           xiaoming.birthday.year, xiaoming.birthday.month,</span><br><span class="line">           xiaoming.birthday.day);</span><br><span class="line">    <span class="comment">// 嵌套的形式定义并初始化</span></span><br><span class="line">    STU xiaoli = &#123;<span class="number">1002</span>, <span class="string">&quot;小丽&quot;</span>, <span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d - %s - %d-%d-%d\n&quot;</span>, xiaoli.id, xiaoli.name, xiaoli.birthday.year,</span><br><span class="line">           xiaoli.birthday.month, xiaoli.birthday.day);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/0ba410eb-be6c-4b95-bd0f-c63e11d2576c"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3id="相同类型的结构体变量可以相互赋值">相同类型的结构体变量可以相互赋值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">zhangsan</span>;</span></span><br><span class="line">    zhangsan.id = <span class="number">1001</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(zhangsan.name, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    zhangsan.sex = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    zhangsan.age = <span class="number">18</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d - %s - %c - %d\n&quot;</span>, zhangsan.id, zhangsan.name, zhangsan.sex,</span><br><span class="line">           zhangsan.age);</span><br><span class="line">    <span class="comment">// 相同类型的结构体变量之间可以直接赋值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">lisi</span>;</span></span><br><span class="line">    lisi = zhangsan;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d - %s - %c - %d\n&quot;</span>, lisi.id, lisi.name, lisi.sex, lisi.age);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/1600c6a0-551c-4545-be40-833e838c7f9c"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="结构体数组">结构体数组</h2><blockquote><p>结构体数组是个数组，由若干个相同类型的结构体变量构成的集合。</p></blockquote><p><strong>结构体数组的定义方法：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体类型名 数组名[元素个数];</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">edu</span>[3];</span></span><br></pre></td></tr></table></figure><p><strong>结构体数组元素的引用：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名[索引];</span><br></pre></td></tr></table></figure><p>结构体数组元素对成员的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名[索引].成员</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125; STU;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个结构体数组</span></span><br><span class="line">    STU edu[<span class="number">3</span>] = &#123;&#123;<span class="number">101</span>, <span class="string">&quot;Lucy&quot;</span>, <span class="number">78</span>&#125;, &#123;<span class="number">102</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">59.5</span>&#125;, &#123;<span class="number">103</span>, <span class="string">&quot;Tom&quot;</span>, <span class="number">85</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">// 输出结构体数组中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d - %s - %.2f\n&quot;</span>, edu[j].num, edu[j].name, edu[j].score);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        sum += edu[i].score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;平均成绩为%.2f\n&quot;</span>, sum / <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/e33e0370-4391-488e-9a46-546671d78fca"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="结构体指针">结构体指针</h2><p>结构体的地址，结构体变量存放内存中，也有起始地址。</p><p><strong>结构体指针变量的定义方法：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 *指针名;</span></span><br></pre></td></tr></table></figure><p><strong>结构体指针变量对成员的引用：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*结构体指针变量名).成员</span><br><span class="line">结构体指针变量名‐&gt;成员</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个结构体指针变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">s</span>;</span></span><br><span class="line">    <span class="comment">// 在堆区开辟结构体空间并将其地址保存在结构体指针变量中</span></span><br><span class="line">    s = (<span class="keyword">struct</span> stu *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> stu));</span><br><span class="line">    s-&gt;id = <span class="number">1001</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(s-&gt;name, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    s-&gt;sex = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    s-&gt;age = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d - %s - %c - %d\n&quot;</span>, s-&gt;id, s-&gt;name, s-&gt;sex, s-&gt;age);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/deee6855-afbc-410a-a566-81459db4dab9"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="结构体内存分配问题">结构体内存分配问题</h2><p><strong>规则 1：以多少个字节为单位开辟内存</strong></p><p>为结构体变量分配内存时，先去找结构体的基本数据类型，找到占用字节数最大的那个类型，以它为基准开辟空间。</p><ol type="1"><li>成员中只有 <code>char</code> 类型，以 1 字节为单位开辟空间。</li><li>成员中出现了 <code>short</code> 类型，没有更大的基本数据类型，以 2个字节为单位开辟内存。</li><li>出现了<code>int</code>、<code>float</code>，没有更大字节的基本数据类型，以 4个字节为单位开辟内存。</li><li>出现了 <code>double</code><ol type="1"><li>在 <code>msvc</code> 中，以 8 个字节为单位开辟空间。</li><li>在 <code>gcc</code> 中，以 4 字节为得开辟空间。</li></ol></li></ol><p><strong>规则 2：字节对齐</strong></p><ol type="1"><li><code>char</code>：1 字节对齐，即存放 <code>char</code>类型的变量的地址是 1 的倍数。</li><li><code>short</code>：2 字节对齐，即存放 <code>short</code>类型的变量的地址是 2 的倍数。</li><li><code>int</code>：4 字节对齐，即存放 <code>int</code>类型的变量的地址是 4 的倍数。</li><li><code>long</code>：在 32 位的操作系统中，4 字节对齐，即存放<code>long</code> 类型的变量的地址是 4 的倍数。</li><li><code>float</code>：4 字节对齐，即存放 <code>float</code>类型的变量的地址是 4 的倍数。</li><li><code>double</code>：<ol type="1"><li>在 <code>msvc</code> 中，8 字节对齐，即存放 <code>double</code>类型的变量的地址是 8 的倍数。</li><li>在 <code>gcc</code> 中，4 字节对齐，即存放 <code>double</code>类型的变量的地址是 4 的倍数。</li></ol></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125; lucy; <span class="comment">// 8字节</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125; lucy; <span class="comment">// 8字节</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125; temp; <span class="comment">// 8字节</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> b;</span><br><span class="line">&#125; temp; <span class="comment">// 12字节</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125; temp; <span class="comment">// 16字节</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">&#125;; <span class="comment">// 12字节</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>字节对齐是一种空间换时间的操作。</p></blockquote><h3 id="位段">位段</h3><p>在结构体中，以位为单位的成员，称之为位段（位域）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packed_data</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a : <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b : <span class="number">6</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> c : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> d : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">&#125; data;</span><br></pre></td></tr></table></figure><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/53efd5a1-afe4-4259-b71c-7b6f3daeee5f"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><blockquote><p>注意：不能对位段成员取地址</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packed_data</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a : <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b : <span class="number">6</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> c : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> d : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">&#125; data;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;(data.i));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/a6798353-3a76-4cba-b258-cc75406623d2"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><blockquote><p>注意：</p><ol type="1"><li>对于位段成员赋值时不要超出位段定义的范围，例如成员 a 定义为 2为，则去哦最大值为 3，如果给 a 赋值为 5，会取最低 2 位进行赋值。</li><li>位段成员必须为整型或字符型。</li><li>一个位段成员必须存放在一个存储单元中，不能跨两个单元，第一个单元不能容纳下一个位段，则该空间不用，从下一个单元其存放该位段。</li></ol></blockquote><p><strong>位段的存储单元：</strong></p><ol type="1"><li><code>char</code> 型的位段，存储单元是 1 个字节；</li><li><code>short int</code> 型的位段，存储单元是 2 个字节；</li><li><code>int</code> 型的位段，存储单元是 4 字节；</li><li><code>long int</code> 型的位段，存储单元是 4 字节。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a : <span class="number">7</span>;</span><br><span class="line">    <span class="type">char</span> b : <span class="number">7</span>;</span><br><span class="line">    <span class="type">char</span> c : <span class="number">2</span>;</span><br><span class="line">&#125; temp;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(temp));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/9a5a3396-0ef9-4b60-896b-037084ab837b"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p><strong>位段的长度不能大于存储单元的长度：</strong></p><ol type="1"><li><code>char</code> 型位段不能大于 8 位；</li><li><code>short</code> 型位段不能大于 16 位；</li><li><code>int</code> 型位段不能大于 32 位；</li><li><code>long</code> 型位段不能大于 32 位。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a : <span class="number">9</span>;</span><br><span class="line">    <span class="type">char</span> b : <span class="number">7</span>;</span><br><span class="line">    <span class="type">char</span> c : <span class="number">2</span>;</span><br><span class="line">&#125; temp;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(temp));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">分析：编译出错，位段a不能大于其存储单元的大小</span><br></pre></td></tr></table></figure><p><strong>如一个段要从另一个存储单元开始，可以定义：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_type</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b : <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c : <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_type</span> <span class="title">temp</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(temp));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/433b3003-4261-4070-b141-3510ab816bd9"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>长度为 0 的位段作用是使下一个位段从下一个存储单元开始存放，将 a、b存储在一个存储单元中，c 存储在下一个单元。</p><p><strong>可以定义无意义位段，如：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> a: <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> : <span class="number">2</span>;</span><br><span class="line"><span class="type">unsigned</span> b: <span class="number">3</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a : <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> b : <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c : <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> d : <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> e : <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> f : <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> g : <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> h : <span class="number">1</span>;</span><br><span class="line">&#125; temp;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> p0;</span><br><span class="line">    <span class="comment">// p0=0x01;// 0000 0001</span></span><br><span class="line">    temp.a = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// p0 = temp; // 错的，类型不匹配</span></span><br><span class="line">    <span class="comment">// p0=(char) temp;//错的，编译器不允许将结构体变量，强制转成基本类型的。</span></span><br><span class="line">    p0 = *((<span class="type">char</span> *)(&amp;temp));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共用体">共用体</h2><p>共用体和结构体类似，也是一种构造类型的数据结构。</p><p>定义共用体类型的方法和结构体非常相似，把 <code>struct</code> 改成<code>union</code> 就可以了。</p><p>在进行某些算法的时候，需要使几种不同类型的变量存到同一段内存单元中，几个变量所使用空间相互重叠，共用体就是这样一种结构。</p><p>共用体所有成员占有同一段地址空间，共用体的大小是其占内存长度最大的成员的大小</p><p><strong>共用体的特点：</strong></p><ol type="1"><li>同一内存段可以用来存放几种不同类型的成员，但每一瞬时只有一种起作用。</li><li>共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员的值会被覆盖。</li><li>共用体变量的地址和它的各成员的地址都是同一地址。</li><li>共用体变量的初始化<code>union data a=&#123;123&#125;;</code>，初始化共用体为第一个成员。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个共用体</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">un</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 定义共用体变量</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">un</span> <span class="title">myun</span>;</span></span><br><span class="line">    myun.a = <span class="number">100</span>;</span><br><span class="line">    myun.b = <span class="number">200</span>;</span><br><span class="line">    myun.c = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d, c = %d\n&quot;</span>, myun.a, myun.b, myun.c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/e9e093b7-5b59-45ad-8ee7-5dda248c367b"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="枚举">枚举</h2><p>将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。</p><p>枚举类型也是个构造类型的</p><p><strong>枚举类型的定义：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> 枚举类型名&#123;</span></span><br><span class="line">    枚举值列表;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在枚举值表中应列出所有可用值，也称为枚举元素。</p><p>枚举变量仅能取枚举值所列元素。</p><p><strong>枚举变量的定义方法：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> 枚举类型名 枚举变量名;</span></span><br></pre></td></tr></table></figure><ol type="1"><li>枚举值是常量；</li><li>枚举元素本身由系统定义了一个表示序号的数值，默认从 0 开始；</li><li>可以改变枚举值的默认值。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span> &#123;</span> mon = <span class="number">3</span>, tue, wed, thu, fri = <span class="number">4</span>, sat, sun &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mon);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tue);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, wed);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, thu);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, fri);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sat);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sun);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/9f84fd78-2150-4089-a342-66f6a57fae18"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure>]]></content>
    
    
    <summary type="html">介绍 C 语言中的构造类型</summary>
    
    
    
    <category term="C 语言基础" scheme="https://xinransix.github.io/categories/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C" scheme="https://xinransix.github.io/tags/C/"/>
    
    <category term="结构体" scheme="https://xinransix.github.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
    <category term="共用体" scheme="https://xinransix.github.io/tags/%E5%85%B1%E7%94%A8%E4%BD%93/"/>
    
    <category term="枚举" scheme="https://xinransix.github.io/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>字符串处理函数</title>
    <link href="https://xinransix.github.io/2023/07/16/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/"/>
    <id>https://xinransix.github.io/2023/07/16/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</id>
    <published>2023-07-16T02:36:33.000Z</published>
    <updated>2024-02-10T08:46:53.116Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获取字符串长度的函数">获取字符串长度的函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br><span class="line">功能：计算一个字符串的长度</span><br><span class="line">参数：</span><br><span class="line">s：指定的字符串 </span><br><span class="line">返回值：</span><br><span class="line">当前字符串的长度</span><br><span class="line">注意：<span class="built_in">strlen</span> 获取的字符串长度遇到第一个\<span class="number">0</span>结束且\<span class="number">0</span>不计算</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> s1[<span class="number">100</span>] = <span class="string">&quot;hel\0lo&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1_len = %d\n&quot;</span>, <span class="built_in">strlen</span>(s1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1_size = %d\n&quot;</span>, <span class="keyword">sizeof</span>(s1));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *s2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2_len = %d\n&quot;</span>, <span class="built_in">strlen</span>(s2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2_size = %d\n&quot;</span>, <span class="keyword">sizeof</span>(s2));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/f3a0c0d4-bde6-49f1-9c9a-06e3453cf506"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>获取字符串长度可以通过如下方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (str[len] &amp;&amp; ++len);</span><br></pre></td></tr></table></figure><h2 id="字符串拷贝函数">字符串拷贝函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line">功能：将 src 复制给 dest</span><br><span class="line">参数：</span><br><span class="line">    dest：目标字符串</span><br><span class="line">    src：源字符串</span><br><span class="line">返回值：</span><br><span class="line">    保存 dest 字符串的首地址</span><br><span class="line">注意：使用 <span class="built_in">strcpy</span> 函数复制字符串时必须保证 dest 足够大，否则会内存溢出。<span class="built_in">strcpy</span> 是将 src 字符串中第一个 \<span class="number">0</span> 之前包括 \<span class="number">0</span> 复制给 dest</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line">函数的说明：</span><br><span class="line">将 src 指向的字符串前 n 个字节，拷贝到 dest 指向的内存中</span><br><span class="line">返回值:</span><br><span class="line">目的内存的首地址</span><br><span class="line">注意：</span><br><span class="line"><span class="number">1</span>、<span class="built_in">strncpy</span> 不拷贝 <span class="string">&#x27;\0&#x27;</span></span><br><span class="line"><span class="number">2</span>、如果n大于src指向的字符串中的字符个数，则在dest后面填充n‐<span class="built_in">strlen</span>(src)个<span class="string">&#x27;\0&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 使用strcpy函数拷贝字符串</span></span><br><span class="line">    <span class="type">char</span> s1[<span class="number">32</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="comment">// 使用strcpy函数时，必须保证第一个参数的内存足够大</span></span><br><span class="line">    <span class="type">char</span> s2[<span class="number">32</span>] = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(s1, s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1 = %s\n&quot;</span>, s1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%c] ‐ %d\n&quot;</span>, s1[i], s1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/ab35b5bf-9034-4903-a630-1e9469f9e7f1"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="字符串追加函数">字符串追加函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line">功能：将src追加到dest的后面</span><br><span class="line">参数：</span><br><span class="line">    dest：目的字符串</span><br><span class="line">    src：源字符串</span><br><span class="line">返回值：</span><br><span class="line">    保存dest字符串的首地址</span><br><span class="line">    </span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line">追加src指向的字符串的前n个字符，到dest指向的字符串的后面。</span><br><span class="line">注意如果n大于src的字符个数，则只将src字符串追加到dest指向的字符串的后面</span><br><span class="line">追加的时候会追加’\<span class="number">0</span>’</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 使用strcat函数追加字符串</span></span><br><span class="line">    <span class="type">char</span> s1[<span class="number">32</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s2[<span class="number">32</span>] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">    <span class="comment">// strcat是从s1的\0的位置开始追加，直到s2的第一个\0复制完毕后结束</span></span><br><span class="line">    <span class="built_in">strcat</span>(s1, s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1 = %s\n&quot;</span>, s1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/61168d3b-68bf-40b9-a08d-755dd171a827"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="字符串比较函数">字符串比较函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2, <span class="type">size_t</span> n)</span>;</span><br><span class="line">功能：<span class="built_in">strcmp</span>是比较两个字符串的内容，<span class="built_in">strncmp</span>是比较两个字符串的前n个字节是否一样</span><br><span class="line">参数：</span><br><span class="line">    s1、s2：要比较的两个字符串</span><br><span class="line">    n：<span class="built_in">strncmp</span>中的参数n表示要比较的字节数</span><br><span class="line">返回值：</span><br><span class="line">    <span class="number">0</span> s1 = s2</span><br><span class="line">    &gt;<span class="number">0</span> s1 &gt; s2</span><br><span class="line">    &lt;<span class="number">0</span> s1 &lt; s2</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 使用strcmp比较两个字符串的内容是否一致</span></span><br><span class="line">    <span class="comment">// strcmp函数一个字符一个字符比较，只要出现不一样的，就会立即返回</span></span><br><span class="line">    <span class="type">char</span> s1[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s2[] = <span class="string">&quot;w&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">strcmp</span>(s1, s2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 = s2\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 &gt; s2\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 &lt; s2\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/5d6e620b-9143-4194-802c-4fef41eb552e"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="字符查找函数">字符查找函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> c)</span>;</span><br><span class="line">功能：在字符指针s指向的字符串中，找ascii 码为c的字符</span><br><span class="line">参数：</span><br><span class="line">    s：指定的字符串</span><br><span class="line">    c：要查找的字符</span><br><span class="line">返回值：</span><br><span class="line">    成功：找到的字符的地址</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br><span class="line">注意：s指向的字符串中有多个ASCII为c的字符，则找的是第<span class="number">1</span>个字符</span><br><span class="line">    </span><br><span class="line"><span class="type">char</span> *<span class="title function_">strrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> c)</span>;</span><br><span class="line">功能：在s指向的字符串中，找最后一次出现的ASCII为c的字符</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 使用strchr函数在一个字符串中查找字符</span></span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;hel6lo wor6ld&quot;</span>;</span><br><span class="line">    <span class="comment">// 找第一个匹配的字符</span></span><br><span class="line">    <span class="type">char</span> *ret = <span class="built_in">strchr</span>(s, <span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">    <span class="comment">// 找最后一个匹配的字符</span></span><br><span class="line">    <span class="comment">// char *ret = strrchr(s, &#x27;6&#x27;);</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有找到\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了，在数组的第%d个位置\n&quot;</span>, ret - s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/c7d6eefd-6a5d-4ee5-8532-469dc906b913"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="字符串匹配函数">字符串匹配函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *haystack, <span class="type">const</span> <span class="type">char</span> *needle)</span>;</span><br><span class="line">函数说明：</span><br><span class="line">在haystack指向的字符串中查找needle指向的字符串，也是首次匹配</span><br><span class="line">返回值：</span><br><span class="line">    找到了：找到的字符串的首地址</span><br><span class="line">    没找到：返回<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 使用strstr函数在一个字符串中查找另一个字符串</span></span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;1234:4567:666:789:666:7777&quot;</span>;</span><br><span class="line">    <span class="comment">// strstr查找的时候，查找的是第二个参数的第一个\0之前的内容</span></span><br><span class="line">    <span class="type">char</span> *ret = <span class="built_in">strstr</span>(s, <span class="string">&quot;666&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没找到\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了，在当前字符串的第%d个位置\n&quot;</span>, ret - s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/50c60c29-b244-4647-b4da-38da048a16b0"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="字符串转换数值">字符串转换数值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span>;</span><br><span class="line">功能：将一个数字型字符串转化为整形数据</span><br><span class="line">参数：</span><br><span class="line">    nptr：指定的字符串</span><br><span class="line">返回值：</span><br><span class="line">    获取到的整形数据</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 使用atoi将数字型字符串转化为整形数据</span></span><br><span class="line">    <span class="type">char</span> s1[] = <span class="string">&quot;7856&quot;</span>;</span><br><span class="line">    <span class="type">int</span> ret1 = atoi(s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret1 = %d\n&quot;</span>, ret1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用atof将浮点型的字符串转化为浮点型数据</span></span><br><span class="line">    <span class="type">char</span> s2[] = <span class="string">&quot;3.1415926&quot;</span>;</span><br><span class="line">    <span class="type">double</span> ret2 = atof(s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret2 = %lf\n&quot;</span>, ret2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/3820eef5-b26c-4e53-a408-a0d19f955b2c"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="字符串切割函数">字符串切割函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strtok</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *delim)</span>;</span><br><span class="line">功能：对字符串进行切割</span><br><span class="line">参数：</span><br><span class="line">    str：要切割的字符串</span><br><span class="line">    第一次切割，传入指定的字符串，后面所有的切割传<span class="literal">NULL</span></span><br><span class="line">delim：标识符，要根据指定的delim进行切割，切割的结果不包含delim</span><br><span class="line">返回值：</span><br><span class="line">返回切割下来的字符串的首地址，如果都切割完毕，则返回<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 使用strtok函数切割字符串</span></span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;111:22222:33:4444444444:5555555555555&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *ret;</span><br><span class="line">    <span class="comment">// 第一次切割</span></span><br><span class="line">    ret = strtok(s, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret = %s\n&quot;</span>, ret);</span><br><span class="line">    <span class="comment">// 后面所有切割时都要将strtok的第一个参数传NULL</span></span><br><span class="line">    <span class="keyword">while</span> ((ret = strtok(<span class="literal">NULL</span>, <span class="string">&quot;:&quot;</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %s\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/5a49aeb6-cb88-455a-aea9-8dbce560dafb"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="格式化字符串操作函数">格式化字符串操作函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line">功能：将按照格式保存的字符串复制给str</span><br><span class="line">参数：</span><br><span class="line">    str：保存字符串</span><br><span class="line">    format：同<span class="built_in">printf</span></span><br><span class="line">返回值：</span><br><span class="line">保存的字符串的字节数</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line">功能：<span class="built_in">scanf</span>是从终端读取数据并赋值给对应变量，而<span class="built_in">sscanf</span>是从第一个参数中读取数据</span><br><span class="line">参数：</span><br><span class="line">    str：指定要获取内容的字符串</span><br><span class="line">    format：按照格式获取数据保存在变量中</span><br><span class="line">返回值：</span><br><span class="line">    成功获取的个数</span><br></pre></td></tr></table></figure><p><strong><code>sprintf</code> 和 <code>sscanf</code>的基本用法：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d:%d:%d&quot;</span>, <span class="number">2013</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sscanf</span>(<span class="string">&quot;2013:10:1&quot;</span>, <span class="string">&quot;%d:%d:%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d,c=%d\n&quot;</span>, a, b, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/d20fb5ab-2389-4437-acae-9da1ba55b9b1"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p><strong><code>sscanf</code> 高级用法：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1、跳过数据：%*s或%*d</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">sscanf</span>(<span class="string">&quot;1234 5678&quot;</span>, <span class="string">&quot;%*d %s&quot;</span>, buf1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf1);</span><br><span class="line">    <span class="comment">// 2、读指定宽度的数据：%[width]s</span></span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">sscanf</span>(<span class="string">&quot;12345678&quot;</span>, <span class="string">&quot;%4s &quot;</span>, buf2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf2);</span><br><span class="line">    <span class="comment">// 3、支持集合操作：只支持获取字符串</span></span><br><span class="line">    <span class="comment">//  %[a‐z] 表示匹配a到z中任意字符(尽可能多的匹配)</span></span><br><span class="line">    <span class="comment">//  %[aBc] 匹配a、B、c中一员，贪婪性</span></span><br><span class="line">    <span class="comment">//  %[^aFc] 匹配非a、F、c的任意字符，贪婪性</span></span><br><span class="line">    <span class="comment">//  %[^a‐z] 表示读取除a‐z以外的所有字符</span></span><br><span class="line">    <span class="type">char</span> buf3[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">sscanf</span>(<span class="string">&quot;agcd32DajfDdFF&quot;</span>, <span class="string">&quot;%[a-z]&quot;</span>, buf3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/781fe874-8ac0-4233-9a4a-6b94da409c7a"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="const">const</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const修饰全局变量</span></span><br><span class="line"><span class="comment">// 此时全局变量只能使用但是不能修改，</span></span><br><span class="line"><span class="comment">// 如果直接拿全局变量修改值，编译直接报错</span></span><br><span class="line"><span class="comment">// 如果使用全局变量的地址修改值，运行时程序异常结束</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="comment">// a = 666;</span></span><br><span class="line">    <span class="comment">// printf(&quot;a = %d\n&quot;, a);</span></span><br><span class="line">    <span class="type">int</span> *p = &amp;a;</span><br><span class="line">    *p = <span class="number">888</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const修饰普通局部变量</span></span><br><span class="line"><span class="comment">// 可以读取变量的值</span></span><br><span class="line"><span class="comment">// 不能直接通过变量进行修改值，编译报错</span></span><br><span class="line"><span class="comment">// 可以通过变量的地址修改值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line">    <span class="comment">// b = 666;</span></span><br><span class="line">    <span class="comment">// printf(&quot;b = %d\n&quot;, b);</span></span><br><span class="line">    <span class="type">int</span> *p = &amp;b;</span><br><span class="line">    *p = <span class="number">888</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const修饰指针变量</span></span><br><span class="line"><span class="comment">// 如果const修饰指针变量的类型，无法通过指针变量修改地址里面的值</span></span><br><span class="line"><span class="comment">// 如果const修饰指针变量，无法修改指针变量保存的地址</span></span><br><span class="line"><span class="comment">// 如果const既修饰指针变量的类型，又修饰指针变量，则只能通过原本变量修改值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// const修饰指针变量的类型</span></span><br><span class="line">    <span class="comment">// const int * p = &amp;c;</span></span><br><span class="line">    <span class="comment">// const修饰指针变量</span></span><br><span class="line">    <span class="comment">// int * const p = &amp;c;</span></span><br><span class="line">    <span class="comment">// const既修饰指针变量的类型，又修饰指针变量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p = &amp;c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">    c = <span class="number">666</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">    *p = <span class="number">777</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">    <span class="type">int</span> d = <span class="number">888</span>;</span><br><span class="line">    p = &amp;d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    test3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">介绍 C 中常用的字符串处理函数</summary>
    
    
    
    <category term="C 语言基础" scheme="https://xinransix.github.io/categories/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C" scheme="https://xinransix.github.io/tags/C/"/>
    
    <category term="字符串" scheme="https://xinransix.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>动态内存申请</title>
    <link href="https://xinransix.github.io/2023/07/16/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7/"/>
    <id>https://xinransix.github.io/2023/07/16/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7/</id>
    <published>2023-07-16T02:35:38.000Z</published>
    <updated>2024-02-10T08:48:30.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态分配内存的概述">动态分配内存的概述</h2><p>动态内存分配就是在堆区开辟空间。</p><blockquote><p>如果想动态分配数组的大小，必须使用动态内存分配。</p></blockquote><h2 id="静态分配动态分配">静态分配、动态分配</h2><p><strong>静态分配</strong>：</p><ol type="1"><li>在程序编译或运行过程中，按事先规定的大小分配空间。</li><li>必须事先知道所需空间的大小。</li><li>分配在栈区或全局变量区。</li><li>按计划分配。</li></ol><p><strong>动态分配</strong>：</p><ol type="1"><li>在程序运行过程中，工具需要自由分配空间。</li><li>按需分配</li><li>分配在堆区，一般使用特定的函数进行分配。</li></ol><h2 id="动态内存分配函数">动态内存分配函数</h2><p>与动态内存分配相关的函数有 4个：<code>malloc</code>、<code>free</code>、<code>calloc</code>、<code>realloc</code>.</p><h3 id="malloc">malloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br><span class="line">功能：在堆区开辟指定长度的空间，并且空间是连续的</span><br><span class="line">参数：</span><br><span class="line">    size：要开辟的空间的大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：开辟好的空间的首地址</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol type="1"><li>在调用 <code>malloc</code>函数知乎，一定要判断一下，是否申请内存成功。</li><li>如果多次用 <code>malloc</code> 函数申请内存，第 1 次和第 2次申请到的内存不一定是连续的。</li><li><code>malloc</code> 函数的返回值是<code>void*</code>，所以在调用函数时要根据实际情况进行强制类型转换。</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *str = (<span class="type">char</span> *)(<span class="built_in">malloc</span>(<span class="number">100</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>)));</span><br><span class="line"></span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">    str[<span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    str[<span class="number">2</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">    str[<span class="number">3</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">    str[<span class="number">4</span>] = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">    str[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p = fun();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %s\n&quot;</span>, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/d40381f2-6531-4539-84f9-57cbcbb3f95f"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="free">free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">功能：释放堆区的空间</span><br><span class="line">参数：</span><br><span class="line"> ptr：开辟后使用完毕的堆区的空间的首地址</span><br><span class="line">返回值：</span><br><span class="line"> 无</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol type="1"><li><code>free</code> 函数只能释放堆区的空间，其他区域的空间无法使用<code>free</code>.</li><li><code>free</code> 释放的空间必须是使用<code>malloc</code>、<code>calloc</code> 或者 <code>realloc</code>函数申请的空间，不能释放部分空间。</li><li>当使用 <code>free(p)</code> 释放 <code>p</code>指向的空间后，<code>p</code>还是会指向原来的地方，但原来的地方的空间已经被释放了，所以不能在使用，<code>p</code>就成了野指针，所以一般来说，在释放完空间之后，要将指针置空，即<code>p = NULL</code>.</li><li>一块空间只能释放一次，不能多次释放。</li></ol></blockquote><h3 id="calloc">calloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> * <span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span>;</span><br><span class="line">功能：在堆区申请指定大小的空间</span><br><span class="line">参数：</span><br><span class="line">    nmemb：要申请的空间的块数</span><br><span class="line">    size：每块的字节数</span><br><span class="line">返回值：</span><br><span class="line">    成功：申请空间的首地址</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>malloc</code> 函数和 <code>calloc</code>函数都是用来申请内存的。</p><p>区别：</p><ol type="1"><li>函数名字别一样；</li><li>函数参数个数不一样；</li><li><code>malloc</code> 申请的内存，内存中的内容是随机的，而<code>calloc</code> 函数的申请的内存中的内存为 0。</li></ol></blockquote><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = (<span class="type">char</span>*)<span class="built_in">calloc</span>(<span class="number">3</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>在堆区申请了 3 快空间，每块的大小为 100 个字节，共 300个字节的连续空间。</p><h3 id="realloc">realloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *s, <span class="type">unsigned</span> <span class="type">int</span> newsize)</span>;</span><br><span class="line">功能：在原本申请好的堆区空间的基础上重新申请内存，新的空间大小为函数的第二个参数如果原本申请好的空间的后面不足以增加指定的大小，系统会重新找一个足够大的位置开辟指定的空间，然后将原本空间中的数据拷贝过来，然后释放原本的空间。如果 newsize 比原先的内存小，则会释放原先内存的后面的存储空间，只留前面的 newsize 个字节</span><br><span class="line">参数：</span><br><span class="line">    s：原本开辟好的空间的首地址</span><br><span class="line">    newsize：重新开辟的空间的大小</span><br><span class="line">返回值：</span><br><span class="line">    新的空间的首地址</span><br></pre></td></tr></table></figure><p>增加空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 想在100个字节后面追加50个字节</span></span><br><span class="line">    p = (<span class="type">char</span> *)<span class="built_in">realloc</span>(p, <span class="number">150</span>); <span class="comment">// p指向的内存的新的大小为150个字节</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>减少空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 想重新申请内存,新的大小为50个字节</span></span><br><span class="line">    <span class="comment">// p指向的内存的新的大小为50个字节,100个字节的后50个字节的存储空间就被释放</span></span><br><span class="line">    p = (<span class="type">char</span> *)<span class="built_in">realloc</span>(p, <span class="number">50</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存泄漏">内存泄漏</h2><p>内存泄漏是指，申请的空间的首地址丢失了，再也找不到了，这块内存没法用，也没法释放，则称这块内存被泄漏了。</p><p>案例 1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 接下来，可以用p指向的内存了</span></span><br><span class="line">    p = <span class="string">&quot;hello world&quot;</span>; <span class="comment">// p指向别的地方了，保存字符串常量的首地址</span></span><br><span class="line">    <span class="comment">// 从此以后，再也找不到你申请的100个字节了。则动态申请的100个字节就被泄露了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例 2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123; <span class="type">char</span> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 每调用一次fun泄露100个字节</span></span><br><span class="line">    fun();</span><br><span class="line">    fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>千万注意：申请的空间，一定不要把首地址弄丢了，在不用之前一定要释放空间。</p></blockquote>]]></content>
    
    
    <summary type="html">介绍 C 语言中的如何在堆上分配内存</summary>
    
    
    
    <category term="C 语言基础" scheme="https://xinransix.github.io/categories/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C" scheme="https://xinransix.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>指针</title>
    <link href="https://xinransix.github.io/2023/07/16/%E6%8C%87%E9%92%88/"/>
    <id>https://xinransix.github.io/2023/07/16/%E6%8C%87%E9%92%88/</id>
    <published>2023-07-16T02:34:31.000Z</published>
    <updated>2024-02-10T09:13:18.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存相关概念">内存相关概念</h2><p><strong>外存</strong>：又称拓展存储器，长期存放数据，是可掉电的设备，常见的外存设备有：硬盘、flash、ROM、U盘、光盘、磁带。</p><p><strong>内存</strong>：暂时存放数据的设备，掉电丢失数据，厂家的内存有：RAM，DDR.</p><p>内存分为<strong>物理内存</strong>和虚拟内存。</p><ul><li>物理内存：实实在在的存储设备；</li><li>虚拟内存：操作系统虚拟出来的内存。</li></ul><p>操作系统会将虚拟内存和物理内存进行映射。</p><p>在 32 位操作系统下，每个进程的寻址范围位<code>0x00000000~0xffffffff</code>，即4G，我们在编程时看到的内存地址都是虚拟地址。</p><p>在程序运行时，操作系统会将<strong>虚拟内存</strong>进行分区：</p><ul><li>堆：在动态申请内存时，会在堆区开辟空间；</li><li>栈：主要存放局部变量；</li><li>静态全局区：<ul><li>位初始化的静态全局区：没有初始化的静态变量（<code>static</code>修饰的变量），或全局变量存放在此区；</li><li>初始化了的静态全局区：初始化过的全局变量、静态变量存在此区。</li></ul></li><li>代码区：存放代码的区；</li><li>文字常量区：存放常量的区；</li></ul><h2 id="指针的相关概念">指针的相关概念</h2><blockquote><p>本文均在 32 为平台上进行讨论。</p></blockquote><p>系统给每个存储单元分配了一个编号，从<code>0x00000000~0xffffffff</code>，这个编号就是地址。</p><blockquote><p>指针就是地址。</p></blockquote><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/51a85890-ee89-4e25-9489-6545d4a5f796"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>指针变量：一个存放地址编号的变量。</p><p>在 32 位平台下，地址总线是 32 位的，所以地址是 32 位编号，占用 4个字节，所以在 32 位平台下指针变量占用 4 个字节。</p><blockquote><p>鱼代表鱼，虾代表虾，乌龟代表是王八。对应指针变量只能存放对应类型变量的地址，例如<code>int</code> 类型的指针只能存放 <code>int</code>类型变量的地址。</p></blockquote><p><code>char</code> 占 1个字节，它有一个地址编号，这个地址编号就是其地址；<code>int</code> 占 4个字节，它占有 4 个字节的存储单元，有 4 个地址编号。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/67036c70-1ee8-4729-8dbf-3df54f568cd7"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="指针的定义方法">指针的定义方法</h2><p>定义指针的语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据类型 *指针变量名;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> *p1, p2;</span><br></pre></td></tr></table></figure><p>与指针相关的运算符：<code>&amp;</code>、<code>*</code>.</p><p><code>&amp;</code> 是取地址运算符，<code>*</code> 是取值运算符。</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/1139ce2c-7536-4c61-a440-9ed2d47bd911"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p = &amp;a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d %d\n&quot;</span>, a, *p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p %p\n&quot;</span>, &amp;a, p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/921666e3-b0bc-40a4-8b5e-3577d2859315"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>指针大小：在 32 位系统下，所有类型的指针都是 4 个字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> *a;</span><br><span class="line">    <span class="type">short</span> *b;</span><br><span class="line">    <span class="type">int</span> *c;</span><br><span class="line">    <span class="type">long</span> *d;</span><br><span class="line">    <span class="type">float</span> *e;</span><br><span class="line">    <span class="type">double</span> *f;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a) = %lld\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(b) = %lld\n&quot;</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(c) = %lld\n&quot;</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(d) = %lld\n&quot;</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(e) = %lld\n&quot;</span>, <span class="keyword">sizeof</span>(e));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(f) = %lld\n&quot;</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/4c425eb6-d0c4-418d-be0a-5ac63d3b2ddc"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="指针的分类">指针的分类</h2><ol type="1"><li><code>char</code> 型指针；</li><li><code>short int</code> 型指针；</li><li><code>int</code> 指针；</li><li><code>long</code> 指针；</li><li><code>float</code> 型指针；</li><li><code>double</code> 型指针；</li><li>函数指针；</li><li>结构体指针；</li><li>指针的指针；</li><li>数组指针。</li></ol><blockquote><p>不管是声明指针，在 32 位操作系统上，均占有 4 个字节。</p></blockquote><h2 id="指针和变量的关系">指针和变量的关系</h2><p>指针可以存放变量的地址。</p><p>在程序中，访问变量的值可以字节使用变量名，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line">a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>也可以通过指针来访问变量的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = &amp;a;</span><br><span class="line">*p = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol type="1"><li>指针在试用期一定要初始化。</li><li>指针只能指向开辟好空间的地址，不能随意保存地址。</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p1, *p2, temp, a, b;</span><br><span class="line">    p1 = &amp;a;</span><br><span class="line">    p2 = &amp;b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入:a b的值:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, p1, p2); <span class="comment">// 给p1和p2指向的变量赋值</span></span><br><span class="line">    temp = *p1;             <span class="comment">// 用p1指向的变量（a）给temp赋值</span></span><br><span class="line">    *p1 = *p2;  <span class="comment">// 用p2指向的变量（b）给p1指向的变量（a）赋值</span></span><br><span class="line">    *p2 = temp; <span class="comment">// temp给p2指向的变量（b）赋值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p1=%d *p2=%d\n&quot;</span>, *p1, *p2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/e6af8b05-742b-47a4-b2b0-08926a1105d6"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><blockquote><p>注意：对应类型的指针，只能保持对应类型数据的地址，如果想让不同类型的指针互相赋值，需要强制类型转换。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x1234</span>, b = <span class="number">0x5678</span>;</span><br><span class="line">    <span class="type">char</span> *p1, *p2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x %#x\n&quot;</span>, a, b);</span><br><span class="line">    p1 = (<span class="type">char</span> *)&amp;a;</span><br><span class="line">    p2 = (<span class="type">char</span> *)&amp;b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x %#x\n&quot;</span>, *p1, *p2);</span><br><span class="line">    p1++;</span><br><span class="line">    p2++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x %#x\n&quot;</span>, *p1, *p2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/a9cbbfec-00d8-43d2-afd0-8618d8d8ec3e"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><blockquote><p>注意：</p><ol type="1"><li>使用 <code>*</code>对指针取值时，取几个字节，由指针类型决定，<code>int</code> 类型的指针取4 个字节，<code>double</code> 类型的指针取 8 个字节。</li><li>对指针进行 <code>+1</code>操作时，指针会跳过若干字节，跳过的字节的大小有指针类型决定，例如<code>int</code> 类型的指针会跳过 4 个字节。</li></ol></blockquote><h2 id="指针和数组元素之间的关系">指针和数组元素之间的关系</h2><h3 id="数组元素与指针的基本关系">数组元素与指针的基本关系</h3><p>变量存放在内存中，有自己的地址编号。数组时多个相同类型变量的集合，每个变量都占用内存空间，都有自己的内存编号，数组在内存中是连续存放的。</p><p>指针变量可以指向存放数组元素的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p = &amp;a[<span class="number">0</span>]; <span class="comment">// 指针变量p保存了数组a中第0个元素的地址，即a[0]的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问数组数组元素的方法">访问数组数组元素的方法</h3><p><strong>方式 1：</strong><code>数组名[索引]</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><strong>方式 2：</strong><code>指针名 + 下标</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = a;</span><br><span class="line">p[<span class="number">2</span>] = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><blockquote><p>在 C 语言中，数组名就是数组的首地址，即第 0个元素的地址，是个常量。</p></blockquote><blockquote><p>注意：p 和 a 不同，p 是指针变量，而 a 是个常量。所以可以使用等号给 p赋值，但不能给 a 赋值。例如：<code>int a[10]; a++;</code>这种用法是错误的，因为 a 是数组名，是一种地址常量。</p></blockquote><p><strong>方式 3：</strong>通过指针运算加取值的方法来引用数组的元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = a;</span><br><span class="line">*(p + <span class="number">2</span>) = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><code>p</code> 是第 个元素的地址，<code>p + 2</code> 是<code>a[2]</code> 这个元素的地址，对第二个元素的地址取值，即<code>a[2]</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要将数组名赋值给同类型的指针变量，则此时的指针变量与数组名可</span></span><br><span class="line">    <span class="comment">// 以用相同的方法操作数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a[2]=%d\n&quot;</span>, a[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p[2]=%d\n&quot;</span>, p[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*(a + n) &lt;==&gt; *(p + n) &lt;==&gt; a[n] &lt;==&gt; p[n]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*(p+2) = %d\n&quot;</span>, *(p + <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*(a+2) = %d\n&quot;</span>, *(a + <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p=%p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p+2=%p\n&quot;</span>, p + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[0] = %p\n&quot;</span>, &amp;a[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[2] = %p\n&quot;</span>, &amp;a[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/e1579dc7-a6f4-458f-b131-da3e6d227fc8"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="指针的运算">指针的运算</h2><h3 id="指针可以加一个整数">指针可以加一个整数</h3><p>往后指几个它指向的变量，结果还是个地址。</p><blockquote><p>注意：一般来说，指针指向数组是加一个整数才有意义。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> *p, *q;</span><br><span class="line">    <span class="comment">// p和q间隔8个字节，意味着加一个整数最终移动的字节数与指针变量的类型也有关系</span></span><br><span class="line">    p = a;</span><br><span class="line">    q = p + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;q = %p\n&quot;</span>, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/0796e556-3cb2-4464-9a0b-aba79d814d8f"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="两个相同类型指针可以比较大小">两个相同类型指针可以比较大小</h3><blockquote><p>注意：只有相同类型的指针指向同一个数组里的元素，比较大小才有意义。</p></blockquote><p>指向前面元素的指针小于指向后面元素的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> *p, *q;</span><br><span class="line">    p = &amp;a[<span class="number">1</span>];</span><br><span class="line">    q = &amp;a[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">if</span> (p &lt; q) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p &lt; q\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p &gt; q) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p &gt; q\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p = q\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/70dfe7a9-6152-40fd-887a-5f883ed571c6"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="两个相同类型的指针可以做减法">两个相同类型的指针可以做减法</h3><blockquote><p>注意：只有相同类型的指针指向同一个数组里的元素，做减法才有意义。</p></blockquote><p>做减法的结果是两个指针之间有多少个元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> *p, *q;</span><br><span class="line">    p = &amp;a[<span class="number">0</span>];</span><br><span class="line">    q = &amp;a[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, q - p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/94c08063-3ba2-4c90-b368-5170dbafb76f"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3id="两个相同类型的指针可以相互赋值">两个相同类型的指针可以相互赋值</h3><blockquote><p>注意：只有相同类型的指针才可以互相赋值（<code>void *</code>类型的除外）。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> *p, *q;</span><br><span class="line">    p = &amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d %d\n&quot;</span>, a, *p);</span><br><span class="line">    q = p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*q = %d\n&quot;</span>, *q);</span><br><span class="line">    *q = <span class="number">999</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/06eaf1c8-1cb9-4b39-9819-8302fb3a1b4b"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="指针数组">指针数组</h2><p>指针可以保存数组元素的地址，也可以定义一个数组，数组中的元素是若干个相同类型的指针变量，这个数组就是<strong>指针数组</strong>。</p><p>定义指针数组的语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型说明符 *数组名[元素个数];</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">p[<span class="number">1</span>] = &amp;a;</span><br><span class="line"><span class="type">int</span> b[<span class="number">10</span>];</span><br><span class="line">p[<span class="number">2</span>] = &amp;b[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// p[2] 和 *(p + 2) 是等价的，都是指针数组中的第 2 个元素。</span></span><br></pre></td></tr></table></figure><p>指针数组按照其元素进行分类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *name[<span class="number">5</span>] = &#123;<span class="string">&quot;Follw me&quot;</span>, <span class="string">&quot;BASIC&quot;</span>, <span class="string">&quot;Greatwall&quot;</span>, <span class="string">&quot;FORTRAN&quot;</span>, <span class="string">&quot;Computer&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, name[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/f14afb71-5e32-4fc7-8753-45f8e5e3d07d"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="指针的指针">指针的指针</h2><p>指针的指针又称为二级指针。</p><p>指针本身也是一个变量，也有地址，可以用二级指针保存其地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;a;</span><br><span class="line">    <span class="type">int</span> **q = &amp;p;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d %d %d\n&quot;</span>, a, *p, **q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p %p %p\n&quot;</span>, &amp;a, p, *q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;p = %p %p\n&quot;</span>, &amp;p, q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;q = %p\n&quot;</span>, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/beb44686-257b-4683-9fdc-00174129116e"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="字符串和指针">字符串和指针</h2><p>在 C 语言中，字符串是以 <code>'\0'</code> 结尾的若干字符的集合。</p><p>字符串的存储形式：数组、字符串指针、堆。</p><ol type="1"><li><code>char string[100] = "I love C!";</code>， 定义了一个字符数组<code>string</code>，用来存放多个字符，并且使用 <code>I love C!\0</code>给 <code>string</code> 数组初始化。</li><li><code>char *str = "I love C!"</code>，定义了一个指针变量<code>str</code>，这个字符串中的字符不能存放在 <code>str</code>变量中，<code>str</code> 只存放了字符 <code>I</code>的地址，<code>"I love C!"</code> 存放在文字常量区。</li><li><code>char *str = (char*)malloc(10 * sizeof(char));</code>，动态申请了10 个字节的存储空间，使用首地址个给 <code>str</code> 赋值，可以使用<code>strcpy(str, "I love C")</code> 的方式将字符串<code>"I love C!"</code> 拷贝到 <code>str</code> 指向的内存中。</li></ol><p><strong>可修改性：</strong></p><ol type="1"><li>栈区和全局区内存中的内容是可修改的。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>] = <span class="string">&quot;I love C!&quot;</span>;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;y&#x27;</span>; <span class="comment">// 这是 ok 的</span></span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>文字常量区的内容是不可修改的。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str = <span class="string">&quot;I love C!&quot;</span>;</span><br><span class="line">*str = <span class="string">&#x27;y&#x27;</span>; <span class="comment">// 这是不行的</span></span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>堆区的内容是可以修改的。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br></pre></td></tr></table></figure><p><strong>初始化：</strong></p><p>字符数组、指向字符串的指针可以在定义时初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf_aver[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">char</span> *buf_point = <span class="string">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure><p>堆中存放的字符串不能初始化，只能使用<code>strcpy</code>、<code>scanf</code> 进行赋值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *buf_heap;</span><br><span class="line">buf_heap = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">15</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(buf_heap, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf_heap);</span><br></pre></td></tr></table></figure><p><strong>使用时赋值：</strong></p><p>字符数组使用 <code>scanf</code> 或者 <code>strcpy</code>进行赋值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf_aver[<span class="number">128</span>];</span><br><span class="line">buf_aver = <span class="string">&quot;hello kitty&quot;</span>; <span class="comment">//这样是错误的，数组名是个常量</span></span><br><span class="line"><span class="built_in">strcpy</span>(buf_aver, <span class="string">&quot;hello kitty&quot;</span>); <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf_aver); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>指向字符串的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *buf_point;</span><br><span class="line">buf_point = <span class="string">&quot;hello kitty&quot;</span>; <span class="comment">// 正确，buf_point 指向另外一个字符串</span></span><br><span class="line"><span class="built_in">strcpy</span>(buf_point, <span class="string">&quot;hello kitty&quot;</span>); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><h2 id="数组指针">数组指针</h2><h3 id="二维数组">二维数组</h3><p>二维数组，有行，有列。二维数组可以看成有多个一维数组构成的，是多个一维数组的集合。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>定义了一个 3 行 5 列的二维数组。</p><p>可以认为二维数组 a 由 3 个一维数组构成，每个元素是一个一维数组。</p><p>二维数组 a 中，<code>a + 1</code>指向下一个元素，即下一个一维数组，即下一行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a+1=%p\n&quot;</span>, a + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/fab7d608-941e-4bc2-b41a-3e1869c52f0a"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="数组指针的概念">数组指针的概念</h3><p>数组本身是一个指针，指向一个数组，对数组指针加1，指向下一个数组。</p><p>数组指针可以用来保存二维数组的首地址。</p><h3 id="数组指针的定义方法">数组指针的定义方法</h3><p>数组指针的定义语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指向的数组的类型 (*指针名)[指向的数组元素的个数]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>定义了一个指向有 5 个元素的 <code>int</code> 类型的指针p，<code>p + 1</code> 会跳过一个有 5 个数组元素的数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span>(*p)[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a+1=%p\n&quot;</span>, a + <span class="number">1</span>);</span><br><span class="line">    p = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p=%p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p+1=%p\n&quot;</span>, p + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/63a00439-b8df-4193-84fa-a96de3a6930d"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>数组指针的用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> (*p)[<span class="number">5</span>], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; p[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">101</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fun(a, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/3faa7ff5-4fc7-42ca-8a17-52750dc99701"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="各种数组指针的定义">各种数组指针的定义</h3><p><strong>一维数组指针</strong></p><p>一维数组指针，加 1 后指向下一个一维数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>配合每行有 5 个 <code>int</code> 类型的二维数组来用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> c[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> d[<span class="number">6</span>][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">p = a;</span><br><span class="line">p = b;</span><br><span class="line">p = c;</span><br><span class="line">p = d;</span><br></pre></td></tr></table></figure><p>上述操作都是可以的。</p><p><strong>二维数组指针</strong></p><p>二维数组指针，加 1 后指向下一个二维数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">4</span>][<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>配合三维数组来用，三维数组由若干 4 行 5 列的二维数组组成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">4</span>][<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> c[<span class="number">5</span>][<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> d[<span class="number">6</span>][<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">p = a;</span><br><span class="line">p = b;</span><br><span class="line">p = c;</span><br><span class="line">p = d;</span><br></pre></td></tr></table></figure><p>上述操作都是可以的。</p><p><strong>三维数组指针</strong></p><p>三维数组指针，加 1 后指向下一个三维数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">4</span>][<span class="number">5</span>][<span class="number">6</span>];</span><br></pre></td></tr></table></figure><p><code>p + 1</code> 跳一个三维数组，配合<code>int a[7][4][5][6];</code> 使用。</p><h3 id="容易混淆的内容">容易混淆的内容</h3><p><strong>指针数组：</strong>是个数组，数组元素是指针。</p><p><strong>数组指针：</strong>是个指针，指向一个数组。</p><p><strong>指针的指针：</strong>是指向指针的指针。</p><h3 id="数组名字取地址">数组名字取地址</h3><p>对一维数组名取地址，变成一位数组指针，即加 1 跳一个一维数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p><code>a + 1</code> 跳一个 <code>int</code> 元素，即 <code>a[1]</code>的地址，<code>a</code> 和 <code>a + 1</code> 相差一个元素，4个字节。</p><p><code>&amp;a</code> 就变成了一个一维数组指针，是<code>int(*p)[10]</code> 类型的，<code>(&amp;a) + 1</code> 和<code>&amp;a</code> 相差一个数组，10 个元素，40 个字节。</p><h3 id="数组名字和指针变量的区别">数组名字和指针变量的区别</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = a;</span><br></pre></td></tr></table></figure><p><strong>相同点：</strong><code>a</code> 是数组的名字，是<code>a[0]</code> 的地址，<code>p</code> 也保存了 <code>a[0]</code>的地址，即 <code>a</code> 和 <code>p</code> 都指向<code>a[0]</code>，所以在访问数组元素时，<code>a</code> 和<code>p</code> 是等价的。</p><p><strong>不同点：</strong></p><ol type="1"><li><code>a</code> 是常量，<code>p</code> 是变量，可以使用<code>=</code> 运算符为 <code>p</code> 赋值，但是不能为 <code>a</code>赋值；</li><li>对 <code>a</code> 取地址和对 <code>p</code> 取地址得到的结果不同。对<code>a</code> 取地址得到的是指针数组，对 <code>p</code>取地址得到的是指针的指针。</li></ol><h3 id="多维数组中指针的转换">多维数组中指针的转换</h3><p>在二维数组中，行地址取 <code>*</code>会将指针降级，由行地址变成指向这一行第 0 个元素的指针，取 <code>*</code>之后还是会指向同一个地方，但指针类型不一样了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a +1=%p\n&quot;</span>, a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*a =%p\n&quot;</span>, *a); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(*a)+1 =%p\n&quot;</span>, (*a) + <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img data-src="https://github.com/XinranSix/docs/assets/62458905/4cdf558d-d9fd-4187-aa9c-c45318b1e1aa" alt="image"  /></p><h2 id="指针与函数的关系">指针与函数的关系</h2><h3 id="指针作为函数的参数">指针作为函数的参数</h3><p>指针可以作为函数的参数。</p><p>C 语言中的参数传递方式：复制传参、地址传参。</p><p><strong>复制传参：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in fun: a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p, &amp;b = %p\n&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before fun: a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p, &amp;b = %p\n&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    fun(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after fun: a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/fbf8f802-cc9d-4b0b-bdff-85cfcbc1f2e2"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p><strong>地址传参：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> *q)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = *p;</span><br><span class="line">    *p = *q;</span><br><span class="line">    *q = temp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in fun: *p = %d, *q = %d\n&quot;</span>, *p, *q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %p, q = %p\n&quot;</span>, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before fun: a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p, &amp;b = %p\n&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    fun(&amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after fun: a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/9d3569fb-81eb-4624-81cf-a1e8b4a7a155"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="传数组">传数组</h3><p>将数组为参数传递给函数，传递的是数组的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传一维数组</span></span><br><span class="line"><span class="comment">// void fun1(int p[])//形式1</span></span><br><span class="line"><span class="comment">// 形式2(常用)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> *p)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(p + <span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    fun1(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传二维数组</span></span><br><span class="line"><span class="comment">// void fun2( int p[][4] )//形式1</span></span><br><span class="line"><span class="comment">// 形式2：通过数组指针</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun2</span><span class="params">(<span class="type">int</span> (*p)[<span class="number">4</span>])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(*(p + <span class="number">1</span>) + <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    fun2(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun3</span><span class="params">(<span class="type">char</span> **q)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p[<span class="number">3</span>] = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;kitty&quot;</span>&#125;;</span><br><span class="line">    fun3(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    test1();</span><br><span class="line">    test2();</span><br><span class="line">    test3();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/2b905c47-9548-49fe-8ac8-0f28d3d07d49"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="指针函数">指针函数</h3><p>返回值为指针的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针函数：指针作为函数的返回值</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 栈区开辟的空间会随着当前代码段的结束而释放空间</span></span><br><span class="line">    <span class="comment">// char str[100] = &quot;hello world&quot;;</span></span><br><span class="line">    <span class="comment">// 静态区的空间不会随着当前代码段的结束而释放空间</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> str[<span class="number">100</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    p = fun();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %s\n&quot;</span>, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/73160357-c6c7-4219-9769-aae6d1ae19c6"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h3 id="函数指针">函数指针</h3><p>在 C语言中，函数名就是函数的首地址，可以定义一个函数指针变量指向这个函数。</p><p><strong>函数指针的定义语法：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 (*指针名)(形参列表);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    p = max;</span><br><span class="line">    p = min;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用函数的方法：</strong></p><p>通过函数的名字调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    num = max(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过函数指针调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">    p = max;</span><br><span class="line">    num = p(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数指针数组：</strong></p><p>是一个数组，每个元素都是一个函数指针。</p><p>定义方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 (*指针名)[函数指针的个数](形参列表);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">10</span>](<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>定义了一个函数指针数组，有 10 个元素，每个元素指向一个返回值为<code>int</code>，有两个 <code>int</code> 类型的参数的指针。</p><p><strong>函数指针最常用的地方：</strong>将函数作为另外一个是函数的参数传递过去，即回调函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mux</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dive</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="keyword">return</span> x / y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = (*p)(a, b);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    num = process(add, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line">    num = process(sub, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line">    num = process(mux, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line">    num = process(dive, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/0381f37e-89f5-4ae6-9252-e1c0c0099cc8"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><h2 id="特殊指针">特殊指针</h2><p><strong><code>void</code>类型的指针：</strong>万能指针，可以将任意类型的指针赋值给他，但<code>void</code>类型的指针要转换成其他类型的指针必须要强转。有些函数的参数或者返回值就是<code>void *</code> 类型。</p><p><code>NULL</code>：空指针，编号为 0 的指针，地址为<code>0x00000000</code>，一般用 <code>NULL</code> 给指针初始化。</p><h2 id="main-函数传参">main 函数传参</h2><p>C 语言中主函数的头为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>;</span><br></pre></td></tr></table></figure><p><code>argv</code>：记录输入的参数个数。</p><p><code>argv</code>：记录输入的参数值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc=%d\n&quot;</span>, argc);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]=%s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用如下命令运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main10.exe nihao hello world</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure><img data-src="https://github.com/XinranSix/docs/assets/62458905/80b7aaf2-06bb-483a-9e42-7002dfcf88f2"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>可以看到第一个参数是程序在计算机上的绝对路径，从第 2个参数开始才是我们输入的值。</p>]]></content>
    
    
    <summary type="html">介绍 C 语言中的各种指针</summary>
    
    
    
    <category term="C 语言基础" scheme="https://xinransix.github.io/categories/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C" scheme="https://xinransix.github.io/tags/C/"/>
    
    <category term="指针" scheme="https://xinransix.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>预处理</title>
    <link href="https://xinransix.github.io/2023/07/16/%E9%A2%84%E5%A4%84%E7%90%86/"/>
    <id>https://xinransix.github.io/2023/07/16/%E9%A2%84%E5%A4%84%E7%90%86/</id>
    <published>2023-07-16T02:32:37.000Z</published>
    <updated>2024-02-10T09:14:01.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-语言编译过程">C 语言编译过程</h2><p>预处理、编译、汇编、链接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -E main.c -o main.i <span class="comment"># 预处理</span></span><br><span class="line">gcc -S main.i -o main.s <span class="comment"># 编译</span></span><br><span class="line">gcc -c main.s -o main.o <span class="comment"># 汇编</span></span><br><span class="line">gcc main.o -o main <span class="comment">#链接</span></span><br></pre></td></tr></table></figure><ol type="1"><li>预处理：将 <code>.c</code> 的头文件展开、宏展开，生成<code>.i</code> 文件；</li><li>编译：将预处理后 <code>.i</code> 文件生成 <code>.s</code>汇编文件；</li><li>汇编：将 <code>.s</code> 汇编文件生成 <code>.o</code>目标文件；</li><li>链接：将 <code>.o</code> 文件链接成目标文件。</li></ol><h2 id="include">include</h2><p><code>#include&lt;&gt;</code>：用尖括号包含头文件，在系统指定的路径下找头文件。</p><p><code>#include ""</code>：用双引号包含头文件，先在当前目录下找头文件，找不到，再到系统指定的路径下找。</p><blockquote><p>注意：<code>include</code> 经常用来包含头文件，可以包含<code>.c</code> 文件，但不要这么做，因为 <code>include</code>包含的文件会在预编译被展开，如果一个 <code>.c</code>被包含多次，展开多次，会导致函数重复定义。</p></blockquote><blockquote><p>注意：预处理只是对 <code>include</code>等预处理操作进行处理并不会进行语法检查这个阶段有语法错误也不会报错，第二个阶段即编译阶段才进行语法检查。</p></blockquote><h2 id="define">define</h2><p>用来定义宏。</p><p><strong>不带参宏：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br></pre></td></tr></table></figure><p>在预编译的时候如果代码中出现了 PI 就用 3.14 去替换。</p><p>宏的好处：只要修改宏定义，其他地方在预编译的时候就会重新替换。</p><blockquote><p>注意：宏定义后边不要加分号。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PI = %lf\n&quot;</span>, PI);</span><br><span class="line">    <span class="type">double</span> d = PI;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d = %lf\n&quot;</span>, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/968daaa1-8453-4af8-a6e0-8e023250be1d"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>宏定义的作用范围：从定义的地方到本文件末，可以使用<code>#undef PI</code> 提前结束宏定义的作用。</p><p><strong>带参宏：</strong></p><p><code>#define S(a, b) a * b</code></p><p>注意带参宏的形参 a 和 b 没有类型名，<code>S(2, 4)</code>将来在预处理的时候替换成实参替代字符串的形参，其他字符保留。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S(a, b) ((a) * (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, S(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, S(<span class="number">2</span> + <span class="number">8</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/54474424-669a-4578-b0b2-8702ff446ce1"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p><strong>带参宏和带参函数的区别：</strong></p><p>带参宏被调用多少次就会展开多少次，执行代码的时候没有函数调用的过程，不需要压栈弹栈。所以带参宏，浪费了空间，节省时间。</p><p>带参函数，代码只有一份，存在代码段，调用的时候去代码段取指令，调用的时候要压栈弹栈，有个调用的过程。带参函数是浪费了时间，节省了空间。</p><p>带参函数的形参是有类型的，带参宏的形参没有类型名。</p><p>如果功能实现的代码相对简单，并且不需要开辟太多的空间，可以选择使用带参宏，但是大多数情况都会使用函数。</p><h2 id="条件编译">条件编译</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> AAA</span></span><br><span class="line">代码段一</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">代码段二</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AAA</span></span><br><span class="line">代码段一</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">代码段二</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 表达式</span></span><br><span class="line">程序段一</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">程序段二</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AAA</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> AAA</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello kitty!!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello tom\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/ff827787-315b-4865-8903-8c88cbbb3e9a"alt="image" /><figcaption aria-hidden="true">image</figcaption></figure>]]></content>
    
    
    <summary type="html">介绍 C 语言预处理过程以及常用预处理指令</summary>
    
    
    
    <category term="C 语言基础" scheme="https://xinransix.github.io/categories/C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="C" scheme="https://xinransix.github.io/tags/C/"/>
    
    <category term="预处理" scheme="https://xinransix.github.io/tags/%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
</feed>
