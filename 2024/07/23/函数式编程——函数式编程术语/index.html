<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"xinransix.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12,"width":280},"hljswrap":true,"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"waline","storage":true,"lazyload":false,"nav":{"waline":{"order":-2},"gitalk":{"order":-1}},"activeClass":"waline"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="介绍函数式编程中的一些术语（基于 JavaScript)">
<meta property="og:type" content="article">
<meta property="og:title" content="函数式编程——函数式编程术语">
<meta property="og:url" content="https://xinransix.github.io/2024/07/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%9C%AF%E8%AF%AD/index.html">
<meta property="og:site_name" content="木漏れ日">
<meta property="og:description" content="介绍函数式编程中的一些术语（基于 JavaScript)">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-07-23T01:51:29.000Z">
<meta property="article:modified_time" content="2025-02-16T07:25:49.334Z">
<meta property="article:author" content="Yao J">
<meta property="article:tag" content="函数式编程">
<meta property="article:tag" content="范畴论">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://xinransix.github.io/2024/07/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%9C%AF%E8%AF%AD/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://xinransix.github.io/2024/07/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%9C%AF%E8%AF%AD/","path":"2024/07/23/函数式编程——函数式编程术语/","title":"函数式编程——函数式编程术语"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>函数式编程——函数式编程术语 | 木漏れ日</title>
  







<link rel="dns-prefetch" href="https://comment-for-blog-psi.vercel.app/">


<script>
  var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)看不见我看不见我" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 咦，竟然被你发现了~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });
</script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="木漏れ日" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">木漏れ日</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">58</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">11</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">34</span></a></li><li class="menu-item menu-item-友人帐"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友人帐</a></li><li class="menu-item menu-item-rss"><a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#arity"><span class="nav-number">1.</span> <span class="nav-text">Arity</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0-higher-order-function-hof"><span class="nav-number">2.</span> <span class="nav-text">高阶函数 (Higher-Order
Function &#x2F; HOF)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AD%E5%8C%85-closure"><span class="nav-number">3.</span> <span class="nav-text">闭包 (Closure)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%8F%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8-partial-application"><span class="nav-number">4.</span> <span class="nav-text">偏函数应用 (Partial
Application)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%AF%E9%87%8C%E5%8C%96-currying"><span class="nav-number">5.</span> <span class="nav-text">柯里化 (Currying)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E6%9F%AF%E9%87%8C%E5%8C%96-auto-currying"><span class="nav-number">6.</span> <span class="nav-text">自动柯里化 (Auto Currying)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E9%98%85%E8%AF%BB"><span class="nav-number">6.0.1.</span> <span class="nav-text">进一步阅读</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E5%90%88-function-composition"><span class="nav-number">7.</span> <span class="nav-text">函数组合 (Function
Composition)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#continuation-%E5%90%8E%E7%BB%AD"><span class="nav-number">8.</span> <span class="nav-text">Continuation (后续)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%AF%E5%87%BD%E6%95%B0-purity"><span class="nav-number">9.</span> <span class="nav-text">纯函数 (Purity)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%AF%E4%BD%9C%E7%94%A8-side-effects"><span class="nav-number">10.</span> <span class="nav-text">副作用 (Side effects)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%82%E7%AD%89-idempotent"><span class="nav-number">11.</span> <span class="nav-text">幂等 (Idempotent)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#point-free-%E9%A3%8E%E6%A0%BC-point-free-style"><span class="nav-number">12.</span> <span class="nav-text">Point-Free 风格 (Point-Free
Style)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%AD%E5%AE%9A-predicate"><span class="nav-number">13.</span> <span class="nav-text">断定 (Predicate)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A5%91%E7%BA%A6-contracts"><span class="nav-number">14.</span> <span class="nav-text">契约 (Contracts)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8C%83%E7%95%B4-category"><span class="nav-number">15.</span> <span class="nav-text">范畴 (Category)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E9%98%85%E8%AF%BB-1"><span class="nav-number">15.0.1.</span> <span class="nav-text">进一步阅读</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%80%BC-value"><span class="nav-number">16.</span> <span class="nav-text">值 (Value)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F-constant"><span class="nav-number">17.</span> <span class="nav-text">常量 (Constant)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E5%AD%90-functor"><span class="nav-number">18.</span> <span class="nav-text">函子 (Functor)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7-preserves-identity"><span class="nav-number">18.1.</span> <span class="nav-text">一致性 (Preserves identity)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%80%A7-composable"><span class="nav-number">18.2.</span> <span class="nav-text">组合性 (Composable)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%90%91%E5%87%BD%E5%AD%90-pointed-functor"><span class="nav-number">18.3.</span> <span class="nav-text">指向函子 (Pointed Functor)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%AC%E5%8D%87-lift"><span class="nav-number">19.</span> <span class="nav-text">抬升 (Lift)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E9%80%8F%E6%98%8E%E6%80%A7-referential-transparency"><span class="nav-number">20.</span> <span class="nav-text">引用透明性 (Referential
Transparency)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AD%89%E5%BC%8F%E6%8E%A8%E7%90%86-equational-reasoning"><span class="nav-number">21.</span> <span class="nav-text">等式推理 (Equational
Reasoning)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lambda"><span class="nav-number">22.</span> <span class="nav-text">Lambda</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lambda%E6%BC%94%E7%AE%97-lambda-calculus"><span class="nav-number">23.</span> <span class="nav-text">Lambda演算 (Lambda Calculus)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC-lazy-evaluation"><span class="nav-number">24.</span> <span class="nav-text">惰性求值 (Lazy evaluation)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BA%E5%8D%8A%E7%BE%A4-monoid"><span class="nav-number">25.</span> <span class="nav-text">幺半群 (Monoid)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E5%AD%90-monad"><span class="nav-number">26.</span> <span class="nav-text">单子 (Monad)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%99%E5%8D%95%E5%AD%90-comonad"><span class="nav-number">27.</span> <span class="nav-text">余单子 (Comonad)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%87%BD%E5%AD%90-applicative-functor"><span class="nav-number">28.</span> <span class="nav-text">应用函子 (Applicative
Functor)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%81%E5%B0%84-morphism"><span class="nav-number">29.</span> <span class="nav-text">态射 (Morphism)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#endomorphism-%E8%87%AA%E5%90%8C%E6%80%81"><span class="nav-number">29.1.</span> <span class="nav-text">Endomorphism (自同态)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isomorphism-%E5%90%8C%E6%9E%84"><span class="nav-number">29.2.</span> <span class="nav-text">Isomorphism (同构)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#homomorphism-%E5%90%8C%E6%80%81"><span class="nav-number">29.3.</span> <span class="nav-text">Homomorphism (同态)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#catamorphism"><span class="nav-number">29.4.</span> <span class="nav-text">Catamorphism</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#anamorphism"><span class="nav-number">29.5.</span> <span class="nav-text">Anamorphism</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hylomorphism"><span class="nav-number">29.6.</span> <span class="nav-text">Hylomorphism</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#paramorphism"><span class="nav-number">29.7.</span> <span class="nav-text">Paramorphism</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#apomorphism"><span class="nav-number">29.8.</span> <span class="nav-text">Apomorphism</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setoid"><span class="nav-number">30.</span> <span class="nav-text">Setoid</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8A%E7%BE%A4-semigroup"><span class="nav-number">31.</span> <span class="nav-text">半群 (Semigroup)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E6%8A%98%E5%8F%A0%E6%80%A7-foldable"><span class="nav-number">32.</span> <span class="nav-text">可折叠性 (Foldable)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%8F%E9%95%9C-lens"><span class="nav-number">33.</span> <span class="nav-text">透镜 (Lens)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E7%AD%BE%E5%90%8D-type-signatures"><span class="nav-number">34.</span> <span class="nav-text">类型签名 (Type Signatures)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E6%95%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-algebraic-data-type"><span class="nav-number">35.</span> <span class="nav-text">代数数据类型 (Algebraic data
type)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%92%8C%E7%B1%BB%E5%9E%8B-sum-type"><span class="nav-number">35.1.</span> <span class="nav-text">和类型 (Sum type)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#product-type"><span class="nav-number">35.2.</span> <span class="nav-text">Product type</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%80%89%E7%B1%BB%E5%9E%8B-option"><span class="nav-number">36.</span> <span class="nav-text">可选类型 (Option)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#function"><span class="nav-number">37.</span> <span class="nav-text">Function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%8F%E5%87%BD%E6%95%B0-partial-function"><span class="nav-number">38.</span> <span class="nav-text">偏函数 (Partial function)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%81%8F%E5%87%BD%E6%95%B0"><span class="nav-number">38.1.</span> <span class="nav-text">处理偏函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8-js-%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%BA%93"><span class="nav-number">39.</span> <span class="nav-text">在 js 中的函数式编程库</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yao J"
      src="https://avatars.githubusercontent.com/u/62458905?v=4">
  <p class="site-author-name" itemprop="name">Yao J</p>
  <div class="site-description" itemprop="description">图形渣</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/XinranSix" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;XinranSix" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2937552332@qq.com" title="E-Mail → 2937552332@qq.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
<div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>
        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://godbolt.org/" title="https:&#x2F;&#x2F;godbolt.org&#x2F;" rel="noopener" target="_blank">Compiler Explorer</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://cppinsights.io/" title="https:&#x2F;&#x2F;cppinsights.io&#x2F;" rel="noopener" target="_blank">C++ Insights</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://play.rust-lang.org/" title="https:&#x2F;&#x2F;play.rust-lang.org&#x2F;" rel="noopener" target="_blank">Rust Playground</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xinransix.github.io/2024/07/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%9C%AF%E8%AF%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62458905?v=4">
      <meta itemprop="name" content="Yao J">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="木漏れ日">
      <meta itemprop="description" content="图形渣">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="函数式编程——函数式编程术语 | 木漏れ日">
      <meta itemprop="description" content="介绍函数式编程中的一些术语（基于 JavaScript)">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          函数式编程——函数式编程术语
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-23 09:51:29" itemprop="dateCreated datePublished" datetime="2024-07-23T09:51:29+08:00">2024-07-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-16 15:25:49" itemprop="dateModified" datetime="2025-02-16T15:25:49+08:00">2025-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">函数式编程</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2024/07/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%9C%AF%E8%AF%AD/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2024/07/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%9C%AF%E8%AF%AD/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="waline-pageview-count" data-path="/2024/07/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%9C%AF%E8%AF%AD/"></span>
    </span>
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>24 分钟</span>
    </span>
</div>

            <div class="post-description">介绍函数式编程中的一些术语（基于 JavaScript)</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><blockquote>
<p>译者注：本项目译自 <a
target="_blank" rel="noopener" href="https://github.com/hemanth/functional-programming-jargon">functional-programing-jargon</a>，专业术语居多，如有错误，可以提
pr 更正。除了术语翻译，针对每项术语，也有代码示例，位于 /demos
目录下。另外，这里也有几份不错的文章和仓库。 + <a
target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html">函数式编程入门教程</a>
+ <a
target="_blank" rel="noopener" href="https://github.com/MostlyAdequate/mostly-adequate-guide">mostly-adequate-guide
(10749 stars)</a> + <a
target="_blank" rel="noopener" href="https://github.com/llh911001/mostly-adequate-guide-chinese">mostly-adequate-guide-chinese
(602 stars)</a> + <a
target="_blank" rel="noopener" href="https://github.com/fantasyland/fantasy-land">fantasy-land</a></p>
</blockquote>
<p>函数式编程有许多优势，由此越来越受欢迎。然而每个编程范式 (paradigm)
都有自己唯一的术语，函数式编程也不例外。我们提供一张术语表，希望使你学习函数式编程变得容易些。</p>
<p>示例均为 javascript (ES2015)。<a
target="_blank" rel="noopener" href="https://github.com/hemanth/functional-programming-jargon/wiki/Why-JavaScript%3F">为什么使用JavaScript?</a></p>
<p><em>尚在 WIP 阶段，欢迎 pr。</em></p>
<p>如果适用，本篇文档使用定义在 <a
target="_blank" rel="noopener" href="https://github.com/fantasyland/fantasy-land">Fantasy Land spec</a>
中的术语。</p>
<p><strong>目录</strong></p>
<ul>
<li><a href="#arity">Arity</a></li>
<li><a href="#高阶函数-higher-order-function--hof">高阶函数
(Higher-Order Function / HOF)</a></li>
<li><a href="#闭包-closure">闭包 (Closure)</a></li>
<li><a href="#偏函数应用-partial-application">偏函数应用 (Partial
Application)</a></li>
<li><a href="#柯里化-currying">柯里化 (Currying)</a></li>
<li><a href="#自动柯里化-auto-currying">自动柯里化 (Auto Currying)</a>
<ul>
<li><a href="#进一步阅读">进一步阅读</a></li>
</ul></li>
<li><a href="#函数组合-function-composition">函数组合 (Function
Composition)</a></li>
<li><a href="#continuation-后续">Continuation (后续)</a></li>
<li><a href="#纯函数-purity">纯函数 (Purity)</a></li>
<li><a href="#副作用-side-effects">副作用 (Side effects)</a></li>
<li><a href="#幂等-idempotent">幂等 (Idempotent)</a></li>
<li><a href="#point-free-风格-point-free-style">Point-Free 风格
(Point-Free Style)</a></li>
<li><a href="#断定-predicate">断定 (Predicate)</a></li>
<li><a href="#契约-contracts">契约 (Contracts)</a></li>
<li><a href="#范畴-category">范畴 (Category)</a>
<ul>
<li><a href="#进一步阅读-1">进一步阅读</a></li>
</ul></li>
<li><a href="#值-value">值 (Value)</a></li>
<li><a href="#常量-constant">常量 (Constant)</a></li>
<li><a href="#函子-functor">函子 (Functor)</a>
<ul>
<li><a href="#一致性-preserves-identity">一致性 (Preserves
identity)</a></li>
<li><a href="#组合性-composable">组合性 (Composable)</a></li>
<li><a href="#指向函子-pointed-functor">指向函子 (Pointed
Functor)</a></li>
</ul></li>
<li><a href="#抬升-lift">抬升 (Lift)</a></li>
<li><a href="#引用透明性-referential-transparency">引用透明性
(Referential Transparency)</a></li>
<li><a href="#等式推理-equational-reasoning">等式推理 (Equational
Reasoning)</a></li>
<li><a href="#lambda">Lambda</a></li>
<li><a href="#lambda演算-lambda-calculus">Lambda演算 (Lambda
Calculus)</a></li>
<li><a href="#惰性求值-lazy-evaluation">惰性求值 (Lazy
evaluation)</a></li>
<li><a href="#幺半群-monoid">幺半群 (Monoid)</a></li>
<li><a href="#单子-monad">单子 (Monad)</a></li>
<li><a href="#余单子-comonad">余单子 (Comonad)</a></li>
<li><a href="#应用函子-applicative-functor">应用函子 (Applicative
Functor)</a></li>
<li><a href="#态射-morphism">态射 (Morphism)</a>
<ul>
<li><a href="#endomorphism-自同态">Endomorphism (自同态)</a></li>
<li><a href="#isomorphism-同构">Isomorphism (同构)</a></li>
<li><a href="#homomorphism-同态">Homomorphism (同态)</a></li>
<li><a href="#catamorphism">Catamorphism</a></li>
<li><a href="#anamorphism">Anamorphism</a></li>
<li><a href="#hylomorphism">Hylomorphism</a></li>
<li><a href="#paramorphism">Paramorphism</a></li>
<li><a href="#apomorphism">Apomorphism</a></li>
</ul></li>
<li><a href="#setoid">Setoid</a></li>
<li><a href="#半群-semigroup">半群 (Semigroup)</a></li>
<li><a href="#可折叠性-foldable">可折叠性 (Foldable)</a></li>
<li><a href="#透镜-lens">透镜 (Lens)</a></li>
<li><a href="#类型签名-type-signatures">类型签名 (Type
Signatures)</a></li>
<li><a href="#代数数据类型-algebraic-data-type">代数数据类型 (Algebraic
data type)</a>
<ul>
<li><a href="#和类型-sum-type">和类型 (Sum type)</a></li>
<li><a href="#product-type">Product type</a></li>
</ul></li>
<li><a href="#可选类型-option">可选类型 (Option)</a></li>
<li><a href="#function">Function</a></li>
<li><a href="#偏函数-partial-function">偏函数 (Partial function)</a>
<ul>
<li><a href="#处理偏函数">处理偏函数</a></li>
</ul></li>
<li><a href="#在-js-中的函数式编程库">在 js 中的函数式编程库</a></li>
</ul>
<div id="arity">

</div>
<h2 id="arity">Arity</h2>
<p>函数参数的个数。来自于单词 unary(一元), binary(二元), ternary(三元)
等等。这个单词是由 -ary 与 -ity
两个后缀拼接而成。例如，加法函数有两个参数，因此它被定义为二元函数(<code>binary function</code>)，或者说它的
<code>arity</code> 是2。它也被那些更喜欢希腊词根而非拉丁词根的人称为
<code>dyadic</code>。同样地，带有可变数量的参数的函数被称为
<code>variadic</code>，而二元函数只能且必须带两个参数，尽管有柯里化(currying)和偏函数应用(partial
application)的存在(见下文)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">a, b</span>) =&gt; a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arity = sum.<span class="property">length</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arity)        <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数sum的arity为2。</span></span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/arity.js">示例</a></p>
<div id="higher-order-functions-hof">

</div>
<h2 id="高阶函数-higher-order-function-hof">高阶函数 (Higher-Order
Function / HOF)</h2>
<p>以函数为参数或/和返回值的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">filter</span> = (<span class="params">predicate, xs</span>) =&gt; xs.<span class="title function_">filter</span>(predicate)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">is</span> = (<span class="params">type</span>) =&gt; <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="title class_">Object</span>(x) <span class="keyword">instanceof</span> type</span><br><span class="line"></span><br><span class="line"><span class="title function_">filter</span>(<span class="title function_">is</span>(<span class="title class_">Number</span>), [<span class="number">0</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">2</span>, <span class="literal">null</span>]) <span class="comment">// 0, 2</span></span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/hoc.js">示例</a></p>
<div id="closure">

</div>
<h2 id="闭包-closure">闭包 (Closure)</h2>
<p>闭包是访问在其作用域外的变量的一种方式。正式地说，闭包是一种用于实现词法作用域命名绑定的技术。它是存储一个函数和它的环境的一种方法。</p>
<p>闭包是一个作用域，它会捕获函数的局部变量，因此即使执行过程已经移出了定义它的那个代码块，也可以访问它们。也就是说，它们允许在声明变量的代码块已经执行完成之后，还是可以引用这个作用域。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">addTo</span> = x =&gt; <span class="function"><span class="params">y</span> =&gt;</span> x + y;</span><br><span class="line"><span class="keyword">var</span> addToFive = <span class="title function_">addTo</span>(<span class="number">5</span>);</span><br><span class="line"><span class="title function_">addToFive</span>(<span class="number">3</span>); <span class="comment">//返回 8</span></span><br></pre></td></tr></table></figure>
<p>函数<code>addTo()</code>返回了一个函数(在内部调用了<code>add()</code>)，我们将它保存在了一个叫做<code>addToFive</code>的变量中，并且柯里化地用一个参数5来调用它。</p>
<p>理想情况下，当函数<code>addTo</code>执行完成后，它的作用域，包括本地变量add(即+)，x，y，都应该无法访问了。但是，<code>addToFive()</code>的调用返回了8。这说明，<code>addTo</code>函数的状态被保存了，即使在代码块已经完成执行之后。否则，就不会知道<code>addTo</code>曾经被<code>addTo(5)</code>这样调用过，且x的值被设为了5。</p>
<p>词法作用域(lexical
scoping)是它能找到x和add这两个已经完成执行的父级私有变量的原因。这个值就称为闭包。</p>
<p>栈和函数的词法作用域被以父函数的引用的形式存储。这可以防止闭包和底层的变量被垃圾回收(因为至少有一个对它的有效引用)。</p>
<p>Lambda Vs
闭包：Lambda本质上是一个内联定义的函数，而不是声明函数的标准方法。Lambda经常可以作为对象被传递。</p>
<p>闭包是通过引用其主体外部的字段来将其周围的状态包裹进来的函数。被包裹的状态在闭包调用期间保持不变。</p>
<div id="partial-application">

</div>
<h2 id="偏函数应用-partial-application">偏函数应用 (Partial
Application)</h2>
<p>"部分地"应用一个函数，即预设原始函数的部分参数来创建一个新的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建偏函数，固定一些参数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">partial</span> = (<span class="params">f, ...args</span>) =&gt;</span><br><span class="line">  <span class="comment">// 返回一个带有剩余参数的函数</span></span><br><span class="line">  <span class="function">(<span class="params">...moreArgs</span>) =&gt;</span></span><br><span class="line">    <span class="comment">// 调用原始函数</span></span><br><span class="line">    <span class="title function_">f</span>(...args, ...moreArgs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add3</span> = (<span class="params">a, b, c</span>) =&gt; a + b + c <span class="comment">// (c) =&gt; 2 + 3 + c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分地将`2`和`3`应用于`add3`，得到一个只有一个参数的函数</span></span><br><span class="line"><span class="keyword">const</span> fivePlus = <span class="title function_">partial</span>(add3, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">fivePlus</span>(<span class="number">4</span>)  <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>Function.prototype.bind</code> 实现偏函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add1More = add3.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// (c) =&gt; 2 + 3 + c</span></span><br></pre></td></tr></table></figure>
<p>偏函数应用通过对复杂的函数填充一部分数据来构成一个简单的函数。柯里化就是自动实现的偏函数。</p>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/partial.js">示例</a></p>
<div id="currying">

</div>
<h2 id="柯里化-currying">柯里化 (Currying)</h2>
<p>将一个多元函数转变为一元函数的过程。
每当函数被调用时，它仅仅接收一个参数并且返回带有一个参数的函数，直到传递完所有的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">a, b</span>) =&gt; a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">curriedSum</span> = (<span class="params">a</span>) =&gt; <span class="function">(<span class="params">b</span>) =&gt;</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="title function_">curriedSum</span>(<span class="number">3</span>)(<span class="number">4</span>)         <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add2 = <span class="title function_">curriedSum</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">add2</span>(<span class="number">10</span>)     <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/curry.js">示例</a></p>
<div id="auto-currying">

</div>
<h2 id="自动柯里化-auto-currying">自动柯里化 (Auto Currying)</h2>
<p>将一个包含多个参数的函数转换成另一个函数，这个函数如果被给到的参数少于正确的数量，就会返回一个接受剩余参数的函数。</p>
<p>lodash &amp; Ramda 有一个<code>curry</code>函数可以做到这一点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">x, y</span>) =&gt; x + y</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curriedAdd = _.<span class="title function_">curry</span>(add)</span><br><span class="line"></span><br><span class="line"><span class="title function_">curriedAdd</span>(<span class="number">1</span>, <span class="number">2</span>)   <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">curriedAdd</span>(<span class="number">1</span>)(<span class="number">2</span>)   <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">curriedAdd</span>(<span class="number">1</span>)      <span class="comment">// (y) =&gt; 1 + y</span></span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/curry2.js">示例</a></p>
<h4 id="进一步阅读">进一步阅读</h4>
<ul>
<li><a target="_blank" rel="noopener" href="http://fr.umio.us/favoring-curry/">Favoring Curry</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=m3svKOdZijA">Hey
Underscore, You're Doing It Wrong!</a></li>
</ul>
<div id="function-composition">

</div>
<h2 id="函数组合-function-composition">函数组合 (Function
Composition)</h2>
<p>把两个函数放在一起形成第三个函数的行为，一个函数的输入为另一个函数的输出。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">compose</span> = (<span class="params">f, g</span>) =&gt; <span class="function">(<span class="params">a</span>) =&gt;</span> <span class="title function_">f</span>(<span class="title function_">g</span>(a))    <span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">const</span> floorAndToString = <span class="title function_">compose</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> val.<span class="title function_">toString</span>(), <span class="title class_">Math</span>.<span class="property">floor</span>) <span class="comment">// 使用</span></span><br><span class="line"><span class="title function_">floorAndToString</span>(<span class="number">12.12</span>)   <span class="comment">// &#x27;12&#x27;</span></span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/compose.js">示例</a></p>
<div id="continuation">

</div>
<h2 id="continuation-后续">Continuation (后续)</h2>
<p>在一个程序执行的任意时刻，尚未执行的代码称为 Continuation。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">printAsString</span> = (<span class="params">num</span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Given <span class="subst">$&#123;num&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addOneAndContinue</span> = (<span class="params">num, cc</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> result = num + <span class="number">1</span></span><br><span class="line">  <span class="title function_">cc</span>(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addOneAndContinue</span>(<span class="number">2</span>, printAsString) <span class="comment">// &#x27;Given 3&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Continuation
在异步编程中很常见，比如当程序需要接收到数据才能够继续执行。请求的响应通常作为代码的剩余执行部分，一旦接收到数据，对数据的处理被作为
Continuation。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">continueProgramWith</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 继续执行程序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">readFileAsync</span>(<span class="string">&#x27;path/to/file&#x27;</span>, <span class="function">(<span class="params">err, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">continueProgramWith</span>(response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<div id="purity">

</div>
<h2 id="纯函数-purity">纯函数 (Purity)</h2>
<p>输出仅由输入决定，且不产生副作用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">greet</span> = (<span class="params">name</span>) =&gt; <span class="string">`hello, <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&#x27;world&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>以下代码不是纯函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;Brianne&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">greet</span> = (<span class="params"></span>) =&gt; <span class="string">`Hi, <span class="subst">$&#123;<span class="variable language_">window</span>.name&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>() <span class="comment">// &quot;Hi, Brianne&quot;</span></span><br></pre></td></tr></table></figure>
<p>以上示例中，函数输出基于在函数外部存储的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">greet</span> = (<span class="params">name</span>) =&gt; &#123;</span><br><span class="line">    greeting = <span class="string">`Hi, <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&#x27;Brianne&#x27;</span>)</span><br><span class="line">greeting <span class="comment">// &quot;Hi, Brianne&quot;</span></span><br></pre></td></tr></table></figure>
<p>以上示例中，函数修改了外部状态。</p>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/purity.js">示例</a></p>
<div id="side-effects">

</div>
<h2 id="副作用-side-effects">副作用 (Side effects)</h2>
<p>如果一个函数或者表达式除了返回一个值之外，还与外部可变状态进行了交互（读取或写入），则它是有副作用的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> differentEveryTime = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;IO就是一种副作用!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/sideEffect.js">示例</a></p>
<div id="idempotent">

</div>
<h2 id="幂等-idempotent">幂等 (Idempotent)</h2>
<p>如果一个函数执行多次皆返回相同的结果，则它是幂等的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">f</span>(<span class="title function_">f</span>(x)) ≍ <span class="title function_">f</span>(x)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">sort</span>(<span class="title function_">sort</span>(<span class="title function_">sort</span>([<span class="number">2</span>, <span class="number">1</span>])))</span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/idempotent.js">示例</a></p>
<div id="point-free-style">

</div>
<h2 id="point-free-风格-point-free-style">Point-Free 风格 (Point-Free
Style)</h2>
<p>定义函数时，不显式地指出函数所带参数。这种风格通常需要柯里化或者高阶函数。也叫
Tacit programming。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已知：</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">map</span> = (<span class="params">fn</span>) =&gt; <span class="function">(<span class="params">list</span>) =&gt;</span> list.<span class="title function_">map</span>(fn)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a</span>) =&gt; <span class="function">(<span class="params">b</span>) =&gt;</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非Points-Free —— number 是显式参数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">incrementAll</span> = (<span class="params">numbers</span>) =&gt; <span class="title function_">map</span>(<span class="title function_">add</span>(<span class="number">1</span>))(numbers)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Points-Free —— list 是隐式参数</span></span><br><span class="line"><span class="keyword">const</span> incrementAll2 = <span class="title function_">map</span>(<span class="title function_">add</span>(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p><code>incrementAll</code> 识别并且使用了 <code>numbers</code>
参数，因此它不是 Point-Free 风格的。 <code>incrementAll2</code>
仅连接函数与值，并不提及它所使用的参数，因为它是 Point-Free 风格的。</p>
<p>Point-Free 风格的函数就像平常的赋值，不使用 <code>function</code>
或者 <code>=&gt;</code>。</p>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/pointFree.js">示例</a></p>
<div id="predicate">

</div>
<h2 id="断定-predicate">断定 (Predicate)</h2>
<p>根据输入返回 true 或 false。通常用在 array filter 的回调函数中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">predicate</span> = (<span class="params">a</span>) =&gt; a &gt; <span class="number">2</span></span><br><span class="line"></span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_">filter</span>(predicate)</span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/predicate.js">示例</a></p>
<div id="contracts">

</div>
<h2 id="契约-contracts">契约 (Contracts)</h2>
<p>契约规定了函数或表达式在运行时的行为的职责和保障。它表现为一组规则，这些规则是对函数或表达式的输入和输出的期望。当违反契约时，将抛出一个错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义的contract: int -&gt; boolean</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">contract</span> = (<span class="params">input</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> input === <span class="string">&#x27;number&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Contract Violated: expected int -&gt; int&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addOne</span> = (<span class="params">num</span>) =&gt; <span class="title function_">contract</span>(num) &amp;&amp; num + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">addOne</span>(<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">addOne</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// 违反了contract: int -&gt; boolean</span></span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/contracts.js">示例</a></p>
<div id="category">

</div>
<h2 id="范畴-category">范畴 (Category)</h2>
<p>在范畴论中，范畴是指对象集合及它们之间的态射
(morphism)。在编程中，数据类型作为对象，函数作为态射。</p>
<p>一个有效的范畴遵从以下三个原则：</p>
<ol type="1">
<li>必有一个同一态射（identity morphism）将一个对象映射到它自身。即当
<code>a</code> 是范畴里的一个对象时，必有一个函数使
<code>a -&gt; a</code>。</li>
<li>态射必是可组合的。<code>a</code>，<code>b</code>，<code>c</code>
是范畴里的对象，<code>f</code> 是态射
<code>a -&gt; b</code>，<code>g</code> 是 <code>b -&gt; c</code>
态射。<code>g(f(x))</code> 一定与 <code>(g • f)(x)</code>
是等价的。</li>
<li>组合满足结合律。<code>f • (g • h)</code> 与 <code>(f • g) • h</code>
是等价的。</li>
</ol>
<p>由于这些准则是在非常抽象的层面控制着组合方式，因此范畴论对于发现组合的新方法来说是伟大的。</p>
<h4 id="进一步阅读-1">进一步阅读</h4>
<ul>
<li><a
target="_blank" rel="noopener" href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">Category
Theory for Programmers</a></li>
</ul>
<div id="value">

</div>
<h2 id="值-value">值 (Value)</h2>
<p>任何可以赋给变量的东西叫做值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;)</span><br><span class="line">;<span class="function">(<span class="params">a</span>) =&gt;</span> a</span><br><span class="line">;[<span class="number">1</span>]</span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/value.js">示例</a></p>
<div id="constant">

</div>
<h2 id="常量-constant">常量 (Constant)</h2>
<p>一旦被定义之后就不可以被重新赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> five = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> john = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>常量是<a
href="#referential-transparency">引用透明</a>的，也就是说，它们可以被它们所代表的值替代而不影响结果。</p>
<p>对于以上两个常量，以下语句总会返回 true。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">john.<span class="property">age</span> + five === (&#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;).<span class="property">age</span> + (<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/constant.js">示例</a></p>
<div id="functor">

</div>
<h2 id="函子-functor">函子 (Functor)</h2>
<p>函子是一个实现了 <code>map</code> 函数的对象。<code>map</code>
函数会遍历对象中的每个值并生成一个新的对象，遵守两个准则:</p>
<div id="preserves-identity">

</div>
<h3 id="一致性-preserves-identity">一致性 (Preserves identity)</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x) ≍ object</span><br></pre></td></tr></table></figure>
<div id="composable">

</div>
<h3 id="组合性-composable">组合性 (Composable)</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.<span class="title function_">map</span>(<span class="title function_">compose</span>(f, g)) ≍ object.<span class="title function_">map</span>(g).<span class="title function_">map</span>(f)  <span class="comment">// f, g 为任意函数</span></span><br></pre></td></tr></table></figure>
<p>(<code>f</code>, <code>g</code> 是任意的函数)</p>
<p>在 javascript 中一个常见的函子是 Array,
因为它遵守因子的两个准则。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = x =&gt; x + <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">g</span> = x =&gt; x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="title function_">f</span>(<span class="title function_">g</span>(x)))</span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(g).<span class="title function_">map</span>(f)</span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/functor.js">示例</a></p>
<div id="pointed-functor">

</div>
<h3 id="指向函子-pointed-functor">指向函子 (Pointed Functor)</h3>
<p>一个对象，拥有一个<code>of</code>函数，可以将一个任何值放入它自身。</p>
<p>ES2015 添加了 <code>Array.of</code>，使 Array 成为了 Pointed
Functor。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<div id="lift">

</div>
<h2 id="抬升-lift">抬升 (Lift)</h2>
<p>抬升是指将一个值放进一个对象（如<a
href="#functor">函子</a>）中。如果你将一个函数抬升到一个<a
href="#applicative-functor">应用函子</a>中，那么就可以将它作用于该函子中的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">liftA2</span> = (<span class="params">f</span>) =&gt; <span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="title function_">map</span>(f).<span class="title function_">ap</span>(b) <span class="comment">// 注意这里是 ap 而不是 map.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mult</span> = a =&gt; <span class="function"><span class="params">b</span> =&gt;</span> a * b</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> liftedMult = <span class="title function_">liftA2</span>(mult) <span class="comment">// 这个函数现在可以作用于函子，如Array</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">liftedMult</span>([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>]) <span class="comment">// [3, 6]</span></span><br><span class="line"><span class="title function_">liftA2</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="function"><span class="params">b</span> =&gt;</span> a + b)([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]) <span class="comment">// [4, 5, 5, 6]</span></span><br></pre></td></tr></table></figure>
<p>抬升并应用一个单参数的函数的作用等同于 <code>map</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params">x</span>) =&gt; x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">lift</span>(increment)([<span class="number">2</span>]) <span class="comment">// [3]</span></span><br><span class="line">;[<span class="number">2</span>].<span class="title function_">map</span>(increment) <span class="comment">// [3]</span></span><br></pre></td></tr></table></figure>
<div id="referential-transparency">

</div>
<h2 id="引用透明性-referential-transparency">引用透明性 (Referential
Transparency)</h2>
<p>如果一个表达式能够被它的值替代而不改变程序的行为，则它是引用透明的。</p>
<p>例如我们有 greet 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">greet</span> = (<span class="params"></span>) =&gt; <span class="string">&#x27;hello, world.&#x27;</span></span><br></pre></td></tr></table></figure>
<p>任何对 <code>greet()</code> 的调用都可以被替换为
<code>Hello World!</code>, 因此 greet 是引用透明的。</p>
<div id="equational-reasoning">

</div>
<h2 id="等式推理-equational-reasoning">等式推理 (Equational
Reasoning)</h2>
<p>当一个应用程序由表达式组成并且没有副作用时，我们可以从这些组成部分中得知系统的真相。</p>
<div id="lambda">

</div>
<h2 id="lambda">Lambda</h2>
<p>一种可以被视作一个值的匿名函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="keyword">function</span> (<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">;<span class="function">(<span class="params">a</span>) =&gt;</span> a + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>Lambda 通常作为参数被传递给高阶函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">a</span>) =&gt;</span> a + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>可以把 Lambda 赋值给一个变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add1</span> = (<span class="params">a</span>) =&gt; a + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<div id="lambda-calculus">

</div>
<h2 id="lambda演算-lambda-calculus">Lambda演算 (Lambda Calculus)</h2>
<p>数学的一个分支，使用函数创造 <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lambda_calculus">通用计算模型</a></p>
<div id="lazy-evaluation">

</div>
<h2 id="惰性求值-lazy-evaluation">惰性求值 (Lazy evaluation)</h2>
<p>惰性求值是一种按需调用的求值机制，它将表达式的求值延迟到需要它的值为止，在函数式语言中，允许类似无限列表这样的结构存在，而这在非常重视命令顺序的命令式语言中通常是不可用的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rand = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title class_">Math</span>.<span class="title function_">random</span>()  </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> randIter = <span class="title function_">rand</span>()</span><br><span class="line">randIter.<span class="title function_">next</span>() <span class="comment">// 每次执行产生一个随机值，表达式会在需要时求值。</span></span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/functor.js">示例</a></p>
<div id="monoid">

</div>
<h2 id="幺半群-monoid">幺半群 (Monoid)</h2>
<p>一个对象，它拥有一个函数，这个函数用来与另一个相同类型的对象"结合"。对象的类型（<a
href="#semigroup">半群</a>）必须具有一个"identity"值。</p>
<p>数值加法是一个简单的幺半群:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">1</span>   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>以上示例中，数是对象而 <code>+</code> 是函数。</p>
<p>当任何一个值与"identity"值结合时，结果一定是原始的值。"identity"也是可换位的（即排列次序不影响结果）。</p>
<p>加法的特征值是 0。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">0</span>   <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>操作的组合不会影响结果（必须满足结合律）:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + (<span class="number">2</span> + <span class="number">3</span>) === (<span class="number">1</span> + <span class="number">2</span>) + <span class="number">3</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>数组的结合也是幺半群:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;[<span class="number">1</span>, <span class="number">2</span>].<span class="title function_">concat</span>([<span class="number">3</span>, <span class="number">4</span>]) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p><code>identity</code> 值为空数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;[<span class="number">1</span>, <span class="number">2</span>].<span class="title function_">concat</span>([])</span><br></pre></td></tr></table></figure>
<p>减法作为一个反例，不形成幺半群，因为不存在可以换位的"identity"值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> - <span class="number">4</span> === <span class="number">4</span> - <span class="number">0</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/monoid.js">示例</a></p>
<div id="monad">

</div>
<h2 id="单子-monad">单子 (Monad)</h2>
<p>拥有 <code>of</code> 和 <code>chain</code>
函数的对象即为单子。<code>chain</code> 很像 <code>map</code>，
不同的是它可以展平嵌套数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">chain</span> = <span class="keyword">function</span> (<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, it</span>) =&gt;</span> acc.<span class="title function_">concat</span>(<span class="title function_">f</span>(it)), [])  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">;<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="string">&#x27;cat,dog&#x27;</span>, <span class="string">&#x27;fish,bird&#x27;</span>).<span class="title function_">chain</span>(<span class="function"><span class="params">s</span> =&gt;</span> s.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)) <span class="comment">// [&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;fish&#x27;, &#x27;bird&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 和 map 相比</span></span><br><span class="line">;<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="string">&#x27;cat,dog&#x27;</span>, <span class="string">&#x27;fish,bird&#x27;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">s</span> =&gt;</span> s.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)) <span class="comment">// [[&#x27;cat&#x27;, &#x27;dog&#x27;], [&#x27;fish&#x27;, &#x27;bird&#x27;]]</span></span><br></pre></td></tr></table></figure>
<p>在有些函数式语言中，<code>of</code> 也称为
<code>return</code>，<code>chain</code> 也称为 <code>flatmap</code> 与
<code>bind</code>。</p>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/monad.js">示例</a></p>
<div id="comonad">

</div>
<h2 id="余单子-comonad">余单子 (Comonad)</h2>
<p>拥有 <code>extract</code> 与 <code>extend</code> 函数的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">CoIdentity</span> = (<span class="params">v</span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">val</span>: v,</span><br><span class="line">  extract () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">val</span>  </span><br><span class="line">  &#125;,</span><br><span class="line">  extend (f) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">CoIdentity</span>(<span class="title function_">f</span>(<span class="variable language_">this</span>))  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Extract 将值从余单子中取出。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">CoIdentity</span>(<span class="number">1</span>).<span class="title function_">extract</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>Extends
在余单子上运行一个函数。这个函数会返回和余单子相同的类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">CoIdentity</span>(<span class="number">1</span>).<span class="title function_">extend</span>(<span class="function"><span class="params">x</span> =&gt;</span> x.<span class="title function_">extract</span>() + <span class="number">1</span>) <span class="comment">// CoIdentity(2)</span></span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/comonad.js">示例</a></p>
<div id="applicative-functor">

</div>
<h2 id="应用函子-applicative-functor">应用函子 (Applicative
Functor)</h2>
<p>一个拥有 <code>ap</code> 函数的对象称为应用函子。<code>ap</code>
将对象中的函数应用于另一个同样类型的对象中的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">ap</span> = <span class="keyword">function</span> (<span class="params">xs</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, f</span>) =&gt;</span> acc.<span class="title function_">concat</span>(xs.<span class="title function_">map</span>(f)), [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">;[<span class="function">(<span class="params">a</span>) =&gt;</span> a + <span class="number">1</span>].<span class="title function_">ap</span>([<span class="number">1</span>]) <span class="comment">// [2]</span></span><br></pre></td></tr></table></figure>
<p>如果你有两个对象，并需要对他们的元素执行一个二元函数，这将会很有用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 你想要组合的两个数组</span></span><br><span class="line"><span class="keyword">const</span> arg1 = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> arg2 = [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合函数 - 必须要柯里化</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">x</span>) =&gt; <span class="function">(<span class="params">y</span>) =&gt;</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> partiallyAppliedAdds = [add].<span class="title function_">ap</span>(arg1) <span class="comment">// [(y) =&gt; 1 + y, (y) =&gt; 3 + y]</span></span><br></pre></td></tr></table></figure>
<p>由此得到了一个函数数组，并且可以调用 <code>ap</code>
函数得到结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">partiallyAppliedAdds.<span class="title function_">ap</span>(arg2) <span class="comment">// [5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/applicativeFunctor.js">示例</a></p>
<div id="morphism">

</div>
<h2 id="态射-morphism">态射 (Morphism)</h2>
<p>一个变形函数。</p>
<div id="endomorphism">

</div>
<h3 id="endomorphism-自同态">Endomorphism (自同态)</h3>
<p>输入输出是相同类型的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uppercase :: String -&gt; String</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">uppercase</span> = (<span class="params">str</span>) =&gt; str.<span class="title function_">toUpperCase</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// decrement :: Number -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params">x</span>) =&gt; x - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<div id="isomorphism">

</div>
<h3 id="isomorphism-同构">Isomorphism (同构)</h3>
<p>两个不用类型的对象之间的变换，保持结构并且不丢失数据。</p>
<p>例如，一个二维坐标既可以表示为数组
<code>[2, 3]</code>，也可以表示为对象 <code>&#123;x: 2, y: 3&#125;</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供函数在两种类型间互相转换</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">pairToCoords</span> = (<span class="params">pair</span>) =&gt; (&#123;<span class="attr">x</span>: pair[<span class="number">0</span>], <span class="attr">y</span>: pair[<span class="number">1</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">coordsToPair</span> = (<span class="params">coords</span>) =&gt; [coords.<span class="property">x</span>, coords.<span class="property">y</span>]</span><br><span class="line"></span><br><span class="line"><span class="title function_">coordsToPair</span>(<span class="title function_">pairToCoords</span>([<span class="number">1</span>, <span class="number">2</span>])) <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">pairToCoords</span>(<span class="title function_">coordsToPair</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;)) <span class="comment">// &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure>
<div id="homomorphism">

</div>
<h3 id="homomorphism-同态">Homomorphism (同态)</h3>
<p>同态只是一个保持结构的映射，实际上，函子只是<a
href="#category">范畴</a>之间的同态，因为它在映射下保持了原范畴的结构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.<span class="title function_">of</span>(f).<span class="title function_">ap</span>(A.<span class="title function_">of</span>(x)) == A.<span class="title function_">of</span>(<span class="title function_">f</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="title class_">Either</span>.<span class="title function_">of</span>(_.<span class="property">toUpper</span>).<span class="title function_">ap</span>(<span class="title class_">Either</span>.<span class="title function_">of</span>(<span class="string">&quot;oreos&quot;</span>)) == <span class="title class_">Either</span>.<span class="title function_">of</span>(_.<span class="title function_">toUpper</span>(<span class="string">&quot;oreos&quot;</span>))</span><br></pre></td></tr></table></figure>
<div id="catamorphism">

</div>
<h3 id="catamorphism">Catamorphism</h3>
<p>一个 <code>reduceRight</code>
函数，它应用于累加器(accumulator)和数组中的每个值（从右到左），来将其缩减为一个单一的值。</p>
<div id="anamorphism">

</div>
<h3 id="anamorphism">Anamorphism</h3>
<p>一个 <code>unfold</code> 函数。<code>unfold</code> 是
<code>fold</code>（<code>ruduce</code>）的反面。它从一个值生成一个列表。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">unfold</span> = (<span class="params">f, seed</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">go</span>(<span class="params">f, seed, acc</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="title function_">f</span>(seed);</span><br><span class="line">    <span class="keyword">return</span> res ? <span class="title function_">go</span>(f, res[<span class="number">1</span>], acc.<span class="title function_">concat</span>([res[<span class="number">0</span>]])) : acc;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">go</span>(f, seed, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">countDown</span> = n =&gt; <span class="title function_">unfold</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> n &lt;= <span class="number">0</span> ? <span class="literal">undefined</span> : [n, n - <span class="number">1</span>]</span><br><span class="line">&#125;, n)</span><br><span class="line"></span><br><span class="line"><span class="title function_">countDown</span>(<span class="number">5</span>) <span class="comment">// [5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure>
<div id="hylomorphism">

</div>
<h3 id="hylomorphism">Hylomorphism</h3>
<p>Anamorphism 和 catamorphism 的结合。</p>
<div id="paramorphism">

</div>
<h3 id="paramorphism">Paramorphism</h3>
<p>一类类似于 <code>reduceRight</code> 的函数，不过还是有区别的：</p>
<p>在Paramorphism中，reducer的参数是当前的值、所有先前的值的缩减(reduction，即reduce的结果)、以及形成该缩减的值的列表。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含 undefined 对于列表来说显然是不安全的，</span></span><br><span class="line"><span class="comment">// 但是足以说明问题。</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">para</span> = (<span class="params">reducer, accumulator, elements</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (elements.<span class="property">length</span> === <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> accumulator</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> head = elements[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> tail = elements.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">reducer</span>(head, tail, <span class="title function_">para</span>(reducer, accumulator, tail))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">suffixes</span> = list =&gt; <span class="title function_">para</span>(</span><br><span class="line">  <span class="function">(<span class="params">x, xs, suffxs</span>) =&gt;</span> [xs, ... suffxs],</span><br><span class="line">  [],</span><br><span class="line">  list</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="title function_">suffixes</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) <span class="comment">// [[2, 3, 4, 5], [3, 4, 5], [4, 5], [5], []]</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中的
reducer（<code>[x, ... xs]</code>）的第三个参数有点像一个"如何达到你当前的
acc 值"的历史记录。</p>
<div id="apomorphism">

</div>
<h3 id="apomorphism">Apomorphism</h3>
<p>paramorphism 的反面。就像 anamorphism 是 catamorphism
的反面一样。对于
paramorphism，我们结合了对累加器的访问和已经累加的东西，而apomorphism让我们可以
unfold（展开）并且具有提早return的可能性。</p>
<div id="setoid">

</div>
<h2 id="setoid">Setoid</h2>
<p>拥有 <code>equals</code> 函数的对象。<code>equals</code>
可以用来和其它相同类型的对象比较。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">equals</span> = <span class="keyword">function</span> (<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> len = <span class="variable language_">this</span>.<span class="property">length</span></span><br><span class="line">  <span class="keyword">if</span> (len !== arr.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>[i] !== arr[i]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>].<span class="title function_">equals</span>([<span class="number">1</span>, <span class="number">2</span>])   <span class="comment">// true</span></span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>].<span class="title function_">equals</span>([<span class="number">3</span>, <span class="number">4</span>])   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/setoid.js">示例</a></p>
<div id="semigroup">

</div>
<h2 id="半群-semigroup">半群 (Semigroup)</h2>
<p>一个拥有 <code>concat</code> 函数的对象。<code>concat</code>
可以连接相同类型的两个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;[<span class="number">1</span>].<span class="title function_">concat</span>([<span class="number">2</span>]) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/semigroup.js">示例</a></p>
<div id="foldable">

</div>
<h2 id="可折叠性-foldable">可折叠性 (Foldable)</h2>
<p>一个拥有 <code>reduce</code>
函数的对象具有可折叠性。<code>reduce</code>
可以把一种类型的对象转化为另一种类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">list</span>) =&gt; list.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc + val, <span class="number">0</span>)</span><br><span class="line"><span class="title function_">sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])        <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<div id="lens">

</div>
<h2 id="透镜-lens">透镜 (Lens)</h2>
<p>Lens是一种结构（通常是一个对象或者函数），他为其他数据结构对 getter
和非可变的 setter 进行配对。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 [Ramda&#x27;s lens](http://ramdajs.com/docs/#lens)</span></span><br><span class="line"><span class="keyword">const</span> nameLens = R.<span class="title function_">lens</span>(</span><br><span class="line">  <span class="comment">// 一个对象的 name 属性的 getter</span></span><br><span class="line">  <span class="function">(<span class="params">obj</span>) =&gt;</span> obj.<span class="property">name</span>,</span><br><span class="line">  <span class="comment">// name 属性的 setter</span></span><br><span class="line">  <span class="function">(<span class="params">val, obj</span>) =&gt;</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj, &#123;<span class="attr">name</span>: val&#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>为给定的数据结构设置 <code>get</code> 和 <code>set</code>
可以实现一些关键特性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;Gertrude Blanch&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 getter</span></span><br><span class="line">R.<span class="title function_">view</span>(nameLens, person) <span class="comment">// &#x27;Gertrude Blanch&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 setter</span></span><br><span class="line">R.<span class="title function_">set</span>(nameLens, <span class="string">&#x27;Shafi Goldwasser&#x27;</span>, person) <span class="comment">// &#123;name: &#x27;Shafi Goldwasser&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将函数应用于结构中的值</span></span><br><span class="line">R.<span class="title function_">over</span>(nameLens, uppercase, person) <span class="comment">// &#123;name: &#x27;GERTRUDE BLANCH&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<p>lens
也是可以组合的。这让我们可以对深度嵌套的数据进行简单的不可变更新。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个 lens 关注一个非空数组中的第一个元素</span></span><br><span class="line"><span class="keyword">const</span> firstLens = R.<span class="title function_">lens</span>(</span><br><span class="line">  <span class="comment">// 获取数组的第一个元素</span></span><br><span class="line">  <span class="function"><span class="params">xs</span> =&gt;</span> xs[<span class="number">0</span>],</span><br><span class="line">  <span class="comment">// 数组的第一个元素的非可变 setter</span></span><br><span class="line">  <span class="function">(<span class="params">val, [__, ...xs]</span>) =&gt;</span> [val, ...xs]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> people = [&#123;<span class="attr">name</span>: <span class="string">&#x27;Gertrude Blanch&#x27;</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&#x27;Shafi Goldwasser&#x27;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无论你怎么想，lens 是从左到右合成的</span></span><br><span class="line">R.<span class="title function_">over</span>(<span class="title function_">compose</span>(firstLens, nameLens), uppercase, people) <span class="comment">// [&#123;&#x27;name&#x27;: &#x27;GERTRUDE BLANCH&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;Shafi Goldwasser&#x27;&#125;]</span></span><br></pre></td></tr></table></figure>
<p>其他实现:</p>
<p><a
target="_blank" rel="noopener" href="https://github.com/calmm-js/partial.lenses">partial.lenses</a> -
"好吃"的语法糖和很多强大功能</p>
<p><a target="_blank" rel="noopener" href="http://www.kovach.me/nanoscope/">nanoscope</a> -
流畅接口</p>
<div id="type-signatures">

</div>
<h2 id="类型签名-type-signatures">类型签名 (Type Signatures)</h2>
<p>通常 js 中的函数会在注释中指出参数与返回值的类型。</p>
<p>在整个社区内存在很大的差异，但通常遵循以下模式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functionName :: firstArgType -&gt; secondArgType -&gt; returnType</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add :: Number -&gt; Number -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">x</span>) =&gt; <span class="function">(<span class="params">y</span>) =&gt;</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment">// increment :: Number -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params">x</span>) =&gt; x + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果函数接受其他函数作为参数，那么这个函数需要用括号括起来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call :: (a -&gt; b) -&gt; a -&gt; b</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">call</span> = (<span class="params">f</span>) =&gt; <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="title function_">f</span>(x)</span><br></pre></td></tr></table></figure>
<p>字符 <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>
表明参数可以是任意类型。以下版本的 <code>map</code> 的函数类型的参数
<code>f</code>，把一种类型 <code>a</code> 的数组转化为另一种类型
<code>b</code> 的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map :: (a -&gt; b) -&gt; [a] -&gt; [b]</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">map</span> = (<span class="params">f</span>) =&gt; <span class="function">(<span class="params">list</span>) =&gt;</span> list.<span class="title function_">map</span>(f)</span><br></pre></td></tr></table></figure>
<p>进一步阅读：</p>
<ul>
<li><a
target="_blank" rel="noopener" href="https://github.com/ramda/ramda/wiki/Type-Signatures">Ramda's type
signatures</a></li>
<li><a
target="_blank" rel="noopener" href="https://stackoverflow.com/questions/399312/what-is-hindley-milner/399392#399392">What
is Hindley-Milner?</a> on Stack Overflow</li>
</ul>
<div id="algebraic-data-type">

</div>
<h2 id="代数数据类型-algebraic-data-type">代数数据类型 (Algebraic data
type)</h2>
<p>一种由其他类型组合而成的复合类型。两种常见的代数类型是<a
href="#sum-type">sum</a>和<a href="#product-type">product</a>。</p>
<div id="sum-type">

</div>
<h3 id="和类型-sum-type">和类型 (Sum type)</h3>
<p>和类型是将两种类型组合成另一种类型。之所以称为和，是因为结果类型的可能的值的数目是两种输入类型的值的数目的和。</p>
<p>js 中没有这种类型，但是我们可以用 set 来假装：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 想象这些不是 set，而是仅包含这些值的某种类型。</span></span><br><span class="line"><span class="keyword">const</span> bools = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="literal">true</span>, <span class="literal">false</span>])</span><br><span class="line"><span class="keyword">const</span> halfTrue = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;half-true&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 weakLogic 类型包含 bools 类型和 halfTrue 类型的和。</span></span><br><span class="line"><span class="keyword">const</span> weakLogicValues = <span class="keyword">new</span> <span class="title class_">Set</span>([...bools, ...halfTrue])</span><br></pre></td></tr></table></figure>
<p>和类型有时也称作联合类型（union type）、区分联合（discriminated
union）或标记联合（tagged unions）。</p>
<p>JS中有一些库可以帮助定义和使用联合类型。</p>
<p>流（flow）包括联合类型，而TypeScript具有提供相同能力的枚举（enum）。</p>
<div id="product-type">

</div>
<h3 id="product-type">Product type</h3>
<p>用一种你可能更熟悉的方式把数据类型联合起来:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// point :: (Number, Number) -&gt; &#123;x: Number, y: Number&#125;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">point</span> = (<span class="params">x, y</span>) =&gt; (&#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;)</span><br></pre></td></tr></table></figure>
<p>之所以称之为积，是因为数据结构的总的可能值是不同值的乘积。许多语言都有
tuple 类型，这是积类型的最简单形式。</p>
<p>另见 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Set_theory">Set
theory</a></p>
<div id="option">

</div>
<h2 id="可选类型-option">可选类型 (Option)</h2>
<p>Option 是一种联合类型，它有两种情况，<code>Some</code> 或者
<code>None</code>。</p>
<p>Option对于一些可能不会返回值的组合函数非常有用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Some</span> = (<span class="params">v</span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">val</span>: v,</span><br><span class="line">  map (f) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Some</span>(<span class="title function_">f</span>(<span class="variable language_">this</span>.<span class="property">val</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">  chain (f) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">f</span>(<span class="variable language_">this</span>.<span class="property">val</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">None</span> = (<span class="params"></span>) =&gt; (&#123;</span><br><span class="line">  map (f) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;,</span><br><span class="line">  chain (f) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// maybeProp :: (String, &#123;a&#125;) -&gt; Option a</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">maybeProp</span> = (<span class="params">key, obj</span>) =&gt; <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;undefined&#x27;</span> ? <span class="title class_">None</span>() : <span class="title class_">Some</span>(obj[key])</span><br></pre></td></tr></table></figure>
<p>使用 <code>chain</code> 可以序列化返回 <code>Option</code>
的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getItem :: Cart -&gt; Option CartItem</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getItem</span> = (<span class="params">cart</span>) =&gt; <span class="title function_">maybeProp</span>(<span class="string">&#x27;item&#x27;</span>, cart)</span><br><span class="line"></span><br><span class="line"><span class="comment">// getPrice :: Item -&gt; Option Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getPrice</span> = (<span class="params">item</span>) =&gt; <span class="title function_">maybeProp</span>(<span class="string">&#x27;price&#x27;</span>, item)</span><br><span class="line"></span><br><span class="line"><span class="comment">// getNestedPrice :: cart -&gt; Option a</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getNestedPrice</span> = (<span class="params">cart</span>) =&gt; <span class="title function_">getItem</span>(obj).<span class="title function_">chain</span>(getPrice)</span><br><span class="line"></span><br><span class="line"><span class="title function_">getNestedPrice</span>(&#123;&#125;) <span class="comment">// None()</span></span><br><span class="line"><span class="title function_">getNestedPrice</span>(&#123;<span class="attr">item</span>: &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;&#125;) <span class="comment">// None()</span></span><br><span class="line"><span class="title function_">getNestedPrice</span>(&#123;<span class="attr">item</span>: &#123;<span class="attr">price</span>: <span class="number">9.99</span>&#125;&#125;) <span class="comment">// Some(9.99)</span></span><br></pre></td></tr></table></figure>
<p>在其它的一些地方，<code>Option</code> 也称为
<code>Maybe</code>，<code>Some</code> 也称为
<code>Just</code>，<code>None</code> 也称为 <code>Nothing</code>。</p>
<p><a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/option.js">示例
option.js</a> <a
target="_blank" rel="noopener" href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/maybe.js">示例
maybe.js</a></p>
<div id="function">

</div>
<h2 id="function">Function</h2>
<p>一个函数 <code>f :: A =&gt; B</code> 是一个表达式，通常称为 arrow
或者 lambda 表达式——只能有<strong>一个</strong>（这点是不可变的）的
<code>A</code> 类型参数和<strong>一个</strong> <code>B</code>
类型返回值。该返回值完全取决于参数，使函数独立于上下文，或者说<a
href="#referential-transparency">引用透明</a>。这里暗示的是一个函数不能产生任何隐藏的<a
href="#side-effects">副作用</a>——根据定义，函数总是<a
href="#purity">纯</a>的。这些属性使函数易于使用：它们是完全确定的，因此也是可以预测的。函数可以将代码作为数据进行处理，对行为进行抽象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// times2 :: Number -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">times2</span> = n =&gt; n * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(times2) <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>
<div id="partial-function">

</div>
<h2 id="偏函数-partial-function">偏函数 (Partial function)</h2>
<p>偏函数是没有为全部参数定义的函数——它可能返回意料之外的结果或者永远不会终止。偏函数增加了认知开销，它们更难推理，并可能导致运行时错误。一些例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1: 列表的和</span></span><br><span class="line"><span class="comment">// sum :: [Number] -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = arr =&gt; arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line"><span class="title function_">sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">sum</span>([]) <span class="comment">// TypeError: Reduce of empty array with no initial value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2: 获取列表的第一个值</span></span><br><span class="line"><span class="comment">// first :: [A] -&gt; A</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">first</span> = a =&gt; a[<span class="number">0</span>]</span><br><span class="line"><span class="title function_">first</span>([<span class="number">42</span>]) <span class="comment">// 42</span></span><br><span class="line"><span class="title function_">first</span>([]) <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 甚至更糟: </span></span><br><span class="line"><span class="title function_">first</span>([[<span class="number">42</span>]])[<span class="number">0</span>] <span class="comment">// 42</span></span><br><span class="line"><span class="title function_">first</span>([])[<span class="number">0</span>] <span class="comment">// Uncaught TypeError: Cannot read property &#x27;0&#x27; of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例3: 将函数重复 N 次</span></span><br><span class="line"><span class="comment">// times :: Number -&gt; (Number -&gt; Number) -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">times</span> = n =&gt; <span class="function"><span class="params">fn</span> =&gt;</span> n &amp;&amp; (<span class="title function_">fn</span>(n), <span class="title function_">times</span>(n - <span class="number">1</span>)(fn))</span><br><span class="line"><span class="title function_">times</span>(<span class="number">3</span>)(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="title function_">times</span>(-<span class="number">1</span>)(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line"><span class="comment">// RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>
<h3 id="处理偏函数">处理偏函数</h3>
<p>偏函数是危险的，它们需要被非常谨慎地对待。你可能会得到意料之外的（错误的）结果或遇到运行时错误。有时偏函数可能根本不会返回。意识到并相应地处理所有这些边缘情况可能会变得非常乏味。幸运的是，部分函数可以转换为常规函数。我们可以提供默认值或使用
guard 来处理偏函数未定义的输入。利用 option
类型，我们可以在可能会出现意外行为的地方使用 yield
<code>Some(value)</code> 或 <code>None</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1: 列表的和</span></span><br><span class="line"><span class="comment">// 我们可以提供默认值，使它总会返回结果</span></span><br><span class="line"><span class="comment">// sum :: [Number] -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = arr =&gt; arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>)</span><br><span class="line"><span class="title function_">sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">sum</span>([]) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2: 获取列表的第一个值</span></span><br><span class="line"><span class="comment">// 将结果改为 Option</span></span><br><span class="line"><span class="comment">// first :: [A] -&gt; A</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">first</span> = a =&gt; a.<span class="property">length</span> ? <span class="title class_">Some</span>(a[<span class="number">0</span>]) : <span class="title class_">None</span>()</span><br><span class="line"><span class="title function_">first</span>([<span class="number">42</span>]).<span class="title function_">map</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a)) <span class="comment">// 42</span></span><br><span class="line"><span class="title function_">first</span>([]).<span class="title function_">map</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a)) <span class="comment">// console.log 不会执行</span></span><br><span class="line"><span class="comment">//我们之前的糟糕情况</span></span><br><span class="line"><span class="title function_">first</span>([[<span class="number">42</span>]]).<span class="title function_">map</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="number">0</span>])) <span class="comment">// 42</span></span><br><span class="line"><span class="title function_">first</span>([]).<span class="title function_">map</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="number">0</span>])) <span class="comment">// 不会执行，所以不会有 error</span></span><br><span class="line"><span class="comment">// 更重要的是，通过返回类型 (Option) ，我们会知道：</span></span><br><span class="line"><span class="comment">// 我们应该使用 .map 方法来访问数据，所以我们不会忘记检查输入，</span></span><br><span class="line"><span class="comment">// 因为这样的检查会被内建在函数中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例3: 将函数重复 N 次</span></span><br><span class="line"><span class="comment">// 我们需要通过改变条件来确保函数总会终止: </span></span><br><span class="line"><span class="comment">// times :: Number -&gt; (Number -&gt; Number) -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">times</span> = n =&gt; <span class="function"><span class="params">fn</span> =&gt;</span> n &gt; <span class="number">0</span> &amp;&amp; (<span class="title function_">fn</span>(n), <span class="title function_">times</span>(n - <span class="number">1</span>)(fn))</span><br><span class="line"><span class="title function_">times</span>(<span class="number">3</span>)(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="title function_">times</span>(-<span class="number">1</span>)(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line"><span class="comment">// 不会再执行</span></span><br></pre></td></tr></table></figure>
<p>将偏函数改成全函数可以防止此类运行时错误。总是返回一个"值"也会使得代码更容易维护和推理。</p>
<div id="functional-programing-libraries-in-javascript">

</div>
<h2 id="在-js-中的函数式编程库">在 js 中的函数式编程库</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/swannodette/mori">mori</a></li>
<li><a
target="_blank" rel="noopener" href="https://github.com/facebook/immutable-js/">Immutable</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/immerjs/immer">Immer</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ramda/ramda">Ramda</a></li>
<li><a
target="_blank" rel="noopener" href="https://github.com/char0n/ramda-adjunct">ramda-adjunct</a></li>
<li><a target="_blank" rel="noopener" href="http://folktalejs.org">Folktale</a></li>
<li><a target="_blank" rel="noopener" href="https://cwmyers.github.io/monet.js/">monet.js</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lodash/lodash">lodash</a></li>
<li><a
target="_blank" rel="noopener" href="https://github.com/jashkenas/underscore">Underscore.js</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/dtao/lazy.js">Lazy.js</a></li>
<li><a
target="_blank" rel="noopener" href="https://github.com/sjsyrek/maryamyriameliamurphies.js">maryamyriameliamurphies.js</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/casualjavascript/haskell-in-es6">Haskell
in ES6</a></li>
<li><a
target="_blank" rel="noopener" href="https://github.com/sanctuary-js/sanctuary">Sanctuary</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/evilsoft/crocks">Crocks</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/fluture-js/Fluture">Fluture</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/gcanti/fp-ts">fp-ts</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Yao J
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://xinransix.github.io/2024/07/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%9C%AF%E8%AF%AD/" title="函数式编程——函数式编程术语">https://xinransix.github.io/2024/07/23/函数式编程——函数式编程术语/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="https://github.com/XinranSix/archives/assets/62458905/6a6f2373-fbf5-4367-9ac2-65230cba90a2">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
      </div>

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 函数式编程</a>
              <a href="/tags/%E8%8C%83%E7%95%B4%E8%AE%BA/" rel="tag"><i class="fa fa-tag"></i> 范畴论</a>
              <a href="/tags/JavaScript/" rel="tag"><i class="fa fa-tag"></i> JavaScript</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/02/23/%E7%9F%B3%E8%92%9C%E6%A8%A1%E6%8B%9F%E5%99%A8-%E4%B8%BA-Next-%E4%B8%BB%E9%A2%98%E5%8A%A0%E4%B8%8A%F0%9F%90%9F%E5%90%A7/" rel="prev" title="石蒜模拟器——为 Next 主题加上🐟吧~">
                  <i class="fa fa-angle-left"></i> 石蒜模拟器——为 Next 主题加上🐟吧~
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/08/06/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BB%8EC-11%E5%88%B0C-17%EF%BC%89/" rel="next" title="C++ 并发编程（从 C++11 到 C++17）">
                  C++ 并发编程（从 C++11 到 C++17） <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-waline">waline</a></li>
            <li class="tab"><a href="#comment-gitalk">gitalk</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane waline" id="comment-waline">
              <div class="comments" id="waline"></div>
            </div>
            <div class="tab-pane gitalk" id="comment-gitalk">
              <div class="comments gitalk-container"></div>
            </div>
        </div>
      </div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Yao J</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">132k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">8:02</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/sakana-widget@2.7.0/lib/sakana.min.css"
/>
<div id="sakana-widget" style="position: fixed; bottom: 10px; right: 20px; z-index: 999;"></div>
<script>
  function initSakanaWidget() {
    new SakanaWidget().mount('#sakana-widget');
  }
</script>
<script
  async
  onload="initSakanaWidget()"
  src="https://cdn.jsdelivr.net/npm/sakana-widget@2.7.0/lib/sakana.min.js"
></script>


    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://xinransix.github.io/2024/07/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%9C%AF%E8%AF%AD/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://comment-for-blog-psi.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v3/dist/waline.css","commentCount":true,"pageview":true,"emoji":["https://unpkg.com/@waline/emojis@1.1.0/alus","https://unpkg.com/@waline/emojis@1.1.0/bilibili","https://unpkg.com/@waline/emojis@1.1.0/bmoji","https://unpkg.com/@waline/emojis@1.1.0/qq","https://unpkg.com/@waline/emojis@1.1.0/tieba","https://unpkg.com/@waline/emojis@1.1.0/weibo","https://unpkg.com/@waline/emojis@1.1.0/tw-emoji","https://unpkg.com/@waline/emojis@1.1.0/tw-body","https://unpkg.com/@waline/emojis@1.1.0/tw-food","https://unpkg.com/@waline/emojis@1.1.0/tw-natural","https://unpkg.com/@waline/emojis@1.1.0/tw-object","https://unpkg.com/@waline/emojis@1.1.0/tw-symbol","https://unpkg.com/@waline/emojis@1.1.0/tw-people","https://unpkg.com/@waline/emojis@1.1.0/tw-sport","https://unpkg.com/@waline/emojis@1.1.0/tw-time","https://unpkg.com/@waline/emojis@1.1.0/tw-travel","https://unpkg.com/@waline/emojis@1.1.0/tw-weather","https://unpkg.com/@waline/emojis@1.1.0/tw-flag"],"el":"#waline","comment":true,"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","path":"/2024/07/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%9C%AF%E8%AF%AD/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v3/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"XinranSix","repo":"comment","client_id":"9c03a2ae7f09aea822ba","client_secret":"d1c9ff2bb92b84493b307f1587585a6b12fc78b8","admin_user":"XinranSix","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"6fff85117534c2c472c0ed22111a6ce8"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
