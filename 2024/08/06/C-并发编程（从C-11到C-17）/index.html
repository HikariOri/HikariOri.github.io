<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.33/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"xinransix.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"width":280},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"waline","storage":true,"lazyload":false,"nav":{"waline":{"order":-2},"gitalk":{"order":-1}},"activeClass":"waline"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="C++11 到 C++17 对多线程的支持">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 并发编程（从 C++11 到 C++17）">
<meta property="og:url" content="https://xinransix.github.io/2024/08/06/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BB%8EC-11%E5%88%B0C-17%EF%BC%89/index.html">
<meta property="og:site_name" content="木漏れ日">
<meta property="og:description" content="C++11 到 C++17 对多线程的支持">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-08-06T04:38:14.000Z">
<meta property="article:modified_time" content="2024-08-06T04:59:09.062Z">
<meta property="article:author" content="Yao J">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="Thread">
<meta property="article:tag" content="Concurrency">
<meta property="article:tag" content="Synchronize">
<meta property="article:tag" content="Lock">
<meta property="article:tag" content="Mutex">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://xinransix.github.io/2024/08/06/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BB%8EC-11%E5%88%B0C-17%EF%BC%89/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://xinransix.github.io/2024/08/06/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BB%8EC-11%E5%88%B0C-17%EF%BC%89/","path":"2024/08/06/C-并发编程（从C-11到C-17）/","title":"C++ 并发编程（从 C++11 到 C++17）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++ 并发编程（从 C++11 到 C++17） | 木漏れ日</title>
  







<link rel="dns-prefetch" href="https://comment-for-blog-psi.vercel.app/">


<script>
  var OriginTitile = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(つェ⊂)看不见我看不见我" + OriginTitile;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 咦，竟然被你发现了~" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
      }, 2000);
    }
  });
</script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="木漏れ日" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">木漏れ日</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">61</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">11</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">34</span></a></li><li class="menu-item menu-item-友人帐"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友人帐</a></li><li class="menu-item menu-item-rss"><a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">为什么要并发编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="nav-number">2.</span> <span class="nav-text">并发与并行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">进程与线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%A7%E8%83%BD"><span class="nav-number">4.</span> <span class="nav-text">并发系统的性能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c-%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">C++ 与并发编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8E-c-%E6%A0%87%E5%87%86"><span class="nav-number">6.</span> <span class="nav-text">编译器与 C++ 标准</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83"><span class="nav-number">7.</span> <span class="nav-text">测试环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#macos"><span class="nav-number">8.</span> <span class="nav-text">MacOS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ubuntu"><span class="nav-number">9.</span> <span class="nav-text">Ubuntu</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">10.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">11.</span> <span class="nav-text">创建线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#join-%E4%B8%8E-detach"><span class="nav-number">12.</span> <span class="nav-text">join 与 detach</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B"><span class="nav-number">13.</span> <span class="nav-text">管理当前线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8"><span class="nav-number">14.</span> <span class="nav-text">一次调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%BB%BB%E5%8A%A1"><span class="nav-number">15.</span> <span class="nav-text">并发任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%E4%B8%8E%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="nav-number">16.</span> <span class="nav-text">竞争条件与临界区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E4%BD%93%E4%B8%8E%E9%94%81"><span class="nav-number">17.</span> <span class="nav-text">互斥体与锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mutex"><span class="nav-number">18.</span> <span class="nav-text">mutex</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">19.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E9%94%81%E5%AE%9A%E7%AE%97%E6%B3%95"><span class="nav-number">20.</span> <span class="nav-text">通用锁定算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E4%BA%92%E6%96%A5%E7%AE%A1%E7%90%86"><span class="nav-number">21.</span> <span class="nav-text">通用互斥管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#raii"><span class="nav-number">21.1.</span> <span class="nav-text">RAII</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">22.</span> <span class="nav-text">条件变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#future"><span class="nav-number">23.</span> <span class="nav-text">future</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#async"><span class="nav-number">24.</span> <span class="nav-text">async</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#packaged_task"><span class="nav-number">25.</span> <span class="nav-text">packaged_task</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#promise-%E4%B8%8E-future"><span class="nav-number">26.</span> <span class="nav-text">promise 与 future</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95"><span class="nav-number">27.</span> <span class="nav-text">并行算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9D%9F%E8%AF%AD"><span class="nav-number">28.</span> <span class="nav-text">结束语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E4%B8%8E%E6%8E%A8%E8%8D%90%E8%AF%BB%E7%89%A9"><span class="nav-number">29.</span> <span class="nav-text">参考资料与推荐读物</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yao J"
      src="https://avatars.githubusercontent.com/u/62458905?v=4">
  <p class="site-author-name" itemprop="name">Yao J</p>
  <div class="site-description" itemprop="description">图形渣</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/XinranSix" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;XinranSix" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2937552332@qq.com" title="E-Mail → 2937552332@qq.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
<div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>
        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://godbolt.org/" title="https:&#x2F;&#x2F;godbolt.org&#x2F;" rel="noopener" target="_blank">Compiler Explorer</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://cppinsights.io/" title="https:&#x2F;&#x2F;cppinsights.io&#x2F;" rel="noopener" target="_blank">C++ Insights</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://play.rust-lang.org/" title="https:&#x2F;&#x2F;play.rust-lang.org&#x2F;" rel="noopener" target="_blank">Rust Playground</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xinransix.github.io/2024/08/06/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BB%8EC-11%E5%88%B0C-17%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/62458905?v=4">
      <meta itemprop="name" content="Yao J">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="木漏れ日">
      <meta itemprop="description" content="图形渣">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++ 并发编程（从 C++11 到 C++17） | 木漏れ日">
      <meta itemprop="description" content="C++11 到 C++17 对多线程的支持">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ 并发编程（从 C++11 到 C++17）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-08-06 12:38:14 / 修改时间：12:59:09" itemprop="dateCreated datePublished" datetime="2024-08-06T12:38:14+08:00">2024-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2024/08/06/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BB%8EC-11%E5%88%B0C-17%EF%BC%89/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2024/08/06/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BB%8EC-11%E5%88%B0C-17%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-item" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="waline-pageview-count" data-path="/2024/08/06/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BB%8EC-11%E5%88%B0C-17%EF%BC%89/"></span>
    </span>
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>54 分钟</span>
    </span>
</div>

            <div class="post-description">C++11 到 C++17 对多线程的支持</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>自 C++11 标准以来，C++
语言开始支持多线程模型。借助多线程模型，我们可以开发出更好的并发系统。本文以
C++ 语言为例，讲解如何进行并发编程。并尽可能涉及 C++11，C++14 以及 C++17
中的主要内容。</p>
<p><img data-src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/bg1.JPG" /></p>
<h2 id="为什么要并发编程">为什么要并发编程</h2>
<p>大型的软件项目常常包含非常多的任务需要处理。例如：对于大量数据的数据流处理，或者是包含复杂
GUI
界面的应用程序。如果将所有的任务都以串行的方式执行，则整个系统的效率将会非常低下，应用程序的用户体验会非常的差。</p>
<p>另一方面，自上个世纪六七十年代英特尔创始人之一 <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Gordon_Moore">Gordon Moore</a> 提出
<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Moore%27s_law">摩尔定义</a>
以来，CPU 频率以每 18
个月翻一番的指数速度增长。但这一增长在最近的十年已经基本停滞，大家会发现曾经有过一段时间
CPU 的频率从 3G 到达 4G，但在这之后就停滞不前了。因此最近的新款 CPU
也基本上都是 3G 左右的频率。相应的，CPU 以更多核的形式在增长。目前的
Intel i7 有 8 核的版本，Xeon 处理器达到了 28
核。并且，最近几年手机上使用的 CPU 也基本上是 4 核或者 8 核的了。</p>
<p>由此，掌握并发编程技术，利用多处理器来提升软件项目的性能将是软件工程师的一项基本技能。</p>
<p>本文以 C++ 语言为例，讲解如何进行并发编程。并尽可能涉及 C++11，C++14
以及 C++17 中的主要内容。</p>
<h2 id="并发与并行">并发与并行</h2>
<p>并发（Concurrent）与并行（Parallel）都是很常见的术语。</p>
<p>Erlang 之父 Joe Armstrong
曾经以人们使用咖啡机的场景为例描述了这两个术语。如下图所示：</p>
<p><img data-src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/con_and_par.jpg" /></p>
<ul>
<li><strong>并发</strong>：如果多个队列可以交替使用某台咖啡机，则这一行为就是并发的。</li>
<li><strong>并行</strong>：如果存在多台咖啡机可以被多个队列交替使用，则就是并行。</li>
</ul>
<p>这里队列中的每个人类比于计算机的任务，咖啡机类比于计算机处理器。因此：并发和并行都是在多任务的环境下的讨论。</p>
<p>更严格的来说：如果一个系统支持多个动作同时存在，那么这个系统就是一个并发系统。如果这个系统还支持多个动作（物理时间上）同时执行，那么这个系统就是一个并行系统。</p>
<p>你可能已经看出，“并行”其实是“并发”的子集。它们的区别在于是否具有多个处理器。如果存在多个处理器同时执行多个线程，就是并行。</p>
<p>在不考虑处理器数量的情况下，我们统称之为“并发”。</p>
<h2 id="进程与线程">进程与线程</h2>
<p>进程与线程是操作系统的基本概念。无论是桌面系统：MacOS，Linux，Windows，还是移动操作系统：Android，iOS，都存在进程和线程的概念。</p>
<blockquote>
<p><strong>进程</strong>（英语：process），是指计算机中已运行的程序。进程为曾经是分时系统的基本运作单位。在面向进程设计的系统（如早期的
UNIX，Linux 2.4 及更早的版本）中，进程是程序的基本执行实体；</p>
<p><strong>线程</strong>（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</p>
<p>– 维基百科</p>
</blockquote>
<p>关于这两个概念在任何一本操作系统书上都可以找到定义。网上也有很多文章对它们进行了解释。因此这里不再赘述，这里仅仅提及一下它们与编程的关系。</p>
<p>对于绝大部分编程语言或者编程环境来说，我们所写的程序都会在一个进程中运行。一个进程至少会包含一个线程。这个线程我们通常称之为主线程。</p>
<p>在默认的情况下，我们写的代码都是在进程的主线程中运行，除非开发者在程序中创建了新的线程。</p>
<p>不同编程语言的线程环境会不一样，Java
语言在很早就支持了多线程接口。（Java 程序在 Java
虚拟机中运行，虚拟机通常还会包含自己特有的线程，例如垃圾回收线程。）。而对于
JavaScript 这样的语言来说，它就没有多线程的概念。</p>
<p>当我们只有一个处理器时，所有的进程或线程会分时占用这个处理器。但如果系统中存在多个处理器时，则就可能有多个任务并行的运行在不同的处理器上。</p>
<p>下面两幅图以不同颜色的矩形代表不同的任务（可能是进程，也可能是线程）来描述它们可能在处理器上执行的顺序。</p>
<p>下图是单核处理器的情况：</p>
<p><img data-src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/single_core.png" /></p>
<p>下面是四核处理器的情况：</p>
<p><img data-src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/four_core.png" /></p>
<p>任务会在何时占有处理器，通常是由操作系统的调度策略决定的。在<a
target="_blank" rel="noopener" href="https://paul.pub/android-process-schedule/">《Android
系统上的进程管理：进程的调度》</a>一文中，我们介绍过 Linux
的调度策略。</p>
<p>当我们在开发跨平台的软件时，我们不应当对调度策略做任何假设，而应该抱有“系统可能以任意顺序来调度我的任务”这样的想法。</p>
<h2 id="并发系统的性能">并发系统的性能</h2>
<p>开发并发系统最主要的动机就是提升系统性能（事实上，这是以增加复杂度为代价的）。</p>
<p>但我们需要知道，单纯的使用多线程并不一定能提升系统性能（当然，也并非线程越多系统的性能就越好）。从上面的两幅图我们就可以直观的感受到：线程（任务）的数量要根据具体的处理器数量来决定。假设只有一个处理器，那么划分太多线程可能会适得其反。因为很多时间都花在任务切换上了。</p>
<p>因此，在设计并发系统之前，一方面我们需要做好对于硬件性能的了解，另一方面需要对我们的任务有足够的认识。</p>
<p>关于这一点，你可能需要了解一下<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Amdahl%27s_law">阿姆达尔定律</a>了。对于这个定律，简单来说：我们想要预先意识到那些任务是可以并行的，那些是无法并行的。只有明确了任务的性质，才能有的放矢的进行优化。这个定律告诉了我们将系统并行之后性能收益的上限。</p>
<p>关于阿姆达尔定律在<a
target="_blank" rel="noopener" href="https://paul.pub/sysstat/#id-%E9%98%BF%E5%A7%86%E8%BE%BE%E5%B0%94%E5%AE%9A%E5%BE%8B">Linux
系统监测工具 sysstat 介绍</a>一文中已经介绍过，因此这里不再赘述。</p>
<h2 id="c-与并发编程">C++ 与并发编程</h2>
<p>前面我们已经了解到，并非所有的语言都提供了多线程的环境。</p>
<p>即便是 C++ 语言，直到<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/C%2B%2B11">C++11</a>标准之前，也是没有多线程支持的。在这种情况下，Linux/Unix
平台下的开发者通常会使用<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/POSIX_Threads">POSIX
Threads</a>，Windows 上的开发者也会有<a
target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/parallel/multithreading-with-cpp-and-mfc?view=vs-2019">相应的接口</a>。但很明显，这些
API 都只针对特定的操作系统平台，可移植性较差。如果要同时支持 Linux 和
Windows 系统，你可能要写两套代码。</p>
<blockquote>
<p>相较而言，Java 自 JDK 1.0 就包含了多线程模型。</p>
</blockquote>
<p>这个状态在 C++ 11 标准发布之后得到了改变。并且，在 C++ 14 和 C++ 17
标准中又对并发编程机制进行了增强。</p>
<p>下图是最近几个版本的 C++ 标准特性的线路图。</p>
<p><img data-src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/cpp_timeline.png" /></p>
<h2 id="编译器与-c-标准">编译器与 C++ 标准</h2>
<p>编译器对于语言特性的支持是逐步完成的。想要使用特定的特性你需要相应版本的编译器。</p>
<ul>
<li>GCC 对于 C++ 特性的支持请参见这里：<a
target="_blank" rel="noopener" href="https://www.gnu.org/software/gcc/projects/cxx-status.html">C++
Standards Support in GCC</a>。</li>
<li>Clang 对于 C++ 特性的支持请参见这里：<a
target="_blank" rel="noopener" href="https://clang.llvm.org/cxx_status.html">C++ Support in
Clang</a>。</li>
</ul>
<p>下面两个表格列出了 C++ 标准和相应编译器的版本对照：</p>
<ul>
<li>C++ 标准与相应的 GCC 版本要求如下：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>C++ 版本</th>
<th>GCC 版本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>C++11</td>
<td>4.8</td>
</tr>
<tr class="even">
<td>C++14</td>
<td>5.0</td>
</tr>
<tr class="odd">
<td>C++17</td>
<td>7.0</td>
</tr>
</tbody>
</table>
<ul>
<li>C++ 标准与相应的 Clang 版本要求如下：</li>
</ul>
<table>
<thead>
<tr class="header">
<th>C++ 版本</th>
<th>Clang 版本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>C++11</td>
<td>3.3</td>
</tr>
<tr class="even">
<td>C++14</td>
<td>3.4</td>
</tr>
<tr class="odd">
<td>C++17</td>
<td>5.0</td>
</tr>
</tbody>
</table>
<p>默认情况下编译器是以较低的标准来进行编译的，如果希望使用新的标准，你需要通过编译参数<code>-std=c++xx</code>告知编译器，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++17 your_file.cpp -o your_program</span><br></pre></td></tr></table></figure>
<h2 id="测试环境">测试环境</h2>
<p>本文的源码可以到下载我的 github 上获取，地址：<a
target="_blank" rel="noopener" href="https://github.com/paulQuei/cpp-concurrency">paulQuei/cpp-concurrency</a>。</p>
<p>你可以直接通过下面这条命令获取源码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/paulQuei/cpp-concurrency.git</span><br></pre></td></tr></table></figure>
<p>源码下载之后，你可以通过任何文本编辑器浏览源码。如果希望编译和运行程序，你还需要按照下面的内容来准备环境。</p>
<p>本文中的源码使用<a target="_blank" rel="noopener" href="https://cmake.org/">cmake</a>编译，只有
cmake 3.8 以上的版本才支持 C++ 17，所以你需要安装这个或者更新版本的
cmake。</p>
<p>另外，截止目前（2019 年 10
月）为止，<code>clang</code>编译器还不支持<a
href="#id-并行算法">并行算法</a>。</p>
<p>但是<a
target="_blank" rel="noopener" href="https://gcc.gnu.org/gcc-9/changes.html">gcc-9</a>是支持的。因此想要编译和运行这部分代码，你需要安装
gcc 9.0 或更新的版本。并且，gcc-9 还要依赖<a
target="_blank" rel="noopener" href="https://github.com/intel/tbb">Intel Threading Building
Blocks</a>才能使用并行算法以及<code>&lt;execution&gt;</code>头文件。</p>
<p>具体的安装方法见下文。</p>
<blockquote>
<p>具体编译器对于 C++ 特性支持的情况请参见这里：<a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/compiler_support">C++ compiler
support</a>。</p>
</blockquote>
<p>安装好之后运行根目录下的下面这个命令即可：</p>
<p>它会完成所有的编译工作。</p>
<p>本文的源码在下面两个环境中经过测试，环境的准备方法如下。</p>
<h2 id="macos">MacOS</h2>
<p>在 Mac 上，我使用<a
target="_blank" rel="noopener" href="https://brew.sh/">brew</a>工具安装<code>gcc</code>以及<code>tbb</code>库。</p>
<p>考虑到其他人与我的环境可能会有所差异，所以需要手动告知<code>tbb</code>库的安装路径。</p>
<p>读者需要执行下面这些命令来准备环境：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew install gcc</span><br><span class="line">brew install tbb</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> tbb_path=/usr/local/Cellar/tbb/2019_U8/</span><br><span class="line">./make_all.sh</span><br></pre></td></tr></table></figure>
<p>注意，请通过运行<code>g++-9</code>命令以确认 gcc
的版本是否正确，如果版本较低，则需要通过<code>brew</code>命令将其升级到新版本：</p>
<h2 id="ubuntu">Ubuntu</h2>
<p>Ubuntu 上，通过下面的命令安装<code>gcc-9</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ubuntu-toolchain-r/test</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install  gcc-9 g++-9</span><br></pre></td></tr></table></figure>
<p>但安装<code>tbb</code>库就有些麻烦了。这是因为<a
target="_blank" rel="noopener" href="https://launchpad.net/ubuntu/+source/tbb">Ubuntu 16.04
默认关联的版本是较低的</a>，直接安装是无法使用的。我们需要安装<a
target="_blank" rel="noopener" href="https://launchpad.net/ubuntu/+source/tbb/2019~U8-1">更新的版本</a>。</p>
<p>联网安装的方式<a
target="_blank" rel="noopener" href="https://medium.com/@george.shuklin/how-to-install-packages-from-a-newer-distribution-without-installing-unwanted-6584fa93208f">步骤繁琐</a>，所以可以通过下载包的方式进行安装，我已经将这需要的两个文件放到的这里：</p>
<ul>
<li><a
target="_blank" rel="noopener" href="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/libtbb2_2019%7EU8-1_amd64.deb">libtbb2_2019~U8-1_amd64.deb</a></li>
<li><a
target="_blank" rel="noopener" href="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/libtbb-dev_2019%7EU8-1_amd64.deb">libtbb-dev_2019~U8-1_amd64.deb</a></li>
</ul>
<p>如果需要，你可以下载后通过<code>apt</code>命令安装即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ~/Downloads/libtbb2_2019~U8-1_amd64.deb </span><br><span class="line">sudo apt install ~/Downloads/libtbb-dev_2019~U8-1_amd64.deb </span><br></pre></td></tr></table></figure>
<h2 id="线程">线程</h2>
<h2 id="创建线程">创建线程</h2>
<p>创建线程非常的简单的，下面就是一个使用了多线程的 Hello World
示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 01_hello_thread.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> <span class="comment">// ①</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// ②</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123; <span class="comment">// ③</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Hello World from new thread.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">thread <span class="title">t</span><span class="params">(hello)</span></span>; <span class="comment">// ④</span></span><br><span class="line">  t.<span class="built_in">join</span>(); <span class="comment">// ⑤</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这段代码说明如下：</p>
<ol type="1">
<li>为了使用多线程的接口，我们需要<code>#include &lt;thread&gt;</code>头文件。</li>
<li>为了简化声明，本文中的代码都将<code>using namespace std;</code>。</li>
<li>新建线程的入口是一个普通的函数，它并没有什么特别的地方。</li>
<li>创建线程的方式就是构造一个<code>thread</code>对象，并指定入口函数。与普通对象不一样的是，此时编译器便会为我们创建一个新的操作系统线程，并在新的线程中执行我们的入口函数。</li>
<li>关于<code>join</code>函数在下文中讲解。</li>
</ol>
<p><code>thread</code>可以和<code>callable</code>类型一起工作，因此如果你熟悉<a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/lambda">lambda
表达式</a>，你可以直接用它来写线程的逻辑，像这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 02_lambda_thread.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">thread <span class="title">t</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    cout &lt;&lt; <span class="string">&quot;Hello World from lambda thread.&quot;</span> &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">  t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了减少不必要的重复，若无必要，下文中的代码将不贴出<code>include</code>指令以及<code>using</code>声明。</p>
</blockquote>
<p>当然，你可以传递参数给入口函数，像下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 03_thread_argument.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Welcome to &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">thread <span class="title">t</span><span class="params">(hello, <span class="string">&quot;https://paul.pub&quot;</span>)</span></span>;</span><br><span class="line">  t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过需要注意的是，参数是以拷贝的形式进行传递的。因此对于拷贝耗时的对象你可能需要传递指针或者引用类型作为参数。但是，如果是传递指针或者引用，你还需要考虑参数对象的生命周期。因为线程的运行长度很可能会超过参数的生命周期（见下文<code>detach</code>），这个时候如果线程还在访问一个已经被销毁的对象就会出现问题。</p>
<h2 id="join-与-detach">join 与 detach</h2>
<ul>
<li>主要 API</li>
</ul>
<table>
<thead>
<tr class="header">
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>join</td>
<td>等待线程完成其执行</td>
</tr>
<tr class="even">
<td>detach</td>
<td>允许线程独立执行</td>
</tr>
</tbody>
</table>
<p>一旦启动线程之后，我们必须决定是要等待直接它结束（通过<code>join</code>），还是让它独立运行（通过<code>detach</code>），我们必须二者选其一。如果在<code>thread</code>对象<strong>销毁的时候</strong>我们还没有做决定，则<code>thread</code>对象在析构函数出将调用<code>std::terminate()</code>从而导致我们的进程异常退出。</p>
<blockquote>
<p>请思考在上面的代码示例中，<code>thread</code>对象在何时会销毁。</p>
</blockquote>
<p>需要注意的是：在我们做决定的时候，很可能线程已经执行完了（例如上面的示例中线程的逻辑仅仅是一句打印，执行时间会很短）。新的线程创建之后，究竟是新的线程先执行，还是当前线程的下一条语句先执行这是不确定的，因为这是由操作系统的调度策略决定的。不过这不要紧，我们只要在<code>thread</code>对象销毁前做决定即可。</p>
<ul>
<li><code>join</code>：调用此接口时，当前线程会一直阻塞，直到目标线程执行完成（当然，很可能目标线程在此处调用之前就已经执行完成了，不过这不要紧）。因此，如果目标线程的任务非常耗时，你就要考虑好是否需要在主线程上等待它了，因此这很可能会导致主线程卡住。</li>
<li><code>detach</code>：<code>detach</code>是让目标线程成为守护线程（daemon
threads）。一旦<code>detach</code>之后，目标线程将独立执行，即便其对应的<code>thread</code>对象销毁也不影响线程的执行。并且，你无法再与之通信。</li>
</ul>
<p>对于这两个接口，都必须是可执行的线程才有意义。你可以通过<code>joinable()</code>接口查询是否可以对它们进行<code>join</code>或者<code>detach</code>。</p>
<h2 id="管理当前线程">管理当前线程</h2>
<ul>
<li>主要 API</li>
</ul>
<table>
<thead>
<tr class="header">
<th>API</th>
<th>C++ 标准</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>yield</td>
<td>C++11</td>
<td>让出处理器，重新调度各执行线程</td>
</tr>
<tr class="even">
<td>get_id</td>
<td>C++11</td>
<td>返回当前线程的线程 id</td>
</tr>
<tr class="odd">
<td>sleep_for</td>
<td>C++11</td>
<td>使当前线程的执行停止指定的时间段</td>
</tr>
<tr class="even">
<td>sleep_until</td>
<td>C++11</td>
<td>使当前线程的执行停止直到指定的时间点</td>
</tr>
</tbody>
</table>
<p>上面是一些在线程内部使用的 API，它们用来对当前线程做一些控制。</p>
<ul>
<li><code>yield</code>
通常用在自己的主要任务已经完成的时候，此时希望让出处理器给其他任务使用。</li>
<li><code>get_id</code> 返回当前线程的
id，可以以此来标识不同的线程。</li>
<li><code>sleep_for</code> 是让当前线程停止一段时间。</li>
<li><code>sleep_until</code>
和<code>sleep_for</code>类似，但是是以具体的时间点为参数。这两个 API
都以<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/header/chrono">chrono</a>
API（由于篇幅所限，这里不展开这方面内容）为基础。</li>
</ul>
<p>下面是一个代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 04_thread_self_manage.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_time</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> now = chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> <span class="type">in_time_t</span> = chrono::system_clock::<span class="built_in">to_time_t</span>(now);</span><br><span class="line"></span><br><span class="line">  std::stringstream ss;</span><br><span class="line">  ss &lt;&lt; <span class="built_in">put_time</span>(<span class="built_in">localtime</span>(&amp;<span class="type">in_time_t</span>), <span class="string">&quot;%Y-%m-%d %X&quot;</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;now is: &quot;</span> &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sleep_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;[thread-&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] is waking up&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;[thread-&quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;] print: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">print_time</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function">thread <span class="title">t1</span><span class="params">(sleep_thread)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t2</span><span class="params">(loop_thread)</span></span>;</span><br><span class="line"></span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print_time</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码应该还是比较容易理解的，这里创建了两个线程。它们都会有一些输出，其中一个会先停止
3
秒钟，然后再输出。主线程调用<code>join</code>会一直卡住等待它运行结束。</p>
<p>这段程序的输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">now is: 2019-10-13 10:17:48</span><br><span class="line">[thread-0x70000cdda000] <span class="built_in">print</span>: 0</span><br><span class="line">[thread-0x70000cdda000] <span class="built_in">print</span>: 1</span><br><span class="line">[thread-0x70000cdda000] <span class="built_in">print</span>: 2</span><br><span class="line">[thread-0x70000cdda000] <span class="built_in">print</span>: 3</span><br><span class="line">[thread-0x70000cdda000] <span class="built_in">print</span>: 4</span><br><span class="line">[thread-0x70000cdda000] <span class="built_in">print</span>: 5</span><br><span class="line">[thread-0x70000cdda000] <span class="built_in">print</span>: 6</span><br><span class="line">[thread-0x70000cdda000] <span class="built_in">print</span>: 7</span><br><span class="line">[thread-0x70000cdda000] <span class="built_in">print</span>: 8</span><br><span class="line">[thread-0x70000cdda000] <span class="built_in">print</span>: 9</span><br><span class="line">[thread-0x70000cd57000] is waking up</span><br><span class="line">now is: 2019-10-13 10:17:51</span><br></pre></td></tr></table></figure>
<h2 id="一次调用">一次调用</h2>
<ul>
<li>主要 API</li>
</ul>
<table>
<thead>
<tr class="header">
<th>API</th>
<th>C++ 标准</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>call_once</td>
<td>C++11</td>
<td>即便在多线程环境下，也能保证只调用某个函数一次</td>
</tr>
<tr class="even">
<td>once_flag</td>
<td>C++11</td>
<td>与<code>call_once</code>配合使用</td>
</tr>
</tbody>
</table>
<p>在一些情况下，我们有些任务需要执行一次，并且我们只希望它执行一次，例如资源的初始化任务。这个时候就可以用到上面的接口。这个接口会保证，即便在多线程的环境下，相应的函数也只会调用一次。</p>
<p>下面就是一个示例：有三个线程都会使用<code>init</code>函数，但是只会有一个线程真正执行它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 05_call_once.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Initialing...&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// Do something...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(once_flag* flag)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">call_once</span>(*flag, init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  once_flag flag;</span><br><span class="line"></span><br><span class="line">  <span class="function">thread <span class="title">t1</span><span class="params">(worker, &amp;flag)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t2</span><span class="params">(worker, &amp;flag)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t3</span><span class="params">(worker, &amp;flag)</span></span>;</span><br><span class="line"></span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line">  t3.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们无法确定具体是哪一个线程会执行<code>init</code>。而事实上，我们也不关心，因为只要有某个线程完成这个初始化工作就可以了。</p>
<blockquote>
<p>请思考一下，为什么要在 main
函数中创建<code>once_flag flag</code>。如果是在<code>worker</code>函数中直接声明一个<code>once_flag</code>并使用行不行？为什么？</p>
</blockquote>
<h2 id="并发任务">并发任务</h2>
<p>下面以一个并发任务为示例讲解如何引入多线程。</p>
<p>任务示例：现在假设我们需要计算某个范围内所有自然数的平方根之和，例如<code>[1, 10e8]</code>。</p>
<p>在单线程模型下，我们的代码可能是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 06_naive_multithread.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX = <span class="number">10e8</span>; <span class="comment">// ①</span></span><br><span class="line"><span class="type">static</span> <span class="type">double</span> sum = <span class="number">0</span>; <span class="comment">// ②</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123; <span class="comment">// ③</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">serial_task</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123; <span class="comment">// ④</span></span><br><span class="line">  <span class="keyword">auto</span> start_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">worker</span>(<span class="number">0</span>, MAX);</span><br><span class="line">  <span class="keyword">auto</span> end_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> ms = chrono::<span class="built_in">duration_cast</span>&lt;chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Serail task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed, Result: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码说明如下：</p>
<ol type="1">
<li>通过一个常量指定数据范围，这个是为了方便调整。</li>
<li>通过一个全局变量来存储结果。</li>
<li>通过一个任务函数来计算值。</li>
<li>统计任务的执行时间。</li>
</ol>
<p>这段程序输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serail task finish, 6406 ms consumed, Result: 2.10819e+13</span><br></pre></td></tr></table></figure>
<p>很显然，上面单线程的做法性能太差了。我们的任务完全是可以并发执行的。并且任务很容易划分。</p>
<p>下面我们就尝试以多线程的方式来改造原先的程序。</p>
<p>改造后的程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 06_naive_multithread.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">concurrent_task</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> start_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> concurrent_count = thread::<span class="built_in">hardware_concurrency</span>(); <span class="comment">// ①</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;hardware_concurrency: &quot;</span> &lt;&lt; concurrent_count &lt;&lt; endl;</span><br><span class="line">  vector&lt;thread&gt; threads;</span><br><span class="line">  min = <span class="number">0</span>;</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; concurrent_count; t++) &#123; <span class="comment">// ②</span></span><br><span class="line">    <span class="type">int</span> range = max / concurrent_count * (t + <span class="number">1</span>);</span><br><span class="line">    threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(worker, min, range)); <span class="comment">// ③</span></span><br><span class="line">    min = range + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// ④</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> end_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> ms = chrono::<span class="built_in">duration_cast</span>&lt;chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed, Result: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码说明如下：</p>
<ol type="1">
<li><code>thread::hardware_concurrency()</code>可以获取到当前硬件支持多少个线程并行执行。</li>
<li>根据处理器的情况决定线程的数量。</li>
<li>对于每一个线程都通过<code>worker</code>函数来完成任务，并划分一部分数据给它处理。</li>
<li>等待每一个线程执行结束。</li>
</ol>
<p>很好，似乎很简单就完成了并发的改造。然后我们运行一下这个程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hardware_concurrency: 16</span><br><span class="line">Concurrent task finish, 6246 ms consumed, Result: 1.78162e+12</span><br></pre></td></tr></table></figure>
<p>很抱歉，我们会发现这里的性能并没有明显的提升。更严重的是，这里的结果是错误的。</p>
<p>要搞清楚为什么结果不正确我们需要更多的背景知识。</p>
<p>我们知道，对于现代的处理器来说，为了加速处理的速度，每个处理器都会有自己的高速缓存（Cache），这个高速缓存是与每个处理器相对应的，如下图所示：</p>
<blockquote>
<p>事实上，目前大部分 CPU 的缓存已经不只一层。</p>
</blockquote>
<p><img data-src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/cpu.png" /></p>
<p>处理器在进行计算的时候，高速缓存会参与其中，例如数据的读和写。而高速缓存和系统主存（Memory）是有可能存在不一致的。即：某个结果计算后保存在处理器的高速缓存中了，但是没有同步到主存中，此时这个值对于其他处理器就是不可见的。</p>
<p>事情还远不止这么简单。我们对于全局变量值的修改：<code>sum += sqrt(i);</code>这条语句，它并非是原子的。它其实是很多条指令的组合才能完成。假设在某个设备上，这条语句通过下面这几个步骤来完成。它们的时序可能如下所示：</p>
<p><img data-src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/multithread.png" /></p>
<p>在时间点 a 的时候，所有线程对于<code>sum</code>变量的值是一致的。</p>
<p>但是在时间点 b 之后，thread3
上已经对<code>sum</code>进行了赋值。而这个时候其他几个线程也同时在其他处理器上使用了这个值，那么这个时候它们所使用的值就是旧的（错误的）。最后得到的结果也自然是错的。</p>
<h2 id="竞争条件与临界区">竞争条件与临界区</h2>
<p>当多个进程或者线程同时访问共享数据时，只要有一个任务会修改数据，那么就可能会发生问题。此时结果依赖于这些任务执行的相对时间，这种场景称为<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Race_condition"><strong>竞争条件</strong>（race
condition）</a>。</p>
<p>访问共享数据的代码片段称之为<strong>临界区</strong>（critical
section）。具体到上面这个示例，临界区就是读写<code>sum</code>变量的地方。</p>
<p>要避免竞争条件，就需要对临界区进行数据保护。</p>
<p>很自然的，现在我们能够理解发生竞争条件是因为这些线程在同时访问共享数据，其中有些线程的改动没有让其他线程知道，导致其他线程在错误的基础上进行处理，结果自然也就是错误的。</p>
<p>那么，如果一次只让一个线程访问共享数据，访问完了再让其他线程接着访问，这样就可以避免问题的发生了。</p>
<p>接下来介绍的 API 提供的就是这样的功能。</p>
<h2 id="互斥体与锁">互斥体与锁</h2>
<h2 id="mutex">mutex</h2>
<p>开发并发系统的目的主要是为了提升性能：将任务分散到多个线程，然后在不同的处理器上同时执行。这些分散开来的线程通常会包含两类任务：</p>
<ol type="1">
<li>独立的对于划分给自己的数据的处理</li>
<li>对于处理结果的汇总</li>
</ol>
<p>其中第 1 项任务因为每个线程是独立的，不存在竞争条件的问题。而第 2
项任务，由于所有线程都可能往总结果（例如上面的<code>sum</code>变量）汇总，这就需要做保护了。在某一个具体的时刻，只应当有一个线程更新总结果，即：保证每个线程对于共享数据的访问是“互斥”的。<code>mutex</code>
就提供了这样的功能。</p>
<p><code>mutex</code>是<strong>mut</strong>ual
<strong>ex</strong>clusion（互斥）的简写。</p>
<ul>
<li>主要 API</li>
</ul>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>API</th>
<th>C++ 标准</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>mutex</td>
<td>C++11</td>
<td>提供基本互斥设施</td>
</tr>
<tr class="even">
<td>timed_mutex</td>
<td>C++11</td>
<td>提供互斥设施，带有超时功能</td>
</tr>
<tr class="odd">
<td>recursive_mutex</td>
<td>C++11</td>
<td>提供能被同一线程递归锁定的互斥设施</td>
</tr>
<tr class="even">
<td>recursive_timed_mutex</td>
<td>C++11</td>
<td>提供能被同一线程递归锁定的互斥设施，带有超时功能</td>
</tr>
<tr class="odd">
<td>shared_timed_mutex</td>
<td>C++14</td>
<td>提供共享互斥设施并带有超时功能</td>
</tr>
<tr class="even">
<td>shared_mutex</td>
<td>C++17</td>
<td>提供共享互斥设施</td>
</tr>
</tbody>
</table>
<p>很明显，在这些类中，<code>mutex</code>是最基础的
API。其他类都是在它的基础上的改进。所以这些类都提供了下面三个方法，并且它们的功能是一样的：</p>
<table>
<tbody>
<tr>
<td>
方法
</td>
<td>
说明
</td>
</tr>
<tr>
<td>
lock
</td>
<td>
锁定互斥体，如果不可用，则阻塞
</td>
</tr>
<tr>
<td>
try_lock
</td>
<td>
尝试锁定互斥体，如果不可用，直接返回
</td>
</tr>
<tr>
<td>
unlock
</td>
<td>
解锁互斥体
</td>
</tr>
</tbody>
</table>
<p>这三个方法提供了基础的锁定和解除锁定的功能。使用<code>lock</code>意味着你有很强的意愿一定要获取到互斥体，而使用<code>try_lock</code>则是进行一次尝试。这意味着如果失败了，你通常还有其他的路径可以走。</p>
<p>在这些基础功能之上，其他的类分别在下面三个方面进行了扩展：</p>
<ul>
<li><strong>超时</strong>：<code>timed_mutex</code>，<code>recursive_timed_mutex</code>，<code>shared_timed_mutex</code>的名称都带有<code>timed</code>，这意味着它们都支持超时功能。它们都提供了<code>try_lock_for</code>和<code>try_lock_until</code>方法，这两个方法分别可以指定超时的时间长度和时间点。如果在超时的时间范围内没有能获取到锁，则直接返回，不再继续等待。</li>
<li><strong>可重入</strong>：<code>recursive_mutex</code>和<code>recursive_timed_mutex</code>的名称都带有<code>recursive</code>。可重入或者叫做可递归，是指在同一个线程中，同一把锁可以锁定多次。这就避免了一些不必要的死锁。</li>
<li><strong>共享</strong>：<code>shared_timed_mutex</code>和<code>shared_mutex</code>提供了共享功能。对于这类互斥体，实际上是提供了两把锁：一把是共享锁，一把是互斥锁。一旦某个线程获取了互斥锁，任何其他线程都无法再获取互斥锁和共享锁；但是如果有某个线程获取到了共享锁，其他线程无法再获取到互斥锁，但是还有获取到共享锁。这里互斥锁的使用和其他的互斥体接口和功能一样。而共享锁可以同时被多个线程同时获取到（使用共享锁的接口见下面的表格）。共享锁通常用在<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem">读者写者模型</a>上。</li>
</ul>
<p>使用共享锁的接口如下：</p>
<table>
<tbody>
<tr>
<td>
方法
</td>
<td>
说明
</td>
</tr>
<tr>
<td>
lock_shared
</td>
<td>
获取互斥体的共享锁，如果无法获取则阻塞
</td>
</tr>
<tr>
<td>
try_lock_shared
</td>
<td>
尝试获取共享锁，如果不可用，直接返回
</td>
</tr>
<tr>
<td>
unlock_shared
</td>
<td>
解锁共享锁
</td>
</tr>
</tbody>
</table>
<p>接下来，我们就借助刚学到的<code>mutex</code>来改造我们的并发系统，改造后的程序如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 07_mutex_lock.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX = <span class="number">10e8</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> mutex exclusive;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">concurrent_worker</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    exclusive.<span class="built_in">lock</span>(); <span class="comment">// ①</span></span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">    exclusive.<span class="built_in">unlock</span>(); <span class="comment">// ②</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">concurrent_task</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> start_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> concurrent_count = thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;hardware_concurrency: &quot;</span> &lt;&lt; concurrent_count &lt;&lt; endl;</span><br><span class="line">  vector&lt;thread&gt; threads;</span><br><span class="line">  min = <span class="number">0</span>;</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; concurrent_count; t++) &#123;</span><br><span class="line">    <span class="type">int</span> range = max / concurrent_count * (t + <span class="number">1</span>);</span><br><span class="line">    threads.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(concurrent_worker, min, range)); <span class="comment">// ③</span></span><br><span class="line">    min = range + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threads.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    threads[i].<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> end_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> ms = chrono::<span class="built_in">duration_cast</span>&lt;chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed, Result: &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只有三个地方需要关注：</p>
<ol type="1">
<li>在访问共享数据之前加锁</li>
<li>访问完成之后解锁</li>
<li>在多线程中使用带锁的版本</li>
</ol>
<p>执行之后结果输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hardware_concurrency: 16</span><br><span class="line">Concurrent task finish, 74232 ms consumed, Result: 2.10819e+13</span><br></pre></td></tr></table></figure>
<p>这下结果是对了，但是我们却发现这个版本比原先单线程的版本性能还要差很多。这是为什么？</p>
<p>这是因为加锁和解锁是有代价的，这里计算最耗时的地方在锁里面，每次只能有一个线程串行执行，相比于单线程模型，它不但是串行的，还增加了锁的负担，因此就更慢了。</p>
<p>这就是为什么前面说多线程系统会增加系统的复杂度，而且并非多线程系统一定就有更好的性能。</p>
<p>不过，对于这里的问题是可以改进的。我们仔细思考一下：我们划分给每个线程的数据其实是独立的，对于数据的处理是耗时的，但其实这部分逻辑每个线程可以单独处理，没必要加锁。只有在最后汇总数据的时候进行一次锁保护就可以了。</p>
<p>于是我们改造<code>concurrent_worker</code>，像下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 08_improved_mutex_lock.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">concurrent_worker</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> tmp_sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    tmp_sum += <span class="built_in">sqrt</span>(i); <span class="comment">// ①</span></span><br><span class="line">  &#125;</span><br><span class="line">  exclusive.<span class="built_in">lock</span>(); <span class="comment">// ②</span></span><br><span class="line">  sum += tmp_sum;</span><br><span class="line">  exclusive.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的改变在于两处：</p>
<ol type="1">
<li>通过一个局部变量保存当前线程的处理结果</li>
<li>在汇总总结过的时候进行锁保护</li>
</ol>
<p>运行一下改进后的程序，其结果输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hardware_concurrency: 16</span><br><span class="line">Concurrent task finish, 451 ms consumed, Result: 2.10819e+13</span><br></pre></td></tr></table></figure>
<p>可以看到，性能一下就提升了好多倍。我们终于体验到多线程带来的好处了。</p>
<p>我们用锁的<strong>粒度</strong>（granularity）来描述锁的范围。<strong>细粒度</strong>（fine-grained）是指锁保护较小的范围，<strong>粗粒度</strong>（coarse-grained）是指锁保护较大的范围。出于性能的考虑，我们应该保证锁的粒度尽可能的细。并且，不应该在获取锁的范围内执行耗时的操作，例如执行
IO。如果是耗时的运算，也应该尽可能的移到锁的外面。</p>
<blockquote>
<p>In general, a lock should be held for only the minimum possible time
needed to perform the required operations.</p>
<p>–《C++ Concurrency in Action》</p>
</blockquote>
<h2 id="死锁">死锁</h2>
<p>死锁是并发系统很常见的一类问题。</p>
<p>死锁是指：两个或以上的运算单元，每一方都在等待其他方释放资源，但是所有方都不愿意释放资源。结果是没有任何一方能继续推进下去，于是整个系统无法再继续运转。</p>
<p>死锁在现实中也很常见，例如：两个孩子分别拿着玩具的一半然后哭着要从对方手里得到另外一半玩具，但是谁都不肯让步。</p>
<p>在成年人的世界里也会发生类似的情况，例如下面这个交通状况：</p>
<p><img data-src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/deadlock.gif" /></p>
<p>下面我们来看一个编程示例。</p>
<p>现在假设我们在开发一个银行的系统，这个系统包含了转账的功能。</p>
<p>首先我们创建一个<code>Account</code>类来描述银行账号。由于这仅仅是一个演示使用的代码，所以我们希望代码足够的简单。<code>Account</code>类仅仅包含名称和金额两个字段。</p>
<p>另外，为了支持并发，这个类包含了一个<code>mutex</code>对象，用来保护账号金额，在读写账号金额时需要先加锁保护。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 09_deadlock_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Account</span>(string name, <span class="type">double</span> money): <span class="built_in">mName</span>(name), <span class="built_in">mMoney</span>(money) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">changeMoney</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">    mMoney += amount;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMoney;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">mutex* <span class="title">getLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;mMoneyLock;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string mName;</span><br><span class="line">  <span class="type">double</span> mMoney;</span><br><span class="line">  mutex mMoneyLock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Account</code>类很简单，我想就不用多做说明了。</p>
<p>接下来，我们再创建一个描述银行的<code>Bank</code>类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 09_deadlock_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">addAccount</span><span class="params">(Account* account)</span> </span>&#123;</span><br><span class="line">    mAccounts.<span class="built_in">insert</span>(account);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">transferMoney</span><span class="params">(Account* accountA, Account* accountB, <span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="function">lock_guard <span class="title">guardA</span><span class="params">(*accountA-&gt;getLock())</span></span>; <span class="comment">// ①</span></span><br><span class="line">    <span class="function">lock_guard <span class="title">guardB</span><span class="params">(*accountB-&gt;getLock())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (amount &gt; accountA-&gt;<span class="built_in">getMoney</span>()) &#123; <span class="comment">// ②</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    accountA-&gt;<span class="built_in">changeMoney</span>(-amount); <span class="comment">// ③</span></span><br><span class="line">    accountB-&gt;<span class="built_in">changeMoney</span>(amount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">totalMoney</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : mAccounts) &#123;</span><br><span class="line">      sum += a-&gt;<span class="built_in">getMoney</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  set&lt;Account*&gt; mAccounts;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>银行类中记录了所有的账号，并且提供了一个方法用来查询整个银行的总金额。</p>
<p>这其中，我们最主要要关注转账的实现：<code>transferMoney</code>。该方法的几个关键点如下：</p>
<ol type="1">
<li>为了保证线程安全，在修改每个账号之前，需要获取相应的锁。</li>
<li>判断转出账户金额是否足够，如果不够此次转账失败。</li>
<li>进行转账。</li>
</ol>
<p>有了银行和账户结构之后就可以开发转账系统了，同样的，由于是为了演示所用，我们的转账系统也会尽可能的简单：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 09_deadlock_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">randomTransfer</span><span class="params">(Bank* bank, Account* accountA, Account* accountB)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">double</span> randomMoney = ((<span class="type">double</span>)<span class="built_in">rand</span>() / RAND_MAX) * <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (bank-&gt;<span class="built_in">transferMoney</span>(accountA, accountB, randomMoney)) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Transfer &quot;</span> &lt;&lt; randomMoney &lt;&lt; <span class="string">&quot; from &quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getName</span>()</span><br><span class="line">           &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; accountB-&gt;<span class="built_in">getName</span>()</span><br><span class="line">           &lt;&lt; <span class="string">&quot;, Bank totalMoney: &quot;</span> &lt;&lt; bank-&gt;<span class="built_in">totalMoney</span>() &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Transfer failed, &quot;</span></span><br><span class="line">           &lt;&lt; accountA-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; has only $&quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getMoney</span>() &lt;&lt; <span class="string">&quot;, but &quot;</span></span><br><span class="line">           &lt;&lt; randomMoney &lt;&lt; <span class="string">&quot; required&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里每次生成一个随机数，然后通过银行进行转账。</p>
<p>最后我们在<code>main</code>函数中创建两个线程，互相在两个账号之间来回转账：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 09_deadlock_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Account <span class="title">a</span><span class="params">(<span class="string">&quot;Paul&quot;</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">  <span class="function">Account <span class="title">b</span><span class="params">(<span class="string">&quot;Moira&quot;</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  Bank aBank;</span><br><span class="line">  aBank.<span class="built_in">addAccount</span>(&amp;a);</span><br><span class="line">  aBank.<span class="built_in">addAccount</span>(&amp;b);</span><br><span class="line"></span><br><span class="line">  <span class="function">thread <span class="title">t1</span><span class="params">(randomTransfer, &amp;aBank, &amp;a, &amp;b)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t2</span><span class="params">(randomTransfer, &amp;aBank, &amp;b, &amp;a)</span></span>;</span><br><span class="line"></span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们的银行转账系统就开发完成了。然后编译并运行，其结果可能像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Transfer 13.2901 from Paul to Moira, Bank totalMoney: 20042.6259 from Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer failed, Moira has only <span class="variable">$34</span>.7581, but 66.3208 required</span><br><span class="line">Transfer failed, Moira has only <span class="variable">$34</span>.7581, but </span><br><span class="line">Transfer 93.191 from 53.9176 required</span><br><span class="line">Transfer 60.6146 from Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer 49.7304 from Moira to Paul, Bank totalMoney: 200Paul to Moira, Bank totalMoney: </span><br><span class="line">Transfer failed, Moira has only <span class="variable">$17</span>.6041, but 18.1186 required</span><br><span class="line">Transfer failed, Moira has only <span class="variable">$17</span>.6041, but 18.893 required</span><br><span class="line">Transfer failed, Moira has only <span class="variable">$17</span>.6041, but 34.7078 required</span><br><span class="line">Transfer failed, Moira has only <span class="variable">$17</span>.6041, but 33.9569 required</span><br><span class="line">Transfer 12.7899 from 200</span><br><span class="line">Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer failed, Moira has only <span class="variable">$63</span>.9373, but 80.9038 required</span><br><span class="line">Transfer 50.933 from Moira to Paul, Bank totalMoney: 200</span><br><span class="line">Transfer failed, Moira has only <span class="variable">$13</span>.0043, but 30.2056 required</span><br><span class="line">Transfer failed, Moira has only <span class="variable">$Transfer</span> 59.123 from Paul to Moira, Bank totalMoney: 200</span><br><span class="line">Transfer 29.0486 from Paul to Moira, Bank totalMoney: 20013.0043, but 64.7307 required</span><br></pre></td></tr></table></figure>
<p>如果你运行了这个程序，你会发现很快它就卡住不动了。为什么？</p>
<p>因为发生了死锁。</p>
<p>我们仔细思考一下这两个线程的逻辑：这两个线程可能会同时获取其中一个账号的锁，然后又想获取另外一个账号的锁，此时就发生了死锁。如下图所示：</p>
<p><img data-src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/deadlock.png" /></p>
<p>当然，发生死锁的原因远不止上面这一种情况。如果两个线程互相<code>join</code>就可能发生死锁。还有在一个线程中对一个不可重入的互斥体（例如<code>mutex</code>而非<code>recursive_mutex</code>）多次加锁也会死锁。</p>
<p>你可能会觉得，我可不会这么傻，写出这样的代码。但实际上，很多时候是由于代码的深层次嵌套导致了死锁的发生，由于调用关系的复杂导致发现这类问题并不容易。</p>
<p>如果仔细看一下上面的输出，我们会发现还有另外一个问题：这里的输出是乱的。两个线程的输出混杂在一起了。究其原因也很容易理解：两个线程可能会同时输出，没有做好隔离。</p>
<p>下面我们就来逐步解决上面的问题。</p>
<p>对于输出混乱的问题很好解决，专门用一把锁来保护输出逻辑即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10_improved_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line">mutex sCoutLock;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">randomTransfer</span><span class="params">(Bank* bank, Account* accountA, Account* accountB)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">double</span> randomMoney = ((<span class="type">double</span>)<span class="built_in">rand</span>() / RAND_MAX) * <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (bank-&gt;<span class="built_in">transferMoney</span>(accountA, accountB, randomMoney)) &#123;</span><br><span class="line">      sCoutLock.<span class="built_in">lock</span>();</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Transfer &quot;</span> &lt;&lt; randomMoney &lt;&lt; <span class="string">&quot; from &quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getName</span>()</span><br><span class="line">          &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; accountB-&gt;<span class="built_in">getName</span>()</span><br><span class="line">          &lt;&lt; <span class="string">&quot;, Bank totalMoney: &quot;</span> &lt;&lt; bank-&gt;<span class="built_in">totalMoney</span>() &lt;&lt; endl;</span><br><span class="line">      sCoutLock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sCoutLock.<span class="built_in">lock</span>();</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Transfer failed, &quot;</span></span><br><span class="line">           &lt;&lt; accountA-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot; has only &quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getMoney</span>() &lt;&lt; <span class="string">&quot;, but &quot;</span></span><br><span class="line">           &lt;&lt; randomMoney &lt;&lt; <span class="string">&quot; required&quot;</span> &lt;&lt; endl;</span><br><span class="line">      sCoutLock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请思考一下两处<code>lock</code>和<code>unlock</code>调用，并考虑为什么不在<code>while(true)</code>下面写一次整体的加锁和解锁。</p>
</blockquote>
<h2 id="通用锁定算法">通用锁定算法</h2>
<ul>
<li>主要 API</li>
</ul>
<table>
<thead>
<tr class="header">
<th>API</th>
<th>C++ 标准</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>lock</td>
<td>C++11</td>
<td>锁定指定的互斥体，若任何一个不可用则阻塞</td>
</tr>
<tr class="even">
<td>try_lock</td>
<td>C++11</td>
<td>试图通过重复调用 try_lock 获得互斥体的所有权</td>
</tr>
</tbody>
</table>
<p>要避免死锁，需要仔细的思考和设计业务逻辑。</p>
<p>有一个比较简单的原则可以避免死锁，即：对所有的锁进行排序，每次一定要按照顺序来获取锁，不允许乱序。例如：要获取某个玩具，一定要先拿到锁
A，再拿到锁 B，才能玩玩具。这样就不会死锁了。</p>
<p>这个原则虽然简单，但却不容易遵守。因为数据常常是分散在很多地方的。</p>
<p>不过好消息是，C++ 11
标准中为我们提供了一些工具来避免因为多把锁而导致的死锁。我们只要直接调用这些接口就可以了。这个就是上面提到的两个函数。它们都支持传入多个<a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/named_req/Lockable">Lockable</a>对象。</p>
<p>接下来我们用它来改造之前死锁的转账系统：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10_improved_bank_transfer.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">transferMoney</span><span class="params">(Account* accountA, Account* accountB, <span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">lock</span>(*accountA-&gt;<span class="built_in">getLock</span>(), *accountB-&gt;<span class="built_in">getLock</span>());    <span class="comment">// ①</span></span><br><span class="line">  <span class="function">lock_guard <span class="title">lockA</span><span class="params">(*accountA-&gt;getLock(), adopt_lock)</span></span>;  <span class="comment">// ②</span></span><br><span class="line">  <span class="function">lock_guard <span class="title">lockB</span><span class="params">(*accountB-&gt;getLock(), adopt_lock)</span></span>;  <span class="comment">// ③</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (amount &gt; accountA-&gt;<span class="built_in">getMoney</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  accountA-&gt;<span class="built_in">changeMoney</span>(-amount);</span><br><span class="line">  accountB-&gt;<span class="built_in">changeMoney</span>(amount);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只改动了 3 行代码。</p>
<ol type="1">
<li>这里通过<code>lock</code>函数来获取两把锁，标准库的实现会保证不会发生死锁。</li>
<li><code>lock_guard</code>在下面我们还会详细介绍。这里只要知道它会在自身对象生命周期的范围内锁定互斥体即可。创建<code>lock_guard</code>的目的是为了在<code>transferMoney</code>结束的时候释放锁，<code>lockB</code>也是一样。但需要注意的是，这里传递了
<code>adopt_lock</code>表示：现在是已经获取到互斥体了的状态了，不用再次加锁（如果不加<code>adopt_lock</code>就是二次锁定了）。</li>
</ol>
<p>运行一下这个改造后的程序，其输出如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">17.5974</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">59.2104</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">49.6379</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">63.6373</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">51.8742</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">50.0081</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">86.1041</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">51.3278</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">66.5754</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">32.1867</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">62.0039</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">98.7819</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">27.046</span> required</span><br><span class="line">Transfer failed, Paul has only $<span class="number">1.76243</span>, but <span class="number">62.9155</span> required</span><br><span class="line">Transfer <span class="number">98.8478</span> from Moira to Paul, Bank totalMoney: <span class="number">200</span></span><br><span class="line">Transfer <span class="number">80.0722</span> from Moira to Paul, Bank totalMoney: <span class="number">200</span></span><br><span class="line">Transfer <span class="number">73.7035</span> from Moira to Paul, Bank totalMoney: <span class="number">200</span></span><br><span class="line">Transfer <span class="number">34.4476</span> from Moira to Paul, Bank totalMoney: <span class="number">200</span></span><br><span class="line">Transfer failed, Moira has only $<span class="number">10.0142</span>, but <span class="number">61.3033</span> required</span><br><span class="line">Transfer failed, Moira has only $<span class="number">10.0142</span>, but <span class="number">24.5595</span> required</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>现在这个转账程序会一直运行下去，不会再死锁了。输出也是正常的了。</p>
<h2 id="通用互斥管理">通用互斥管理</h2>
<ul>
<li>主要 API</li>
</ul>
<table>
<thead>
<tr class="header">
<th>API</th>
<th>C++ 标准</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>lock_guard</td>
<td>C++11</td>
<td>实现严格基于作用域的互斥体所有权包装器</td>
</tr>
<tr class="even">
<td>unique_lock</td>
<td>C++11</td>
<td>实现可移动的互斥体所有权包装器</td>
</tr>
<tr class="odd">
<td>shared_lock</td>
<td>C++14</td>
<td>实现可移动的共享互斥体所有权封装器</td>
</tr>
<tr class="even">
<td>scoped_lock</td>
<td>C++17</td>
<td>用于多个互斥体的免死锁 RAII 封装器</td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>锁定策略</th>
<th>C++ 标准</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>defer_lock</td>
<td>C++11</td>
<td>类型为 <code>defer_lock_t</code>，不获得互斥的所有权</td>
</tr>
<tr class="even">
<td>try_to_lock</td>
<td>C++11</td>
<td>类型为<code>try_to_lock_t</code>，尝试获得互斥的所有权而不阻塞</td>
</tr>
<tr class="odd">
<td>adopt_lock</td>
<td>C++11</td>
<td>类型为<code>adopt_lock_t</code>，假设调用方已拥有互斥的所有权</td>
</tr>
</tbody>
</table>
<p>互斥体（<code>mutex</code>相关类）提供了对于资源的保护功能，但是手动的锁定（调用<code>lock</code>或者<code>try_lock</code>）和解锁（调用<code>unlock</code>）互斥体是要耗费比较大的精力的，我们需要精心考虑和设计代码才行。因为我们需要保证，在任何情况下，解锁要和加锁配对，因为假设出现一条路径导致获取锁之后没有正常释放，就会影响整个系统。如果考虑方法还可以会抛出异常，这样的代码写起来会很费劲。</p>
<p>鉴于这个原因，标准库就提供了上面的这些 API。它们都使用了叫做 RAII
的编程技巧，来简化我们手动加锁和解锁的“体力活”。</p>
<p>请看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://en.cppreference.com/w/cpp/thread/lock_guard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> g_i = <span class="number">0</span>;</span><br><span class="line">std::mutex g_i_mutex;  <span class="comment">// ①</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_i_mutex)</span></span>;  <span class="comment">// ②</span></span><br><span class="line">  ++g_i;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="comment">// ③</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(safe_increment)</span></span>; <span class="comment">// ④</span></span><br><span class="line">  <span class="function">std::thread <span class="title">t2</span><span class="params">(safe_increment)</span></span>;</span><br><span class="line"> </span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line"> </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中：</p>
<ol type="1">
<li>全局的互斥体<code>g_i_mutex</code>用来保护全局变量<code>g_i</code></li>
<li>这是一个设计为可以被多线程环境使用的方法。因此需要通过互斥体来进行保护。这里没有调用<code>lock</code>方法，而是直接使用<code>lock_guard</code>来锁定互斥体。</li>
<li>在方法结束的时候，局部变量<code>std::lock_guard&lt;std::mutex&gt; lock</code>会被销毁，它对互斥体的锁定也就解除了。</li>
<li>在多个线程中使用这个方法。</li>
</ol>
<h3 id="raii">RAII</h3>
<p>上面的几个类（<code>lock_guard</code>，<code>unique_lock</code>，<code>shared_lock</code>，<code>scoped_lock</code>）都使用了一个叫做
RAII 的编程技巧。</p>
<p>RAII 全称是 Resource Acquisition Is
Initialization，直译过来就是：资源获取即初始化。</p>
<p>RAII 是一种<a
target="_blank" rel="noopener" href="http://www.stroustrup.com/bs_faq2.html#finally">C++
编程技术</a>，它将必须在使用前请求的资源（例如：分配的堆内存、执行线程、打开的套接字、打开的文件、锁定的互斥体、磁盘空间、数据库连接等——任何存在受限供给中的事物）的生命周期与一个对象的生存周期相绑定。RAII
保证资源可用于任何会访问该对象的函数。它亦保证所有资源在其控制对象的生存期结束时，以获取顺序的逆序释放。类似地，若资源获取失败（构造函数以异常退出），则为已构造完成的对象和基类子对象所获取的所有资源，会以初始化顺序的逆序释放。这有效地利用了语言特性以消除内存泄漏并保证异常安全。</p>
<p>RAII 可总结如下：</p>
<ul>
<li>将每个资源封装入一个类，其中：
<ul>
<li>构造函数请求资源，并建立所有类不变式，或在它无法完成时抛出异常，</li>
<li>析构函数释放资源并决不抛出异常；</li>
</ul></li>
<li>始终经由 RAII 类的实例使用满足要求的资源，该资源
<ul>
<li>自身拥有自动存储期或临时生存期，或</li>
<li>具有与自动或临时对象的生存期绑定的生存期</li>
</ul></li>
</ul>
<p>回想一下上文中的<code>transferMoney</code>方法中的三行代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lock</span>(*accountA-&gt;<span class="built_in">getLock</span>(), *accountB-&gt;<span class="built_in">getLock</span>());</span><br><span class="line"><span class="function">lock_guard <span class="title">lockA</span><span class="params">(*accountA-&gt;getLock(), adopt_lock)</span></span>;</span><br><span class="line"><span class="function">lock_guard <span class="title">lockB</span><span class="params">(*accountB-&gt;getLock(), adopt_lock)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果使用<code>unique_lock</code>这三行代码还有一种等价的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_lock <span class="title">lockA</span><span class="params">(*accountA-&gt;getLock(), defer_lock)</span></span>;</span><br><span class="line"><span class="function">unique_lock <span class="title">lockB</span><span class="params">(*accountB-&gt;getLock(), defer_lock)</span></span>;</span><br><span class="line"><span class="built_in">lock</span>(*accountA-&gt;<span class="built_in">getLock</span>(), *accountB-&gt;<span class="built_in">getLock</span>());</span><br></pre></td></tr></table></figure>
<p>请注意这里<code>lock</code>方法的调用位置。这里先定义<code>unique_lock</code>指定了<code>defer_lock</code>，因此实际没有锁定互斥体，而是到第三行才进行锁定。</p>
<p>最后，借助<code>scoped_lock</code>，我们可以将三行代码合成一行，这种写法也是等价的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">scoped_lock <span class="title">lockAll</span><span class="params">(*accountA-&gt;getLock(), *accountB-&gt;getLock())</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>scoped_lock</code>会在其生命周期范围内锁定互斥体，销毁的时候解锁。同时，它可以锁定多个互斥体，并且避免死锁。</p>
<p>目前，只还有<code>shared_lock</code>我们没有提到。它与其他几个类的区别在于：它是以共享的方式锁定互斥体。</p>
<h2 id="条件变量">条件变量</h2>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>API</th>
<th>C++ 标准</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>condition_variable</td>
<td>C++ 11</td>
<td>提供与 std::unique_lock 关联的条件变量</td>
</tr>
<tr class="even">
<td>condition_variable_any</td>
<td>C++ 11</td>
<td>提供与任何锁类型关联的条件变量</td>
</tr>
<tr class="odd">
<td>notify_all_at_thread_exit</td>
<td>C++ 11</td>
<td>安排到在此线程完全结束时对 notify_all 的调用</td>
</tr>
<tr class="even">
<td>cv_status</td>
<td>C++ 11</td>
<td>列出条件变量上定时等待的可能结果</td>
</tr>
</tbody>
</table>
<p>至此，我们还有一个地方可以改进。那就是：转账金额不足的时候，程序直接返回了<code>false</code>。这很难说是一个好的策略。因为，即便虽然当前账号金额不足以转账，但只要别的账号又转账进来之后，当前这个转账操作也许就可以继续执行了。</p>
<p>这在很多业务中是很常见的一个需求：每一次操作都要正确执行，如果条件不满足就停下来等待，直到条件满足之后再继续。而不是直接返回。</p>
<p>条件变量提供了一个可以让多个线程间同步协作的功能。这对于<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem">生产者
- 消费者模型</a>很有意义。在这个模型下：</p>
<ul>
<li>生产者和消费者共享一个工作区。这个区间的大小是有限的。</li>
<li>生产者总是产生数据放入工作区中，当工作区满了。它就停下来等消费者消费一部分数据，然后继续工作。</li>
<li>消费者总是从工作区中拿出数据使用。当工作区中的数据全部被消费空了之后，它也会停下来等待生产者往工作区中放入新的数据。</li>
</ul>
<p>从上面可以看到，无论是生产者还是消费者，当它们工作的条件不满足时，它们并不是直接报错返回，而是停下来等待，直到条件满足。</p>
<p>下面我们就借助于条件变量，再次改造之前的银行转账系统。</p>
<p>这个改造主要在于账号类。我们重点是要调整<code>changeMoney</code>方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 11_bank_transfer_wait_notify.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Account</span>(string name, <span class="type">double</span> money): <span class="built_in">mName</span>(name), <span class="built_in">mMoney</span>(money) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">changeMoney</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="function">unique_lock <span class="title">lock</span><span class="params">(mMoneyLock)</span></span>; <span class="comment">// ②</span></span><br><span class="line">    mConditionVar.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>, amount] &#123; <span class="comment">// ③</span></span><br><span class="line">      <span class="keyword">return</span> mMoney + amount &gt; <span class="number">0</span>; <span class="comment">// ④</span></span><br><span class="line">    &#125;);</span><br><span class="line">    mMoney += amount;</span><br><span class="line">    mConditionVar.<span class="built_in">notify_all</span>(); <span class="comment">// ⑤</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMoney;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string mName;</span><br><span class="line">  <span class="type">double</span> mMoney;</span><br><span class="line">  mutex mMoneyLock;</span><br><span class="line">  condition_variable mConditionVar; <span class="comment">// ①</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这几处改动说明如下：</p>
<ol type="1">
<li>这里声明了一个条件变量，用来在多个线程之间协作。</li>
<li>这里使用的是<code>unique_lock</code>，这是为了与条件变量相配合。因为条件变量会解锁和重新锁定互斥体。</li>
<li>这里是比较重要的一个地方：通过条件变量进行等待。此时：会通过后面的
lambda
表达式判断条件是否满足。如果满足则继续；如果不满足，则<strong>此处会解锁互斥体，并让当前线程等待</strong>。<strong>解锁</strong>这一点非常重要，因为只有这样，才能让其他线程获取互斥体。</li>
<li>这里是条件变量等待的条件。如果你不熟悉 lambda
表达式，请自行网上学习，或者阅读<a
target="_blank" rel="noopener" href="https://paul.pub/cpp-lambda-function-bind/">我之前写的文章</a>。</li>
<li>此处也很重要。当金额发生变动之后，我们需要通知所有在条件变量上等待的其他线程。此时所有调用<code>wait</code>线程都会再次唤醒，然后尝试获取锁（当然，只有一个能获取到）并再次判断条件是否满足。除了<code>notify_all</code>还有<code>notify_one</code>，它只通知一个等待的线程。<code>wait</code>和<code>notify</code>就构成了线程间互相协作的工具。</li>
</ol>
<p>请注意：<code>wait</code> 和 <code>notify_all</code>
虽然是写在一个函数中的，但是在运行时它们是在多线程环境中执行的，因此对于这段代码，需要能够从不同线程的角度去思考代码的逻辑。这也是开发并发系统比较难的地方。</p>
<p>有了上面的改动之后，银行的转账方法实现起来就很简单了，不用再考虑数据保护的问题了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 11_bank_transfer_wait_notify.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bank::transferMoney</span><span class="params">(Account* accountA, Account* accountB, <span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">    accountA-&gt;<span class="built_in">changeMoney</span>(-amount);</span><br><span class="line">    accountB-&gt;<span class="built_in">changeMoney</span>(amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，转账逻辑也会变得简单，不用再管转账失败的情况发生。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 11_bank_transfer_wait_notify.cpp</span></span><br><span class="line"></span><br><span class="line">mutex sCoutLock;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">randomTransfer</span><span class="params">(Bank* bank, Account* accountA, Account* accountB)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">double</span> randomMoney = ((<span class="type">double</span>)<span class="built_in">rand</span>() / RAND_MAX) * <span class="number">100</span>;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">lock_guard <span class="title">guard</span><span class="params">(sCoutLock)</span></span>;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;Try to Transfer &quot;</span> &lt;&lt; randomMoney</span><br><span class="line">           &lt;&lt; <span class="string">&quot; from &quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; accountA-&gt;<span class="built_in">getMoney</span>()</span><br><span class="line">           &lt;&lt; <span class="string">&quot;) to &quot;</span> &lt;&lt; accountB-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; accountB-&gt;<span class="built_in">getMoney</span>()</span><br><span class="line">           &lt;&lt; <span class="string">&quot;), Bank totalMoney: &quot;</span> &lt;&lt; bank-&gt;<span class="built_in">totalMoney</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    bank-&gt;<span class="built_in">transferMoney</span>(accountA, accountB, randomMoney);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改完之后的程序运行输出如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Try to Transfer <span class="number">13.72</span> <span class="function">from <span class="title">Moira</span><span class="params">(<span class="number">10.9287</span>)</span> to <span class="title">Paul</span><span class="params">(<span class="number">189.071</span>)</span>, Bank totalMoney: <span class="number">200</span></span></span><br><span class="line"><span class="function">Try to Transfer <span class="number">28.6579</span> from Paul(<span class="number">189.071</span>) to Moira(<span class="number">10.9287</span>), Bank totalMoney: <span class="number">200</span></span></span><br><span class="line"><span class="function">Try to Transfer <span class="number">91.8049</span> from Paul(<span class="number">160.413</span>) to Moira(<span class="number">39.5866</span>), Bank totalMoney: <span class="number">200</span></span></span><br><span class="line"><span class="function">Try to Transfer <span class="number">5.56383</span> from Paul(<span class="number">82.3285</span>) to Moira(<span class="number">117.672</span>), Bank totalMoney: <span class="number">200</span></span></span><br><span class="line"><span class="function">Try to Transfer <span class="number">11.3594</span> from Paul(<span class="number">76.7646</span>) to Moira(<span class="number">123.235</span>), Bank totalMoney: <span class="number">200</span></span></span><br><span class="line"><span class="function">Try to Transfer <span class="number">16.9557</span> from Paul(<span class="number">65.4053</span>) to Moira(<span class="number">134.595</span>), Bank totalMoney: <span class="number">200</span></span></span><br><span class="line"><span class="function">Try to Transfer <span class="number">74.998</span> from Paul(<span class="number">48.4495</span>) to Moira(<span class="number">151.55</span>), Bank totalMoney: <span class="number">200</span></span></span><br><span class="line"><span class="function">Try to Transfer <span class="number">65.3005</span> from Moira(<span class="number">151.55</span>) to Paul(<span class="number">48.4495</span>), Bank totalMoney: <span class="number">200</span></span></span><br><span class="line"><span class="function">Try to Transfer <span class="number">90.6084</span> from Moira(<span class="number">86.25</span>) to Paul(<span class="number">113.75</span>), Bank totalMoney: <span class="number">125.002</span></span></span><br><span class="line"><span class="function">Try to Transfer <span class="number">99.6425</span> from Moira(<span class="number">70.6395</span>) to Paul(<span class="number">129.36</span>), Bank totalMoney: <span class="number">200</span></span></span><br><span class="line"><span class="function">Try to Transfer <span class="number">55.2091</span> from Paul(<span class="number">129.36</span>) to Moira(<span class="number">70.6395</span>), Bank totalMoney: <span class="number">200</span></span></span><br><span class="line"><span class="function">Try to Transfer <span class="number">92.259</span> from Paul(<span class="number">74.1513</span>) to Moira(<span class="number">125.849</span>), Bank totalMoney: <span class="number">200</span></span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure>
<p>这下比之前都要好了。</p>
<p>但是细心的读者会发现，Bank totalMoney 的输出有时候是
200，有时候不是。但不管怎样，即便这一次不是，下一次又是了。关于这一点，请读者自行思考一下为什么，以及如何改进。</p>
<h2 id="future">future</h2>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>API</th>
<th>C++ 标准</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>async</td>
<td>C++11</td>
<td>异步运行一个函数，并返回保有其结果的<code>std::future</code></td>
</tr>
<tr class="even">
<td>future</td>
<td>C++11</td>
<td>等待被异步设置的值</td>
</tr>
<tr class="odd">
<td>packaged_task</td>
<td>C++11</td>
<td>打包一个函数，存储其返回值以进行异步获取</td>
</tr>
<tr class="even">
<td>promise</td>
<td>C++11</td>
<td>存储一个值以进行异步获取</td>
</tr>
<tr class="odd">
<td>shared_future</td>
<td>C++11</td>
<td>等待被异步设置的值（可能为其他 future 所引用）</td>
</tr>
</tbody>
</table>
<p>这一小节中，我们来熟悉更多的可以在并发环境中使用的工具，它们都位于<code>&lt;future&gt;</code>头文件中。</p>
<h2 id="async">async</h2>
<p>很多语言都提供了异步的机制。异步使得耗时的操作不影响当前主线程的执行流。</p>
<p>在 C++11
中，<code>async</code>便是完成这样的功能的。下面是一个代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 12_async_task.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX = <span class="number">10e8</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">auto</span> f1 = <span class="built_in">async</span>(worker, <span class="number">0</span>, MAX);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Async task triggered&quot;</span> &lt;&lt; endl;</span><br><span class="line">  f1.<span class="built_in">wait</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Async task finish, result: &quot;</span> &lt;&lt; sum &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这仍然是我们之前熟悉的例子。这里有两个地方需要说明：</p>
<ol type="1">
<li>这里以异步的方式启动了任务。它会返回一个<code>future</code>对象。<code>future</code>用来存储异步任务的执行结果，关于<code>future</code>我们在后面<code>packaged_task</code>的例子中再详细说明。在这个例子中我们仅仅用它来等待任务执行完成。</li>
<li>此处是等待异步任务执行完成。</li>
</ol>
<p>需要注意的是，默认情况下，<code>async</code>是启动一个新的线程，还是以同步的方式（不启动新的线程）运行任务，这一点标准是没有指定的，由具体的编译器决定。如果希望一定要以新的线程来异步执行任务，可以通过<code>launch::async</code>来明确说明。<code>launch</code>中有两个常量：</p>
<ul>
<li><code>async</code>：运行新线程，以异步执行任务。</li>
<li><code>deferred</code>：调用方线程上第一次请求其结果时才执行任务，即惰性求值。</li>
</ul>
<p>除了通过函数来指定异步任务，还可以 lambda
表达式的方式来指定。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 12_async_task.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> result = <span class="number">0</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Async task with lambda triggered, thread: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">auto</span> f2 = <span class="built_in">async</span>(launch::async, [&amp;result]() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Lambda task in thread: &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= MAX; i++) &#123;</span><br><span class="line">      result += <span class="built_in">sqrt</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  f2.<span class="built_in">wait</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Async task with lambda finish, result: &quot;</span> &lt;&lt; result &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这段代码中，我们使用一个 lambda
表达式来编写异步任务的逻辑，并通过<code>launch::async</code>明确指定要通过独立的线程来执行任务，同时我们打印出了线程的
id。</p>
<p>这段代码输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Async task with lambda triggered, thread: 0x11290d5c0</span><br><span class="line">Lambda task <span class="keyword">in</span> thread: 0x700007aa1000</span><br><span class="line">Async task with lambda finish, result: 2.10819e+13</span><br></pre></td></tr></table></figure>
<p>对于面向对象编程来说，很多时候肯定希望以对象的方法来指定异步任务。下面是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 12_async_task.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Worker</span>(<span class="type">int</span> min, <span class="type">int</span> max): <span class="built_in">mMin</span>(min), <span class="built_in">mMax</span>(max) &#123;&#125; <span class="comment">// ①</span></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">work</span><span class="params">()</span> </span>&#123; <span class="comment">// ②</span></span><br><span class="line">    mResult = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = mMin; i &lt;= mMax; i++) &#123;</span><br><span class="line">      mResult += <span class="built_in">sqrt</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mResult;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mResult;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> mMin;</span><br><span class="line">  <span class="type">int</span> mMax;</span><br><span class="line">  <span class="type">double</span> mResult;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Worker <span class="title">w</span><span class="params">(<span class="number">0</span>, MAX)</span></span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Task in class triggered&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">auto</span> f3 = <span class="built_in">async</span>(&amp;Worker::work, &amp;w); <span class="comment">// ③</span></span><br><span class="line">  f3.<span class="built_in">wait</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Task in class finish, result: &quot;</span> &lt;&lt; w.<span class="built_in">getResult</span>() &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码有三处需要说明：</p>
<ol type="1">
<li>这里通过一个类来描述任务。这个类是对前面提到的任务的封装。它包含了任务的输入参数，和输出结果。</li>
<li><code>work</code>函数是任务的主体逻辑。</li>
<li>通过<code>async</code>执行任务：这里指定了具体的任务函数以及相应的对象。请注意这里是<code>&amp;w</code>，因此传递的是对象的指针。如果不写<code>&amp;</code>将传入<code>w</code>对象的临时复制。</li>
</ol>
<h2 id="packaged_task">packaged_task</h2>
<p>在一些业务中，我们可能会有很多的任务需要调度。这时我们常常会设计出任务队列和线程池的结构。此时，就可以使用<code>packaged_task</code>来包装任务。</p>
<blockquote>
<p>如果你了解设计模式，你应该会知道<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Command_pattern">命令模式</a>。</p>
</blockquote>
<p><code>packaged_task</code>绑定到一个函数或者可调用对象上。当它被调用时，它就会调用其绑定的函数或者可调用对象。并且，可以通过与之相关联的<code>future</code>来获取任务的结果。调度程序只需要处理<code>packaged_task</code>，而非各个函数。</p>
<p><code>packaged_task</code>对象是一个可调用对象，它可以被封装成一个<code>std::fucntion</code>，或者作为线程函数传递给<code>std::thread</code>，或者直接调用。</p>
<p>下面是一个代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 13_packaged_task.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">concurrent_worker</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">concurrent_task</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">  vector&lt;future&lt;<span class="type">double</span>&gt;&gt; results; <span class="comment">// ①</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> concurrent_count = thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">  min = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; concurrent_count; i++) &#123; <span class="comment">// ②</span></span><br><span class="line">    <span class="function">packaged_task&lt;<span class="title">double</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(concurrent_worker)</span></span>; <span class="comment">// ③</span></span><br><span class="line">    results.<span class="built_in">push_back</span>(task.<span class="built_in">get_future</span>()); <span class="comment">// ④</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> range = max / concurrent_count * (i + <span class="number">1</span>);</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(std::move(task), min, range)</span></span>; <span class="comment">// ⑤</span></span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    min = range + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;threads create finish&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : results) &#123;</span><br><span class="line">    sum += r.<span class="built_in">get</span>(); <span class="comment">// ⑥</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> start_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> r = <span class="built_in">concurrent_task</span>(<span class="number">0</span>, MAX);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> end_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> ms = chrono::<span class="built_in">duration_cast</span>&lt;chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed, Result: &quot;</span> &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中：</p>
<ol type="1">
<li>首先创建一个集合来存储<code>future</code>对象。我们将用它来获取任务的结果。</li>
<li>同样的，根据 CPU 的情况来创建线程的数量。</li>
<li>将任务包装成<code>packaged_task</code>。请注意，由于<code>concurrent_worker</code>被包装成了任务，我们无法直接获取它的<code>return</code>值。而是要通过<code>future</code>对象来获取。</li>
<li>获取任务关联的<code>future</code>对象，并将其存入集合中。</li>
<li>通过一个新的线程来执行任务，并传入需要的参数。</li>
<li>通过<code>future</code>集合，逐个获取每个任务的计算结果，将其累加。这里<code>r.get()</code>获取到的就是每个任务中<code>concurrent_worker</code>的返回值。</li>
</ol>
<p>为了简单起见，这里的示例只使用了我们熟悉的例子和结构。但在实际上的工程中，调用关系通常更复杂，你可以借助于<code>packaged_task</code>将任务组装成队列，然后通过<a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Thread_pool">线程池</a>的方式进行调度：</p>
<p><img data-src="https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/Thread_pool.svg" /></p>
<h2 id="promise-与-future">promise 与 future</h2>
<p>在上面的例子中，<code>concurrent_task</code>的结果是通过<code>return</code>返回的。但在一些时候，我们可能不能这么做：在得到任务结果之后，可能还有一些事情需要继续处理，例如清理工作。</p>
<p>这个时候，就可以将<code>promise</code>与<code>future</code>配对使用。这样就可以将返回结果和任务结束两个事情分开。</p>
<p>下面是对上面代码示例的改写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 14_promise_future.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">concurrent_worker</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">sqrt</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">concurrent_task</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, promise&lt;<span class="type">double</span>&gt;* result)</span> </span>&#123; <span class="comment">// ①</span></span><br><span class="line">  vector&lt;future&lt;<span class="type">double</span>&gt;&gt; results;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> concurrent_count = thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">  min = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; concurrent_count; i++) &#123;</span><br><span class="line">    <span class="function">packaged_task&lt;<span class="title">double</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(concurrent_worker)</span></span>;</span><br><span class="line">    results.<span class="built_in">push_back</span>(task.<span class="built_in">get_future</span>()); </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> range = max / concurrent_count * (i + <span class="number">1</span>);</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(std::move(task), min, range)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    min = range + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;threads create finish&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; r : results) &#123;</span><br><span class="line">    sum += r.<span class="built_in">get</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  result-&gt;<span class="built_in">set_value</span>(sum); <span class="comment">// ②</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;concurrent_task finish&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> start_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  promise&lt;<span class="type">double</span>&gt; sum; <span class="comment">// ③</span></span><br><span class="line">  <span class="built_in">concurrent_task</span>(<span class="number">0</span>, MAX, &amp;sum);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> end_time = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> ms = chrono::<span class="built_in">duration_cast</span>&lt;chrono::milliseconds&gt;(end_time - start_time).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms consumed.&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; sum.<span class="built_in">get_future</span>().<span class="built_in">get</span>() &lt;&lt; endl; <span class="comment">// ④</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码和上面的示例在很大程度上是一样的。只有小部分内容做了改动：</p>
<ol type="1">
<li><code>concurrent_task</code>不再直接返回计算结果，而是增加了一个<code>promise</code>对象来存放结果。</li>
<li>在任务计算完成之后，将总结过设置到<code>promise</code>对象上。一旦这里调用了<code>set_value</code>，其相关联的<code>future</code>对象就会就绪。</li>
<li>这里是在<code>main</code>中创建一个<code>promoise</code>来存放结果，并以指针的形式传递进<code>concurrent_task</code>中。</li>
<li>通过<code>sum.get_future().get()</code>来获取结果。第 2
点中已经说了：一旦调用了<code>set_value</code>，其相关联的<code>future</code>对象就会就绪。</li>
</ol>
<p>需要注意的是，<code>future</code>对象只有被一个线程获取值。并且在调用<code>get()</code>之后，就没有可以获取的值了。如果从多个线程调用<code>get()</code>会出现数据竞争，其结果是未定义的。</p>
<p>如果真的需要在多个线程中获取<code>future</code>的结果，可以使用<code>shared_future</code>。</p>
<h2 id="并行算法">并行算法</h2>
<p>从 C++17 开始。<a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/algorithm"><algorithm></a>和<a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/numeric#Numeric_algorithms"><numeric></a>
头文件的中的很多算法都添加了一个新的参数：<code>sequenced_policy</code>。</p>
<p>借助这个参数，开发者可以直接使用这些算法的并行版本，不用再自己创建并发系统和划分数据来调度这些算法。</p>
<p><code>sequenced_policy</code>可能的取值有三种，它们的说明如下：</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>变量</th>
<th>类型</th>
<th>C++ 版本</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>execution::seq</td>
<td>execution::sequenced_policy</td>
<td>C++17</td>
<td>要求并行算法的执行可以不并行化</td>
</tr>
<tr class="even">
<td>execution::par</td>
<td>execution::parallel_policy</td>
<td>C++17</td>
<td>指示并行算法的执行可以并行化</td>
</tr>
<tr class="odd">
<td>execution::par_unseq</td>
<td>execution::parallel_unsequenced_policy</td>
<td>C++17</td>
<td>指示并行算法的执行可以并行化、向量化</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：<a href="#id-测试环境">本文的前面</a>已经提到，目前 clang
编译器还不支持这个功能。因此想要编译这部分代码，你需要使用 gcc 9.0
或更高版本，同时还需要安装<a target="_blank" rel="noopener" href="https://github.com/intel/tbb">Intel
Threading Building Blocks</a>。</p>
</blockquote>
<p>下面还是通过一个示例来进行说明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 15_parallel_algorithm.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generateRandomData</span><span class="params">(vector&lt;<span class="type">double</span>&gt;&amp; collection, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  random_device rd;</span><br><span class="line">  <span class="function">mt19937 <span class="title">mt</span><span class="params">(rd())</span></span>;</span><br><span class="line">  <span class="function">uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">dist</span><span class="params">(<span class="number">1.0</span>, <span class="number">100.0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    collection.<span class="built_in">push_back</span>(<span class="built_in">dist</span>(mt));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">double</span>&gt; collection;</span><br><span class="line">  <span class="built_in">generateRandomData</span>(collection, <span class="number">10e6</span>); <span class="comment">// ①</span></span><br><span class="line"></span><br><span class="line">  <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">copy1</span><span class="params">(collection)</span></span>; <span class="comment">// ②</span></span><br><span class="line">  <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">copy2</span><span class="params">(collection)</span></span>;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">copy3</span><span class="params">(collection)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> time1 = chrono::steady_clock::<span class="built_in">now</span>(); <span class="comment">// ③</span></span><br><span class="line">  <span class="built_in">sort</span>(execution::seq, copy1.<span class="built_in">begin</span>(), copy1.<span class="built_in">end</span>()); <span class="comment">// ④</span></span><br><span class="line">  <span class="keyword">auto</span> time2 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="keyword">auto</span> duration = chrono::<span class="built_in">duration_cast</span>&lt;chrono::milliseconds&gt;(time2 - time1).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Sequenced sort consuming &quot;</span> &lt;&lt; duration &lt;&lt; <span class="string">&quot;ms.&quot;</span> &lt;&lt; endl; <span class="comment">// ⑤</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> time3 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="built_in">sort</span>(execution::par, copy2.<span class="built_in">begin</span>(),copy2.<span class="built_in">end</span>()); <span class="comment">// ⑥</span></span><br><span class="line">  <span class="keyword">auto</span> time4 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  duration = chrono::<span class="built_in">duration_cast</span>&lt;chrono::milliseconds&gt;(time4 - time3).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Parallel sort consuming &quot;</span> &lt;&lt; duration &lt;&lt; <span class="string">&quot;ms.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> time5 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="built_in">sort</span>(execution::par_unseq, copy2.<span class="built_in">begin</span>(),copy2.<span class="built_in">end</span>()); <span class="comment">// ⑦</span></span><br><span class="line">  <span class="keyword">auto</span> time6 = chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">  duration = chrono::<span class="built_in">duration_cast</span>&lt;chrono::milliseconds&gt;(time6 - time5).<span class="built_in">count</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Parallel unsequenced sort consuming &quot;</span> &lt;&lt; duration &lt;&lt; <span class="string">&quot;ms.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码很简单：</p>
<ol type="1">
<li>通过一个函数生成 1000,000 个随机数。</li>
<li>将数据拷贝 3 份，以备使用。</li>
<li>接下来将通过三个不同的<code>parallel_policy</code>参数来调用同样的<code>sort</code>算法。每次调用记录开始和结束的时间。</li>
<li>第一次调用使用<code>std::execution::seq</code>参数。</li>
<li>输出本次测试所使用的时间。</li>
<li>第二次调用使用<code>std::execution::par</code>参数。</li>
<li>第三次调用使用<code>std::execution::par_unseq</code>参数。</li>
</ol>
<p>该程序的输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sequenced sort consuming 4464ms.</span><br><span class="line">Parallel sort consuming 459ms.</span><br><span class="line">Parallel unsequenced sort consuming 168ms.</span><br></pre></td></tr></table></figure>
<p>可以看到，性能最好的和最差的相差了超过 26 倍。</p>
<h2 id="结束语">结束语</h2>
<p>在本篇文章中，我们介绍了 C++ 语言中新增的并发编程
API。虽然这部分内容已经不少（大部分人很难一次性搞懂所有这些内容，包括我自己），但实际上还有一个很重要的话题我们没有触及，那就是“内存模型”。</p>
<p>C++ 内存模型是 C++11
标准中最重要的特性之一。它是多线程环境能够可靠工作的基础。考虑到这部分内容还需要比较多的篇幅来说明，因此我们会在下一篇文章中继续讨论。</p>
<h2 id="参考资料与推荐读物">参考资料与推荐读物</h2>
<ul>
<li><a
target="_blank" rel="noopener" href="https://www.amazon.com/C-Concurrency-Action-Anthony-Williams/dp/1617294691/">C++
Concurrency in Action 2nd</a></li>
<li><a target="_blank" rel="noopener" href="http://wikipedia.org/">Wikipedia</a></li>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread">cpprefernce:
Thread support library</a></li>
<li><a
target="_blank" rel="noopener" href="https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996">Effective
Modern C++: 42 Specific Ways to Improve Your Use of C++11 and
C++14</a></li>
<li><a
target="_blank" rel="noopener" href="https://www.hpl.hp.com/techreports/2004/HPL-2004-209.pdf">Threads
Cannot be Implemented as a Library</a></li>
<li><a
target="_blank" rel="noopener" href="https://www.modernescpp.com/index.php/i-m-proud-to-present-modern-c-concurrency-is-available-as-interactive-course">I’m
Proud to Present: Modern C++ Concurrency is available as interactive
course</a></li>
<li><a
target="_blank" rel="noopener" href="https://intellij-support.jetbrains.com/hc/en-us/community/posts/115000682210-How-do-I-enable-C-17-">How
do I enable C++17?</a></li>
<li><a
target="_blank" rel="noopener" href="https://solarianprogrammer.com/2019/05/09/cpp-17-stl-parallel-algorithms-gcc-intel-tbb-linux-macos/">C++17
STL Parallel Algorithms - with GCC 9.1 and Intel TBB on Linux and
macOS</a></li>
<li><a
target="_blank" rel="noopener" href="https://medium.com/@george.shuklin/how-to-install-packages-from-a-newer-distribution-without-installing-unwanted-6584fa93208f">How
to install packages from a newer distribution without installing
unwanted</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Yao J
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://xinransix.github.io/2024/08/06/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BB%8EC-11%E5%88%B0C-17%EF%BC%89/" title="C++ 并发编程（从 C++11 到 C++17）">https://xinransix.github.io/2024/08/06/C-并发编程（从C-11到C-17）/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="https://github.com/XinranSix/archives/assets/62458905/6a6f2373-fbf5-4367-9ac2-65230cba90a2">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
      </div>

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a>
              <a href="/tags/Thread/" rel="tag"><i class="fa fa-tag"></i> Thread</a>
              <a href="/tags/Concurrency/" rel="tag"><i class="fa fa-tag"></i> Concurrency</a>
              <a href="/tags/Synchronize/" rel="tag"><i class="fa fa-tag"></i> Synchronize</a>
              <a href="/tags/Lock/" rel="tag"><i class="fa fa-tag"></i> Lock</a>
              <a href="/tags/Mutex/" rel="tag"><i class="fa fa-tag"></i> Mutex</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/07/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%9C%AF%E8%AF%AD/" rel="prev" title="函数式编程——函数式编程术语">
                  <i class="fa fa-angle-left"></i> 函数式编程——函数式编程术语
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-waline">waline</a></li>
            <li class="tab"><a href="#comment-gitalk">gitalk</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane waline" id="comment-waline">
              <div class="comments" id="waline"></div>
            </div>
            <div class="tab-pane gitalk" id="comment-gitalk">
              <div class="comments gitalk-container"></div>
            </div>
        </div>
      </div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Yao J</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">132k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">8:02</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/sakana-widget@2.7.0/lib/sakana.min.css"
/>
<div id="sakana-widget" style="position: fixed; bottom: 10px; right: 20px; z-index: 999;"></div>
<script>
  function initSakanaWidget() {
    new SakanaWidget().mount('#sakana-widget');
  }
</script>
<script
  async
  onload="initSakanaWidget()"
  src="https://cdn.jsdelivr.net/npm/sakana-widget@2.7.0/lib/sakana.min.js"
></script>


    </div>
  </footer>

  
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.33/fancybox/fancybox.umd.js" integrity="sha256-+2+qOqR8CKoHh/AsVR9k2qaDBKWjYNC2nozhYmv5j9k=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/2.3.0/quicklink.umd.js" integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://xinransix.github.io/2024/08/06/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BB%8EC-11%E5%88%B0C-17%EF%BC%89/"}</script>
  <script src="/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-CN","enable":true,"serverURL":"https://comment-for-blog-psi.vercel.app/","cssUrl":"https://unpkg.com/@waline/client@v3/dist/waline.css","commentCount":true,"pageview":true,"emoji":["https://unpkg.com/@waline/emojis@1.1.0/alus","https://unpkg.com/@waline/emojis@1.1.0/bilibili","https://unpkg.com/@waline/emojis@1.1.0/bmoji","https://unpkg.com/@waline/emojis@1.1.0/qq","https://unpkg.com/@waline/emojis@1.1.0/tieba","https://unpkg.com/@waline/emojis@1.1.0/weibo","https://unpkg.com/@waline/emojis@1.1.0/tw-emoji","https://unpkg.com/@waline/emojis@1.1.0/tw-body","https://unpkg.com/@waline/emojis@1.1.0/tw-food","https://unpkg.com/@waline/emojis@1.1.0/tw-natural","https://unpkg.com/@waline/emojis@1.1.0/tw-object","https://unpkg.com/@waline/emojis@1.1.0/tw-symbol","https://unpkg.com/@waline/emojis@1.1.0/tw-people","https://unpkg.com/@waline/emojis@1.1.0/tw-sport","https://unpkg.com/@waline/emojis@1.1.0/tw-time","https://unpkg.com/@waline/emojis@1.1.0/tw-travel","https://unpkg.com/@waline/emojis@1.1.0/tw-weather","https://unpkg.com/@waline/emojis@1.1.0/tw-flag"],"el":"#waline","comment":true,"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","path":"/2024/08/06/C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BB%8EC-11%E5%88%B0C-17%EF%BC%89/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v3/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"XinranSix","repo":"comment","client_id":"9c03a2ae7f09aea822ba","client_secret":"d1c9ff2bb92b84493b307f1587585a6b12fc78b8","admin_user":"XinranSix","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"60f4c69ce4fd6a360887f899d5b9efa5"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
