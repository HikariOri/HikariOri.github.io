<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ 模板元编程基础</title>
    <url>/2023/08/07/CPP%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="元编程基础">元编程基础</h2>
<p>元函数较为接近数学的定义为：是一个无副作用的映射或变换，即在输入相同的前提下，多次调用同一个函数，得到的结果也是相同的。</p>
<p>元函数会在编译器被调用。</p>
<p>编译阶段，编译器只能构造常量作为中间结果，无法构造并维护可以记录系统状态并随着改变的量，因此编译器可以使用的函数只能是无副作用的函数。</p>
<p>例如下面这个函数可以作为元函数使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a + <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>而下面的代码不能通过编译：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> call_count = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fun2</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a + (call_count++); &#125;</span><br></pre></td></tr></table></figure>
<p>从某一角度来看，元函数可以分为数值元函数和类型元函数，上面的
<code>fun</code> 视为数组元函数。</p>
<p>类型元函数用的比数值元函数多。</p>
<h3 id="类型元函数">类型元函数</h3>
<p>一个函数（映射）从数学的角度来定义：</p>
<p><span class="math display">\[
y = f\left(x\right)
\]</span></p>
<p>元编程的核心是元函数，元函数的输入、输出的形式可以有很多种，可以是数值类型，也可以将
C++ 的数据类型作为函数的输出与输入。</p>
<p>例如下面的元函数将 <code>int</code> 和 <code>long</code>
转换为对应的无符号类型，如果不是这两个类型则直接返回原类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun_</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun_</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun_</span>&lt;<span class="type">long</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">unsigned</span> <span class="type">long</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Fun = <span class="keyword">typename</span> Fun_&lt;T&gt;::type;</span><br><span class="line"></span><br><span class="line">Fun_&lt;<span class="type">int</span>&gt;::type h = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>在上古神作《C++ 模板元编程》一书中（现在有点过时了这书），将类模板
<code>Fun_</code> 视为元函数，当输入为 <code>X</code> 时，输出为
<code>Fun_&lt;X&gt;::type</code>，同时，该书规定了所讨论的元函数的输入和输出均是类型。</p>
<p>在《C++ 模板元编程》中，将一个包含了 <code>type</code>
声明的类模板视为元函数，这一定义并非不好（统一了接口，带来了设计上的便利性），但过于狭隘。</p>
<p>将元函数定义为：</p>
<ul>
<li>不限制映射的表示方法，例如以 <code>constexpr</code>
开头的函数，已经提供内嵌 <code>type</code>
类型的模板，以及后文讨论的其他形式的「函数」，只要其无副作用，同时可以在编译器被调用，都可以视为元函数。</li>
<li>不限制输入与输出的形式，输入与输出可以是数值、类型、模板等等。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Fun = <span class="keyword">typename</span> Fun_&lt;T&gt;::type;</span><br><span class="line"></span><br><span class="line">Fun&lt;<span class="type">int</span>&gt; h = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p><code>Fun</code> 如果按照《C++
模板元编程》中的定义，它表示一个标准的元函数，原因在于其没有内嵌类型
<code>type</code>，但根据我们的定义，它应该被视为一个元函数。</p>
<p>在标准库中，也是有这种方式来定义元函数，例如，在 C++ 11
中定义了元函数 <code>std::enable_if</code>，而在 C++ 14 引入了 定义
<code>std::enable_if_t</code>，它们的关系大致为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">enable_if_t</span> = <span class="keyword">typename</span> enable_if&lt;T&gt;::type</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上，在 C++ 14 中对 C++ 11 中的元函数做了「增强」，例如
<code>std::xxx&lt;X&gt;::type</code> 可以通过
<code>std::xxx_t&lt;X&gt;</code>
代替，<code>std::xxx&lt;X&gt;::value</code> 可以通过
<code>std::xxx_v&lt;X&gt;</code> 代替。</p>
</blockquote>
<h3 id="各种各样的元函数">各种各样的元函数</h3>
<p>一切「无副作用」的、可以在编译器被调用，用于对编译器甚乃至运行期的程序行为产生影响，那么这个映射都可以称为元函数，其表现形式千变万化。</p>
<p>实际上，一个模板就是一个元函数。例如，下面这个类模板就是一个元函数，它接受一个输入
<code>T</code>，输出为 <code>Fun&lt;T&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以建立无参元函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参，返回值为 int</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">int</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参，返回值为 10</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用 C++ 14 中对 <code>constexpr</code> 的拓展来构建元函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> a&gt; </span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> fun = a + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>元函数可以有多个返回值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun_</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> reference_type = <span class="type">int</span> &amp;;</span><br><span class="line">    <span class="keyword">using</span> const_reference_type = <span class="type">const</span> <span class="type">int</span> &amp;;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="type">int</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="type_traits">type_traits</h3>
<p>type_traits 是一个元函数库，由 boost 引入（可参考《C++
模板元编程》），C++ 11 被标准吸收，C++ 14 得到加强，需引入头文件
<code>type_traits</code>
来引入。这个库实现类类型转换、类型比较与判断等功能。</p>
<p>可参考：https://www.cnblogs.com/gtarcoder/p/4807670.html</p>
<p>下面几个例子可以参考一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ios&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在根据模板参数创建对象时，要注意移除引用：</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">std::<span class="type">remove_reference_t</span>&lt;T&gt; *<span class="title">Create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> U = std::<span class="type">remove_reference_t</span>&lt;T&gt;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">U</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为模板参数可能是引用类型，而创建对象时，需要原始的类型，不能用引用类型，所以需要将可能的引用移除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果给的模板参数是一个带cv描述符的引用类型，要获取它的原始类型，可以使用decay</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">std::<span class="type">decay_t</span>&lt;T&gt; *<span class="title">Create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> U = std::<span class="type">decay_t</span>&lt;T&gt;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">U</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// decay还可以获得函数的指针类型，从而将函数指针变量保存起来，以便在后面延迟调用。</span></span><br><span class="line"><span class="keyword">using</span> F = std::<span class="type">decay_t</span>&lt;<span class="built_in">int</span>(<span class="type">double</span>)&gt;; <span class="comment">// F为一个函数指针类型， int(*)(double)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SimpleFunction</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> FnType = std::<span class="type">decay_t</span>&lt;F&gt;;</span><br><span class="line">    <span class="built_in">SimpleFunction</span>(F &amp;f) : <span class="built_in">m_fn</span>(f)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span> </span>&#123; <span class="built_in">m_fn</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    FnType m_fn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="keyword">auto</span> t)</span> </span>&#123; std::cout &lt;&lt; std::boolalpha &lt;&lt; t &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> arvc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; std::is_same&lt;const int, std::add_const&lt;int&gt;::type&gt;::value</span></span><br><span class="line">    <span class="comment">//           &lt;&lt; std::endl; // 结果为true</span></span><br><span class="line">    <span class="comment">// std::cout</span></span><br><span class="line">    <span class="comment">// &lt;&lt; std::is_same&lt;int, std::remove_all_extent&lt;int[2][2][3]&gt;::type&gt;::value</span></span><br><span class="line">    <span class="comment">// &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span>, std::<span class="type">remove_const_t</span>&lt;<span class="type">int</span> <span class="type">const</span>&gt;&gt;);</span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span> <span class="type">const</span>, std::<span class="type">add_const_t</span>&lt;<span class="type">int</span> <span class="type">const</span>&gt;&gt;);</span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span>, std::<span class="type">remove_reference_t</span>&lt;<span class="type">int</span> &amp;&gt;&gt;);</span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span>, std::<span class="type">remove_reference_t</span>&lt;<span class="type">int</span> &amp;&amp;&gt;&gt;);</span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span> &amp;, std::<span class="type">add_lvalue_reference_t</span>&lt;<span class="type">int</span>&gt;&gt;);</span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span> &amp;&amp;, std::<span class="type">add_rvalue_reference_t</span>&lt;<span class="type">int</span>&gt;&gt;);</span><br><span class="line">    <span class="comment">// print(  std::boolalpha &lt;&lt; std::is_same_v&lt;int[3][2],</span></span><br><span class="line">    <span class="comment">// std::remove_all_extent_t&lt;int[3][3][2]&gt;&gt; );</span></span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span>[<span class="number">4</span>][<span class="number">5</span>], std::<span class="type">remove_extent_t</span>&lt;<span class="type">int</span>[<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>]&gt;&gt;);</span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span>, std::<span class="type">remove_pointer_t</span>&lt;<span class="type">int</span> *&gt;&gt;);</span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span> **, std::<span class="type">add_pointer_t</span>&lt;<span class="type">int</span> *&gt;&gt;);</span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span>, std::<span class="type">decay_t</span>&lt;<span class="type">int</span> <span class="type">const</span>&gt;&gt;);</span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span>, std::<span class="type">decay_t</span>&lt;<span class="type">int</span> <span class="keyword">volatile</span>&gt;&gt;);</span><br><span class="line">    <span class="built_in">print</span>(std::is_same_v&lt;<span class="type">int</span> *, std::<span class="type">decay_t</span>&lt;<span class="type">int</span>[]&gt;&gt;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> T = std::<span class="type">common_type_t</span>&lt;<span class="type">int</span>, <span class="type">double</span>, <span class="type">bool</span>, <span class="type">float</span>&gt;;</span><br><span class="line"></span><br><span class="line">    T a&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    T b&#123;<span class="number">1.0</span>&#125;;</span><br><span class="line">    T c&#123;<span class="literal">true</span>&#125;;</span><br><span class="line">    T d&#123;<span class="number">1.0f</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命名约定：如果元函数的返回值要用某种依赖性的名称表示，那么函数将被命名为
<code>XXX_</code>
的形式；反之，如果元函数的返回值可以字节用某种非依赖性的名称表示，那么元函数的名称将不包含下划线形式的后缀，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> a, <span class="type">int</span> b&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Add_</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">int</span> value = a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> a, <span class="type">int</span> b&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> Add = a + b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> x1 = Add_&lt;<span class="number">2</span>, <span class="number">3</span>&gt;::value;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> x2 = Add&lt;<span class="number">2</span>, <span class="number">3</span>&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="模板型模板参数">模板型模板参数</h3>
<h4 id="模板作为容器的输入">模板作为容器的输入</h4>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun_</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> T1&lt;T2&gt;::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">using</span> Fun = <span class="keyword">typename</span> Fun_&lt;T1, T2&gt;::type;</span><br><span class="line"></span><br><span class="line">Fun&lt;std::remove_reference, <span class="type">int</span>&amp;&gt; h = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h4 id="模板作为元函数的输出">模板作为元函数的输出</h4>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> AddOrRemoveRef&gt; <span class="keyword">struct</span> <span class="title class_">Fun_</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun_</span>&lt;<span class="literal">true</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">using</span> type = std::add_lvalue_reference&lt;T&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun_</span>&lt;<span class="literal">false</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">using</span> type = std::remove_reference&lt;T&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> AddOrRemove&gt;</span><br><span class="line"><span class="keyword">using</span> Fun = <span class="keyword">typename</span> Fun_&lt;AddOrRemove&gt;::<span class="keyword">template</span> type&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Res_ = Fun&lt;<span class="literal">false</span>&gt;;</span><br><span class="line"></span><br><span class="line">Res_&lt;<span class="type">int</span>&amp;&gt;::type h = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h3 id="容器模板">容器模板</h3>
<p>我们的容器也仅能保存一种类别的操作数，比如一个仅能保存数值的容器，或者仅能保存类型的容器，或者仅能保存模板的容器。</p>
<p>使用 C++ 11 中引入的变参数模板，可以很容易实现我们想要的功能。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span>... Vals&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">InContainer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span>... Vals&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BoolContainer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TypeContainer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span>... T&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TemplateCont</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>...&gt; <span class="keyword">class</span>...T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TemplateCont2</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>元编程中有一个惯用法，就是仅在必要时才引入定义。</p>
</blockquote>
<h3 id="顺序分支与循环代码的编写">顺序、分支与循环代码的编写</h3>
<h4 id="顺序执行的代码">顺序执行的代码</h4>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RemoveReferenceConst_</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> inter_type = std::<span class="type">remove_reference_t</span>&lt;T&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> type = std::<span class="type">remove_const_t</span>&lt;inter_type&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> RemoveReferenceConst = <span class="keyword">typename</span> RemoveReferenceConst_&lt;T&gt;::type;</span><br><span class="line"></span><br><span class="line">RemoveReferenceConst&lt;<span class="type">const</span> <span class="type">int</span>&amp;&gt; h = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h4 id="分支执行的代码">分支执行的代码</h4>
<p>使用模板特化或部分特化来实现分支，是一种非常常见的手段，当然也有些其他手段。</p>
<p><strong>使用 <code>std::conditional</code> 与
<code>std::conditional_t</code> 实现分支</strong></p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::conditional&lt;<span class="literal">true</span>, <span class="type">int</span>, <span class="type">float</span>&gt;::type x = <span class="number">3</span>;</span><br><span class="line">std::conditional_y&lt;<span class="literal">false</span>, <span class="type">int</span>, <span class="type">float</span>&gt; y = <span class="number">1.0f</span>;</span><br></pre></td></tr></table></figure>
<p>这种方法只能实现简单的分支。</p>
<p><strong>使用（部分）特化实现分支</strong></p>
<p>特化天生就是来引入差异的，因此，使用它来实现分支也十分自然。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun_</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">size_t</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun_</span>&lt;A&gt; &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">size_t</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fun_</span>&lt;B&gt; &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">size_t</span> value = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> h = Fun_&lt;B&gt;::value;</span><br></pre></td></tr></table></figure>
<p>再例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> Fun = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> Fun&lt;A&gt; = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> Fun&lt;B&gt; = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> h = Fun&lt;B&gt;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，在非完全特化的类模板中引入完全特化的代码是非法的，例如：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TW&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Fun_</span> &#123;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">size_t</span> value = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Fun_</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">size_t</span> value = <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>酱紫的代码是不行的，我们可以酱紫修改：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TW&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> TDummy = <span class="type">void</span>&gt;</span><br><span class="line">    <span class="keyword">struct</span> Fun_ &#123;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">size_t</span> value = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> TDummy&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Fun_</span>&lt;<span class="type">int</span>, TDummy&gt; &#123;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">size_t</span> value = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>使用 <code>std::enable_if</code> 与
<code>std::enable_if_t</code> 实现分支</strong></p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> IsFeedbackOut, <span class="keyword">typename</span> T, std::<span class="type">enable_if_t</span>&lt;IsFeedbackOut&gt;* = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">FeedbackOut_</span>(T&amp;&amp;) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> IsFeedbackOut, <span class="keyword">typename</span> T, std::<span class="type">enable_if_t</span>&lt;!IsFeedbackOut&gt;* = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">FeedbackOut_</span>(T&amp;&amp;) &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>FeedbackOut_</code>
为真时，<code>std::enable_if_t&lt;IsFeedbackOut&gt;::type</code>
是有意义的，这使得第一个函数匹配成功；与之对应的，第二个函数匹配是失败的。反之，当
<code>FeedbackOut_</code>
为假时，<code>std::enable_if_t&lt;!IsFeedbackOut&gt;::type</code>
是有意义的，这就使得第二个函数匹配成功，第一个函数匹配失败。</p>
<p><strong>编译期分支与多种返回类型</strong></p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">wrap1</span><span class="params">(<span class="type">bool</span> Check)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Check) &#123;</span><br><span class="line">        (<span class="type">int</span>) <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> (<span class="type">double</span>) <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是编译不过去的，我们可以酱紫做：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> Check, std::<span class="type">enable_if_t</span>&lt;Check&gt;* = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">fun</span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> (<span class="type">int</span>) <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> Check, std::<span class="type">enable_if_t</span>&lt;!Check&gt;* = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">fun</span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> (<span class="type">double</span>) <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> Check&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">wrap2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fun</span>&lt;Check&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="built_in">wrap2</span>&lt;<span class="literal">true</span>&gt;() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用 C++ 17 引入的 <code>if constexpr</code> 来简化代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> Check&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(Check)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> (<span class="type">double</span>) <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cerr &lt;&lt; <span class="built_in">fun</span>&lt;<span class="literal">true</span>&gt;() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行循环的代码</strong></p>
<p>在编译器，我们往往使用递归来实现循环。</p>
<p>例如，给定一个无符号整数，求该整数所对应的二进制中 1 的个数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> Input&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> OnesCount = (Input % <span class="number">2</span>) + OnesCount&lt;Input / <span class="number">2</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> OnesCount&lt;<span class="number">0</span>&gt; = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> res = OnesCount&lt;<span class="number">45</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>下面是处理数组的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">szie_t</span>...Inputs&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> Accumulate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> CurInput, <span class="type">size_t</span>...Inputs&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> Accumulate&lt;CurInput, Inputs...&gt; = CurInput + Accumulate&lt;Inputs...&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> = res = Accumulate&lt;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>或者使用 C++ 17 引入的折叠表达式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> values&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span> + ... + values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> res = <span class="built_in">fun</span>&lt;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="分支选择与短路逻辑">分支选择与短路逻辑</h3>
<p>减少编译器实例化的另外一种主要的技术就是引入短路逻辑，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> is_odd = ((N % <span class="number">2</span>) == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AllOdd_</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> is_cur_odd = is_odd&lt;N&gt;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> is_pre_odd = AllOdd_&lt;N<span class="number">-1</span>&gt;::value;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> value = is_cur_odd &amp;&amp; is_pre_odd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AllOdd_</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> value = is_odd&lt;<span class="number">0</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改进版本如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> cur, <span class="keyword">typename</span> TNext&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> AndValue = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TNext&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> AndValue&lt;<span class="literal">true</span>, TNext&gt; = TNext::value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> is_odd = ((N % <span class="number">2</span>) == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AllOdd_</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> is_cur_odd = is_odd&lt;N&gt;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> value = AndValue&lt;is_cur_odd, AllOdd_&lt;N - <span class="number">1</span>&gt;&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AllOdd_</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> value = is_odd&lt;<span class="number">0</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="奇特的递归模板">奇特的递归模板</h3>
<p>CRTP
是一种派生类的什么方式，其「奇特」之处在于：派生类会将本身作为模板参数传递给其基类，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> D&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;Derived&gt; &#123; <span class="comment">/*...*/</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>CRTP 的典型应用场景是模拟虚函数，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> D&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(<span class="type">const</span> T1&amp; input)</span> </span>&#123;</span><br><span class="line">        D* ptr = <span class="built_in">static_cast</span>&lt;D*&gt;(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">Imp</span>(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> Derive : <span class="keyword">public</span> Base&lt;Derive&gt; &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1&gt; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Imp</span><span class="params">(T1 <span class="type">const</span>&amp; input)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; input &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个代码中，基类 <code>Base&lt;D&gt;</code>
会假定派生类实现类一个接口 <code>Imp</code>，会在其函数 <code>Fun</code>
中调用这个接口。如果采用面向对象的编程方法，我们需要引入虚函数
<code>Imp</code>。但是，<code>Imp</code>
是一个函数模板，无法被声明为虚函数，这里可以借助 <code>CRTP</code>
技术实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> D&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        D::<span class="built_in">Imp</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base&lt;Derive&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Imp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Implementation from derive class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Derive:<span class="built_in">Fun</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>元编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>模板</tag>
        <tag>元编程</tag>
        <tag>元函数</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM 汇编</title>
    <url>/2023/07/24/ARM%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<h2 id="前置知识">前置知识</h2>
<p>计算机的指令集一般可分为 4 种：</p>
<ul>
<li>复杂指令集（CISC）</li>
<li>精简指令集 （ RISC）</li>
<li>显式并行指令集 （ EPIC ）</li>
<li>超长指令字指令集（VLIW）</li>
</ul>
<p>我们在嵌入式学习和工作中需要经常打交道的是 RISC 指令集。RISC
指令集相对于 CISC 指令集，主要有以下特点：</p>
<ul>
<li>Load / Store架构，CPU 不能直接处理内存中的数据，要先将内存中的数据
Load（加载）到寄存器中才能操作，然后将处理结果
Store（存储）到内存中。</li>
<li>固定的指令长度、单周期指令。</li>
<li>倾向于使用更多的寄存器来存储数据，而不是使用内存中的堆栈，效率更高。</li>
</ul>
<p>ARM 指令集虽然属于 RISC，但是和原汁原味的 RISC 相比，还是有一
些差异的，具体如下：</p>
<ul>
<li>ARM 有桶型移位寄存器，单周期内可以完成数据的各种移位操作。</li>
<li><strong>并不是所有的 ARM 指令都是单周期的。</strong></li>
<li>ARM 有 16 位的 Thumb 指令集，是 32 位 ARM
指令集的压缩形式，提高了代码密度。</li>
<li>条件执行：通过指令组合，减少了分支指令数目，提高了代码密度。</li>
<li>增加了 DSP、SIMD / NEON 等指令。</li>
</ul>
<p>ARM 处理器有多种工作模式，如下图所示。应用程序正常运行时，ARM
处理器工作在用户模式（User mode），当程序运行出错或有中断发生时，ARM
处理器就会切换到对应的特权工作模式。用户模式属于普通模式，有些特权指令是运行不了的，需要切换到特权模式下才能运行。在
ARM
处理器中，除了用户模式是普通模式，剩下的几种工作模式都属于特权模式。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/7059623d-ec4c-473f-b6dd-cc592303c1b7"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>在 ARM
处理器内部，除了基本的算术运算单元、逻辑运算单元、浮点运算单元和控制单元，还有一系列寄存器，包括各种通用寄存器、状态寄存器、控制寄存器，用来控制处理器的运行，保存程序运行时的各种状态和临时结果，如下图所示：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/2fbec729-8e2e-477d-9f8b-a5bb2804262f"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>ARM 处理器中的寄存器可分为通用寄存器和专用寄存器两种。寄存器 R0～R12
属于通用寄存器，除了 FIQ
工作模式，在其他工作模式下这些寄存器都是共用、共享的：R0～R3
通常用来传递函数参数，R4～R11
用来保存程序运算的中间结果或函数的局部变量等，R12
常用来作为函数调用过程中的临时寄存器。ARM
处理器有多种工作模式，除了这些在各个模式下通用的寄存器，还有一些寄存器在各自的工作模式下是独立存在的，如
R13、R14、R15、CPSP、SPSR
寄存器，在每个工作模式下都有自己单独的寄存器。R13
寄存器又称为堆栈指针寄存器（Stack
Pointer，SP），用来维护和管理函数调用过程中的栈帧变化，R13
总是指向当前正在运行的函数的栈帧，一般不能再用作其他用途。R14
寄存器又称为链接寄存器（Link
Register，LR），在函数调用过程中主要用来保存上一级函数调用者的返回地址。寄存器
R15 又称为程序计数器（Program Counter，PC），CPU
从内存取指令执行，就是默认从 PC 保存的地址中取的，每取一次指令，PC
寄存器的地址值自动增加。CPU
一条一条不停地取指令，程序也就源源不断地一直运行下去。在 ARM
三级流水线中，PC 指针的值等于当前正在运行的指令地 +8，后续的 32
位处理器虽然流水线的级数不断增加，但为了简化编程，PC
指针的值继续延续了这种计算方式。</p>
<p>当前处理器状态寄存器（Current Processor State
Register，CPSR）主要用来表征当前处理器的运行状态。除了各种状态位、标志位，CPSR
寄存器里也有一些控制位，用来切换处理器的工作模式和中断使能控制。CPSR
寄存器各个标志位、控制位的详细说明下图所示：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/0e3f3e48-8ce0-46aa-9d89-f212df6b883b"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>在每种工作模式下，都有一个单独的程序状态保存寄存器（Saved Processor
State Register，SPSR）。当 ARM 处理器切换工作模式或发生异常时，SPSR
用来保存当前工作模式下的处理器现场，即将 CPSR
寄存器的值保存到当前工作模式下的 SPSR 寄存器。当 ARM
处理器从异常返回时，就可以从 SPSR
寄存器中恢复原先的处理器状态，切换到原来的工作模式继续运行。</p>
<p>在 ARM 所有的工作模式中，有一种工作模式比较特殊，即 FIQ
模式。为了快速响应中断，减少中断现场保护带来的时间开销，在 FIQ
工作模式下，ARM处理器有自己独享的 R8～R12 寄存器。</p>
<h2 id="arm-汇编指令">ARM 汇编指令</h2>
<p>一个完整的 ARM 指令通常由<strong>操作码 +
操作数</strong>组成，指令的编码格式如下：</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line">&lt;opcode&gt; &#123;&lt;<span class="meta">code</span>&gt; &#123;S&#125; &lt;Rd&gt;, &lt;Rn&gt; &#123;, &lt;operand2&gt;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个完整的 ARM
指令需要遵循的格式规则，指令格式的具体说明如下：</p>
<ul>
<li>使用 <code>&lt;&gt;</code> 标起来的是必选项，使用 <code>&#123;&#125;</code>
标起来的是可选项。</li>
<li><code>&lt;opcode&gt;</code> 是二进制机器指令的操作码助记符，如
<code>MOV</code>、<code>ADD</code>
这些汇编指令都是操作码的指令助记符。</li>
<li><code>cond</code>：执行条件，ARM 为减少分支跳转指令个数，允许类似
<code>BEQ</code>、<code>BNE</code> 等形式的组合指令。</li>
<li><code>S</code>：是否影响 CPSR 寄存器中的标志位，如 SUBS 指令会影响
CPSR 寄存器中的 N、Z、C、V 标志位，而 SUB 指令不会。</li>
<li><code>Rd</code>：目标寄存器。</li>
<li><code>Rn</code>：第一个操作数的寄存器。</li>
<li><code>operand2</code>：第二个可选操作数，灵活使用第二个操作数可以提高代码效率。</li>
</ul>
<h3 id="存储访问指令">存储访问指令</h3>
<p>ARM 指令集属于 RISC 指令集，RISC
处理器采用典型的加载/存储体系结构，CPU
无法对内存里的数据直接操作，只能通 Load / Store
指令来实现：当我们需要对内存中的数据进行操作时，要首先将这个数据从内存加载到寄存器，然后在寄存器中对数据进行处理，最后将结果重新存储到内存中。</p>
<p>ARM
处理器属于冯·诺依曼架构，程序和数据都存储在同一存储器上，内存空间和 I/O
空间统一编址，ARM 处理器对程序指令、数据、I/O
空间中外设寄存器的访问都要通过 Load/Store 指令来完成。ARM
处理器中经常使用的 Load/Store 指令的使用方法如下。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/2ff6eaef-147d-4815-b1e5-51014f28cfe5"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>在 ARM 存储访问指令中，我们经常使用的是 LDR/STR、LDM/STM
这两对指令。LDR/STR 指令是 ARM
汇编程序中使用频率最高的一对指令，每一次数据的处理基本上都离不开它们。LDM/STM
指令常用来加载或存储一组寄存器到一片连续的内存，通过和堆栈格式符组合使用，LDM/STM
指令还可以用来模拟堆栈操作。LDM/STM 指令常和下表的堆栈格式组合使用：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/4a6e20a4-2630-4466-9765-6d8660b4d6c3"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>如图3-3所示，在一个堆栈内存结构中，如果堆栈指针 SP
总是指向栈顶元素，那么这个栈就是满栈；如果堆栈指针 SP
指向的是栈顶元素的下一个空闲的存储单元，那么这个栈就是空栈。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/24b7757d-999b-4056-938e-8333a9a4816d"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>每入栈一个元素，栈指针 SP
都会往栈增长的方向移动一个存储单元。如果栈指针 SP
从高地址往低地址移动，那么这个栈就是递减栈；如果栈指针 SP
从低地址往高地址移动，那么这个栈就是递增栈。ARM
处理器使用的一般都是满递减堆栈，在将一组寄存器入栈，或者从栈中弹出一组寄存器时，我们可以使用下面的指令。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/f8a0c6d1-ad66-466f-86e1-9b6b63046408"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>这里需要注意的一个细节是，在入栈和出栈过程中要留意栈中各个元素的入栈出栈顺序。栈的特点是先入后出（First
In Last Out，FILO），栈元素在入栈操作时，STMFD 会根据大括号
<code>&#123;&#125;</code>
中寄存器列表中各个寄存器的顺序，从左往右依次压入堆栈。在上面的例子中，R0
会先入栈，接着 R1、R2 入栈，最后 R14 入栈，入栈操作完成后，栈指针 SP
在内存中的位置如图 3-4
左侧所示。栈元素在出栈操作时，顺序刚好相反，栈中的元素先弹出到 R14
寄存器中，接着是 R2、R1、R0。将栈中的元素依次弹出到 R14、R2
寄存器后，堆栈指针在内存中的位置如图3-4右侧所示。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/4f3d58b9-a7d2-43a9-b930-12d616bd6e69"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>除此之外，ARM 还专门提供了 PUSH 和 POP
指令来执行栈元素的入栈和出栈操作。PUSH 和 POP 指令的使用方法如下：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/44cfc5d7-eb03-41a3-8721-a95305014d7f"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="数据传送指令">数据传送指令</h3>
<p>LDR/STR
指令用来在寄存器和内存之间输送数据。如果我们想要在寄存器之间传送数据，则可以使用
MOV 指令。MOV 指令的格式如下：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/14355230-5433-48e6-927e-deab72902f19"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>其中，<code>&#123;cond&#125;</code> 为条件指令可选项，<code>&#123;S&#125;</code>
用来表示是否影响 CPSR 寄存器的值，如 MOVS 指令就会影响寄存器 CPSR
的值，而 MOV 则不会。</p>
<p>MVN 指令用来将操作数 operand2 按位取反后传送到目标寄存器 Rd。操作数
operand2 可以是一个立即数，也可以是一个寄存器。</p>
<p>MOV 和 MVN 指令的一般使用方法如下：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/6f681bd5-7e86-4a23-842f-c4e142b2b6af"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="算术逻辑运算指令">算术逻辑运算指令</h3>
<p>算术运算指令包括基本的加、减、乘、除，逻辑运算指令包括与、或、非、异或、清除等。指令格式如下。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/79a6eaa2-57c2-491b-ba21-f9490fdd0038"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>算术逻辑运算指令的基本使用方法及说明如下。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/e023cb2e-fa28-44a2-9bbd-9c67e3285d0b"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="操作数operand2-详解">操作数：operand2 详解</h3>
<p>ARM 指令的可选项很多，操作数也很灵活。很多 ARM 指令会使用第 2 个参数
operand2：可以是一个常数，也可以是寄存器+偏移的形式。</p>
<p>操作数 operand2 在汇编程序中经常出现的两种格式如下：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/670567f6-0f40-4adf-85f8-388b78e29cc9"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>第一种格式比较简单，操作数是一个立即数，第二种格式可以直接使用寄存器的值作为操作数。</p>
<p><code>ADD</code>、<code>SUB</code>、<code>AND</code>
指令示例中，第二个操作数要么是一个常数，要么是一个寄存器。在第二种格式中，通过
<code>&#123;，shift&#125;</code>
可选项，我们还可以通过多种移位或循环移位的方式，构建更加灵活的操作数。可选项
<code>&#123;，shift&#125;</code> 可以选择的移位方式如下。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/9ed294d1-cd66-46da-9be7-09329c8228e0"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>可选性指令的使用示例及说明如下：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/e01e4b37-f585-4cff-aa7e-1aae71d5ebf0"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="比较指令">比较指令</h3>
<p>比较指令用来比较两个数的大小，或比较两个数是否相等。比较指令的运算结果会影响
CPSR 寄存器的 N、Z、C、V 标志位，具体的标志、位说明可参考前面的 CPSR
寄存器介绍。</p>
<p>比较指令的格式如下：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/d1a40e26-faa9-441c-a003-6a5d35cf36e6"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>比较指令的使用示例及说明如下：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/33bee05a-a3d9-4a07-afd5-2e1f2756a303"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>比较指令的运行结果 Z=1 时，表示运算结果为零，两个数相等；N=1
表示运算结果为负，N=0 表示运算结果为非负，即运算结果为正或者为零。</p>
<h3 id="条件执行指令">条件执行指令</h3>
<p>为了提高代码密度，减少 ARM 指令的数量，几乎所有的 ARM 指令都可以根据
CPSR 寄存器中的标志位，通过指令组合实现条件执行。如无条件跳转指令
B，我们可以在后面加上条件码组成 BEQ、BNE 组合指令。</p>
<p>BEQ 指令表示两个数比较，结果相等时跳转；BNE
指令则表示结果不相等时跳转。CPSR
寄存器中的标志位根据需要可以任意搭配成不同的条件码，和 ARM
指令一起组合使用。</p>
<p>ARM 指令的条件码如表3-3所示：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/08284c0f-d520-44bc-9aa3-02dfa66f44c8"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>条件执行经常出现在跳转或循环的程序结构中。如下面的汇编程
序，通过循环结构，我们可以实现数据块的搬运功能。我们可以将无条件跳转指令
B 和条件码 NE 组合在一起使用，构成一个循环程序结构。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/f2266b5e-6b35-435a-ad37-7fa42974b0c4"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="跳转指令">跳转指令</h3>
<p>在函数调用的场合，以及循环结构、分支结构的程序中经常会用
到跳转指令。ARM 指令集提供了
<code>B</code>、<code>BL</code>、<code>BX</code>、`BLX``
等跳转指令，每个指令都有各自的用武之地和使用场景。</p>
<p>跳转指令的格式如下：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/3962c140-0876-473d-a460-87be2dc695a6"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h4 id="b-label">B label</h4>
<p>跳转到标号 label 处，B
跳转指令的跳转范围大小为[0，32MB]，可以往前跳，也可以往后跳。无条件跳转指令
B 主要用在循环、分支结构的汇编程序中，使用示例如下：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/c4a44fc3-65d4-4900-b669-f30e6d35a612"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h4 id="bl-label">BL label</h4>
<p>BL 跳转指令表示带链接的跳转。</p>
<p>在跳转之前，BL 指令会先将当前指令的下一条指令地址（即返回地址）保存到
LR 寄存器中，然后跳转到 label 处执行。</p>
<p>BL
指令一般用在函数调用的场合，主函数在跳转到子函数执行之前，会先将返回地址，即当前跳转指令的下一条指令地址保存到
LR 寄存器中；子函数执行结束后，LR 寄存器中的地址被赋值给
PC，处理器就可以返回到原来的主函数中继续运行了。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/32056188-99a5-4044-aa38-df9a7d06a043"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h4 id="bx-rm">BX Rm</h4>
<p>BX 表示带状态切换的跳转。</p>
<p>Rm 寄存器中保存的是跳转地址，要跳转的目标地址处可能是 ARM
指令，也可能是 Thumb 指令。处理器根据 Rm[0] 位决定是切换到 ARM
状态还是切换到 Thumb 状态。</p>
<ul>
<li>0：表示目标地址处是 ARM 指令，在跳转之前要先切换至 ARM 状态。</li>
<li>1：表示目标地址处是 Thumb 指令，在跳转之前要先切换至 Thumb 状态。BLX
指令是 BL 指令和 BX
指令的综合，表示带链接和状态切换的跳转，使用方法和上面相同，不再赘述。</li>
</ul>
<h2 id="arm-寻址方式">ARM 寻址方式</h2>
<p>ARM 属于 RISC 体系架构，一个 ARM
汇编程序中的大部分汇编指令，基本上都和数据传输有关：在内存-寄存器、内存-内存、寄存器-寄存器之间来回传输数据。不同的
ARM
指令又有不同的寻址方式，比较常见的寻址方式有寄存器寻址、立即寻址、寄存器偏移寻址、寄存器间接寻址、基址寻址、多寄存器寻址、相对寻址等。</p>
<h3 id="寄存器寻址">寄存器寻址</h3>
<p>寄存器寻址比较简单，操作数保存在寄存器中，通过寄存器名就可以直接对寄存器中的数据进行读写。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/eb0bf15a-0c26-41bf-a569-73a632ea5a66"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="立即数寻址">立即数寻址</h3>
<p>在立即数寻址中，ARM 指令中的操作数为一个常数。立即数以 ＃ 为前缀，0x
前缀表示该立即数为十六进制，不加前缀默认是十进制。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/84c6864e-7512-4e11-8ab4-aaa9f408dac5"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="寄存器偏移寻址">寄存器偏移寻址</h3>
<p>寄存器偏移寻址可以看作寄存器寻址的一种特例，通过第二个操作数 operand2
的灵活配置，我们可以将第二个操作数做各种左移和右移操作，作为新的操作数使用。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/6d9f7d6d-7229-4461-a85a-448cfe7471c0"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>常见的移位操作有逻辑移位和算术移位，两者的区别是：逻辑移位无论是左移还是右移，空缺位一律补
0；而算术移位则不同，左移时空缺位补 0，右移时空缺位使用符号位填充。</p>
<h3 id="寄存器间接寻址">寄存器间接寻址</h3>
<p>寄存器间接寻址主要用来在内存和寄存器之间传输数据。寄存器中保存的是数据在内存中的存储地址，我们通过这个地址就可以在寄存器和内存之间传输数据。C
语言中的指针操作，在汇编层次其实就是使用寄存器间接寻址实现的。寄存器间接寻址的使用示例及说明如下所示。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/06d0cfd1-8274-4523-9777-b2772ae8ccf9"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="基址寻址">基址寻址</h3>
<p>基址寻址其实也属于寄存器间接寻址。两者的不同之处在于，基址寻址将寄存器中的地址与一个偏移量相加，生成一个新地址，然后基于这个新地址去访问内存。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/d107f147-5f08-46fd-aacc-2f6d1f2bde0c"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>基址寻址一般用在查表、数组访问、函数的栈帧管理等场合。根据偏移量的正负，基址寻址又可以分为向前索引寻址和向后索引寻址，如上面的第
1 条和第 3 条指令，就是向后索引寻址，而第6条指令则为向前索引寻址。</p>
<h3 id="多寄存器寻址">多寄存器寻址</h3>
<p>STM/LDM 指令就属于多寄存器寻址，一次可以传输多个寄存器的值。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/5d43bfe1-a2e3-4017-bbc2-65b23e668453"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>在多寄存器寻址中，用大括号 <code>&#123;&#125;</code>
括起来的是寄存器列表，寄存器之间用逗号隔开，如果是连续的寄存器，还可以使用连接符-连接，如
R0-R3，就表示 R0、R1、R2、R3 这 4 个寄存器。</p>
<p>LDM/STM 指令一般和 IA、IB、DA、DB 组合使用，分别表示 Increase
After、Increase Before、Decrease After、Decrease Before。</p>
<p>LDM/STM 指令也可以和 FD、ED、FA、EA 组合使用，用于堆栈操作。</p>
<p>栈是程序运行过程中非常重要的一段内存空间，栈是 C
语言运行的基础，函数内的局部变量、函数调用过程中要传递的参数、函数的返回值一般都是保存在栈中的。</p>
<p>ARM 没有专门的入栈和出栈指令，ARM 中的栈操作其实就是通过上面所讲的
STM/LDM 指令和栈指针 SP 配合操作完成的。栈一般可以分为以下 4 类：</p>
<ul>
<li>递增栈 A：入栈时，SP 栈指针从低地址往高地址方向增长。</li>
<li>递减栈 D：入栈时，SP 栈指针从高地址往低地址方向增长。</li>
<li>满栈 F：SP 栈指针总是指向栈顶元素。</li>
<li>空栈 E：SP 栈指针总是指向栈顶元素的下一个空闲存储单元。</li>
</ul>
<p>ARM 默认使用满递减堆栈，通过 STMFD/LDMFD
指令配对使用，完成堆栈的入栈和出栈操作。</p>
<p>ARM 中的 PUSH 和 POP 指令其实就是 LDM/STM 的同义词，是 LDMFD 和 STMFD
组合指令的助记符。</p>
<p>PUSH 指令和 POP 指令的使用示例如下：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/1f106995-cf0d-46bf-999a-c5ccd62a135d"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="相对寻址">相对寻址</h3>
<p>相对寻址其实也属于基址寻址，只不过它是基址寻址的一种特殊
情况。特殊在什么地方呢？它是以 PC
指针作为基地址进行寻址的，以指令中的地址差作为偏移，两者相加后得到的就是一个新地址，然后可以对这个地址进行读写操作。</p>
<p>ARM 中的 B、BL、ADR 指令其实都是采用相对寻址的。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/682acaa6-6c3b-40e5-b9c2-4c695eb0f3d2"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>在上面的示例代码中，B LOOP 指令其实就等价于：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/6bb5563d-7e93-4cfa-a329-d08c6b51de46"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>除此之外，很多与位置无关的代码，如动态链接共享库，其在汇编代码层次的实现其实也是采用相对寻址的。程序中使用相对寻址访问的好处是不需要重定位，将代码加载到内存中的任何地址都可以直接运行。</p>
<h2 id="arm-伪指令">ARM 伪指令</h2>
<p>ARM 伪指令并不是 ARM
指令集中定义的标准指令，而是为了编程方便，各家编译器厂商自定义的一些辅助指令。</p>
<p>伪指令有点类似 C 语言中的预处理命令，在程序编译时，这些伪
指令会被翻译为一条或多条 ARM 标准指令。</p>
<p>常见的 ARM 伪指令主要有 4
个：ADR、ADRL、LDR、NOP，它们的使用示例如下：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/4a12f423-5440-4198-a6b1-5b1a9f978f31"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>NOP 伪指令比较简单，其实就相当于 MOV R0，R0。</p>
<p>在以后的学习和工作中，大家在 ARM 汇编程序中经常看到的就是 LDR
伪指令。</p>
<h3 id="ldr-伪指令">LDR 伪指令</h3>
<p>LDR 伪指令通常会让很多朋友感到迷惑，容易和加载指令 LDR 混淆。</p>
<p>LDR 伪指令的主要用途是将一个 32 位的内存地址保存到寄存器中。</p>
<p>在寄存器之间传递数据可以使用 MOV 指令，但是当传递的一个内存地址是 32
位的立即数时，MOV 指令就应付不了了，如下面的第 2 条指令。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/a8d5ce2d-05b6-4136-8cce-a66f082ad0e6"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>当我们往寄存器传递的地址是一个 32 位的常数时，为什么不能使用
MOV，而要使用 LDR 伪指令呢？这还得从 ARM 指令的编码格式说起。</p>
<p>RISC 指令的特点是单周期指令，指令的长度一般都是固定的。在一个 32
位的系统中，一条指令通常是 32
位的，指令中包括操作码和操作数，如图3-5所示：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/8cf1c334-6199-4c1f-be9d-a97b7c49add8"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>指令中的操作码和操作数共享 3
2位的存储空间：一般前面的操作码要占据几个比特位，剩下来的留给操作数的编码空间就小
32 位了。</p>
<p>当编译器遇到 <code>MOV R0，＃0x30008000</code>
这条指令时，因为后面的操作数是 32
位，编译器就无法对这条指令进行编码了。为了解决这个难题，编译器提供了一个
LDR 伪指令来完成上面的功能。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/dbbce217-c541-488c-b905-d2d0e2030e43"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>在上面的示例代码中，LDR 不是普通的 ARM
加载指令，而是一个伪指令。为了与 ARM 指令集中的加载指令 LDR
区别开来，<strong>LDR
伪指令中的操作数前一般会有一个等于号=</strong>，用来表示该指令是个伪指令。</p>
<p>通过 LDR 伪指令，编译器就解决了向一个寄存器传送 32
位的立即数时指令无法编码的难题。</p>
<p>因为伪指令并不是 ARM 指令集中定义的标准指令，所以 CPU
硬件译码电路并不支持直接运行这些伪指令。</p>
<p>在程序编译期间，这些伪指令会被标准的 ARM 指令替代。</p>
<p>编译器在处理伪指令时，根据伪指令中的操作数大小，会使用不同的 ARM
标准指令替代。</p>
<p>如当 LDR 伪指令中的操作数小于 8 位时，LDR 伪指令一般会被 MOV
指令替代。下面的两行汇编指令其实是等价的：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/076072b8-7b10-421c-8d29-9da2ad9c1d0f"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>当 LDR 伪指令中的操作数大于 8 位时，LDR 指令会被编译器转换为
<code>LDR 标准指令+文字池</code> 的形式。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/f6505634-6ec4-41cf-92c7-1906d46ac9fc"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>在上面的示例代码中，当 LDR 伪指令中的操作数为一个 32
位的立即数时，编译器会首先在内存中分配一个 4
字节大小的存储单元，然后将这个 32 位的地址 0x30008000
存放到该存储单元中，该存储单元通常也 叫作文字池（literal pool）。</p>
<p>接着编译器计算出该存储单元到 LDR 伪指令之间的偏移
OFFSET，然后使用寄存器相对寻址，就可以将这个 32 位的立即数送到 R0
寄存器中。偏移量 OFFSET 的大小一般要小于
4KB，所以在分析汇编代码时你会看到，存放这些 32
位地址常量的文字池一般紧挨着当前指令的代码段，直接放置在当前代码段的后面。</p>
<h3 id="adr-伪指令">ADR 伪指令</h3>
<p>ADR 伪指令的功能与 LDR 伪指令类似，将基于 PC
相对偏移的地址值读取到寄存器中。</p>
<p>ADR
为小范围的地址读取伪指令，底层使用相对寻址来实现，因此可以做到代码与位置无关。</p>
<p>ADR 伪指令的使用示例代码如下：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/10a60acb-927d-41fb-85c2-c17e30cf5143"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>在上面的示例代码中，ADR 伪指令的作用是将标号 LOOP
表征的内存地址送到寄存器 R0 中。</p>
<p>编译器在编译 ADR 伪指令时，会首先计算出当前正在执行的 ADR
伪指令地址与标号 LOOP 之间的地址偏移 OFFSET，然后使用 ARM
指令集中的一条标准指令代替之，如使用 ADD 指令将标号表征的地址送到寄存器
R0 中。</p>
<h2 id="arm-汇编程序设计">ARM 汇编程序设计</h2>
<h3 id="arm-汇编程序格式">ARM 汇编程序格式</h3>
<p>ARM 汇编程序是以段（section）为单位进行组织的。</p>
<p>在一个汇编文件中，可以有不同的
section，分为代码段、数据段等，各个段之间相互独立，一个 ARM
汇编程序至少要有一个代码段。</p>
<p>我们可以使用 AREA 伪操作来标识一个段的起始、段名和段的读写属性。</p>
<p>我们使用分号；来注释代码。</p>
<h3 id="符号与标号">符号与标号</h3>
<p>在 ARM
汇编程序中，我们可以使用符号来标识一个地址、变量或数字常量。</p>
<p>当用符号来标识一个地址时，这个符号通常又被称为标号。</p>
<p>符号的命名规则和 C
语言的标识符命名规则一样：由字母、数字和下画线组成，符号的开头不能使用数字，但标号除外。标号比较任性，标号的开头不仅可以是数字，甚至整个标号可以是一个纯数字。</p>
<p>符号的命名在其作用域内必须唯一，不能与系统内部或系统预定义的符号同名，不能与指令助记符、伪指令同名。</p>
<p>有时候我们会直接通过数字 [0，99]
而不是使用字符来进行地址引用，我们称这种数字为局部标号。局部标号的作用域为当前段，在汇编程序中，我们可以使用下面的格式来引用局部标号。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/07151451-7548-407c-8645-5ce2ee7b0321"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>在局部标号的引用格式中，由大括号 <code>&#123;&#125;</code>
括起来的部分是可选项，N 表示局部标号，其余的参数说明如下。</p>
<ul>
<li>%：引用符号，对一个局部标号产生引用。</li>
<li>F：指示编译器只向前搜索。</li>
<li>B：指示编译器只向后搜索。</li>
<li>A：指示编译器搜索宏的所有宏命令层。</li>
<li>T：指示编译器搜索宏的当前层。</li>
<li>N：局部标号的名字。</li>
<li>routename：局部标号作用范围名称，使用 ROUT 定义。</li>
</ul>
<p>若 B、F 没有指定，编译器将默认先向后搜索，然后向前搜索。若 A、T
都没指定，则汇编程序默认搜索从当前层到最顶层的所有宏命令，但不搜索较低层的宏命令。如果在标签中或者对一个标签的引用中指定了
routename，则汇编程序将其与最近的一个前 ROUT
指令的名称进行比较，如果不匹配，则汇编程序会生成一条错误消息，汇编失败。</p>
<p>在汇编代码中，使用局部标号的示例程序如下：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/7b12ddc0-45c4-4f7d-899e-b8bcf8458b8d"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="伪操作">伪操作</h3>
<p>在 C 语言中，为了编程方便，编译器会定义一系列预处理命令，并用 #
来标识，如 #include、#define、#if、#else、#end 等。</p>
<p>在汇编语言中，为了编程方便，汇编器也定义了一些特殊的指令助记符，以方便对汇编程序做各种处理。如使用
AREA 来定义一个段（section），使用 GBLA 来定义一个数据，使用 ENTRY
来指定汇编程序的执行入口等，这些指令助记符统称为伪指令或伪操作。</p>
<p>伪操作一般用在符号定义、数据定义、汇编程序结构控制等场合。在一个汇编程序中经常使用的伪操作如下：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/58ee7a2b-2622-4872-881f-86526cec3feb"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>关于数据定义，常用的伪操作有
DCD、DCB、SPACE、DATA，这些伪操作的使用方法如下所示。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/31f36818-6281-4977-b2bf-b3ccb8fd0b1f"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>除此之外，还有一些其他常用的伪操作，如用来标识程序的入口地址、程序的结束地址、用来定义段的属性等，具体如表3-4所示。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/012659fa-3f6b-4dad-a32b-7a2dd01b8030"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>有了这些伪操作辅助，我们就可以设计出更加灵活、功能更加复杂的程序结构，也可以定义一个个汇编子程序，然后在主程序中分别去调用它们，实现汇编语言的模块化编程。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/131643eb-cbfc-4dcc-a3a1-11a955b3005c"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>SUM_ASM 汇编子程序自身又调用了其他子程序 sum，这个 sum
子程序可以是一个汇编子程序，也可以是一个使用 C
语言定义的函数。在调用之前我们要先使用 IMPORT 伪操作把 sum
子程序导入进来，然后就可以直 接使用 BL
指令跳转过去运行了。只要遵循一些约定的规则，C
程序和汇编程序其实是可以相互调用的，从汇编指令的层面上看，它们之间并无本质的区别。</p>
<h2 id="c-语言和汇编语言混合编程">C 语言和汇编语言混合编程</h2>
<h3 id="atpcs-规则">ATPCS 规则</h3>
<p>ATPCS 的全称是 ARM-Thumb Procedure Call
Standard，其核心内容就是定义了 ARM
子程序调用的基本规则及堆栈的使用约定等。</p>
<p>ATPCS
最重要的内容是定义了子程序调用的具体规则，无论是程序员编写程序，还是编译器开发商开发编译器工具，一般都要遵守它。规则的主要内容如下：</p>
<ul>
<li>子程序间要通过寄存器 R0～R3（可记作a0～a3）传递参数，当参数个数大于
4 时，剩余的参数使用堆栈来传递。</li>
<li>子程序通过 R0～R1 返回结果。</li>
<li>子程序中使用 R4～R11（可记作 v1～v8）来保存局部变量。</li>
<li>R12 作为调用过程中的临时寄存器，一般用来保存函数的栈帧基址，记作
FP。</li>
<li>R13 作为堆栈指针寄存器，一般记作 SP。</li>
<li>R14 作为链接寄存器，用来保存函数调用者的返回地址，记作 LR。</li>
<li>R15 作为程序计数器，总是指向当前正在运行的指令，记作 PC。</li>
</ul>
<h3 id="在-c-程序中内嵌汇编代码">在 C 程序中内嵌汇编代码</h3>
<p>为了能在 C 程序中内嵌汇编代码，ARM 编译器在 ANSI C
标准的基础上扩展了一个关键字
<code>__asm</code>。通过这个关键字，我们就可以在 C 程序中内嵌 ARM
汇编代码。</p>
<p>在 C 程序中内嵌汇编代码的格式如下：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/8f570a61-88e5-4952-b79c-d82214b14038"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="在汇编程序中调用-c-程序">在汇编程序中调用 C 程序</h3>
<p>在 C 程序中可以内嵌汇编代码，在汇编程序中同样也可以调用 C 程序。</p>
<p>在调用的时候，我们要注意根据 ATPCS 规则来完成参数的传递，并配置好 C
程序传递参数和保存局部变量所依赖的堆栈环境，然后使用 BL
指令直接跳转即可。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/02259172-1ab3-47b0-978a-15adc003ba33"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="gnu-arm-汇编语言">GNU ARM 汇编语言</h2>
<p>在 ARM
平台下从事嵌入式软件开发，大家会遇到各种不同的集成开发环境和编译器，如
IAR、ADS1.2、RVDS、Keil MDK、RealView MDK、ARM 交叉编译器 arm-linux-gcc
等。</p>
<p>如果将这些不同的 IDE 归类，一般可以分为两大类：一类 IDE 内部集成了
ARM 编译器，另一类则使用开源的 GNU GCC for ARM
编译器，为了方便，在后续的文字中我们就简称为 GNU ARM 编译器。</p>
<p>一套完整的编译工具集主要包括以下几部分：</p>
<ul>
<li>编译器：用来将 C 源文件编译成汇编文件。</li>
<li>汇编器：用来将汇编文件汇编成目标文件。</li>
<li>链接器：用来将目标文件组装成可执行文件。</li>
<li>二进制转化工具：objdump、objcopy、strip 等。</li>
<li>库打包工具：ar.</li>
<li>调试工具：gdb、nm.</li>
<li>库/头文件：根据 C 语言标准定义的 API 实现的 C
标准库及对应的头文件。</li>
</ul>
<h3 id="gnu-arm-编译器的伪操作">GNU ARM 编译器的伪操作</h3>
<p>不同的 ARM 编译器之间的伪操作差别还是蛮大的。以 ARM 编译器和 GNU ARM
编译器为例，我们可以对比一下它们在数据定义、程序结构方面的差别，如表3-5所示。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/a7aa4969-e9d8-4f5e-a3ae-6fa5a4e59eb1"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>在后面的内容中，我们会经常使用 ARM 反汇编代码来分析 C
语言的底层运行机制。为了能看懂反汇编代码，我们还需要熟悉一下在一个反汇编文件中经常看到的各种
GNU ARM 伪指令操作，如表3-6所示：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/aba59382-95c7-4fc0-954f-0fe6d326265d"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="gnu-arm-汇编语言中的标号">GNU ARM 汇编语言中的标号</h3>
<p>汇编语言中的符号定义规则，和 C
语言中标识符的定义规则类似：由字母、数字和下画线构成。</p>
<p>GNU ARM
编译器除了遵循标识符的一般规则，还有一些特殊的地方需要注意：GNU ARM
汇编语言中的标识符可以由字母、数字、下画线和“.”构成，局部标号可以由纯数字构成。</p>
<p>GNU 格式的局部标号由数字 N 组成，在引用时使用 Nf 或 Nb
的形式，分别表示向前搜索或向后搜索。除此之外，GNU ARM 汇编语言使用标号
<code>_start</code>
作为汇编程序的入口，如果你希望该标号被其他文件引用，只要在定义的地方使用
<code>.global</code> 伪操作声明一下就可以了。</p>
<h3 id="section-伪操作">section 伪操作</h3>
<p>在 GNU ARM 汇编语言中，用户可以使用 <code>.section</code>
伪操作自定义一个段，使用格式如下。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/3ac36ade-80c3-40a7-90d2-6e3c46fbdb33"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>在使用伪操作 <code>.section</code>
定义一个段时，每个段以段名开始，以下一个段名或文件结尾作为结束标记。</p>
<p>在定义段名时，注意不要和系统预留的段名冲突，如
<code>.text</code>、<code>.data</code>、<code>.bss</code>、<code>.rodata</code>
都是编译器系统预留的段名，分别表示代码段、数据段、BSS
段、只读数据段。我们可以通过readelf命令来查看系统预留的段名。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/e183e122-8678-49f8-8b72-a028d05dea23"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="基本数据格式">基本数据格式</h3>
<p>二进制数据通常以 0B 或 0b 开头，八进制数据以 0 开头，十六进制数据以
0x 开头，十进制数据则以非 0 数字开头。负数前面加 “-”，取补
用“～”，不相等用“&lt;&gt;”，其他运算符号如
+、-、*、%、&lt;、&lt;&lt;、&gt;、&gt;&gt;、|、&amp;、^、！、==、&gt;=、&amp;&amp;
与 C 语言语法相似。</p>
<p>字符串常量要用双引号 <code>""</code> 括起来。使用 <code>.ascii</code>
定义字符串时要自行在结尾加 <code>'\0'</code>，<code>.string</code>
伪操作可以定义多个字符串，使用 <code>.asciz</code> 伪操作可以定义一个以
<code>NULL</code> 字符结尾的字符串，使用 <code>.rept</code>
伪操作可以重复定义数据。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/2eeeef5f-5a09-42ea-aa04-19ef4adbc8c9"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="数据定义">数据定义</h3>
<p>在 GNU ARM
汇编程序中，如果我们想定义一个浮点数，那么可以使用下面的伪操作来定义：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/5043e05e-22cd-46bd-9437-2260e8eb59c7"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>我们可以使用 <code>.float</code> 伪操作定义一个浮点数
f，并初始化为3.14。如果你想将这个浮点数重新赋值为3.1415，则可以通过
<code>.equ</code> 伪操作来完成。</p>
<p><code>.equ</code>
伪操作除了给数据赋值，还可以把常量定义在代码段中，然后在代码中直接引用。这一点有点类似
C 语言中的 <code>#define</code> 宏定义。</p>
<figure>
<img data-src="/image/illustrations/0ba8b357a0694ce59173d2d7dcd455b3.jpg"
alt="alt text" />
<figcaption aria-hidden="true">alt text</figcaption>
</figure>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><span
class="math inline">\(\displaystyle \int k \mathrm{d} x = kx +
C\)</span></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(\displaystyle \int x^{\alpha} \mathrm{d}
x=\frac{x^{\alpha+1}}{\alpha+1}+C(\alpha \neq -1)\)</span></td>
<td><span class="math inline">\(\displaystyle \int \frac{\mathrm{d}
x}{x} = \ln \lvert x \rvert + C\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(\displaystyle\int \frac{\mathrm{d} x}{1 + x^{2}} =
\arctan x + C\)</span></td>
<td><span class="math inline">\(\displaystyle\int \frac{\mathrm{d}
x}{\sqrt{1 - x^{2}}} = \arcsin x + C\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(\displaystyle\int \cos x \mathrm{d} x = \sin x
+C\)</span></td>
<td><span class="math inline">\(\displaystyle\int \sin x \mathrm{d} x =
-\cos x + C\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(\displaystyle\int \frac{\mathrm{d} x}{\cos^{2} x}
= \int {\sec}^{2} x \mathrm{d} x = \tan x + C\)</span></td>
<td><span class="math inline">\(\displaystyle\int \frac{\mathrm{d}
x}{\sin^{2} x} = \int {\csc}^{2} \mathrm{d} x = -\cot x +
C\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(\displaystyle\int \sec x \tan x \mathrm{d} x =
\sec x + C\)</span></td>
<td><span class="math inline">\(\displaystyle\int \csc x \cot x
\mathrm{d} x = -\csc x + C\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(\displaystyle\int \mathrm{e}^{x} \mathrm{d} x =
\mathrm{e}^{x} + C\)</span></td>
<td><span class="math inline">\(\displaystyle\int a^{x} = \frac{a^x}{\ln
a} + C\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(\displaystyle\int \mathrm{sh} x \mathrm{d} x =
\int \mathrm{ch} x + C\)</span></td>
<td><span class="math inline">\(\displaystyle\int \mathrm{ch} x
\mathrm{d} x = \mathrm{sh} x + C\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(\displaystyle\int\tan x \mathrm{d} x = -\lvert
\cos x \rvert + C\)</span></td>
<td><span class="math inline">\(\displaystyle\int \cot x \mathrm{d} x =
\ln \lvert \sin x \rvert + C\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(\displaystyle\int \sec x \mathrm{d} x = \ln \lvert
\sec x + \tan x \rvert + C\)</span></td>
<td><span class="math inline">\(\displaystyle\int \csc \mathrm{d} x =
\ln \lvert \csc x - \cot x \rvert + C\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><span
class="math inline">\(\displaystyle\int \frac{\mathrm{d} x}{a^{2} +
x^{2}} = \frac{1}{a} \arctan \frac{x}{a} + C\)</span></td>
<td><span class="math inline">\(\displaystyle\int \frac{\mathrm{d}
x}{a^{2} - x^{2}} = \arcsin \frac{x}{a} + C\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span
class="math inline">\(\displaystyle\int \frac{\mathrm{d} x}{\sqrt{x^2 +
a^2}} = \ln{(x + \sqrt{x^{2} + a^{2}})} + C\)</span></td>
<td><span class="math inline">\(\displaystyle\int \frac{\mathrm{d}
x}{\sqrt{x^{2}-a^{2}}} = \ln \lvert x+ \sqrt{x^{2}-a^{2}} \rvert +
C\)</span></td>
</tr>
</tbody>
</table>
<img data-src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSIyODlweCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ibm9uZSIgc3R5bGU9IndpZHRoOjUxM3B4O2hlaWdodDoyODlweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA1MTMgMjg5IiB3aWR0aD0iNTEzcHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48IS0tZW50aXR5IEFkbWluLS0+PGcgaWQ9ImVsZW1fQWRtaW4iPjxlbGxpcHNlIGN4PSIyODIuOTU3NyIgY3k9IjE0IiBmaWxsPSIjRjFGMUYxIiByeD0iOCIgcnk9IjgiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjxwYXRoIGQ9Ik0yODIuOTU3NywyMiBMMjgyLjk1NzcsNDkgTTI2OS45NTc3LDMwIEwyOTUuOTU3NywzMCBNMjgyLjk1NzcsNDkgTDI2OS45NTc3LDY0IE0yODIuOTU3Nyw0OSBMMjk1Ljk1NzcsNjQgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI4Mi43MzU0IiB4PSIyNDEuNTkiIHk9Ijc4LjQ5NTEiPk1haW4gQWRtaW48L3RleHQ+PC9nPjxnIGlkPSJlbGVtX1VzZSI+PGVsbGlwc2UgY3g9IjE0NS45NTg3IiBjeT0iMjYyLjE5OTciIGZpbGw9IiNGMUYxRjEiIHJ4PSI4Ny4xNDg3IiByeT0iMTkuODI5NyIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTM1LjI1NTkiIHg9Ijc4LjMzMDciIHk9IjI2NS4wNDY0Ij5Vc2UgdGhlIGFwcGxpY2F0aW9uPC90ZXh0PjwvZz48IS0tZW50aXR5IFVzZXItLT48ZyBpZD0iZWxlbV9Vc2VyIj48ZWxsaXBzZSBjeD0iMjEuOTU1MSIgY3k9IjE0IiBmaWxsPSIjRjFGMUYxIiByeD0iOCIgcnk9IjgiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjxwYXRoIGQ9Ik0yMS45NTUxLDIyIEwyMS45NTUxLDQ5IE04Ljk1NTEsMzAgTDM0Ljk1NTEsMzAgTTIxLjk1NTEsNDkgTDguOTU1MSw2NCBNMjEuOTU1MSw0OSBMMzQuOTU1MSw2NCAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjMxLjkxMDIiIHg9IjYiIHk9Ijc4LjQ5NTEiPlVzZXI8L3RleHQ+PC9nPjxnIGlkPSJlbGVtX1N0YXJ0Ij48ZWxsaXBzZSBjeD0iMTIwLjk1NTUiIGN5PSI0My42NTMyIiBmaWxsPSIjRjFGMUYxIiByeD0iMzUuNjk1NSIgcnk9IjE0LjUzMzIiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjM0LjIwMDIiIHg9IjEwMi45MTU5IiB5PSI0Ni44MzEyIj5TdGFydDwvdGV4dD48L2c+PGcgaWQ9ImVsZW1fR01OOSI+PHBhdGggZD0iTTM1OS41MiwzMS4wOCBMMzU5LjUyLDM5LjY1IEwzMjQuNTYsNDMuNjUgTDM1OS41Miw0Ny42NSBMMzU5LjUyLDU2LjIxMjggQTAsMCAwIDAgMCAzNTkuNTIsNTYuMjEyOCBMNTA2LjM4NzcsNTYuMjEyOCBBMCwwIDAgMCAwIDUwNi4zODc3LDU2LjIxMjggTDUwNi4zODc3LDQxLjA4IEw0OTYuMzg3NywzMS4wOCBMMzU5LjUyLDMxLjA4IEEwLDAgMCAwIDAgMzU5LjUyLDMxLjA4ICIgZmlsbD0iI0ZFRkZERCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7Ii8+PHBhdGggZD0iTTQ5Ni4zODc3LDMxLjA4IEw0OTYuMzg3Nyw0MS4wOCBMNTA2LjM4NzcsNDEuMDggTDQ5Ni4zODc3LDMxLjA4ICIgZmlsbD0iI0ZFRkZERCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTI1Ljg2NzciIHg9IjM2NS41MiIgeT0iNDguMTQ2OSI+VGhpcyBpcyBhbiBleGFtcGxlLjwvdGV4dD48L2c+PGcgaWQ9ImVsZW1fR01OMTIiPjxwYXRoIGQ9Ik0yNjguMjMsMjQyLjA2IEwyNjguMjMsMjU4LjIgTDIzMy40OCwyNjIuMiBMMjY4LjIzLDI2Ni4yIEwyNjguMjMsMjgyLjMyNTYgQTAsMCAwIDAgMCAyNjguMjMsMjgyLjMyNTYgTDQxMS42ODksMjgyLjMyNTYgQTAsMCAwIDAgMCA0MTEuNjg5LDI4Mi4zMjU2IEw0MTEuNjg5LDI1Mi4wNiBMNDAxLjY4OSwyNDIuMDYgTDI2OC4yMywyNDIuMDYgQTAsMCAwIDAgMCAyNjguMjMsMjQyLjA2ICIgZmlsbD0iI0ZFRkZERCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7Ii8+PHBhdGggZD0iTTQwMS42ODksMjQyLjA2IEw0MDEuNjg5LDI1Mi4wNiBMNDExLjY4OSwyNTIuMDYgTDQwMS42ODksMjQyLjA2ICIgZmlsbD0iI0ZFRkZERCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTAwLjIzNTgiIHg9IjI3NC4yMyIgeT0iMjU5LjEyNjkiPkEgbm90ZSBjYW4gYWxzbzwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMjIuNDU5IiB4PSIyNzQuMjMiIHk9IjI3NC4yNTk3Ij5iZSBvbiBzZXZlcmFsIGxpbmVzPC90ZXh0PjwvZz48ZyBpZD0iZWxlbV9OMiI+PHBhdGggZD0iTTYyLjEsMTQxLjggTDYyLjEsMTgyLjA2NTYgTDIyOS44MDcsMTgyLjA2NTYgTDIyOS44MDcsMTUxLjggTDIxOS44MDcsMTQxLjggTDYyLjEsMTQxLjggIiBmaWxsPSIjRkVGRkREIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiLz48cGF0aCBkPSJNMjE5LjgwNywxNDEuOCBMMjE5LjgwNywxNTEuOCBMMjI5LjgwNywxNTEuOCBMMjE5LjgwNywxNDEuOCAiIGZpbGw9IiNGRUZGREQiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE0Ni43MDciIHg9IjY4LjEiIHk9IjE1OC44NjY5Ij5UaGlzIG5vdGUgaXMgY29ubmVjdGVkPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjExOS42NjYiIHg9IjY4LjEiIHk9IjE3My45OTk3Ij50byBzZXZlcmFsIG9iamVjdHMuPC90ZXh0PjwvZz48IS0tbGluayBVc2VyIHRvIFN0YXJ0LS0+PGcgaWQ9ImxpbmtfVXNlcl9TdGFydCI+PHBhdGggZD0iTTM4LjIsNDMuNjUgQzUzLjgyLDQzLjY1IDYzLjQ1LDQzLjY1IDc5LjA3LDQzLjY1ICIgZmlsbD0ibm9uZSIgaWQ9IlVzZXItdG8tU3RhcnQiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwb2x5Z29uIGZpbGw9IiMxODE4MTgiIHBvaW50cz0iODUuMDcsNDMuNjUsNzYuMDcsMzkuNjUsODAuMDcsNDMuNjUsNzYuMDcsNDcuNjUsODUuMDcsNDMuNjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjwvZz48IS0tbGluayBVc2VyIHRvIFVzZS0tPjxnIGlkPSJsaW5rX1VzZXJfVXNlIj48cGF0aCBkPSJNMjEuMDYsODIuMTQgQzIxLjk3LDExMS4yOCAyNi45MiwxNTEuNyA0NC45NiwxODIuMDYgQzYwLjg4LDIwOC44OCA4NC40NTYsMjI2Ljk0MTQgMTA3LjIwNiwyNDAuNjAxNCAiIGZpbGw9Im5vbmUiIGlkPSJVc2VyLXRvLVVzZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBvbHlnb24gZmlsbD0iIzE4MTgxOCIgcG9pbnRzPSIxMTIuMzUsMjQzLjY5LDEwNi42OTMyLDIzNS42Mjc3LDEwOC4wNjM0LDI0MS4xMTYxLDEwMi41NzUsMjQyLjQ4NjQsMTEyLjM1LDI0My42OSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PC9nPjwhLS1saW5rIEFkbWluIHRvIFVzZS0tPjxnIGlkPSJsaW5rX0FkbWluX1VzZSI+PHBhdGggZD0iTTI3OS42OCw4Mi4yOSBDMjc1LjY1LDExMS41MSAyNjYuNzIsMTUxLjk3IDI0Ni45NiwxODIuMDYgQzIyOS43MSwyMDguMzIgMjA1LjkyNTcsMjI2LjUwODQgMTgzLjQ1NTcsMjQwLjM3ODQgIiBmaWxsPSJub25lIiBpZD0iQWRtaW4tdG8tVXNlIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cG9seWdvbiBmaWxsPSIjMTgxODE4IiBwb2ludHM9IjE3OC4zNSwyNDMuNTMsMTg4LjEwOTUsMjQyLjIwNjQsMTgyLjYwNDcsMjQwLjkwMzcsMTgzLjkwNzQsMjM1LjM5ODksMTc4LjM1LDI0My41MyIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PC9nPjwhLS1saW5rIFN0YXJ0IHRvIE4yLS0+PGcgaWQ9ImxpbmtfU3RhcnRfTjIiPjxwYXRoIGQ9Ik0xMjMuOTIsNTguNDUgQzEyOC4zNCw3OS4wMiAxMzYuNjksMTE3Ljg0IDE0MS43NCwxNDEuMzQgIiBmaWxsPSJub25lIiBpZD0iU3RhcnQtTjIiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wO3N0cm9rZS1kYXNoYXJyYXk6Ny4wLDcuMDsiLz48L2c+PCEtLWxpbmsgTjIgdG8gVXNlLS0+PGcgaWQ9ImxpbmtfTjJfVXNlIj48cGF0aCBkPSJNMTQ1Ljk2LDE4Mi4zNSBDMTQ1Ljk2LDE5OS42OCAxNDUuOTYsMjI0LjkzIDE0NS45NiwyNDIuMTYgIiBmaWxsPSJub25lIiBpZD0iTjItVXNlIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDtzdHJva2UtZGFzaGFycmF5OjcuMCw3LjA7Ii8+PC9nPjwhLS1TUkM9W05PeW4zaThtMzROdGRFQWhLcGxHZU1DN2YxdzBCaTM2dWhRNjFnTEViS0k4dXZFYTVLWDhLVkJ6XzZ0N3hPY3FlOWlNQkl0OFJxZ0xMeXk4Q3VGTXJVWUhXaFBJZk5IQUw0aDVzLTVtSDdhRXY0QXJubWJpLVRtYldYeUg2blhFRi1PMFV6LWNlQ0xiclh4bmE4M1ZqQW82d3RfaExXenFvN29DTFpCVUhaOG1oQzNwWW5xUDYydGk1U2tLVk5rTjhXXzhDaHdaNVU0bnk3SUpPQi01VGRYNndFaVl4VFN0UWp5OVRQc1lsYWFZVi04M10tLT48L2c+PC9zdmc+'>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>OOP</title>
    <url>/2023/07/16/OOP/</url>
    <content><![CDATA[<h2 id="类和对象">类和对象</h2>
<p>OOP 的三大特性：封装、继承、多态。</p>
<p><code>struct</code> 和 <code>class</code> 区别：</p>
<p>在 C++ 中 <code>struct</code> 和 <code>class</code>
唯一的区别就在于：默认的访问权限不同，<code>struct</code>
默认权限为公共，<code>class</code> 默认权限为私有。</p>
<p>相较于 C 中的 <code>struct</code>，C++ 中的 <code>struct</code> 和
<code>class</code> 都可以定义自己的成员函数。</p>
<p><strong>C++ 中的成员权限和继承：</strong></p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 25%" />
<col style="width: 28%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">继承方式</th>
<th style="text-align: center;">基类的 <code>public</code> 成员</th>
<th style="text-align: center;">基类的 <code>protected</code> 成员</th>
<th style="text-align: center;">基类的 <code>private</code> 成员</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>public</code> 继承</td>
<td style="text-align: center;">仍为 <code>public</code> 成员</td>
<td style="text-align: center;">仍为 <code>protected</code> 成员</td>
<td style="text-align: center;">不可见</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>protected</code> 继承</td>
<td style="text-align: center;">变为 <code>protected</code> 成员</td>
<td style="text-align: center;">变为 <code>protected</code> 成员</td>
<td style="text-align: center;">不可见</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>private</code> 继承</td>
<td style="text-align: center;">变为 <code>private</code> 成员</td>
<td style="text-align: center;">变为 <code>private</code> 成员</td>
<td style="text-align: center;">不可见</td>
</tr>
</tbody>
</table>
<h2 id="对象的初始化和清理">对象的初始化和清理</h2>
<h3 id="构造函数和析构函数">构造函数和析构函数</h3>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造函数和析构函数，编译器会提供</strong>。编译器提供的构造函数和析构函数是空实现。</p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li>
</ul>
<p>构造函数语法：<code>类名() &#123;&#125;</code></p>
<ol type="1">
<li>构造函数，没有返回值也不写 <code>void</code></li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p>析构函数语法：<code>~类名() &#123;&#125;</code></p>
<ol type="1">
<li>析构函数，没有返回值也不写 <code>void</code></li>
<li>函数名称与类名相同，在名称前加上符号 <code>~</code></li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
</ol>
<h3 id="构造函数的分类及调用">构造函数的分类及调用</h3>
<p><strong>两种分类方式：</strong></p>
<ul>
<li><p>按参数分为： 有参构造和无参构造</p></li>
<li><p>按类型分为： 普通构造和拷贝构造</p></li>
</ul>
<blockquote>
<p>注意：</p>
<ol type="1">
<li>如果不提供任何函数，编译器会提供至少 4
个函数：默认构造函数、拷贝构造函数、析构函数、<code>operator=()</code>.</li>
<li>如果自定义了一个构造函数，编译器不在提供默认构造函数。</li>
<li>如果自定义了一个拷贝构造函数，编译器不在提供默认的拷贝构造函数。</li>
<li>默认的拷贝构造函数是浅拷贝。</li>
</ol>
</blockquote>
<p><strong>三种调用方式：</strong></p>
<ul>
<li>括号法</li>
<li>显示法</li>
<li>隐式转换法</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123; cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">        age = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p) &#123;</span><br><span class="line">        age = p.age;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123; cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用无参构造函数</span></span><br><span class="line">    Person p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 括号法，常用</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line">    <span class="comment">// Person p2();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式法</span></span><br><span class="line">    Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>);</span><br><span class="line">    Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Person(10)单独写是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐式转换法</span></span><br><span class="line">    Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10);</span></span><br><span class="line">    Person p5 = p4; <span class="comment">// Person p5 = Person(p4);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line">    <span class="comment">// Person p5(p4);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/a01c48d7-61f0-4343-a6ff-f8a637c4d55d"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="拷贝构造函数调用时机">拷贝构造函数调用时机</h3>
<p>C++ 中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象。</li>
<li>值传递的方式给函数参数传值。</li>
<li>以值方式返回局部对象。</li>
</ul>
<blockquote>
<p>即：旧对象初始化新对象。</p>
<p>以值传递返回局部对象在 GCC 中会有优化，可能看到不同的结果。</p>
</blockquote>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        mAge = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        mAge = p.mAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123; cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>;</span><br><span class="line">    Person newman2 = man;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Person newman3;</span></span><br><span class="line">    <span class="comment">// newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    <span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">    cout &lt;&lt; (<span class="type">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/6291335b-6b3b-4eaa-b1be-e8a95717e6d5"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="c-默认增加的函数">C++ 默认增加的函数</h3>
<p>默认情况下，C++ 编译器至少给一个类添加 3 个函数：</p>
<p>1．默认构造函数 2．默认析构函数
3．默认拷贝构造函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下：</p>
<ul>
<li>如果用户定义有参构造函数，C++
不在提供默认无参构造，但是会提供默认拷贝构造。</li>
<li>如果用户定义拷贝构造函数，C++ 不会再提供其他构造函数。</li>
</ul>
<h3 id="深拷贝与浅拷贝">深拷贝与浅拷贝</h3>
<p>浅拷贝：简单的赋值拷贝操作。</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123; cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age, <span class="type">int</span> height) &#123;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        m_age = age;</span><br><span class="line">        m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person &amp;p) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_age = p.m_age;</span><br><span class="line">        m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (m_height != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="type">int</span> *m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/24dbcb6b-8bf2-4091-b3c2-7ad1a254a7b3"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<blockquote>
<p>如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题。</p>
</blockquote>
<h3 id="初始化列表">初始化列表</h3>
<p><strong>语法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">构造函数(): 属性<span class="number">1</span>(值<span class="number">1</span>),属性<span class="number">2</span>(值<span class="number">2</span>)...&#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ol type="1">
<li>初始化列表是先声明，在调用构造函数时定义并初始化，定义初始化的顺序和声明的顺序一致。</li>
<li>普通的构造函数是先定义，在赋值。</li>
</ol>
</blockquote>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) : <span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/04c95237-ea87-4a09-a521-71b63a5527c5"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="类对象作为类成员">类对象作为类成员</h3>
<blockquote>
<ul>
<li>类中有多个对象时，构造的顺序是先构造里面的对象，再构造外面的对象。</li>
<li>类中有多个对象时，析构时顺序是先析构外面的对象，再析构里面的对象。</li>
</ul>
</blockquote>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Phone</span>(string name) &#123;</span><br><span class="line">        m_PhoneName = name;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Phone</span>() &#123; cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    string m_PhoneName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, string pName) : <span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>() &#123; cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string m_Name;</span><br><span class="line">    Phone m_Phone;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/885cb689-998e-4a26-9819-f934feeb7f43"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="静态成员">静态成员</h3>
<p>静态成员就是在成员变量和成员函数前加上关键字 <code>static</code>.</p>
<p>静态成员分为：</p>
<ul>
<li>静态成员变量
<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul></li>
<li>静态成员函数
<ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul></li>
</ul>
<p><strong>示例 1</strong>：静态成员变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、通过对象</span></span><br><span class="line">    Person p1;</span><br><span class="line">    p1.m_A = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Person p2;</span><br><span class="line">    p2.m_A = <span class="number">200</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="comment">// 共享同一份数据</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、通过类名</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/9c1bb88d-dc1b-4ab3-849f-dd2194512563"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p><strong>示例 2</strong>：静态成员函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 静态成员函数特点：</span></span><br><span class="line">    <span class="comment">// 1 程序共享一个函数</span></span><br><span class="line">    <span class="comment">// 2 静态成员函数只能访问静态成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">// 静态成员变量</span></span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 静态成员函数也是有访问权限的</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、通过对象</span></span><br><span class="line">    Person p1;</span><br><span class="line">    p1.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、通过类名</span></span><br><span class="line">    Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Person::func2(); //私有权限访问不到</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/e55aee64-5cfc-4e38-9f26-20a53bfbb223"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="explicit"><code>explicit</code></h3>
<p><code>explicit</code> 修饰的构造函数不能在隐式转换中使用。</p>
<h2 id="c对象模型">C++对象模型</h2>
<h3 id="动态对象创建">动态对象创建</h3>
<p>使用 <code>malloc</code> 和 <code>free</code>
函数去动态申请对象和释放申请的对象，不会调用构造函数和析构函数。</p>
<p>在 C++ 中建议使用 <code>new</code> 运算符和 <code>delete</code>
运算符进行动态对象的申请和释放。</p>
<p>语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">类型 *p = <span class="keyword">new</span> 构造器;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line">类型 *p = <span class="keyword">new</span> 类型[size];</span><br><span class="line"><span class="keyword">delete</span> []p;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不要 <code>delete</code> 万能指针（<code>void *</code>）</p>
</blockquote>
<h3 id="const-修饰的静态成员变量"><code>const</code>
修饰的静态成员变量</h3>
<ul>
<li><code>const</code>
修饰的静态成员变量保存在常量区，只读的，在内存中只有一份</li>
<li><code>const</code> 修饰的静态成员变量可以在类内定义且初始化</li>
<li><code>const</code> 修饰的静态成员变量可以通过类的作用域访问</li>
<li><code>const</code> 修饰的静态成员变量可以通过对象访问</li>
<li>静态成员函数可以访问 <code>const</code> 修饰的静态成员变量</li>
</ul>
<h3 id="成员变量和成员函数分开存储">成员变量和成员函数分开存储</h3>
<ul>
<li>普通成员变量占用对象空间大小</li>
<li>静态成员变量不占用对象空间大小</li>
<li>普通成员函数不占用对象空间大小</li>
<li>静态成员函数不占用对象空间大小</li>
</ul>
<blockquote>
<p>在 C++
中，类内的成员变量和成员函数分开存储，只有非静态成员变量才属于类的对象上</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123; mA = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mA;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> mB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/aadab981-0981-487a-88b1-340ec574b261"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<blockquote>
<p>一个对象至少占 1 个字节，要不然获取不到其地址。</p>
</blockquote>
<h3 id="this-指针"><code>this</code> 指针</h3>
<p><code>this</code> 指针是一个指向对象自己的指针。</p>
<h3 id="空指针访问成员函数">空指针访问成员函数</h3>
<p>C++ 中空指针也是可以调用成员函数的，但是也要注意有没有用到
<code>this</code> 指针。</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Person *p = <span class="literal">nullptr</span>;</span><br><span class="line">    p-&gt;<span class="built_in">ShowClassName</span>();</span><br><span class="line">    p-&gt;<span class="built_in">ShowPerson</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/abd55810-bb6d-489d-a4bd-624fc10a4f19"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="const-修饰成员函数"><code>const</code> 修饰成员函数</h3>
<ul>
<li>在函数后面加上 <code>const</code>，这个是一个常函数</li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字 <code>mutable</code>
后，在常函数中依然可以修改</li>
</ul>
<blockquote>
<p>上述规则对于非成员函数和成员变量也适用。</p>
</blockquote>
<h2 id="友元">友元</h2>
<p>友元可以让一个函数、类或者一个类的成员函数访问另外一个类的私有成员。</p>
<p>有 3 种友元：</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h3 id="全局函数做友元">全局函数做友元</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building *building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building *building)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问：&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Building b;</span><br><span class="line">    <span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/0fda622a-9f93-4072-8152-18f3e277150a"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="类做友元">类做友元</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">goodGay</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>() &#123; building = <span class="keyword">new</span> Building; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问：&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    goodGay gg;</span><br><span class="line">    gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/93e20484-9d59-4566-9c63-30e4e770c3a9"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="成员函数做友元">成员函数做友元</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">goodGay</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>() &#123; building = <span class="keyword">new</span> Building; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    goodGay gg;</span><br><span class="line">    gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/55166aa2-fa3e-4ba6-b7c2-372e51a1e577"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="继承">继承</h2>
<p>通过继承机制可以利用已有的数据类型来定义新的数据类型，新的类不仅拥有旧类的成员，还拥有新定义的成员。</p>
<p>一个 B 类继承于 A 类，或称从类 A 派生类 B。这样的话，类 A 成为基类，
类 B 成为派生类</p>
<p>派生类中的成员，包含两大部分：一类是从基类继承过来的，一类是自己增加的成员。从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>
<h3 id="继承的语法">继承的语法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类 : 继承方式 基类 &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>C++ 中的成员权限和继承方式：</strong></p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 25%" />
<col style="width: 28%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">继承方式</th>
<th style="text-align: center;">基类的 <code>public</code> 成员</th>
<th style="text-align: center;">基类的 <code>protected</code> 成员</th>
<th style="text-align: center;">基类的 <code>private</code> 成员</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>public</code> 继承</td>
<td style="text-align: center;">仍为 <code>public</code> 成员</td>
<td style="text-align: center;">仍为 <code>protected</code> 成员</td>
<td style="text-align: center;">不可见</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>protected</code> 继承</td>
<td style="text-align: center;">变为 <code>protected</code> 成员</td>
<td style="text-align: center;">变为 <code>protected</code> 成员</td>
<td style="text-align: center;">不可见</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>private</code> 继承</td>
<td style="text-align: center;">变为 <code>private</code> 成员</td>
<td style="text-align: center;">变为 <code>private</code> 成员</td>
<td style="text-align: center;">不可见</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; age &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> tail_len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承中的对象模型">继承中的对象模型</h3>
<p>在 C++
编译器的内部可以理解为结构体，子类是由父类成员叠加子类新成员而成。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Aclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mA;</span><br><span class="line">    <span class="type">int</span> mB;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bclass</span> : <span class="keyword">public</span> Aclass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mC;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cclass</span> : <span class="keyword">public</span> Bclass &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mD;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;A size:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Aclass) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;B size:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Bclass) &lt;&lt; endl; <span class="comment">// 12</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C size:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Cclass) &lt;&lt; endl; <span class="comment">// 16</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/e2072c43-3580-4473-b2e0-2ac533b5e38e"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="非自动继承的函数">非自动继承的函数</h3>
<p>子类不会继承父类的构造函数 、析构函数和 <code>operator=</code>
函数。</p>
<h3 id="继承中构造和析构顺序">继承中构造和析构顺序</h3>
<p>子类对象在创建时会首先调用父类的构造函数，父类构造函数执行完毕后，才会调用子类的构造函数。</p>
<p>当父类构造函数有参数时，需要在子类初始化列表中显示调用父类构造函数。</p>
<p>析构函数调用顺序和构造函数相反。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>() &#123; cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">Son</span>() &#123; cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Son s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/564d4c31-3b73-4e47-9383-96fac5b9c26f"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="继承同名成员处理方式">继承同名成员处理方式</h3>
<p>如果子类和父类有同名的成员变量和成员函数，继承时，父类的成员变量和成员函数会被隐藏</p>
<ul>
<li>访问子类同名成员，直接访问即可</li>
<li>访问父类同名成员，需要加作用域</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; m_A = <span class="number">100</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>() &#123; m_A = <span class="number">200</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Son s;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">func</span>();</span><br><span class="line">    s.Base::<span class="built_in">func</span>();</span><br><span class="line">    s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/410da135-a8cc-4c9b-92fe-00482ee9a60c"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="继承同名静态成员处理方式">继承同名静态成员处理方式</h3>
<p>继承时，子类和父类有同名的静态成员函数或静态成员变量，父类中的静态成员函数或静态成员变量会被隐藏。</p>
<ul>
<li>访问子类同名成员，直接访问即可</li>
<li>访问父类同名成员，需要加作用域</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过对象访问：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Son s;</span><br><span class="line">    s.<span class="built_in">func</span>();</span><br><span class="line">    s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过类名访问：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Son::<span class="built_in">func</span>();</span><br><span class="line">    Son::Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/cb7f86e7-b6be-48ad-a9ea-8347a6cd2f3e"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="多继承">多继承</h3>
<p>C++ 允许<strong>一个类继承多个类</strong></p>
<p>语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 子类 : 继承方式 父类<span class="number">1</span>, 继承方式 父类<span class="number">2.</span>..</span><br></pre></td></tr></table></figure>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分。</p>
<blockquote>
<p>实际开发中不建议使用多继承</p>
</blockquote>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>() &#123; m_A = <span class="number">100</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>() &#123; m_A = <span class="number">200</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>() &#123;</span><br><span class="line">        m_C = <span class="number">300</span>;</span><br><span class="line">        m_D = <span class="number">400</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">    <span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Son s;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/1f762a21-da8b-409f-a31f-c0d139e57c6c"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="菱形继承">菱形继承</h3>
<p>菱形继承：两个派生类继承同一个基类，又有某个类同时继承者两个派生类，这种继承被称为菱形继承，或者钻石继承。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SheepTuo st;</span><br><span class="line">    st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">    st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt; st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/ce265823-5977-4432-b125-0e3ca2d8247a"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p><strong>虚继承的实现原理：</strong></p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/2d2be114-5ca3-40c2-ae80-bce2ca22c92d"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="多态">多态</h2>
<h3 id="多态的基本概念">多态的基本概念</h3>
<p>多态分为两类：</p>
<ul>
<li>静态多态：函数重载和运算符重载属于静态多态，复用函数名</li>
<li>动态多态：派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定：编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定：运行阶段确定函数地址</li>
</ul>
<p>多态满足条件：</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数</li>
</ul>
<p>多态使用条件：</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写：函数返回值类型、函数名、参数列表完全一致称为重写。</p>
<h3 id="纯虚函数和抽象类">纯虚函数和抽象类</h3>
<p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为<strong>纯虚函数</strong></p>
<p>纯虚函数语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 返回值类型 函数名 （参数列表）= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>当类中有了纯虚函数，这个类也称为抽象类。</p>
<p><strong>抽象类特点</strong>：</p>
<ul>
<li>无法实例化对象。</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类。</li>
</ul>
<h3 id="虚析构和纯虚析构">虚析构和纯虚析构</h3>
<p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">virtual</span> ~类名()&#123;&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol type="1">
<li>虚析构或纯虚析构用来解决通过父类指针释放子类对象。</li>
<li>如果子类中没有堆区数据，可以不写为虚析构或纯虚析构。</li>
<li>拥有纯虚析构函数的类也属于抽象类。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>C++ 基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>C 语言入门</title>
    <url>/2023/07/16/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="第一个-c-语言程序">第一个 C 语言程序</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">//头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>); <span class="comment">// 使用printf函数输出括号里面的字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关键字">关键字</h2>
<h3 id="数据类型相关的关键字">数据类型相关的关键字</h3>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 46%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">关键字</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">数据范围</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>char</code></td>
<td style="text-align: center;">用来定义字符型变量，占 1 个字节</td>
<td style="text-align: center;">有符号：<span
class="math inline">\(-2^{7}\sim2^7-1\)</span><br />无符号：<span
class="math inline">\(0 \sim 2^8-1\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>short</code></td>
<td style="text-align: center;">用来定义短整型变量，占 2 个字节</td>
<td style="text-align: center;">有符号：<span
class="math inline">\(-2^{15}\sim2^{15}-1\)</span><br />无符号：<span
class="math inline">\(0 \sim 2^{16}-1\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>int</code></td>
<td style="text-align: center;">用来定义整型变量，占 4 个字节</td>
<td style="text-align: center;">有符号：<span
class="math inline">\(-2^{31}\sim2^{31}-1\)</span><br />无符号：<span
class="math inline">\(0 \sim 2^{32}-1\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>long</code></td>
<td style="text-align: center;">用来定义长整型变量，在 32 位操作系统下占
4 个字节，在 64 位操作系统下占 8 个字节</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>double</code></td>
<td style="text-align: center;">用来定义双精度浮点类型，占 8 个字节，在
32 位操作系统上由两个 4 字节组成</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>float</code></td>
<td style="text-align: center;">用来定义单精度浮点类型，占 4 个字节</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>struct</code></td>
<td style="text-align: center;">用来定义结构体的关键字</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>union</code></td>
<td style="text-align: center;">用来定义共用体的关键字</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>enum</code></td>
<td style="text-align: center;">用来定义枚举的关键字</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>signed</code></td>
<td style="text-align: center;">表示有符号数，用来修饰
<code>short</code>、<code>int</code>、<code>long</code>，默认情况下整形都是有符号数，无需带上此关键字</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>unsigned</code></td>
<td style="text-align: center;">表示无符号数，用来修饰
<code>short</code>、<code>int</code>、<code>long</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>void</code></td>
<td
style="text-align: center;">空类型关键字，可以用来修饰函数返回值、声明万能指针（<code>void *</code>）</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>不同类型所占字节数还可参考下图：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/4856a65b-becf-4328-97b3-893c0e195740"
alt="d63070cbc8e96067a73e397fe2c1e65" />
<figcaption
aria-hidden="true">d63070cbc8e96067a73e397fe2c1e65</figcaption>
</figure>
<p>测试数据类型所占内存大小：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">short</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">long</span> d;</span><br><span class="line">    <span class="type">float</span> e;</span><br><span class="line">    <span class="type">double</span> f;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="keyword">sizeof</span>(e));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/6b55d317-594d-41c8-b1f1-5070692ffada"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h4 id="存储相关关键字">存储相关关键字</h4>
<p>存储相关关键字有：<code>register</code>、<code>static</code>、<code>auto</code>、<code>extern</code>.</p>
<h4 id="register">register</h4>
<p><code>register</code> 是寄存器的意思，用 <code>register</code>
修饰的变量是寄存器变量，即：在编译的时候告诉编译器这个变量是寄存器变量，尽量将其存储空间分配在寄存器中。</p>
<p>注意：</p>
<ol type="1">
<li>定义的变量不一定真的存放在寄存器中。</li>
<li>CPU 取数据的时候去寄存器中拿数据比去内存中拿数据要快。</li>
<li>因为寄存器比较宝贵，所以不能定义寄存器数组。</li>
<li><code>register</code> 只能修饰字符型及整型的，不能修饰浮点型。</li>
<li>因为 <code>register</code>
修饰的变量可能存放在寄存器中不存放在内存中，所以不能对寄存器变量取地址，因为只有存放在内存中的数据才有地址。</li>
</ol>
<h4 id="static">static</h4>
<p><code>static</code> 可以修饰全局变量、局部变量、函数，使用
<code>static</code> 修饰的变量保存在内存的静态区空间中。</p>
<h4 id="const">const</h4>
<p>用 <code>const</code> 修饰的变量是只读的，不能修改它的值。</p>
<h4 id="auto">auto</h4>
<p><code>auto int a</code>; 和 <code>int a;</code>
是等价的，<code>auto</code> 关键字现在基本不用。</p>
<h4 id="extern">extern</h4>
<p>是外部的意思，一般用于函数和全局变量的声明。</p>
<h3 id="控制语句相关的关键字">控制语句相关的关键字</h3>
<p><code>if</code> 、<code>else</code>
、<code>break</code>、<code>continue</code>、<code>for</code>
、<code>while</code>、<code>do</code>、<code>switch</code>、<code>case</code>、<code>goto</code>、<code>default</code>.</p>
<h3 id="其他关键字">其他关键字</h3>
<p><code>sizeof</code>、<code>typedef</code>、<code>volatile</code>.</p>
<h4 id="sizeof">sizeof</h4>
<p>使用来测变量、数据类型、数组的占用存储空间的大小（字节数）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/89177b85-9d3f-4105-9734-edbfa0bf45ea"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h4 id="typedef">typedef</h4>
<p>给一个已有的类型重新起个类型名，没有创造一个新的类型。</p>
<p>语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> old_type_name new_type_name</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> <span class="type">int</span> INT16;</span><br></pre></td></tr></table></figure>
<p><code>INT16</code> 就和 <code>short int</code> 是等价的。</p>
<h4 id="volatile">volatile</h4>
<p>用 <code>volatile</code> 定义的变量，是易改变的，即告诉 CPU 每次用
<code>volatile</code>
变量的时候，重新去内存中读取，保证用的是最新的值，而不是寄存器中的备份。</p>
<p><code>volatile</code> 关键字现在较少适用。</p>
<h2 id="数据类型">数据类型</h2>
<h3 id="基本类型">基本类型</h3>
<p><code>char</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> a = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %c\n&quot;</span>, a);</span><br><span class="line">    <span class="type">short</span> b = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line">    <span class="type">int</span> c = <span class="number">9999</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>, c);</span><br><span class="line">    <span class="type">long</span> d = <span class="number">34536453</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d = %ld\n&quot;</span>, d);</span><br><span class="line">    <span class="type">float</span> e = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;e = %f\n&quot;</span>, e);</span><br><span class="line">    <span class="type">double</span> f = <span class="number">3452.2345324523452</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f = %lf\n&quot;</span>, f);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/e4ecc5cd-3da4-4a0d-a2b1-31877af0b8aa"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="构造类型">构造类型</h3>
<p>由若干个相同或不同类型数据构成的集合，包括：数组、结构体、共用体、枚举。</p>
<h3 id="常量和变量">常量和变量</h3>
<h4 id="常量">常量</h4>
<p>在程序运行过程中，其值不可以改变的量。</p>
<p>例：<code>100</code>、<code>'a'</code>、<code>"hello"</code>.</p>
<p>常量的分类：</p>
<ul>
<li>整型：<code>100</code>，<code>125</code>，<code>-100</code>，<code>0</code></li>
<li>实型：<code>3.14</code>、<code>0.125f</code>、<code>-3.789</code></li>
<li>字符型：'a'、<code>b</code>、<code>2</code></li>
<li>字符串：<code>"a"</code>、<code>"ab"</code>、<code>"1232"</code></li>
</ul>
<p>ASCII
码表：对于计算机而言，只能识别二进制数，也就是数字，对于非数值型数据，如果要使用，就需要将其用一个数值型数据进行标识，描述这种映射关系的就是
<a href="http://c.biancheng.net/c/ascii/">ASCII 码表</a>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> ch1 = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch1 = %c %d\n&quot;</span>, ch1, ch1);</span><br><span class="line">    <span class="type">char</span> ch2 = <span class="number">97</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch2 = %c %d\n&quot;</span>, ch2, ch2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/2eeaec89-9366-46cd-9201-79d91b8d74fd"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h4 id="变量">变量</h4>
<p>值可以改变的量被称为变量。</p>
<p>定义方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">存储类型 数据类型 变量名;</span><br><span class="line">存储类型 数据类型 变量名 = 变量或者常量;</span><br></pre></td></tr></table></figure>
<p>变量在定义的时候要满足标识符的命名规则：</p>
<ol type="1">
<li>只能由字母、数字和下划线组成。</li>
<li>首字母不能是数字。</li>
<li>不能是关键字。</li>
</ol>
<p>整型：</p>
<ul>
<li><p>整型常量:（按进制分）</p>
<ul>
<li><p>十进制： 以正常数字 1- 9 开头，如
<code>457</code>、<code>789</code>.</p></li>
<li><p>八进制：以数字 0 开头，如 <code>0123</code>.</p></li>
<li><p>十六进制：以 0x 开头，如 <code>0x1e</code>.</p></li>
</ul></li>
<li><p>整型变量：</p>
<ul>
<li>短整型：2 个字节。</li>
<li>整型：4 个字节，</li>
<li>长整型：32 位平台上位 4 个字节。</li>
</ul></li>
</ul>
<p>实型（浮点型）：</p>
<ul>
<li>实型常量：实型常量也称为实数或者浮点数，不以 f 结尾的常量是
<code>double</code> 类型，以 f 结尾的常量（如 <code>3.14f</code>）是
<code>float</code> 类型。
<ul>
<li>十进制形式：由数字和小数点组成：<code>0.0</code>、<code>0.12</code>、<code>5.0</code>.</li>
<li>指数形式：<code>123e3</code> 代表 <span
class="math inline">\({123}\times
{10}^3\)</span>，<code>123e-3</code>代表 <span
class="math inline">\({123}\times {10}^{-3}\)</span>.</li>
</ul></li>
<li>实型变量：
<ul>
<li>f<code>loat</code> 型：占 4 字节，7 位有效数字，指数 -37 到 38.</li>
<li>double 型：占 8 字节，16 位有效数字，指数 -307 到 308.</li>
</ul></li>
</ul>
<p>字符数据：</p>
<ul>
<li>字符常量：
<ul>
<li>直接常量：用单引号括起，如：<code>'a'</code>、<code>'b'</code>、<code>'0'</code>等。</li>
<li>转义字符：以反斜杠 <code>\</code> 开头，后跟一个或几个字符、如
<code>'\n'</code>、<code>\t</code> 等，分别代表换行、制表符。</li>
</ul></li>
<li>字符变量：用 char 定义，每个字符变量被分配一个字节的内存空间字符值以
ASCII 码的形式存放在变量的内存单元中。</li>
</ul>
<p>字符串常量：</p>
<p>是由双引号括起来的字符序列，如：<code>"CHINA"</code>、<code>"哈哈哈"</code>、<code>"C program"</code>，<code>"$12.5"</code>
等都是合法的字符串常量。</p>
<blockquote>
<p>字符串常量与字符常量的不同：<code>'a'</code>
为字符常量，<code>"a"</code>
为字符串常量，每个字符串的结尾，编译器会为其自动添加一个结束标志位
<code>\0</code>，即字符串 <code>"a"</code> 包含两个字符：<code>a</code>
和 '\0'.</p>
</blockquote>
<h3 id="格式化输出字符串">格式化输出字符串</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">格式符</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>%d</code></td>
<td style="text-align: center;">十进制有符号整数</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>%ld</code></td>
<td style="text-align: center;">十进制 <code>long</code>
型有符号整数</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>%u</code></td>
<td style="text-align: center;">十进制无符号整数</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>%o</code></td>
<td style="text-align: center;">以八进制表示的整数</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>%x</code></td>
<td style="text-align: center;">以十六进制表示的整数</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>%f</code></td>
<td style="text-align: center;"><code>float</code> 型浮点数</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>%lf</code></td>
<td style="text-align: center;"><code>double</code> 型浮点数</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>%e</code></td>
<td style="text-align: center;">指数形式的浮点数</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>%c</code></td>
<td style="text-align: center;">单个字符</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>%s</code></td>
<td style="text-align: center;">字符串</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>%p</code></td>
<td style="text-align: center;">指针的值</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化输出字符的使用</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 输出整数</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 输出十进制数，用%d</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="comment">// 输出八进制数，用%o</span></span><br><span class="line">    <span class="comment">// printf(&quot;a = %o\n&quot;, a);</span></span><br><span class="line">    <span class="comment">// 使用%#o，可以输出八进制数的前导符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %#o\n&quot;</span>, a);</span><br><span class="line">    <span class="comment">// 输出十六进制数</span></span><br><span class="line">    <span class="comment">// printf(&quot;a = %x\n&quot;, a);</span></span><br><span class="line">    <span class="comment">//  使用%#x，可以输出十六进制数的前导符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %#x\n&quot;</span>, a);</span><br><span class="line">    <span class="comment">// 输出浮点型数据,float使用%f，double使用%lf</span></span><br><span class="line">    <span class="comment">// 默认小数点后保留六位，并且可以四舍五入，如果不够六位自动补0</span></span><br><span class="line">    <span class="type">float</span> b = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="type">double</span> c = <span class="number">2345.2345</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %f\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %lf\n&quot;</span>, c);</span><br><span class="line">    <span class="comment">// 输出字符，使用%c输出字符，使用%d可以输出字符的ascii码值</span></span><br><span class="line">    <span class="type">char</span> d = <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d = %c %d\n&quot;</span>, d, d);</span><br><span class="line">    <span class="comment">// 输出字符串，使用%s</span></span><br><span class="line">    <span class="comment">// 没有专门的变量保存字符串，一般使用数组来保存</span></span><br><span class="line">    <span class="type">char</span> e[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;e = %s\n&quot;</span>, e);</span><br><span class="line">    <span class="comment">// 输出地址，使用%p</span></span><br><span class="line">    <span class="type">int</span> f = <span class="number">999</span>;</span><br><span class="line">    <span class="comment">//&amp;：取一个变量的地址，一般地址用十六进制数标识</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;f = %p\n&quot;</span>, &amp;f);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/0730882c-0318-4ab1-a78d-3bfde5f2b1af"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<ul>
<li><code>%3d</code>：要求宽度为 3 位，如果不足 3
位，前面空格补齐；如果足够 3 位，此语句无效。</li>
<li><code>%03d</code>：要求宽度为 3 位，如果不足 3 位，前面 0
补齐；如果足够 3 位，此语句无效。</li>
<li><code>%-3d</code>：要求宽度为 3 位，如果不足 3
位，后面空格补齐；如果足够 3 位，此语句无效。</li>
<li><code>%.2f</code>：小数点后只保留 2 位。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = <span class="number">456</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%d\n&quot;</span>, m, m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%5d%5d\n&quot;</span>, m, m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%05d%05d\n&quot;</span>, m, m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-5d%-5d\n&quot;</span>, m, m);</span><br><span class="line">    <span class="type">float</span> n = <span class="number">3.678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n = %f\n&quot;</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n = %.2f\n&quot;</span>, n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/8d43328e-ce79-4fa2-8111-225cab0c19dc"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="类型转换">类型转换</h3>
<p>数据有不同的类型，不同类型数据之间进行混合运算时必然涉及到类型的转换问题。</p>
<p>转换的方法有两种：</p>
<ul>
<li>自动转换：遵循一定的规则，由编译系统自动完成。</li>
<li>强制类型转换：把表达式的运算结果强制转换成所需的数据类型。</li>
</ul>
<h4 id="自动转换">自动转换</h4>
<p>自动转换原则</p>
<ol type="1">
<li>占用内存字节数少的类型，向占用内存字节数多的类型转换，以保证精度不降低。</li>
<li>转换方向：</li>
</ol>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/d1ce4c8d-9328-4aa6-a606-ff6e918efcb0"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h4 id="强制转换">强制转换</h4>
<p>通过类型转换运算来实现，语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(类型名) (表达式)</span><br></pre></td></tr></table></figure>
<p>功能：把表达式的运算结果强制转换成类型说明符所表示的类型。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(<span class="type">float</span>) a;</span><br><span class="line">(<span class="type">int</span>) (x + y);</span><br></pre></td></tr></table></figure>
<p>注意：类型名必须加括号。</p>
<h4 id="案例">案例：</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">5</span> / <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, <span class="number">5.0</span> / <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> a = <span class="number">-8</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span> (a + b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a+b&gt;0\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a+b&lt;=0\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="type">float</span> n = <span class="number">5.8f</span>;</span><br><span class="line">    m = n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;m = %d\n&quot;</span>, m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n = %f\n&quot;</span>, n);</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">4</span>;</span><br><span class="line">    <span class="type">float</span> w;</span><br><span class="line">    w = (<span class="type">float</span>)x / (<span class="type">float</span>)y;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;w = %f\n&quot;</span>, w);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/af098cf9-c45d-4897-a1d8-cafd9423cc36"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="运算符">运算符</h2>
<h3 id="算术运算符">算术运算符</h3>
<p><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">40</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>, a, b, a + b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d - %d = %d\n&quot;</span>, a, b, a - b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d * %d = %d\n&quot;</span>, a, b, a * b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d / %d = %d\n&quot;</span>, a, b, a / b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %% %d = %d\n&quot;</span>, a, b, a % b);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> m = <span class="number">10.32</span>;</span><br><span class="line">    <span class="type">float</span> n = <span class="number">4.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.4f + %.4f = %.4f\n&quot;</span>, m, n, m + n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.4f - %.4f = %.4f\n&quot;</span>, m, n, m - n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.4f * %.4f = %.4f\n&quot;</span>, m, n, m * n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.4f / %.4f = %.4f\n&quot;</span>, m, n, m / n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/31aae51d-3a09-4f54-a860-7bdc44cb0198"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="关系运算符">关系运算符</h3>
<p><code>&gt;</code>、<code>&lt;</code>、<code>==</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>!=</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span> &gt; <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span> &lt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/e2fe18b3-46de-410d-b32e-668543432de0"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="逻辑运算符">逻辑运算符</h3>
<p><code>&amp;&amp;</code>、<code>||</code>、<code>!</code>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> ret = a &gt; <span class="number">10</span> &amp;&amp; a &lt; <span class="number">19</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line">    ret = a &gt; <span class="number">10</span> || a &lt; <span class="number">19</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b = <span class="number">100</span>;</span><br><span class="line">    ret = (a &lt; <span class="number">19</span>) &amp;&amp; (b += <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">    ret = (a &gt; <span class="number">19</span>) || (b += <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/a8e3f10a-e346-41d0-aa96-e728d1f0d880"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<blockquote>
<p>注意逻辑运算符存在短路现象。</p>
</blockquote>
<h3 id="位运算符">位运算符</h3>
<p><code>&amp;</code>：任何值与 0 得 0，与 1 保持不变</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0101 1011</span><br><span class="line">1011 0100</span><br><span class="line">0001 0000</span><br></pre></td></tr></table></figure>
<p><code>|</code>：任何值或 1 得 1，或 0 保持不变</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0101 0011</span><br><span class="line">1011 0100</span><br><span class="line">1111 0111</span><br></pre></td></tr></table></figure>
<p><code>~</code>：1 变 0，0 变 1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0101 1101</span><br><span class="line">1010 0010</span><br></pre></td></tr></table></figure>
<p><code>^</code>：相异得 1，相同得 0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1001 1100</span><br><span class="line">0101 1010</span><br><span class="line">1100 0110</span><br></pre></td></tr></table></figure>
<p><code>&gt;&gt;</code>：右移</p>
<p>高位溢出，低位补 0</p>
<p><code>&lt;&lt;</code>：左移</p>
<blockquote>
<p>注意右移分：逻辑右移、算数右移。</p>
</blockquote>
<p>逻辑右移：高位补 0，低位溢出。</p>
<p>算数右移：高位补符号位，低位溢出。</p>
<p>在一个编译系统中到底是逻辑右移动，还是算数右移，取决于编译器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断右移是逻辑右移还是算数右移</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">-1</span> &gt;&gt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果结果还是‐1 证明是算数右移</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/032c6576-78dd-4ec9-8fba-d268e650f918"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="条件运算符号">条件运算符号</h3>
<p>语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(表达式 A) ? (表达式 B) : (表达式 C)</span><br></pre></td></tr></table></figure>
<p>相对于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (A) &#123;</span><br><span class="line">    B;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    c = (a &gt; b) ? (a += <span class="number">10</span>) : (b += <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %d\n&quot;</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/83689588-d49c-4fe6-ad02-d8292a5955d1"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="逗号运算符">逗号运算符</h3>
<p>语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(表达 A, 表达式 B, 表达式 C, ...)</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A = (B, C, D);</span><br></pre></td></tr></table></figure>
<p>先运行表达式 B，再运行表达式 C，最后运行表达式 D，最终变量 A
的值为表达式 D 的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    c = (a += <span class="number">10</span>, b += <span class="number">10</span>, a += b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d, c = %d\n&quot;</span>, a, b, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/6bbaa575-b203-40dc-90cf-b85a9975bcb1"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="自增自减运算符">自增自减运算符</h3>
<p><code>++</code>、<code>--</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    b = a++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">    a = <span class="number">100</span>;</span><br><span class="line">    b = ++a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/00b4d8b3-0496-42b9-a1b5-6d4f7f359893"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="运算符优先级表">运算符优先级表</h3>
<p><a href="http://c.biancheng.net/view/161.html">C
语言运算符优先级和结合性一览表</a></p>
<h2 id="控制语句">控制语句</h2>
<h3 id="选择控制语句">选择控制语句</h3>
<h4 id="if-语句">if 语句</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">50</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &gt; 50\n&quot;</span>, n);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">50</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d = 50\n&quot;</span>, n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &lt; 50\n&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/104075a5-01ea-442f-b33c-6ed91aebc32d"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h4 id="switch-语句">switch 语句</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (num) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;111111111111\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;222222222222\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;333333333333\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hahahahahaha\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/52ed46eb-d44c-47b1-ae8e-bd7d120a2fd9"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>运行顺序：将常量表达式的值语句 switch
后面的表达式的值对比，如果表达式的值刚好等于 case
后面的某一个值，就会立即去执行 case 后的语句，如果都不是，则会执行
default 后面的语句。</p>
<p>注意事项：</p>
<ol type="1">
<li>switch 后面的表达式不能是浮点型，只能是整形的。</li>
<li>如果 case 后面的常量表达式与 switch 的表达式的值都不同，则执行
default 后面的语句。</li>
<li>每一个 case 执行结束后理论上必须跟一个 break，作用就是跳出整个
switch.</li>
<li>case 后面如果语句很多，不需要加大括号。</li>
</ol>
<h3 id="循环控制语句">循环控制语句</h3>
<h4 id="for-循环">for 循环</h4>
<p>使用 for 循环求 1 到 100 的累加和：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1 + 2 + 3 + ... + 100 = %d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/3d008b67-abf2-4cc5-a1d8-39f5f7ba6f22"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h4 id="while-循环">while 循环</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1 + 2 + 3 + ... + 100 = %d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/7133b3c2-d601-4897-8b10-fb3e6d8ab331"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h4 id="do-while-循环">do while 循环</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sum += (i++);</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt;= <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1 + 2 + 3 + ... + 100 = %d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/79006d13-e08c-4a83-bdf1-74ffdfda3648"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<blockquote>
<p>do while 至少执行一次循环体。</p>
</blockquote>
<h4 id="goto">goto</h4>
<p>goto 主要用于在一个函数里面实现代码的跳转。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;11111111111111\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> NEXT;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;22222222222222\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;33333333333333\n&quot;</span>);</span><br><span class="line">NEXT:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;44444444444444\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/027264d2-9b5e-48fb-acc0-dc4dd353f299"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>使用 goto 实现求 1 到 100 的累加和：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">JOOP:</span><br><span class="line">    sum += i;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> JOOP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1 + 2 + 3 + ... + 100 = %d\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/cbf35b47-f485-4f3c-8b1f-153684f64dd3"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<blockquote>
<p>迪杰斯特拉提出了 goto 有害论，所以我们要少用 goto 语句。</p>
</blockquote>
]]></content>
      <categories>
        <category>C 语言基础</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础命令</title>
    <url>/2023/07/17/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="终端提示符">终端提示符</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yaojie@yaojie-virtual-machine:~$ </span><br><span class="line">yaojie: 用户名</span><br><span class="line">yaojie-virtual-machine: 主机名</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~: 家目录</span><br><span class="line">/: 根目录</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$: 普通用户权限</span><br><span class="line"><span class="comment">#: 管理员权限</span></span><br></pre></td></tr></table></figure>
<h2 id="命令帮助信息">命令帮助信息</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令 --help</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：并不是所有的命令都有帮助信息。</p>
</blockquote>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/ddd040ff-025a-4674-b58a-cf33e3184e24"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="man-命令">man 命令</h3>
<p>man 命令是 linux
提供的帮助手册，可以查询命令、函数或者特殊的文件，这个手册有很多个章节。</p>
<p>第一章中放的是命令的帮助信息。</p>
<p>第二章中放的是系统调用。</p>
<p>第三章中放的是库函数的帮助信息。</p>
<p>使用 <code>man man</code> 查看 man 命令的帮助信息：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/3ded45a7-de5d-41f8-9b3d-3f59fa945f3a"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man 章节 查找信息</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">man 1 <span class="built_in">ls</span> 或者 man <span class="built_in">ls</span></span><br><span class="line">man 2 open</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/262e202c-0379-4fb5-8945-6a2d8fe1e02e"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="命令常用的技巧">命令常用的技巧</h2>
<h3 id="自动补全">自动补全</h3>
<p>输入命令的一部分，按 <kbd>tab</kbd>
键，会可以自动补全命令，如果匹配到了多个命令，按两次
<kbd>tab</kbd>，会在终端打印所有可用的命令。</p>
<p>文件和目录也可以使用如上操作进行补全。</p>
<h3 id="历史命令">历史命令</h3>
<p>可以通过<strong>上下方向键</strong>将以前输入过的命令调出来，敲回车再次执行和做修改后执行。</p>
<h3 id="重定向">重定向</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">命令 &gt; 目的文件 <span class="comment"># 先清空原本文件内容，然后将命令的输出结果写入文件</span></span><br><span class="line">命令 &gt;&gt; 目的文件 <span class="comment"># 以追加的方式将命令的输出结果写入文件</span></span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/3acef1f4-1c41-4965-8d40-607529f00ddf"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="管道">管道</h3>
<p>将一个程序的输出作为另外一个程序的输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> --<span class="built_in">help</span> | more <span class="comment"># 以每页的方式查看ls命令的帮助信息</span></span><br><span class="line"><span class="built_in">ls</span> /etc | <span class="built_in">wc</span> w <span class="comment"># 统计根目录下的etc目录中的文件数</span></span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/7e3f7021-9de4-4573-af31-55793882d017"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="ls"><code>ls</code></h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> <span class="comment">#查看当前目录下的文件名</span></span><br><span class="line"><span class="built_in">ls</span> 目录名 <span class="comment">#查看指定目录下的文件名</span></span><br><span class="line"><span class="built_in">ls</span> / <span class="comment">#查看根目录下的文件名</span></span><br><span class="line"><span class="built_in">ls</span> -a <span class="comment">#查看当前目录下的所有文件名，包括隐藏文件</span></span><br><span class="line"><span class="built_in">ls</span> -l <span class="comment">#查看当前目录下文件的详细信息（以列表的显示输出）</span></span><br><span class="line"><span class="built_in">ls</span> -al <span class="comment">#查看当前目录下所有文件的详细信息</span></span><br><span class="line"><span class="built_in">ls</span> -hl <span class="comment">#详细信息中的字节数可以带单位的显示</span></span><br><span class="line"><span class="built_in">ls</span> -d <span class="comment">#只列出目录</span></span><br><span class="line"><span class="built_in">ls</span> -r <span class="comment">#倒序显示文件和目录</span></span><br><span class="line"><span class="built_in">ls</span> -R <span class="comment">#递归显示目录中的所有文件和子目录</span></span><br><span class="line"><span class="built_in">ls</span> -t <span class="comment">#按修改时间排序，最新的文件在最前面</span></span><br><span class="line"><span class="built_in">ls</span> -A <span class="comment">#同 &quot;-a&quot;，但不列出 &quot;.&quot; 和 &quot;..&quot;</span></span><br><span class="line"><span class="built_in">ls</span> -F <span class="comment">#在列出的文件名称后加一符号；例如可执行档则加 &quot;*&quot;, 目录则加 &quot;/&quot;</span></span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/76da838f-68bb-420b-a4c9-328006bd8293"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">drwxr-xr-x  20 root root       4096  6月  7 15:12 .</span><br><span class="line">d：文件类型，linux里面不以后缀名作为文件类型的区分</span><br><span class="line">linux里面一共有其中文件类型bcd-lsp，linux里面一切皆文件</span><br><span class="line">    b：块设备文件</span><br><span class="line">    c：字符设备文件</span><br><span class="line">    d：目录文件</span><br><span class="line">    -：普通文件</span><br><span class="line">    l：软链接文件</span><br><span class="line">    s：套接字文件</span><br><span class="line">    p：管道文件</span><br><span class="line">rwxr-xr-x：文件权限，以三个为一组，分别表示用户主、用户组以及其他用户对文件的操作权限，r：读权限，w：写权限，x：可执行权限，如果是-，就表示没有这个权限</span><br><span class="line">20：链接文件的个数</span><br><span class="line">root：用户名</span><br><span class="line">root：用户组名</span><br><span class="line">4096：文件大小，默认以字节为单位</span><br><span class="line">6月  7 15:12：时间戳，文件的最后修改时间</span><br><span class="line">.：文件名</span><br></pre></td></tr></table></figure>
<h2 id="tree"><code>tree</code></h2>
<p>以树状结构显示目录信息。</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/978079cd-598c-4112-a24b-066af2214d7b"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tree -L 层数 <span class="comment"># 用于显示指定的层数</span></span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/2e1ec8ac-82f4-47da-aef5-dd805bc7bf2e"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="clear"><code>clear</code></h2>
<p>清屏。</p>
<h2 id="cd"><code>cd</code></h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 当前目录下的目录名 <span class="comment">#进入指定的目录</span></span><br><span class="line"><span class="built_in">cd</span> / <span class="comment">#进入根目录</span></span><br><span class="line"><span class="built_in">cd</span> ~ <span class="comment">#进入家目录</span></span><br><span class="line"><span class="built_in">cd</span> .. <span class="comment">#进入当前目录的上一级目录</span></span><br><span class="line"><span class="built_in">cd</span> - <span class="comment">#返回到上一次的路径</span></span><br></pre></td></tr></table></figure>
<h2 id="pwd"><code>pwd</code></h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span> <span class="comment">#显示当前路径的绝对路径</span></span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/985fd7a6-2383-4925-acdd-87f6c853130c"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="cat"><code>cat</code></h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> 文件名 <span class="comment">#显示文件的内容</span></span><br><span class="line"><span class="built_in">cat</span> -n 文件名 <span class="comment">#带行号的显示文件的内容</span></span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/dbbfe639-6755-49ad-805d-74421f89b169"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="rm"><code>rm</code></h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> 文件名 <span class="comment">#删除指定的文件</span></span><br><span class="line"><span class="built_in">rm</span> -rf 目录文件名 <span class="comment">#删除指定的目录文件</span></span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/e89c9545-9582-43a4-b8e8-086aa2cefcd2"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="cp"><code>cp</code></h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> 文件名 目录名 <span class="comment">#将文件复制到目录中</span></span><br><span class="line"><span class="built_in">cp</span> 目录1 目录2 -a <span class="comment">#将目录1复制到目录2中</span></span><br><span class="line"><span class="built_in">cp</span> 文件名1 文件名2 <span class="comment">#如果文件2不是目录，则文件1复制一份为文件2，如果文件2存在且不是一个目录，则直接将内容替换传文件1的</span></span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/590f369d-0beb-4655-b094-de8792eabef8"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="mv"><code>mv</code></h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> 文件名 目录名 <span class="comment">#将文件移动到指定的目录中</span></span><br><span class="line"><span class="built_in">mv</span> 目录1 目录2 <span class="comment">#将目录1移动到目录2中</span></span><br><span class="line"><span class="built_in">mv</span> 文件1 文件2 <span class="comment">#如果文件2不存在，则功能为重命名</span></span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/80561c5d-d60f-4225-b78d-5b3f749bcd70"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="mkdir"><code>mkdir</code></h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> 目录名 <span class="comment">#创建一个目录文件</span></span><br><span class="line"><span class="built_in">mkdir</span> 目录1 目录2 ... <span class="comment">#创建多个目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p 目录1/目录2/目录3/... <span class="comment">#嵌套的创建多个文件</span></span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/17230b5f-42b5-46aa-a898-d9fefbf90a42"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="touch"><code>touch</code></h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> 文件名 <span class="comment">#创建一个文件</span></span><br><span class="line"><span class="comment">#注意：如果文件已经存在，则touch会修改当前时间的时间戳</span></span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/c99c60dd-fb89-4b43-b4cf-5306b95aa39d"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p><code>touch</code> 创建的文件默认情况下是 664 的权限。</p>
<h2 id="find"><code>find</code></h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find 路径 -name 文件名 <span class="comment">#在指定的路径下查找指定的文件，会从指定路径下包括所有的子目录中寻找</span></span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/22dc10dc-17c9-4171-b0ce-23ab6ea161be"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="grep"><code>grep</code></h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep 查找信息 文件名  <span class="comment">#在指定的文件中查找指定的内容，将查找到的内容整行输出并高亮显示查找的内容</span></span><br><span class="line">grep 查找信息 文件名 -n <span class="comment">#在指定的文件中查找指定的内容，将查找到的内容整行且带行号输出并高亮显示查找的内容</span></span><br><span class="line">grep 查找信息 * -R -n <span class="comment">#从当前目录以及子目录中的文件中查找指定信息</span></span><br></pre></td></tr></table></figure>
<h2 id="ln"><code>ln</code></h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> 源文件名 链接文件名 -s <span class="comment">#创建一个链接文件（类似windows的快捷方式）</span></span><br><span class="line"><span class="built_in">ln</span> 源文件名 链接文件名 -sfn <span class="comment">#创建一个链接文件，如果之前存在则覆盖（类似windows的快捷方式）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ul>
<li>不管对源文件还是链接文件进行修改，双方的内容都会改变。</li>
<li>如果删除链接文件，对源文件没有任何影响。</li>
<li>如果删除源文件，则链接文件失效</li>
<li>硬链接无需带任何选项</li>
</ul>
</blockquote>
<h2 id="more-和-less"><code>more</code> 和 <code>less</code></h2>
<h2 id="chmod"><code>chmod</code></h2>
<p><code>Linux</code> 文件调用权限分为 3
级：文件拥有者（Owner）、用户组（Group）、其他用户（Other Users）。</p>
<figure>
<img data-src="https://www.runoob.com/wp-content/uploads/2014/08/file-permissions-rwx.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>只有文件所有者和超级用户可以修改文件或目录的权限。可以使用绝对模式（八进制数字模式），符号模式指定文件的权限。</p>
<figure>
<img data-src="https://www.runoob.com/wp-content/uploads/2014/08/rwx-standard-unix-permission-bits.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> [-cfvR] [--<span class="built_in">help</span>] [--version] mode file...</span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<p><code>mode</code>：权限设定字串，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ugoa...][[+-=][rwxX]...][,...]</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>u</code> 表示该文件的拥有者，g
表示与该文件的拥有者属于同一个组的用户，<code>o</code>
表示其他以外的人，<code>a</code> 表示这三者皆是。</li>
<li><code>+</code> 表示增加权限、<code>-</code>
表示取消权限、<code>=</code> 表示唯一设定权限。</li>
<li><code>r</code> 表示可读取，<code>w</code> 表示可写入，<code>x</code>
表示可执行，<code>X</code>
表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</li>
</ul>
<p>其他参数说明：</p>
<ul>
<li><code>-c</code>：若该文件权限确实已经更改，才显示其更改动作</li>
<li><code>-f</code>：若该文件权限无法被更改也不要显示错误讯息</li>
<li><code>-v</code> ：显示权限变更的详细资料</li>
<li><code>-R</code>：对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)</li>
<li><code>--help</code>：显示辅助说明</li>
<li><code>--version</code>：显示版本</li>
</ul>
<p><strong>符号模式：</strong></p>
<p>使用符号模式可以设置多个项目：who（用户类型），operator（操作符）和
permission（权限），每个项目的设置可以用逗号隔开。 命令
<code>chmod</code> 将修改 who
指定的用户类型对文件的访问权限，用户类型由一个或者多个字母在 who
的位置来说明，如 who 的符号模式表所示：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">who</th>
<th style="text-align: center;">用户类型</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>u</code></td>
<td style="text-align: center;">user</td>
<td style="text-align: center;">文件所有者</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>g</code></td>
<td style="text-align: center;">group</td>
<td style="text-align: center;">文件所有者所在组</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>o</code></td>
<td style="text-align: center;">others</td>
<td style="text-align: center;">所有其他用户</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>a</code></td>
<td style="text-align: center;">all</td>
<td style="text-align: center;">所有用户, 相当于 ugo</td>
</tr>
</tbody>
</table>
<p>operator 的符号模式表：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Operator</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>+</code></td>
<td style="text-align: center;">为指定的用户类型增加权限</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>-</code></td>
<td style="text-align: center;">去除指定用户类型的权限</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>=</code></td>
<td
style="text-align: center;">设置指定用户权限的设置，即将用户类型的所有权限重新设置</td>
</tr>
</tbody>
</table>
<p>permission 的符号模式表：</p>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 15%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">模式</th>
<th style="text-align: center;">名字</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>r</code></td>
<td style="text-align: center;">读</td>
<td style="text-align: center;">设置为可读权限</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>w</code></td>
<td style="text-align: center;">写</td>
<td style="text-align: center;">设置为可写权限</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>x</code></td>
<td style="text-align: center;">执行权限</td>
<td style="text-align: center;">设置为可执行权限</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>X</code></td>
<td style="text-align: center;">特殊执行权限</td>
<td
style="text-align: center;">只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>s</code></td>
<td style="text-align: center;">setuid/gid</td>
<td style="text-align: center;">当文件被执行时，根据 who
参数指定的用户类型设置文件的 setuid 或者 setgid 权限</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>t</code></td>
<td style="text-align: center;">粘贴位</td>
<td
style="text-align: center;">设置粘贴位，只有超级用户可以设置该位，只有文件所有者
u 可以使用该位</td>
</tr>
</tbody>
</table>
<p><strong>八进制语法：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">#</th>
<th style="text-align: center;">权限</th>
<th style="text-align: center;">rwx</th>
<th style="text-align: center;">二进制</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">7</td>
<td style="text-align: center;">读 + 写 + 执行</td>
<td style="text-align: center;">rwx</td>
<td style="text-align: center;">111</td>
</tr>
<tr class="even">
<td style="text-align: center;">6</td>
<td style="text-align: center;">读 + 写</td>
<td style="text-align: center;">rw-</td>
<td style="text-align: center;">110</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">读 + 执行</td>
<td style="text-align: center;">r-x</td>
<td style="text-align: center;">101</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">只读</td>
<td style="text-align: center;">r--</td>
<td style="text-align: center;">100</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">写 + 执行</td>
<td style="text-align: center;">-wx</td>
<td style="text-align: center;">011</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">只写</td>
<td style="text-align: center;">-w-</td>
<td style="text-align: center;">010</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">只执行</td>
<td style="text-align: center;">--x</td>
<td style="text-align: center;">001</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">无</td>
<td style="text-align: center;">---</td>
<td style="text-align: center;">000</td>
</tr>
</tbody>
</table>
<p><strong>实例：</strong></p>
<p>将文件 file1.txt 设为所有人皆可读取：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> ugo+r file1.txt</span><br></pre></td></tr></table></figure>
<p>将文件 file1.txt 设为所有人皆可读取：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> a+r file1.txt</span><br></pre></td></tr></table></figure>
<p>将文件 file1.txt 与 file2.txt
设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> ug+w,o-w file1.txt file2.txt</span><br></pre></td></tr></table></figure>
<p>为 ex1.py 文件拥有者增加可执行权限:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+x ex1.py</span><br></pre></td></tr></table></figure>
<p>将目前目录下的所有文件与子目录皆设为任何人可读取：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -R a+r *</span><br></pre></td></tr></table></figure>
<p>此外 <code>chmod</code> 也可以用数字来表示权限如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 file</span><br></pre></td></tr></table></figure>
<p>语法为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> abc file</span><br></pre></td></tr></table></figure>
<p>其中 a、b、c 各为一个数字，分别表示 User、Group、及 Other
的权限。</p>
<p>r=4，w=2，x=1</p>
<ul>
<li>若要 rwx 属性则 4+2+1=7；</li>
<li>若要 rw- 属性则 4+2=6；</li>
<li>若要 r-x 属性则 4+1=5。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> a=rwx file</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 file</span><br></pre></td></tr></table></figure>
<p>效果相同</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> ug=rwx,o=x file</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 771 file</span><br></pre></td></tr></table></figure>
<p>效果相同</p>
<p>若用 <code>chmod 4755 filename</code> 可使此程序具有 root
的权限。</p>
<p><strong>更多说明：</strong></p>
<table>
<colgroup>
<col style="width: 41%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">命令</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>chmod a+r file</code></td>
<td style="text-align: center;">给file的所有用户增加读权限</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>chmod a-x file</code></td>
<td style="text-align: center;">删除file的所有用户的执行权限</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>chmod a+rw file</code></td>
<td style="text-align: center;">给file的所有用户增加读写权限</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>chmod +rwx file</code></td>
<td style="text-align: center;">给file的所有用户增加读写执行权限</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>chmod u=rw,go= file</code></td>
<td
style="text-align: center;">对file的所有者设置读写权限，清空该用户组和其他用户对file的所有权限（空格代表无权限）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>chmod -R u+r,go-r docs</code></td>
<td
style="text-align: center;">对目录docs和其子目录层次结构中的所有文件给用户增加读权限，而对用户组和其他用户删除读权限</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>chmod 664 file</code></td>
<td style="text-align: center;">对file的所有者和用户组设置读写权限,
为其其他用户设置读权限</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>chmod 0755 file</code></td>
<td
style="text-align: center;">相当于<code>u=rwx (4+2+1),go=rx (4+1 &amp; 4+1)</code>。<code>0</code>
没有特殊模式。</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>chmod 4755 file</code></td>
<td
style="text-align: center;"><code>4</code>设置了设置用户ID位，剩下的相当于
u=rwx (4+2+1), go=rx (4+1 &amp; 4+1)。</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>find path/ -type d -exec chmod a-x &#123;&#125; \;</code></td>
<td style="text-align: center;">删除可执行权限对 <code>path/</code>
以及其所有的目录（不包括文件）的所有用户，使用 <code>-type f</code>
匹配文件</td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>find path/ -type d -exec chmod a+x &#123;&#125; \;</code></td>
<td style="text-align: center;">允许所有用户浏览或通过目录
<code>path/</code></td>
</tr>
</tbody>
</table>
<h2 id="tar"><code>tar</code></h2>
<h3 id="gzip-格式">gzip 格式</h3>
<p><strong>压缩：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zcvf 压缩包包名 文件1 文件2 文件3 ...</span><br><span class="line"><span class="comment"># 注意：压缩包包名一般以.tar.gz作为后缀名</span></span><br></pre></td></tr></table></figure>
<p><strong>解压：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar zxvf 压缩包包名</span><br><span class="line">tar zxvf 压缩包包名 -C 路径 <span class="comment">#解压到指定的路径</span></span><br></pre></td></tr></table></figure>
<h3 id="bz2-格式">bz2 格式</h3>
<p><strong>压缩：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar jcvf 压缩包包名 文件1 文件2 文件3 ... <span class="comment">#注意：压缩包包名一般以.tar.bz2作为后缀名</span></span><br></pre></td></tr></table></figure>
<p><strong>解压：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar jxvf 压缩包包名</span><br><span class="line">tar jxvf 压缩包包名 -C 路径 解压到指定的路径</span><br></pre></td></tr></table></figure>
<h2 id="vi">vi</h2>
<h3 id="安装-vimvi-升级版">安装 vim（vi 升级版）</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install vim <span class="comment"># 安装 vim</span></span><br><span class="line">sudo apt install ctags <span class="comment"># 安装 ctags</span></span><br></pre></td></tr></table></figure>
<h3 id="vi-的使用">vi 的使用</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi 文件名 <span class="comment">#在vi编辑器中打开或者创建一个文件，并将光标置于第一行行首</span></span><br><span class="line">vi +n 文件名 <span class="comment">#打开存在文件，并将光标置于第n行行首</span></span><br></pre></td></tr></table></figure>
<h3 id="vi-的三种模式">vi 的三种模式</h3>
<ol type="1">
<li>插入模式：这种模式可以直接编辑文档</li>
<li>编辑模式：在编辑模式下可以执行一些命令，执行复制、剪切、粘贴等功能。</li>
<li>命令模式：在此模式下可以保存文件，退出 vi.</li>
</ol>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/fb96ef4d-e48e-4800-a772-2b5700375c15"
alt="vim-vi-workmodel" />
<figcaption aria-hidden="true">vim-vi-workmodel</figcaption>
</figure>
<blockquote>
<p>编辑模式进入插入模式可使用
<code>i</code>、<code>a</code>、<code>o</code>、<code>a</code>，分别表示在光标处插入、在光标后一个字符插入，新开启一行插入以及替换一个字符。</p>
</blockquote>
<p><strong>命令模式下的一些指令：</strong></p>
<ul>
<li><code>w</code>：保存文件</li>
<li><code>wq</code>：保存并退出</li>
<li><code>x</code>：保存并退出</li>
<li><code>q!</code>：强制退出</li>
<li><code>w finename</code>：能成为 <code>filename</code></li>
<li><code>set nu</code>：设置显示行号</li>
<li><code>set nonu</code>：设置取消行号</li>
</ul>
<p><strong>编辑模式下的操作：</strong></p>
<ul>
<li><code>u</code>：撤销前面多次修改，<code>ctrl</code> 反撤销。</li>
<li><code>[n]x</code>：删除光标后 n 个字符。</li>
<li><code>[n]X</code>：删除光标前 n 个字符。</li>
<li><code>[n]dd</code>：剪切从当前行开始的 n 行。</li>
<li><code>[n]yy</code>：复制从当前行开始的 n 行（<code>y[n]y</code>
也行）。</li>
<li><code>p</code>：粘贴。</li>
<li><code>.</code>：执行上一次操作。</li>
<li><kbd>shift</kbd> + <code>zz</code>：保存退出。</li>
</ul>
<p><strong>编辑模式下移动光标：</strong></p>
<ul>
<li><code>[n]G</code>：将光标移动到第 n 行开始处。</li>
<li><code>G</code>：将光标移动到文件尾。</li>
<li><code>gg</code>：将光标移动到文件开始处。</li>
</ul>
<p><strong>编辑模式下的查找：</strong></p>
<ul>
<li><code>/字符串</code>：从光标开始处向文件尾查找字符串，<code>n</code>
查找下一个，<code>N</code> 查找上一个，在要搜索的字符串之前加
<code>\c</code> 可以忽略大小写。</li>
<li><code>n</code>：同一方向重复上一次查找命令。</li>
<li><code>N</code>：反方向错误上一次查找命令。</li>
</ul>
<h2 id="gcc-编译器">GCC 编译器</h2>
<p>程序的编译分为四个阶段： 由 <code>.c</code> 到可执行程序：</p>
<ol type="1">
<li>预处理；</li>
<li>编译；</li>
<li>汇编；</li>
<li>链接。</li>
</ol>
<p><strong>编译程序：</strong></p>
<ol type="1">
<li>一步到位：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc hello.c <span class="comment"># 默认会生成一个名为a.out的可执行文件</span></span><br><span class="line">gcc hello.c -o hello</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/940f33cf-8714-47ba-9475-416d87e4e98b"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<ol start="2" type="1">
<li>分步骤完成：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i <span class="comment">#1、预处理</span></span><br><span class="line">gcc -S hello.i -o hello.s <span class="comment">#2、编译</span></span><br><span class="line">gcc -c hello.s -o hello.o <span class="comment">#3、汇编</span></span><br><span class="line">gcc hello.o –o hello <span class="comment">#4、链接</span></span><br></pre></td></tr></table></figure>
<h2 id="用户操作">用户操作</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd 用户名</span><br><span class="line">userdel 用户名</span><br></pre></td></tr></table></figure>
<h2 id="其它">其它</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> </span><br><span class="line">whereis</span><br><span class="line">locate</span><br></pre></td></tr></table></figure>
<p><code>PWD</code>
是一个环境变量，记录了当前目录，引用时要：<code>$PWD</code></p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.runoob.com/linux/linux-vim.html">Linux vi/vim |
菜鸟教程</a></li>
<li><a href="https://www.runoob.com/linux/linux-comm-chmod.html">Linux
chmod命令 | 菜鸟教程</a></li>
<li><a
href="https://www.cnblogs.com/mouseleo/p/13326837.html">让Vim查找字符忽略大小写
| 博客园</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>STL</title>
    <url>/2023/07/16/STL/</url>
    <content><![CDATA[<h2 id="stl-概述">STL 概述</h2>
<ul>
<li>STL（Standard Template Library，<strong>标准模板库</strong>）</li>
<li>STL 从广义上分为：<strong>容器、算法、迭代器</strong></li>
<li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接</li>
<li>STL 几乎所有的代码都采用了模板类或者模板函数</li>
</ul>
<p>STL 六大组件：</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 27%" />
<col style="width: 62%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">名字</th>
<th style="text-align: center;">别名</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">容器</td>
<td style="text-align: center;">containers</td>
<td style="text-align: center;">各种数据结构，如
<code>vector</code>、<code>list</code>、<code>deque</code>、<code>set</code>、<code>map</code>
等数据结构</td>
</tr>
<tr class="even">
<td style="text-align: center;">算法</td>
<td style="text-align: center;">演算法、algorithms</td>
<td
style="text-align: center;">各种常用算法，如：<code>sort</code>、<code>search</code>、<code>cpoy</code>、<code>erase</code>
等。</td>
</tr>
<tr class="odd">
<td style="text-align: center;">迭代器</td>
<td style="text-align: center;">iterators</td>
<td style="text-align: center;">扮演了容器与算法之间的胶合剂</td>
</tr>
<tr class="even">
<td style="text-align: center;">仿函数</td>
<td style="text-align: center;">仿函式、函数对象、functors</td>
<td style="text-align: center;">行为类似函数，可作为算法的某种策略</td>
</tr>
<tr class="odd">
<td style="text-align: center;">适配器</td>
<td style="text-align: center;">配接器、adapters</td>
<td
style="text-align: center;">一种用来修饰容器或者仿函数或迭代器接口的东西</td>
</tr>
<tr class="even">
<td style="text-align: center;">空间配置器</td>
<td style="text-align: center;">配置器、allocators</td>
<td style="text-align: center;">负责空间的配置与管理</td>
</tr>
</tbody>
</table>
<h3 id="stl-中容器算法迭代器">STL 中容器、算法、迭代器</h3>
<blockquote>
<p><strong>容器</strong>：置物之所也。</p>
</blockquote>
<p>STL
<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来。</p>
<p>常用的数据结构：<code>array</code>、<code>list</code>、<code>tree</code>、<code>stack</code>、<code>queue</code>、<code>set</code>、<code>map</code>
等。</p>
<p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种：</p>
<p><strong>序列式容器</strong>：强调值的排序，序列式容器中的每个元素均有固定的位置。
​
<strong>关联式容器</strong>：二叉树结构，各元素之间没有严格的物理上的顺序关系。</p>
<blockquote>
<p><strong>算法</strong>：问题之解法也。</p>
</blockquote>
<p>算法分为：<strong>质变算法</strong>和<strong>非质变算法</strong>。</p>
<p>质变算法：是指运算过程中会更改区间内的元素的内容，如拷贝，替换，删除等等。</p>
<p>非质变算法：是指运算过程中不会更改区间内的元素内容，如查找、计数、遍历、寻找极值等等。</p>
<blockquote>
<p><strong>迭代器</strong>：容器和算法之间粘合剂。</p>
</blockquote>
<p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p>
<p>每个容器都有自己专属的迭代器。</p>
<p>迭代器在使用上非常像指针。</p>
<p>迭代器种分类：</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 44%" />
<col style="width: 44%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">种类</th>
<th style="text-align: center;">功能</th>
<th style="text-align: center;">支持运算</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">输入迭代器</td>
<td style="text-align: center;">对数据的只读访问</td>
<td style="text-align: center;">只读，支持
<code>++</code>、<code>==</code>、<code>!=</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">输出迭代器</td>
<td style="text-align: center;">对数据的只写访问</td>
<td style="text-align: center;">只写，支持 <code>++</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">前向迭代器</td>
<td style="text-align: center;">读写操作，并能向前推进迭代器</td>
<td style="text-align: center;">读写，支持
<code>++</code>、<code>==</code>、<code>!=</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">双向迭代器</td>
<td style="text-align: center;">读写操作，并能向前和向后操作</td>
<td style="text-align: center;">读写，支持
<code>++</code>、<code>--</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">随机访问迭代器</td>
<td
style="text-align: center;">读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td>
<td style="text-align: center;">读写，支持
<code>++</code>、<code>--</code>、<code>[n]</code>、<code>-n</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code></td>
</tr>
</tbody>
</table>
<p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器。</p>
<h2 id="常用容器">常用容器</h2>
<h3 id="string-容器"><code>string</code> 容器</h3>
<p><code>char *</code> 是 C++ 风格的字符串，而 <code>string</code>
本质上是一个类。</p>
<p><strong><code>string</code> 和 <code>char *</code>
的区别：</strong></p>
<ul>
<li><code>char *</code> 是一个指针</li>
<li><code>string</code> 是一个类，类内部封装了
<code>char *</code>，管理这个字符串，是一个 <code>char *</code>
的容器。</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li><code>string</code> 类内部封装了很多成员方法，例如：查找
<code>find</code>，拷贝 <code>copy</code>，删除 <code>delete</code> 替换
<code>replace</code>，插入 <code>insert</code>.</li>
<li><code>string</code> 管理 <code>char *</code>
所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责。</li>
</ul>
<p><code>string</code> 容器的内置函数。</p>
<p><strong>构造函数：</strong></p>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 53%" />
<col style="width: 14%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数原型</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>string();</code></td>
<td style="text-align: center;">创建一个空的字符串</td>
<td style="text-align: center;"><code>string str;</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>string(const char* s);</code></td>
<td style="text-align: center;">使用字符串 s 初始化</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>string(const string&amp; str);</code></td>
<td style="text-align: center;">使用一个 <code>string</code>
对象初始化另一个 <code>string</code> 对象</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>string(int n, char c);</code></td>
<td style="text-align: center;">使用 n 个字符 c 初始化</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><code>string</code> 的多种构造方式没有可比性，灵活使用即可。</p>
<p><strong>string 赋值操作：</strong></p>
<table style="width:100%;">
<colgroup>
<col style="width: 54%" />
<col style="width: 41%" />
<col style="width: 4%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数原型</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>string&amp; operator=(const char* s);</code></td>
<td style="text-align: center;"><code>char *</code>
类型字符串赋值给当前字符串</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>string&amp; operator=(const string &amp;s);</code></td>
<td style="text-align: center;">把字符串 s 赋给当前字符串</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>string&amp; operator=(char c);</code></td>
<td style="text-align: center;">字符赋值给当前的字符串</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>string&amp; assign(const char *s);</code></td>
<td style="text-align: center;">把字符串 s 赋给当前的字符串</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>string&amp; assign(const char *s, int n);</code></td>
<td style="text-align: center;">把字符串 s 的前 n
个字符赋给当前的字符串</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>string&amp; assign(const string &amp;s);</code></td>
<td style="text-align: center;">把字符串 s 赋给当前字符串</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>string&amp; assign(int n, char c);</code></td>
<td style="text-align: center;">用 n 个字符 c 赋给当前字符串</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>string&amp; assign(const string &amp;s, int start, int n);</code></td>
<td style="text-align: center;">将 s 从 start 开始 n
个字符赋值给字符串</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>string</code> 的赋值方式很多，<code>operator=</code>
这种方式是比较实用的。</p>
</blockquote>
<p><strong>string 拼接操作：</strong></p>
<table>
<colgroup>
<col style="width: 48%" />
<col style="width: 47%" />
<col style="width: 3%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数原型</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>string&amp; operator+=(const char* str);</code></td>
<td style="text-align: center;">重载 <code>+=</code> 运算符</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>string&amp; operator+=(const char c);</code></td>
<td style="text-align: center;">重载 <code>+=</code> 运算符</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>string&amp; operator+=(const string&amp; str);</code></td>
<td style="text-align: center;">重载 <code>+=</code> 运算符</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>string&amp; append(const char *s);</code></td>
<td style="text-align: center;">把字符串 s 连接到当前字符串结尾</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>string&amp; append(const char *s, int n);</code></td>
<td style="text-align: center;">把字符串 s 的前 n
个字符连接到当前字符串结尾</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>string&amp; append(const string &amp;s);</code></td>
<td style="text-align: center;">同
<code>operator+=(const string&amp; str)</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>string&amp; append(const string &amp;s, int pos, int n);</code></td>
<td style="text-align: center;">字符串 s 中从 pos 开始的 n
个字符连接到字符串结尾</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>string&amp; append(int n, char c);</code></td>
<td style="text-align: center;">在当前字符串结尾添加 n 个字符 c</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>string 存取字符操作：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数原型</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>char&amp; operator[](int n);</code></td>
<td style="text-align: center;">通过 <code>[]</code> 方式取字符</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>char&amp; at(int n);</code></td>
<td style="text-align: center;">通过 <code>at()</code> 函数获取字符</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>string 查找和替换：</strong></p>
<table>
<colgroup>
<col style="width: 54%" />
<col style="width: 41%" />
<col style="width: 4%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数原型</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>int find(const string&amp; str, int pos = 0) const;</code></td>
<td style="text-align: center;">查找 str 第一次出现位置，从 pos
开始查找</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>int find(const char* s, int pos = 0) const;</code></td>
<td style="text-align: center;">查找 s 第一次出现位置,从 pos
开始查找</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>int find(const char* s, int pos, int n) const;</code></td>
<td style="text-align: center;">从 pos 位置查找 s 的前 n
个字符第一次位置</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>int find(const char c, int pos = 0) const;</code></td>
<td style="text-align: center;">查找字符 c 第一次出现位置</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>int rfind(const string&amp; str, int pos = npos) const;</code></td>
<td style="text-align: center;">查找 str 最后一次位置，从 pos
开始查找</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>int rfind(const char* s, int pos = npos) const;</code></td>
<td style="text-align: center;">查找 s 最后一次出现位置，从 pos
开始查找</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>int rfind(const char* s, int pos, int n) const;</code></td>
<td style="text-align: center;">从 pos 查找 s 的前 n
个字符最后一次位置</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>int rfind(const char c, int pos = 0) const;</code></td>
<td style="text-align: center;">查找字符 c 最后一次出现位置</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>string&amp; replace(int pos, int n, const string&amp; str);</code></td>
<td style="text-align: center;">替换从 pos 开始 n 个字符为字符串
str</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>string&amp; replace(int pos, int n, const char* s);</code></td>
<td style="text-align: center;">替换从 pos 开始的 n 个字符为字符串
s</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li><code>find</code> 查找是从左往后，<code>rfind</code> 从右往左</li>
<li><code>find</code> 找到字符串后返回查找的第一个字符位置，找不到返回
-1</li>
<li><code>replace</code>
在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li>
</ul>
</blockquote>
<p><strong>string 比较：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数原型</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>int compare(const string &amp;s) const;</code></td>
<td style="text-align: center;">与字符串 s 比较</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>int compare(const char *s) const;</code></td>
<td style="text-align: center;">与字符串 s 比较</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<blockquote>
<p>字符串比较是按字符的 ASCII 码进行对比：</p>
<ul>
<li>= 返回 0</li>
<li>&gt; 返回 1</li>
<li>&lt; 返回 -1</li>
</ul>
</blockquote>
<p><strong>string 插入和删除：</strong></p>
<table>
<colgroup>
<col style="width: 60%" />
<col style="width: 34%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数原型</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>string&amp; insert(int pos, const char* s);</code></td>
<td style="text-align: center;">插入字符串</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>string&amp; insert(int pos, const string&amp; str);</code></td>
<td style="text-align: center;">插入字符串</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>string&amp; insert(int pos, int n, char c);</code></td>
<td style="text-align: center;">在指定位置插入 n 个字符 c</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>string&amp; erase(int pos, int n = npos);</code></td>
<td style="text-align: center;">删除从 Pos 开始的 n 个字符</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>string 子串：</strong></p>
<table style="width:100%;">
<colgroup>
<col style="width: 53%" />
<col style="width: 41%" />
<col style="width: 4%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数原型</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>string substr(int pos = 0, int n = npos) const;</code></td>
<td style="text-align: center;">返回从 pos 开始的 n
个字符组成的字符串</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>string 和 c-style 字符串转换：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//string 转 char*</span></span><br><span class="line">string str = <span class="string">&quot;lxr&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cstr = str.<span class="built_in">c_str</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//char* 转 string</span></span><br><span class="line"><span class="type">char</span>* s = <span class="string">&quot;itcast&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(s)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 c++中存在 <code>const char *</code> 到 <code>string</code>
的隐式类型转换，不存在从 <code>string</code> 对象到
<code>c-string</code> 的自动类型转换。对于 <code>string</code>
类型的字符串，可以通过 <code>c_str()</code> 成员函数，返回
<code>string</code> 对象对应的 <code>c-string</code>.</p>
<p>为了修改 <code>string</code> 字符串的内容，可以使用下标操作符 [] 或
at，它们都会返回字符的引用，但当字符串的内存被重新分配之后，可能发生错误。</p>
</blockquote>
<h3 id="vector-容器"><code>vector</code> 容器</h3>
<p>vector 数据结构和<strong>数组非常相似</strong>。</p>
<p><strong>vector
与普通数组区别：</strong>不同之处在于数组是静态空间，而
<code>vector</code> 可以<strong>动态扩容</strong>。</p>
<p><strong>动态扩展：</strong>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间。</p>
<p><code>vector</code> 容器的迭代器是支持随机访问的迭代器。</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/8a08605d-92ee-417a-915f-b16622df34f4"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p><strong>vector 构造函数：</strong></p>
<table>
<colgroup>
<col style="width: 37%" />
<col style="width: 57%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>vector&lt;T&gt; v;</code></td>
<td style="text-align: center;">采用模板实现类实现，默认构造函数</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>vector(v.begin(), v.end());</code></td>
<td style="text-align: center;">将 <code>v[begin(), end())</code>
区间中的元素拷贝给本身</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>vector(n, elem);</code></td>
<td style="text-align: center;">构造函数将 n 个 elem 拷贝给本身</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>vector(const vector &amp;vec);</code></td>
<td style="text-align: center;">拷贝构造函数</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>vector 赋值操作：</strong></p>
<table>
<colgroup>
<col style="width: 45%" />
<col style="width: 49%" />
<col style="width: 4%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>vector&amp; operator=(const vector &amp;vec);</code></td>
<td style="text-align: center;">重载等号操作符</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>assign(beg, end);</code></td>
<td style="text-align: center;">将 <code>[beg, end)</code>
区间中的数据拷贝赋值给本身</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>assign(n, elem);</code></td>
<td style="text-align: center;">将 n 个 elem 拷贝赋值给本身</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>vector 容量和大小：</strong></p>
<table style="width:100%;">
<colgroup>
<col style="width: 27%" />
<col style="width: 68%" />
<col style="width: 4%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>size();</code></td>
<td style="text-align: center;">返回容器中元素的个数</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>empty();</code></td>
<td style="text-align: center;">判断容器是否为空</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>capacity();</code></td>
<td style="text-align: center;">容器的容量</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>resize(int num);</code></td>
<td style="text-align: center;">重新指定容器的长度为
num，若容器变长，则以默认值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>resize(int num, elem);</code></td>
<td style="text-align: center;">重新指定容器的长度为
num，若容器变长，则以 elem
值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>vector 数据存取操作：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>at(int idx);</code></td>
<td style="text-align: center;">返回索引 idx 所指的数据</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>operator[];</code></td>
<td style="text-align: center;">返回索引 idx 所指的数据</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>front();</code></td>
<td style="text-align: center;">返回容器中第一个数据元素</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>back();</code></td>
<td style="text-align: center;">返回容器中最后一个数据元素</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>vector 插入和删除：</strong></p>
<table style="width:100%;">
<colgroup>
<col style="width: 53%" />
<col style="width: 42%" />
<col style="width: 4%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>push_back(ele);</code></td>
<td style="text-align: center;">尾部插入元素 ele</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>pop_back();</code></td>
<td style="text-align: center;">删除最后一个元素</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>insert(const_iterator pos, ele);</code></td>
<td style="text-align: center;">迭代器指向位置 pos 插入元素 ele</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>insert(const_iterator pos, int count, ele);</code></td>
<td style="text-align: center;">迭代器指向位置 pos 插入 count 个元素
ele</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>erase(const_iterator pos);</code></td>
<td style="text-align: center;">删除迭代器指向的元素</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>erase(const_iterator start, const_iterator end);</code></td>
<td style="text-align: center;">删除迭代器从 start 到 end
之间的元素</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>clear();</code></td>
<td style="text-align: center;">删除容器中所有元素</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>vector 互换容器：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>swap(vec);</code></td>
<td style="text-align: center;">将 vec 与本身的元素互换</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>swap</code> 可以使两个容器互换，可以达到收缩内存的效果。</p>
</blockquote>
<p><strong>vector 预留空间：</strong></p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 71%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>reserve(int len);</code></td>
<td style="text-align: center;">容器预留 len
个元素长度，预留位置不初始化，元素不可访问。</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<blockquote>
<p>如果数据量较大，可以一开始利用 <code>reserve</code> 预留空间。</p>
</blockquote>
<h3 id="deque-容器"><code>deque</code> 容器</h3>
<p>双端数组，可以对头端进行插入删除操作</p>
<p><strong>deque 与 vector 区别：</strong></p>
<ul>
<li><code>vector</code>
对于头部的插入删除效率低，数据量越大，效率越低</li>
<li><code>deque</code> 相对而言，对头部的插入删除速度回比 vector 快</li>
<li><code>vector</code> 访问元素时的速度会比 deque
快，这和两者内部实现有关</li>
</ul>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/4a454687-deac-4040-8c49-beb1a395e681"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p><code>deque</code> 内部工作原理:</p>
<p><code>deque</code>
内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据，中控器维护的是每个缓冲区的地址，使得使用
<code>deque</code> 时像一片连续的内存空间。</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/ced135ee-5483-4f88-97be-3c4d3b530d54"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p><code>deque</code> 容器的迭代器也是支持随机访问的。</p>
<p><strong>deque 构造函数：</strong></p>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 60%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>deque&lt;T&gt;</code></td>
<td style="text-align: center;">默认构造形式</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>deque(beg, end);</code></td>
<td style="text-align: center;">构造函数将 <code>[beg, end)</code>
区间中的元素拷贝给本身</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>deque(n, elem);</code></td>
<td style="text-align: center;">构造函数将 n 个 elem 拷贝给本身</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>deque(const deque &amp;deq);</code></td>
<td style="text-align: center;">拷贝构造函数</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>deque 赋值操作：</strong></p>
<table>
<colgroup>
<col style="width: 44%" />
<col style="width: 50%" />
<col style="width: 4%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>deque&amp; operator=(const deque &amp;deq);</code></td>
<td style="text-align: center;">重载等号操作符</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>assign(beg, end);</code></td>
<td style="text-align: center;">将 <code>[beg, end)</code>
区间中的数据拷贝赋值给本身</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>assign(n, elem);</code></td>
<td style="text-align: center;">将 n 个 elem 拷贝赋值给本身</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>deque 互换容器：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>swap(deq);</code></td>
<td style="text-align: center;">将 deq 与本身的元素互换</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>deque 大小操作：</strong></p>
<table style="width:100%;">
<colgroup>
<col style="width: 28%" />
<col style="width: 66%" />
<col style="width: 4%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>deque.empty();</code></td>
<td style="text-align: center;">判断容器是否为空</td>
<td></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>deque.size();</code></td>
<td style="text-align: center;">返回容器中元素的个数</td>
<td></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>deque.resize(num);</code></td>
<td style="text-align: center;">重新指定容器的长度为
num，若容器变长，则以默认值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除</td>
<td></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>deque.resize(num, elem);</code></td>
<td style="text-align: center;">重新指定容器的长度为
num，若容器变长，则以 elem
值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>deque 双端插入和删除操作：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>push_back(elem);</code></td>
<td style="text-align: center;">在容器尾部添加一个数据</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>push_front(elem);</code></td>
<td style="text-align: center;">在容器头部插入一个数据</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>pop_back();</code></td>
<td style="text-align: center;">删除容器最后一个数据</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>pop_front();</code></td>
<td style="text-align: center;">删除容器第一个数据</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>deque 插入和删除操作：</strong></p>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 67%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>insert(pos,elem);</code></td>
<td style="text-align: center;">在 pos 位置插入一个 elem
元素的拷贝，返回新数据的位置</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>insert(pos, n,elem);</code></td>
<td style="text-align: center;">在 pos 位置插入 n 个 elem
数据，无返回值</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>insert(pos,beg,end);</code></td>
<td style="text-align: center;">在 pos 位置插入 <code>[beg,end)</code>
区间的数据，无返回值</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>clear();</code></td>
<td style="text-align: center;">清空容器的所有数据</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>erase(beg,end);</code></td>
<td style="text-align: center;">删除 <code>[beg,end)</code>
区间的数据，返回下一个数据的位置</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>erase(pos);</code></td>
<td style="text-align: center;">删除 pos
位置的数据，返回下一个数据的位置。</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>deque 数据存取：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>at(int idx);</code></td>
<td style="text-align: center;">返回索引 idx 所指的数据</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>operator[];</code></td>
<td style="text-align: center;">返回索引 idx 所指的数据</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>front();</code></td>
<td style="text-align: center;">返回容器中第一个数据元素</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>back();</code></td>
<td style="text-align: center;">返回容器中最后一个数据元素</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h3 id="stack-容器"><code>stack</code> 容器</h3>
<p><code>stack</code> 没有迭代器。</p>
<p><strong>stack 构造器：</strong></p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 61%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>stack&lt;T&gt; stk;</code></td>
<td style="text-align: center;">stack 采用模板类实现， stack
对象的默认构造形式</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>stack(const stack &amp;stk);</code></td>
<td style="text-align: center;">拷贝构造函数</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>stack 赋值操作：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>stack&amp; operator=(const stack &amp;stk);</code></td>
<td style="text-align: center;">重载等号操作符</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>stack 数据存取：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>push(elem);</code></td>
<td style="text-align: center;">向栈顶添加元素</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>pop();</code></td>
<td style="text-align: center;">从栈顶移除第一个元素</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>top();</code></td>
<td style="text-align: center;">返回栈顶元素</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>stack 大小操作：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>empty();</code></td>
<td style="text-align: center;">判断栈是否为空</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>size();</code></td>
<td style="text-align: center;">回栈的大小</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h3 id="queue-容器"><code>queue</code> 容器</h3>
<p>队列是一种 <a
href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)">FIFO</a>
的数据结构。</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/10400176-5ec1-48c4-abd6-56ba7ada0ee7"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>队列容器允许从一端新增元素，从另一端移除元素。</p>
<p>队列中只有队头和队尾才可以被外界使用，因此队列没有迭代器。</p>
<p><strong>queue 构造函数：</strong></p>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 60%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>queue&lt;T&gt; que;</code></td>
<td style="text-align: center;">queue 采用模板类实现，queue
对象的默认构造形式</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>queue(const queue &amp;que);</code></td>
<td style="text-align: center;">拷贝构造函数</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>queue 赋值操作：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>queue&amp; operator=(const queue &amp;que);</code></td>
<td style="text-align: center;">重载等号操作符</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>queue 数据存取：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>push(elem);</code></td>
<td style="text-align: center;">往队尾添加元素</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>pop();</code></td>
<td style="text-align: center;">从队头移除第一个元素</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>back();</code></td>
<td style="text-align: center;">返回最后一个元素</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>front();</code></td>
<td style="text-align: center;">返回第一个元素</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>queue 大小操作：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>empty();</code></td>
<td style="text-align: center;">判断堆栈是否为空</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>size();</code></td>
<td style="text-align: center;">返回栈的大小</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h3 id="list-容器"><code>list</code> 容器</h3>
<p>STL 中的链表是一个双向循环链表</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/6fc56009-08b2-4ca6-95d7-8143e9a1deeb"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>由于链表的存储方式并不是连续的内存空间，因此链表 <code>list</code>
中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong>。</p>
<p><code>list</code> 的优点：</p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
</ul>
<p><code>list</code> 的缺点：</p>
<ul>
<li>链表灵活，但是空间和时间额外耗费较大。</li>
</ul>
<p><code>list</code> 有一个重要的性质，插入操作和删除操作都不会造成原有
<code>list</code> 迭代器的失效。</p>
<p><strong>list 构造函数：</strong></p>
<table>
<colgroup>
<col style="width: 32%" />
<col style="width: 62%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>list&lt;T&gt; lst;</code></td>
<td style="text-align: center;"><code>list</code>
采用采用模板类实现，对象的默认构造形式</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>list(beg,end);</code></td>
<td style="text-align: center;">构造函数将 <code>[beg, end)</code>
区间中的元素拷贝给本身</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>list(n,elem);</code></td>
<td style="text-align: center;">构造函数将 n 个 elem 拷贝给本身</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>list(const list &amp;lst);</code></td>
<td style="text-align: center;">拷贝构造函数</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>list 赋值和交换：</strong></p>
<table>
<colgroup>
<col style="width: 43%" />
<col style="width: 51%" />
<col style="width: 4%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>assign(beg, end);</code></td>
<td style="text-align: center;">将 <code>[beg, end)</code>
区间中的数据拷贝赋值给本身</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>assign(n, elem);</code></td>
<td style="text-align: center;">将 n 个 elem 拷贝赋值给本身</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>list&amp; operator=(const list &amp;lst);</code></td>
<td style="text-align: center;">重载等号操作符</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>swap(lst);</code></td>
<td style="text-align: center;">将 lst 与本身的元素互换</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>list 大小操作：</strong></p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 71%" />
<col style="width: 4%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>size();</code></td>
<td style="text-align: center;">返回容器中元素的个数</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>empty();</code></td>
<td style="text-align: center;">判断容器是否为空</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>resize(num);</code></td>
<td style="text-align: center;">重新指定容器的长度为
num，若容器变长，则以默认值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>resize(num, elem);</code></td>
<td style="text-align: center;">重新指定容器的长度为
num，若容器变长，则以 elem
值填充新位置；如果容器变短，则末尾超出容器长度的元素被删除</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>list 插入和删除：</strong></p>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 63%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>push_back(elem);</code></td>
<td style="text-align: center;">在容器尾部加入一个元素</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>pop_back();</code></td>
<td style="text-align: center;">删除容器中最后一个元素</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>push_front(elem);</code></td>
<td style="text-align: center;">在容器开头插入一个元素</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>pop_front();</code></td>
<td style="text-align: center;">从容器开头移除第一个元素</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>insert(pos, elem);</code></td>
<td style="text-align: center;">在 pos 位置插 elem
元素的拷贝，返回新数据的位置</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>insert(pos, n, elem);</code></td>
<td style="text-align: center;">在 pos 位置插入 n 个 elem
数据，无返回值</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>insert(pos, beg, end);</code></td>
<td style="text-align: center;">在 pos 位置插入 <code>[beg,end)</code>
区间的数据，无返回值</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>clear();</code></td>
<td style="text-align: center;">移除容器的所有数据</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>erase(beg, end);</code></td>
<td style="text-align: center;">删除 <code>[beg,end)</code>
区间的数据，返回下一个数据的位置</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>erase(pos);</code></td>
<td style="text-align: center;">删除 pos
位置的数据，返回下一个数据的位置</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>remove(elem);</code></td>
<td style="text-align: center;">删除容器中所有与 elem 值匹配的元素</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>list 数据存取：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>front();</code></td>
<td style="text-align: center;">返回第一个元素</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>back();</code></td>
<td style="text-align: center;">返回最后一个元素</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>list</code> 容器中不可以通过 <code>[]</code> 或者
<code>at</code> 方式访问数据。</p>
</blockquote>
<p><strong>list 反转和排序：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>reverse();</code></td>
<td style="text-align: center;">反转链表</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>sort();</code></td>
<td style="text-align: center;">链表排序</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h3 id="set-multiset-容器"><code>set / multiset</code> 容器</h3>
<p><code>set</code>：</p>
<ul>
<li>所有元素都会根据元素的键值自动被排序</li>
<li>不允许两个元素有相同的值</li>
<li>不可以通过 <code>set</code> 的迭代器改变 <code>set</code>
元素的值</li>
<li><code>set</code> 的 <code>iterator</code> 是一种
<code>const_iterator</code></li>
<li>当对容器中的元素进行插入操作或者删除操作的时候，操作之前所有的迭代器，在操作完成之后依然有效。</li>
</ul>
<p><code>multiset</code>：特性及用法和 set
完全相同，唯一的差别在于它允许键值重复。</p>
<p><code>set</code> 和 <code>multiset</code> 的底层实现是<a
href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a>。</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/c3db04d9-0269-432a-8082-a50bbe5807aa"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p><strong>set 构造函数：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>set&lt;T&gt; st;</code></td>
<td style="text-align: center;">默认构造函数</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>set(const set &amp;st);</code></td>
<td style="text-align: center;">拷贝构造函数</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>set 赋值和交换操作：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>set&amp; operator=(const set &amp;st);</code></td>
<td style="text-align: center;">重载等号操作符</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>swap(st);</code></td>
<td style="text-align: center;">交换两个集合容器</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>set 大小操作：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>size();</code></td>
<td style="text-align: center;">返回容器中元素的数目</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>empty();</code></td>
<td style="text-align: center;">判断容器是否为空</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>swap(st);</code></td>
<td style="text-align: center;">交换两个集合容器</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>set 插入和删除操作：</strong></p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 71%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>insert(elem);</code></td>
<td style="text-align: center;">在容器中插入元素</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>clear();</code></td>
<td style="text-align: center;">清除所有元素</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>erase(pos);</code></td>
<td style="text-align: center;">删除 pos
迭代器所指的元素，返回下一个元素的迭代器</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>erase(beg, end);</code></td>
<td style="text-align: center;">删除区间 <code>[beg,end)</code>
的所有元素 ，返回下一个元素的迭代器</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>erase(elem);</code></td>
<td style="text-align: center;">删除容器中值为 elem 的元素</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>set 查找和统计：</strong></p>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 68%" />
<col style="width: 4%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>find(key);</code></td>
<td style="text-align: center;">查找 key
是否存在，若存在，返回该键的元素的迭代器；若不存在，返回
<code>set.end();</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>count(key);</code></td>
<td style="text-align: center;">统计 key 的元素个数</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>lower_bound(keyElem);</code></td>
<td style="text-align: center;">返回第一个 key&gt;=keyElem
元素的迭代器</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>upper_bound(keyElem);</code></td>
<td style="text-align: center;">返回第一个 key&gt;keyElem
元素的迭代器。</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>equal_range(keyElem);</code></td>
<td style="text-align: center;">返回容器中 key 与 keyElem
相等的上下限的两个迭代器。</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h3 id="pair"><code>pair</code></h3>
<p><strong>两种创建方式：</strong></p>
<ul>
<li><code>pair&lt;type, type&gt; p(value1, value2);</code></li>
<li><code>pair&lt;type, type&gt; p = make_pair(value1, value2);</code></li>
</ul>
<h3 id="map-multimap-容器"><code>map / multimap</code> 容器</h3>
<ul>
<li><p>map 中所有元素都是 pair</p></li>
<li><p>pair 中第一个元素为 key（键值），起到索引作用，第二个元素为
value</p></li>
<li><p>所有元素都会根据元素的键值自动排序</p></li>
<li><p><code>map / multimap</code>
属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</p></li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>可以根据 key 值快速找到 value 值</li>
</ul>
<p><code>map</code> 和 <code>multimap</code> <strong>区别</strong>：</p>
<ul>
<li><code>map</code> 不允许容器中有重复 key 值元素</li>
<li><code>multimap</code> 允许容器中有重复 key 值元素</li>
</ul>
<p><strong>map 构造函数：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>map&lt;T1, T2&gt; mp;</code></td>
<td style="text-align: center;">默认构造函数</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>map(const map &amp;mp);</code></td>
<td style="text-align: center;">拷贝构造函数</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>map 赋值操作：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>map&amp; operator=(const map &amp;mp);</code></td>
<td style="text-align: center;">重载等号操作符</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>map 大小和交换操作：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>size();</code></td>
<td style="text-align: center;">返回容器中元素的数目</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>empty();</code></td>
<td style="text-align: center;">判断容器是否为空</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>swap(st);</code></td>
<td style="text-align: center;">交换两个集合容器</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>map 插入数据元素操作：</strong></p>
<table>
<colgroup>
<col style="width: 24%" />
<col style="width: 70%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>insert(elem);</code></td>
<td style="text-align: center;">在容器中插入元素</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>operator[](elem);</code></td>
<td style="text-align: center;">在容器中插入元素</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>clear();</code></td>
<td style="text-align: center;">清除所有元素</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>erase(pos);</code></td>
<td style="text-align: center;">删除 pos
迭代器所指的元素，返回下一个元素的迭代器</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>erase(beg, end);</code></td>
<td style="text-align: center;">删除区间 <code>[beg,end)</code>
的所有元素 ，返回下一个元素的迭代器</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>erase(key);</code></td>
<td style="text-align: center;">删除容器中值为 key 的元素</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>map 查找和统计：</strong></p>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 68%" />
<col style="width: 4%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>find(key);</code></td>
<td style="text-align: center;">查找 key
是否存在，若存在，返回该键的元素的迭代器；若不存在，返回
<code>set.end()</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>operator[](key);</code></td>
<td style="text-align: center;">查找 key
是否存在，若存在，返回该键的元素的迭代器；若不存在，返回
<code>set.end()</code></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>count(key);</code></td>
<td style="text-align: center;">统计 key 的元素个数</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>lower_bound(keyElem);</code></td>
<td style="text-align: center;">返回第一个 key&gt;=keyElem
元素的迭代器</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>upper_bound(keyElem);</code></td>
<td style="text-align: center;">返回容器中 key 与 keyElem
相等的上下限的两个迭代器</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<h3 id="总结">总结</h3>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/003ac080-8c9e-44b2-b257-dec25f5de084"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/f8665a43-82eb-4b82-a947-233bccaa7151"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="函数对象">函数对象</h2>
<p>就是重载了 <code>()</code> 运算符类的实例。</p>
<p>亦称仿函数。</p>
<p>本质是一个对象，不是一个函数。</p>
<p>根据重载 <code>operator()</code>
时的形参个数可分为：一元仿函数、二元仿函数。</p>
<p>函数对象在调用时跟普通函数一样。</p>
<p>函数对象不同于普通函数，函数对象有自己的状态。</p>
<p>函数对象可作为参数传递。</p>
<p>函数对象通常不定义构造函数和析构函数，所以在构造和析构时不会发生任何问题，避免了函数调用的运行时问题。</p>
<p>函数对象可内联编译，性能好，函数指针几乎不可能。</p>
<p>模版函数对象使函数对象具有通用性。</p>
<p><strong>示例:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123; <span class="keyword">return</span> v1 + v2; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyAdd myAdd;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">myAdd</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyPrint</span>() &#123; count = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">        count++; <span class="comment">// 统计使用次数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count; <span class="comment">// 内部自己的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyPrint myPrint;</span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp, string test)</span> </span>&#123; <span class="built_in">mp</span>(test); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyPrint myPrint;</span><br><span class="line">    <span class="built_in">doPrint</span>(myPrint, <span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/c48cbfae-7b10-4b01-952c-be54233c0a2d"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="谓词">谓词</h3>
<ul>
<li>返回值类型为 <code>boo</code>l
类型的仿函数称为<strong>谓词</strong></li>
<li>如果 <code>operator()</code> 接受一个参数，为一元谓词</li>
<li>如果 <code>operator()</code> 接受两个参数，为二元谓词</li>
</ul>
<p><strong>一元谓词示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一元谓词</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterFive</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; <span class="keyword">return</span> val &gt; <span class="number">5</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line">    <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/82042860-dc78-4360-9d38-10480f0860e7"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p><strong>二元谓词示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二元谓词</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123; <span class="keyword">return</span> num1 &gt; num2; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认从小到大</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> &amp;i) &#123; cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> &amp;i) &#123; cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/a9aff19d-0ea7-49e9-b964-f31bbcf1860f"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="内建函数对象">内建函数对象</h3>
<ul>
<li><p>算术仿函数</p></li>
<li><p>关系仿函数</p></li>
<li><p>逻辑仿函数</p></li>
</ul>
<p><strong>用法：</strong></p>
<ul>
<li>这些仿函数所产生的对象，用法和一般函数完全相同</li>
<li>使用内建函数对象，需要引入头文件
<code>#include&lt;functional&gt;</code></li>
</ul>
<p><strong>算术仿函数</strong></p>
<ul>
<li>实现四则运算</li>
<li>其中 negate 是一元运算，其他都是二元运算</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">仿函数原型</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>template&lt;class T&gt; T plus&lt;T&gt;</code></td>
<td style="text-align: center;">加法仿函数</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>template&lt;class T&gt; T minus&lt;T&gt;</code></td>
<td style="text-align: center;">减法仿函数</td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code></td>
<td style="text-align: center;">乘法仿函数</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>template&lt;class T&gt; T divides&lt;T&gt;</code></td>
<td style="text-align: center;">除法仿函数</td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>template&lt;class T&gt; T modulus&lt;T&gt;</code></td>
<td style="text-align: center;">取模仿函数</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>template&lt;class T&gt; T negate&lt;T&gt;</code></td>
<td style="text-align: center;">取反仿函数</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// negate</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    negate&lt;<span class="type">int</span>&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">n</span>(<span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// plus</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    plus&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/277d29fc-ef61-4c1c-af40-d4a2cb676650"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p><strong>关系仿函数：</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">仿函数原型</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code></td>
<td style="text-align: center;">等于</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code></td>
<td style="text-align: center;">不等于</td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>template&lt;class T&gt; bool greater&lt;T&gt;</code></td>
<td style="text-align: center;">大于</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code></td>
<td style="text-align: center;">大于等于</td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>template&lt;class T&gt; bool less&lt;T&gt;</code></td>
<td style="text-align: center;">小于</td>
</tr>
<tr class="even">
<td style="text-align: center;">template<class T> bool
less_equal<T>`</td>
<td style="text-align: center;">小于等于</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">10</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> &amp;i) &#123; cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> &amp;i) &#123; cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/d2ce0b9f-1791-4eb2-9fe4-59ee568092f5"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p><strong>逻辑仿函数：</strong></p>
<p>逻辑运算类运算函数，<code>not</code> 为一元运算，其余为二元运算。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">仿函数原型</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code></td>
<td style="text-align: center;">逻辑与</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code></td>
<td style="text-align: center;">逻辑或</td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code></td>
<td style="text-align: center;">逻辑非</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; v&#123;<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="type">bool</span> &amp;b) &#123; cout &lt;&lt; b &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span></span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; v2;</span><br><span class="line">    v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), <span class="built_in">logical_not</span>&lt;<span class="type">bool</span>&gt;());</span><br><span class="line"></span><br><span class="line">    for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="type">bool</span> &amp;b) &#123; cout &lt;&lt; b &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/9d50a19b-9eb0-4b86-a91f-29dd562a9586"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="适配器">适配器</h2>
<p>用来适配参数，扩展参数接口，一般结合仿函数一起使用。</p>
<h3 id="函数对象适配器">函数对象适配器</h3>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一元继承public unary_function&lt;参数1 ,返回值类型&gt;</span></span><br><span class="line"><span class="comment">// 二元继承public binary_function&lt;int,int,void&gt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Print</span> : <span class="keyword">public</span> binary_function&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> num)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; a + num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定参数 bind2nd</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">Print</span>(), <span class="number">200</span>));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// bind1st</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind1st</span>(<span class="built_in">Print</span>(), <span class="number">200</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/bc636f64-cd86-4c91-9786-ae5067b13651"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="取反适配器">取反适配器</h3>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// not1 一元取反</span></span><br><span class="line">    <span class="comment">// not2 二元取反</span></span><br><span class="line">    <span class="comment">// vector&lt;int&gt;::iterator it = find_if(v.begin(),v.end(), not1(greater2()));</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it =</span><br><span class="line">        <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not2</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()));</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="type">int</span> &amp;a) &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/127acbc6-70b3-4143-900a-9ee582f3d4e9"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="函数指针适配器">函数指针适配器</h3>
<p>将函数指针适配成函数对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> num)</span> </span>&#123; cout &lt;&lt; a + num &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要将函数指针print适配成函数对象</span></span><br><span class="line">    <span class="comment">// ptr_fun 将函数指针适配成函数对象</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">ptr_fun</span>(print), <span class="number">200</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/af1de132-03f0-41c0-aa99-a6e0fdd293d8"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="成员函数适配器">成员函数适配器</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">        m_Name = name;</span><br><span class="line">        m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;成员函数:&quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Plus100</span><span class="params">()</span> </span>&#123; m_Age += <span class="number">100</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;Person *&gt; v1;</span><br><span class="line">    <span class="comment">// 创建数据</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    v1.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">    v1.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line"></span><br><span class="line">    for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">mem_fun</span>(&amp;Person::ShowPerson));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;Person&gt; v;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">    v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">    <span class="comment">// mem_fun_ref 将Person的成员函数适配成 普通回调函数</span></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">mem_fun_ref</span>(&amp;Person::ShowPerson));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/69eff3b3-029c-4124-b556-f2f71a8466b9"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="常用算法">常用算法</h2>
<ul>
<li><p>算法主要是由头文件 <code>&lt;algorithm&gt;</code>、
<code>&lt;functional&gt;</code>、 <code>&lt;numeric&gt;</code>
组成。</p></li>
<li><p><code>&lt;algorithm&gt;</code> 是所有 STL
头文件中最大的一个，范围涉及到比较、
交换、查找、遍历操作、复制、修改等等。</p></li>
<li><p><code>&lt;numeric&gt;</code>
体积很小，只包括几个在序列上面进行简单数学运算的模板函数。</p></li>
<li><p><code>&lt;functional&gt;</code>
定义了一些模板类，用以声明函数对象。</p></li>
</ul>
<h3 id="常用遍历算法">常用遍历算法</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">算法</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>for_each(iterator beg, iterator end, _callback);</code></td>
<td
style="text-align: center;">遍历算法<br /><code>beg</code>：开始迭代器<br /><code>end</code>：结束迭代器<br /><code>callback</code>：回调函数或函数对象<br />返回值：函数对象，即
<code>callback</code> 参数指向的函数对象</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>transform(iterator beg1, iterator end1, iterator beg2, _callbakc);</code></td>
<td
style="text-align: center;">将指定容器区间元素搬运到另一容器中<br /><code>beg1</code>：源容器开始迭代器<br /><code>end1</code>：源容器结束迭代器<br /><code>beg2</code>：目标容器开始迭代器<br /><code>_callbakc</code>：回调函数或函数对象<br />返回值：返回目标容器迭代器</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"></span><br><span class="line">    v1.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), [](<span class="type">const</span> <span class="type">int</span> &amp;a) &#123; <span class="keyword">return</span> a; &#125;);</span><br><span class="line"></span><br><span class="line">    for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="type">int</span> &amp;a) &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/9ee06748-2504-4d1c-9e2b-18c1988de2fa"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="常用查找算法">常用查找算法</h3>
<table>
<colgroup>
<col style="width: 48%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">算法</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>find(iterator beg, iterator end, value);</code></td>
<td
style="text-align: center;">查找元素<br /><code>beg</code>：容器开始迭代器<br /><code>end</code>：容器结束迭代器<br /><code>value</code>：查找的元素<br />返回值：返回查找元素的位置</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>find_if(iterator beg, iterator end, _callback);</code></td>
<td
style="text-align: center;">按条件查找元素<br /><code>beg</code>：容器开始迭代器<br /><code>end</code>：容器结束迭代器<br /><code>callback</code>：回调函数或者谓词<br />返回值：找到返回
<code>true</code>，否则 <code>false</code></td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>adjacent_find(iterator beg, iterator end, _callback);</code></td>
<td
style="text-align: center;">查找相邻重复元素<br /><code>beg</code>：容器开始迭代器<br /><code>end</code>：容器结束迭代器<br /><code>_callback</code>：回调函数或者谓词<br />返回值：返回相邻元素的第一个位置的迭代器</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>bool binary_search(iterator beg, iterator end, value);</code></td>
<td
style="text-align: center;">二分查找法<br />注意：在无序序列中不可用<br /><code>beg</code>：容器开始迭代器<br /><code>end</code>：容器结束迭代器<br /><code>value</code>：查找的元素<br />返回值：找到返回
<code>true</code>，否则 <code>false</code></td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>count(iterator beg, iterator end, value);</code></td>
<td
style="text-align: center;">统计元素个数<br /><code>beg</code>：容器开始迭代器<br /><code>end</code>：容器结束迭代器<br /><code>value</code>：统计的元素<br />返回值：返回元素个数</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>count_if(iterator beg, iterator end, _callback);</code></td>
<td
style="text-align: center;">统计元素个数按条件统计元素个数<br /><code>beg</code>：容器开始迭代器<br /><code>end</code>：容器结束迭代器<br /><code>_callback</code>：回调函数或者谓词<br />返回值：返回元素个数</td>
</tr>
</tbody>
</table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">compare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; b % <span class="number">2</span> == <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> a) &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    it = <span class="built_in">adjacent_find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">compare</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">3</span>))</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/87eaeef8-e174-44b5-b0e4-14c4b8cba7cc"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="常用排序算法">常用排序算法</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">算法</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></td>
<td
style="text-align: center;">容器元素合并，并存储到另一容器中<br />注意：两个容器必须是有序的<br /><code>beg1</code>：容器
1 开始迭代器<br /><code>end1</code>：容器 1
结束迭代器<br /><code>beg2</code>：容器 2
开始迭代器<br /><code>end2</code>：容器 2
结束迭代器<br /><code>dest</code>：目标容器开始迭代器</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>sort(iterator beg, iterator end, _callback);</code></td>
<td style="text-align: center;">容器元素排序<br /><code>beg</code>：容器
1 开始迭代器<br /><code>end</code>：容器 1
结束迭代器<br /><code>_callback</code>：回调函数或者谓词</td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>random_shuffle(iterator beg, iterator end);</code></td>
<td
style="text-align: center;">对指定范围内的元素随机调整次序<br /><code>beg</code>：容器开始迭代器<br /><code>end</code>：容器结束迭代器</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>reverse(iterator beg, iterator end);</code></td>
<td
style="text-align: center;">反转指定范围的元素<br /><code>beg</code>：容器开始迭代器<br /><code>end</code>：容器结束迭代器</td>
</tr>
</tbody>
</table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"></span><br><span class="line">    v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>() + v1.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">merge</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), [](<span class="type">int</span> a) &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// random_shuffle(v.begin(),v.end());</span></span><br><span class="line">    <span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> a) &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/1aaa134a-0a60-465c-bf63-92c42e0723ba"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="常用拷贝和替换算法">常用拷贝和替换算法</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">算法</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>copy(iterator beg, iterator end, iterator dest);</code></td>
<td
style="text-align: center;">将容器内指定范围的元素拷贝到另一容器中<br />beg：容器开始迭代器<br />end：容器结束迭代器<br />dest：目标起始迭代器</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>replace(iterator beg, iterator end, oldvalue, newvalue);</code></td>
<td
style="text-align: center;">将容器内指定范围的旧元素修改为新元素<br />beg：容器开始迭代器<br />end：容器结束迭代器<br />oldvalue：旧元素<br />
newvalue：新元素</td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>replace_if(iterator beg, iterator end, _callback, newvalue);</code></td>
<td
style="text-align: center;">将容器内指定范围满足条件的元素替换为新元素<br /><code>beg</code>：容器开始迭代器<br /><code>end</code>：容器结束迭代器<br /><code>callback</code>：函数回调或者谓词<br /><code>newvalue</code>：新元素</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>swap(container c1, container c2);</code></td>
<td style="text-align: center;">互换两个容器的元素<br />
<code>c1</code>：容器 1<br /> <code>c1</code>：容器 2</td>
</tr>
</tbody>
</table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">greater10</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; <span class="keyword">return</span> a &gt; <span class="number">2</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// copy(v.begin(),v.end(),v2.begin());</span></span><br><span class="line">    <span class="comment">// replace(v.begin(), v.end(), 3, 10);</span></span><br><span class="line">    <span class="built_in">replace_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater10</span>(), <span class="number">10</span>);</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> a) &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(v, v2);</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> a) &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/e7e7c18a-4042-45a0-af61-4b69cb2bc2d3"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="常用算术生成算法">常用算术生成算法</h3>
<table>
<colgroup>
<col style="width: 44%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">算法</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>accumulate(iterator beg, iterator end, value);</code></td>
<td
style="text-align: center;">计算容器元素累计总和<br /><code>beg</code>：容器开始迭代器<br />
<code>end</code>：容器结束迭代器<br /><code>value</code>：起始值</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>fill(iterator beg, iterator end, value);</code></td>
<td
style="text-align: center;">向容器中添加元素<br /><code>beg</code>：容器开始迭代器<br />
<code>end</code>：容器结束迭代器<br /><code>value</code>：填充元素</td>
</tr>
</tbody>
</table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fill</span>(v.<span class="built_in">begin</span>() + <span class="number">2</span>, v.<span class="built_in">end</span>(), <span class="number">20</span>);</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> a) &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/e0d8973f-3518-4031-b2db-3d1e2aedb4a0"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="常用集合算法">常用集合算法</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">算法</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td
style="text-align: center;"><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></td>
<td style="text-align: center;">求两个 set
的交集<br /><code>beg1</code>：容器 1
开始迭代器<br /><code>end1</code>：容器 1
结束迭代器<br /><code>beg2</code>：容器 2
开始迭代器<br /><code>end2</code>：容器 2
结束迭代器<br /><code>dest</code>
目标容器开始迭代器<br />返回值：目标容器的最后一个元素的迭代器地址</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></td>
<td style="text-align: center;">求两个 set
的并集<br /><code>beg1</code>：容器 1
开始迭代器<br /><code>end1</code>：容器 1
结束迭代器<br /><code>beg2</code>：容器 2
开始迭代器<br /><code>end2</code>：容器 2
结束迭代器<br /><code>dest</code>：目标容器开始迭代器<br />返回值：目标容器的最后一个元素的迭代器地址</td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></td>
<td style="text-align: center;">求两个 set
的差集<br /><code>beg1</code>：容器 1
开始迭代器<br /><code>end1</code>：容器 1
结束迭代器<br /><code>beg2</code>：容器2
开始迭代器<br /><code>end2</code>：容器 2
结束迭代器<br /><code>dest</code>：目标容器开始迭代器<br />返回值：目标容器的最后一个元素的迭代器地址</td>
</tr>
</tbody>
</table>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>() + v1.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_intersection</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line">    for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), [](<span class="type">int</span> a) &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_union</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line">    for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), [](<span class="type">int</span> a) &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    v2.<span class="built_in">clear</span>();</span><br><span class="line">    v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">set_difference</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line">    for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), [](<span class="type">int</span> a) &#123; cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/15d21458-3f7c-46c9-8a43-d23b1d62c122"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<blockquote>
<ol type="1">
<li>求交目标容器开辟空间需要从<strong>两个容器中取小值</strong></li>
<li>求并目标容器开辟空间需要<strong>两个容器相加</strong></li>
<li>求差目标容器开辟空间需要从<strong>两个容器取较大值</strong></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>C++ 基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>SymPy 的简单使用</title>
    <url>/2024/02/13/SymPy%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="sympy-库简介"><code>SymPy</code> 库简介</h2>
<p><a href="https://www.sympy.org/en/index.html">SymPy</a>
是一个用于符号数学的 <code>Python</code> 库。</p>
<p>可以用来代替 Mathematica 和 Maple 等数学软件，同时可以结合
<code>Python</code> 其他库来拓展功能。</p>
<h2 id="加载-sympy-库">加载 <code>SymPy</code> 库</h2>
<p>使用如下代码加载 <code>SymPy</code> 库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy <span class="keyword">as</span> sp</span><br><span class="line">sp.init_printing()</span><br></pre></td></tr></table></figure>
<p>当然，你要先使用 <code>pip</code> 安装 <code>sympy</code> 库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install sympy</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：调用 <code>init_printing()</code>
可能会使代码执行时间过长甚至出现卡死的情况，可以不调用该函数。</p>
</blockquote>
<h2 id="四则运算">四则运算</h2>
<div class="tabs" id="sympy四则运算"><ul class="nav-tabs"><li class="tab active"><a href="#sympy四则运算-1">加法</a></li><li class="tab"><a href="#sympy四则运算-2">减法</a></li><li class="tab"><a href="#sympy四则运算-3">乘法</a></li><li class="tab"><a href="#sympy四则运算-4">除法</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sympy四则运算-1"><p><span class="math display">\[
3 + 2
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> + <span class="number">2</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="sympy四则运算-2"><p><span class="math display">\[
3 - 2
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> - <span class="number">2</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="sympy四则运算-3"><p><span class="math display">\[
3 * 2
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> * <span class="number">2</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="sympy四则运算-4"><p><span class="math display">\[
\frac{3}{2}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> / <span class="number">2</span></span><br></pre></td></tr></table></figure></div></div></div>
<p>使用如下代码处理分数：</p>
<div class="tabs" id="sympy分数"><ul class="nav-tabs"><li class="tab active"><a href="#sympy分数-1">分数</a></li><li class="tab"><a href="#sympy分数-2">分母</a></li><li class="tab"><a href="#sympy分数-3">分子</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sympy分数-1"><p><span class="math display">\[
\frac{3}{2}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.Rational(<span class="number">3</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="sympy分数-2"><p><span class="math display">\[
\frac{3}{2}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.denom(sp.Rational(<span class="number">3</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="sympy分数-3"><p><span class="math display">\[
\frac{3}{2}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.numer(sp.Rational(<span class="number">3</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="幂阶乘">幂、阶乘</h2>
<div class="tabs" id="sympy幂和阶乘"><ul class="nav-tabs"><li class="tab active"><a href="#sympy幂和阶乘-1">幂</a></li><li class="tab"><a href="#sympy幂和阶乘-2">阶乘</a></li><li class="tab"><a href="#sympy幂和阶乘-3">双阶乘</a></li><li class="tab"><a href="#sympy幂和阶乘-4">平方根</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sympy幂和阶乘-1"><p><span class="math display">\[
3^2
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> ** <span class="number">2</span></span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="sympy幂和阶乘-2"><p><span class="math display">\[
50!
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.factorial(<span class="number">50</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="sympy幂和阶乘-3"><p><span class="math display">\[
50!!
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.factorial2(<span class="number">50</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="sympy幂和阶乘-4"><p><span class="math display">\[
\sqrt{50}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.sqrt(<span class="number">50</span>)</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="常数">常数</h2>
<div class="tabs" id="sympy中的常数"><ul class="nav-tabs"><li class="tab active"><a href="#sympy中的常数-1">圆周率</a></li><li class="tab"><a href="#sympy中的常数-2">自然对数的底数</a></li><li class="tab"><a href="#sympy中的常数-3">无穷大</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sympy中的常数-1"><p><span class="math display">\[
\pi
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.pi</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="sympy中的常数-2"><p><span class="math display">\[
\mathrm{e}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.E</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="sympy中的常数-3"><p><span class="math display">\[
\infty
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.oo</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="复数">复数</h2>
<div class="tabs" id="复数"><ul class="nav-tabs"><li class="tab active"><a href="#复数-1">虚数单位</a></li><li class="tab"><a href="#复数-2">共轭复数</a></li><li class="tab"><a href="#复数-3">实部</a></li><li class="tab"><a href="#复数-4">虚部</a></li><li class="tab"><a href="#复数-5">模长</a></li><li class="tab"><a href="#复数-6">幅角</a></li></ul><div class="tab-content"><div class="tab-pane active" id="复数-1"><p><span class="math display">\[
\mathrm{i}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.I</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="复数-2"><p><span class="math display">\[
\overline{2 + 3\mathrm{i}}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.conjugate(<span class="number">2</span> + <span class="number">3</span> * sp.I)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="复数-3"><p><span class="math display">\[
\mathrm{Re}\left(2 + 3\mathrm{i}\right)
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.re(<span class="number">2</span> + sp.I * <span class="number">3</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="复数-4"><p><span class="math display">\[
\mathrm{Im}\left(2 + 3\mathrm{i}\right)
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.im(<span class="number">2</span> + sp.I * <span class="number">3</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="复数-5"><p><span class="math display">\[
\left|2 + 3\mathrm{i}\right|
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.Abs(<span class="number">2</span> + sp.I * <span class="number">3</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="复数-6"><p><span class="math display">\[
\mathrm{Arg} \left(2 + 3\mathrm{i}\right)
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.arg(<span class="number">2</span> + sp.I * <span class="number">3</span>)</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="变量">变量</h2>
<h3 id="声明变量">声明变量</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, r, s, t, u, v, w, x, y, z = sp.symbols(<span class="string">&#x27;a b c d e f g h i j k l m n o p r s t u v w x y z&#x27;</span>)</span><br><span class="line">A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, R, S, T, U, V, W, X, Y, Z = sp.symbols(<span class="string">&#x27;A B C D E F G H I J K L M N O P R S T U V W X Y Z&#x27;</span>)</span><br><span class="line">alpha, beta, gamma, delta, epsilon, zeta, eta, theta, iota, kappa, lamda, mu, nu, xi, omicron, pi, rho, sigma, tau, upsilon, phi, chi, psi, omega = sp.symbols(<span class="string">&#x27;alpha beta gamma delta epsilon zeta eta theta iota kappa lamda mu nu xi omicron pi rho sigma tau upsilon phi chi psi omega&#x27;</span>)</span><br><span class="line">Alpha, Beta, Gamma, Delta, Epsilon, Zeta, Eta, Theta, Iota, Kappa, Lamda, Mu, Nu, Xi, Omicron, Pi, Rho, Sigma, Tau, Upsilon, Phi, Chi, Psi, Omega = sp.symbols(<span class="string">&#x27;Alpha Beta Gamma Delta Epsilon Zeta Eta Theta Iota Kappa Lamda Mu Nu Xi Omicron Pi Rho Sigma Tau Upsilon Phi Chi Psi Omega&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="算术运算">算术运算</h3>
<p><span class="math display">\[
x+y+x-y
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x + y + x - y</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\left(x+y\right)^2
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(x + y) ** <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="代数运算">代数运算</h2>
<h3 id="质因数分解">质因数分解</h3>
<p><span class="math display">\[
10!=2^8 \cdot 3^4 \cdot 5^2 \cdot 7
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.factorint(sp.factorial(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<h3 id="因式分解">因式分解</h3>
<p><span class="math display">\[
x^2 -4x+3 = \left(x-3\right)\left(x-1\right)
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.factor(x ** <span class="number">2</span> - <span class="number">4</span> * x + <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><a
href="https://en.wikipedia.org/wiki/Irreducible_polynomial">不可约多项式</a>在整数上的因式分解：</p>
<p><span class="math display">\[
\left(1+x-x^2\right)\left(1-x-x^2\right)=\left(x^2-x-1\right)\left(x^2+x-1\right)
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.factor((<span class="number">1</span> + x - x ** <span class="number">2</span>) * (<span class="number">1</span> - x - x ** <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p><a
href="https://en.wikipedia.org/wiki/Cyclotomic_polynomial">分圆多项式</a>的不可约因式分解（模
5）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.factor((<span class="number">1</span> + x - x ** <span class="number">2</span>) * (<span class="number">1</span> - x - x ** <span class="number">2</span>), modulus=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="化简">化简</h3>
<p><span class="math display">\[
\frac{x+xy}{x}=y+1
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.simplify((x + x * y) / x)</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\frac{\sin x}{\cos x} = \tan x
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.trigsimp(sp.sin(x) / sp.cos(x))</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\sin^2x + \cos^2x = 1
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.trigsimp((sp.sin(a)) ** <span class="number">2</span> + (sp.cos(a)) ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\sinh^2a+\cosh^2a = \cosh 2a
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.trigsimp((sp.sinh(a)) ** <span class="number">2</span> + (sp.cosh(a)) ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="部分分式分解">部分分式分解</h3>
<p><span class="math display">\[
\frac{1}{x^2-4x+3} = \frac{1}{2\left(x-3\right)} -
\frac{1}{2\left(x-1\right)}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.apart(<span class="number">1</span> / (x ** <span class="number">2</span> - <span class="number">4</span> * x + <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\frac{1}{x^6-1}=\frac{x-2}{6\left(x^2-x+1\right)}-\frac{x+2}{6\left(x^2+x+1\right)}-\frac{1}{6\left(x+1\right)}+\frac{1}{6\left(x-1\right)}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.apart(<span class="number">1</span> / (x ** <span class="number">6</span> - <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h3 id="展开">展开</h3>
<p><span class="math display">\[
\left(x+y\right)^6=x^6+6x^5y+15x^4y^2+20x^3y^3+15x^2y^4+6xy^5+y^6
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.expand((x + y) ** <span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\tan\left(a+b\right)=\frac{\tan a+\tan b}{1-\tan a\tan b}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.simplify(sp.expand(sp.tan(a + b), trig=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>
<details class="note "><summary><p>pink fas fa-car-crash simple</p>
</summary>
<p>注意：<code>trig=True</code> 表示展开三角函数。</p>

</details>
<h3 id="通分">通分</h3>
<p><span class="math display">\[
\frac{2x-2}{\left(x-1\right)^2\left(x-2\right)}=\frac{2}{\left(x-2\right)\left(x-1\right)}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.simplify((<span class="number">2</span> * x - <span class="number">2</span>) / ((x - <span class="number">1</span>) ** <span class="number">2</span> * (x - <span class="number">2</span>)))</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\frac{1}{\left(x-1\right)^2}+\frac{1}{\left(x-1\right)\left(x-2\right)}=\frac{2x-3}{\left(x-2\right)\left(x-1\right)^2}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.simplify(<span class="number">1</span> / (x - <span class="number">1</span>) ** <span class="number">2</span> + <span class="number">1</span> / ((x - <span class="number">1</span>) * (x - <span class="number">2</span>)))</span><br></pre></td></tr></table></figure>
<h3 id="通分展开">通分展开</h3>
<p><span class="math display">\[
\frac{2x-2}{\left(x-1\right)^2\left(x-2\right)}=\frac{2}{x^2-3x+2}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.cancel((<span class="number">2</span> * x - <span class="number">2</span>) / ((x - <span class="number">1</span>) ** <span class="number">2</span> * (x - <span class="number">2</span>)))</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\frac{1}{\left(x-1\right)^2}+\frac{1}{\left(x-1\right)\left(x-2\right)}=\frac{2x-3}{x^3-4x^2+5x-2}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.cancel(<span class="number">1</span> / (x - <span class="number">1</span>) ** <span class="number">2</span> + <span class="number">1</span> / ((x - <span class="number">1</span>) * (x - <span class="number">2</span>)))</span><br></pre></td></tr></table></figure>
<h3 id="系数">系数</h3>
<p>求</p>
<p><span class="math display">\[
\left(x+y\right)^6
\]</span></p>
<p>的 <span class="math inline">\(x^3\)</span> 的系数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.expand((x + y) ** <span class="number">6</span>).coeff(x, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h3 id="代入">代入</h3>
<p><span class="math display">\[
a x^2+b x+c\left.\right|_{x=3}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(a * x ** <span class="number">2</span> + b * x + c).subs(x, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
ax^2+bx+c
\]</span></p>
<p>where:</p>
<p><span class="math display">\[
x=\frac{-b+\sqrt{-4ac+b^2}}{2a}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.expand((a * x ** <span class="number">2</span> + b * x + c).subs(x, (-b + sp.sqrt(-<span class="number">4</span> * a * c + b ** <span class="number">2</span>)) / (<span class="number">2</span> * a)))</span><br></pre></td></tr></table></figure>
<h3 id="求和">求和</h3>
<p><span class="math display">\[
\sum_{x=1}^{10}x
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.summation(x, (x, <span class="number">1</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\sum_{x=1}^{a}x
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.factor(sp.summation(x, (x, <span class="number">1</span>, a)))</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\sum_{x=1}^{a}x^3
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.factor(sp.summation(x ** <span class="number">3</span>, (x, <span class="number">1</span>, a)))</span><br></pre></td></tr></table></figure>
<h3 id="求积">求积</h3>
<p><span class="math display">\[
\prod_{x=1}^{10}x
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.product(x, (x, <span class="number">1</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<h2 id="命题逻辑">命题逻辑</h2>
<h3 id="真伪判断">真伪判断</h3>
<div class="tabs" id="真伪判断"><ul class="nav-tabs"><li class="tab active"><a href="#真伪判断-1">例1</a></li><li class="tab"><a href="#真伪判断-2">例2</a></li><li class="tab"><a href="#真伪判断-3">例3</a></li><li class="tab"><a href="#真伪判断-4">例4</a></li><li class="tab"><a href="#真伪判断-5">例5</a></li></ul><div class="tab-content"><div class="tab-pane active" id="真伪判断-1"><p><span class="math display">\[
0=\sqrt{2}-2^{\frac{1}{2}} \text { ? }
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> == sp.sqrt(<span class="number">2</span>) - <span class="number">2</span> ** (sp.Rational(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="真伪判断-2"><p><span class="math display">\[
0=\sqrt{2}-2^{\frac{1}{3}} \text { ? }
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> == sp.sqrt(<span class="number">2</span>) - <span class="number">2</span> ** (sp.Rational(<span class="number">1</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">False</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="真伪判断-3"><p><span class="math display">\[
10!=\prod_{x=1}^{10}x \text { ? }
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.factorial(<span class="number">10</span>) == sp.product(x, (x, <span class="number">1</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="真伪判断-4"><p><span class="math display">\[
50!=50!!\times 49!!\text { ? }
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.factorial(<span class="number">10</span>) == sp.product(x, (x, <span class="number">1</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="真伪判断-5"><p>对于公式的处理要小心，例如对于如下判断：</p>
<p><span class="math display">\[
x^2-2x+1=\left(x-1\right)^2 \text {?}
\]</span></p>
<p>结果应该为 <code>True</code>，但如果使用如下代码的话：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x ** <span class="number">2</span> - <span class="number">2</span> * x + <span class="number">1</span> == (x - <span class="number">1</span>) ** <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>其结果为
<code>False</code>，应该显示的将公式进行展开，然后再进行判断：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x ** <span class="number">2</span> - <span class="number">2</span> * x + <span class="number">1</span> == sp.expand((x - <span class="number">1</span>) ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>这样就可以得到我们想要的结果。</p></div></div></div>
<h3 id="逻辑运算">逻辑运算</h3>
<div class="tabs" id="逻辑运算"><ul class="nav-tabs"><li class="tab active"><a href="#逻辑运算-1">例1</a></li><li class="tab"><a href="#逻辑运算-2">例2</a></li></ul><div class="tab-content"><div class="tab-pane active" id="逻辑运算-1"><p><span class="math display">\[
x \wedge y=\text { True ? }
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.satisfiable(x &amp; y)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;x: True, y: True&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="逻辑运算-2"><p><span class="math display">\[
x \wedge \neg x=\text { True ? }
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.satisfiable(x &amp; ~x)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">False</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="数学分析">数学分析</h2>
<h3 id="函数定义">函数定义</h3>
<p><span class="math display">\[
f\left(x\right) =\frac{\log\left(x+1\right)}{x}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> sp.log(<span class="number">1</span> + x) / x</span><br><span class="line"></span><br><span class="line">f(x)</span><br></pre></td></tr></table></figure>
<h3 id="极限">极限</h3>
<div class="tabs" id="极限"><ul class="nav-tabs"><li class="tab active"><a href="#极限-1">例1</a></li><li class="tab"><a href="#极限-2">例2</a></li><li class="tab"><a href="#极限-3">例3</a></li><li class="tab"><a href="#极限-4">例4</a></li></ul><div class="tab-content"><div class="tab-pane active" id="极限-1"><p><span class="math display">\[
\lim _{x \rightarrow 0} \frac{\sin (x)}{x}=1
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.limit(sp.sin(x) / x, x, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="极限-2"><p><span class="math display">\[
\lim _{x \rightarrow \infty} x=\infty
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.limit(x, x, sp.oo)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="极限-3"><p><span class="math display">\[
\lim _{x \rightarrow \infty} \frac{1}{x}=0
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.limit(<span class="number">1</span> / x, x, sp.oo)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="极限-4"><p><span class="math display">\[
\lim _{x \rightarrow 0} x^x=1
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.limit(x ** x, x, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></div></div></div>
<h3 id="微分">微分</h3>
<div class="tabs" id="微分"><ul class="nav-tabs"><li class="tab active"><a href="#微分-1">例1</a></li><li class="tab"><a href="#微分-2">例2</a></li><li class="tab"><a href="#微分-3">例3</a></li><li class="tab"><a href="#微分-4">例4</a></li><li class="tab"><a href="#微分-5">例5</a></li></ul><div class="tab-content"><div class="tab-pane active" id="微分-1"><p><span class="math display">\[
\frac{\partial}{\partial x}(x+y)^3=3(x+y)^2
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.diff((x + y) ** <span class="number">3</span>, x)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="微分-2"><p><span class="math display">\[
\frac{\partial^2}{\partial y^2}(x+y)^3=6(x+y)
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.diff((x + y) ** <span class="number">3</span>, y, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="微分-3"><p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d} x} \tan (x)=\tan ^2(x)+1
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.diff(sp.tan(x), x)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="微分-4"><p><span class="math display">\[
\lim _{y \rightarrow 0} \frac{\tan (x+y)-\tan (x)}{y}=\tan ^2(x)+1
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.limit((sp.tan(x + y) - sp.tan(x)) / y, y, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="微分-5"><p><span class="math display">\[
\frac{\mathrm{d}}{\mathrm{d} x} f(x)=\frac{\mathrm{d}}{\mathrm{d} x}
\frac{\log (x+1)}{x}=\frac{1}{x(x+1)}-\frac{\log (x+1)}{x^2}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.diff(f(x), x, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></div></div></div>
<h3 id="级数展开">级数展开</h3>
<p><span class="math display">\[
\frac{1}{\cos (x)}=1+\frac{x^2}{2}+\frac{5
x^4}{24}+\Omicron\left(x^6\right)
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.series(sp.cos(x), x)</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
f(x)=\frac{\log
(x+1)}{x}=1-\frac{x}{2}+\frac{x^2}{3}-\frac{x^3}{4}+\frac{x^4}{5}-\frac{x^5}{6}+\frac{x^6}{7}+\Omicron\left(x^7\right)
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.series(f(x), x, <span class="number">0</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<h3 id="积分">积分</h3>
<p><span class="math display">\[
\int\left(x+y\right)\mathrm{d}x = \frac{x^2}{2}+xy
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.integrate(x + y, x)</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\int(2 x+\sinh x) \mathrm{d} x=x^2+\cosh (x)
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.integrate(<span class="number">2</span> * x + sp.sinh(x), x)</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\int_0^6(x+y)^3 \mathrm{d} x=6 y^3+54 y^2+216 y+324
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.integrate((x + y) ** <span class="number">3</span>, (x, <span class="number">0</span>, <span class="number">6</span>))</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\int_{-\infty}^{\infty} \mathrm{e}^{-x^2} \mathrm{d} x=\sqrt{\pi}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.integrate(sp.exp(-x ** <span class="number">2</span>), (x, -sp.oo, sp.oo))</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\int \mathrm{e}^{-x^2} \operatorname{erf}(x) \mathrm{d} x=\frac{\sqrt{x}
\operatorname{erf}^2(x)}{4}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.integrate(sp.exp(-x ** <span class="number">2</span>) * sp.erf(x), x)</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\int f(x) \mathrm{d}  x=\int \frac{\log (x+1)}{x} \mathrm{d}
x=-\operatorname{Li}_2\left(x \mathrm{e}^{i \pi}\right)
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.integrate(f(x), x)</span><br></pre></td></tr></table></figure>
<h2 id="代数方程">代数方程</h2>
<h3 id="求解">求解</h3>
<p>解方程：</p>
<p><span class="math display">\[
x^4-1=0
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.solve(x ** <span class="number">4</span> - <span class="number">1</span>, x)</span><br></pre></td></tr></table></figure>
<p>解方程组：</p>
<p><span class="math display">\[
\begin{align*}
x+5y-2=0\\
-3x+6y-15=0
\end{align*}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.solve([x + <span class="number">5</span> * y - <span class="number">2</span>, -<span class="number">3</span> * x + <span class="number">6</span> * y - <span class="number">15</span>], [x, y])</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\mathrm{e}^x + 1= 0
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.solve(sp.exp(x) + <span class="number">1</span>, x)</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
ax^2+bx+c=0
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.solve(a * x ** <span class="number">2</span> + b * x + c, x)</span><br></pre></td></tr></table></figure>
<h3 id="等式">等式</h3>
<p>解方程 <span class="math display">\[
x+1=\frac{x+1}{x^2+x-2}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">equation = sp.Eq(x + <span class="number">1</span>, (x + <span class="number">1</span>) / (x ** <span class="number">2</span> + x - <span class="number">2</span>))</span><br><span class="line">sp.solve(equation, x)</span><br></pre></td></tr></table></figure>
<p>得到等式右边：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">equation.rhs</span><br></pre></td></tr></table></figure>
<p>得到等式左边：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">equation.lhs</span><br></pre></td></tr></table></figure>
<h2 id="线性代数">线性代数</h2>
<h3 id="矩阵">矩阵</h3>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; x \\
y &amp; 1
\end{bmatrix}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.Matrix([[<span class="number">1</span>, x], [y, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; x \\
y &amp; 1
\end{bmatrix}^2=
\begin{bmatrix}
xy+1 &amp; 2x \\
2y &amp; xy+1  
\end{bmatrix}
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.Matrix([[<span class="number">1</span>, x], [y, <span class="number">1</span>]]) ** <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="阶梯型">阶梯型</h3>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 0 &amp; 1 &amp; 3 \\
2 &amp; 3 &amp; 4 &amp; 7 \\
-1 &amp; -3 &amp; -3 &amp; -4
\end{bmatrix}
\]</span></p>
<p>的阶梯型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.Matrix([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>], [-<span class="number">1</span>, -<span class="number">3</span>, -<span class="number">3</span>, -<span class="number">4</span>]]).rref()</span><br></pre></td></tr></table></figure>
<h3 id="零空间">零空间</h3>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 2 &amp; 3 &amp; 0 &amp; 0\\
4 &amp; 10 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<p>的零空间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.Matrix([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">4</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]]).nullspace()</span><br></pre></td></tr></table></figure>
<h3 id="列空间">列空间</h3>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 1 &amp; 2 \\
2 &amp; 1 &amp; 3 \\
3 &amp; 1 &amp; 4
\end{bmatrix}
\]</span></p>
<p>的列空间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.Matrix([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>]]).columnspace()</span><br></pre></td></tr></table></figure>
<h3 id="特征方程">特征方程</h3>
<p><span class="math display">\[
\begin{bmatrix}
3 &amp; -2 &amp; 4 &amp; -2 \\
5 &amp; 3 &amp; -3 &amp; -2 \\
5 &amp; -2 &amp; 2 &amp; -2 \\
5 &amp; -2 &amp; -3 &amp; 3
\end{bmatrix}
\]</span></p>
<p>的特征方程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.factor(sp.Matrix([[<span class="number">3</span>, -<span class="number">2</span>, <span class="number">4</span>, -<span class="number">2</span>], [<span class="number">5</span>, <span class="number">3</span>, -<span class="number">3</span>, -<span class="number">2</span>], [<span class="number">5</span>, -<span class="number">2</span>, <span class="number">2</span>, -<span class="number">2</span>], [<span class="number">5</span>, -<span class="number">2</span>, -<span class="number">3</span>, <span class="number">3</span>]]).charpoly())</span><br></pre></td></tr></table></figure>
<h3 id="特征值和特征向量">特征值和特征向量</h3>
<p><span class="math display">\[
\begin{bmatrix}
3 &amp; -2 &amp; 4 &amp; -2 \\
5 &amp; 3 &amp; -3 &amp; -2 \\
5 &amp; -2 &amp; 2 &amp; -2 \\
5 &amp; -2 &amp; -3 &amp; 3
\end{bmatrix}
\]</span></p>
<p>的特征值和特征向量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.Matrix([[<span class="number">3</span>, -<span class="number">2</span>, <span class="number">4</span>, -<span class="number">2</span>], [<span class="number">5</span>, <span class="number">3</span>, -<span class="number">3</span>, -<span class="number">2</span>], [<span class="number">5</span>, -<span class="number">2</span>, <span class="number">2</span>, -<span class="number">2</span>], [<span class="number">5</span>, -<span class="number">2</span>, -<span class="number">3</span>, <span class="number">3</span>]]).eigenvects()</span><br></pre></td></tr></table></figure>
<h3 id="对角化">对角化</h3>
<p><span class="math display">\[
\begin{bmatrix}
3 &amp; -2 &amp; 4 &amp; -2 \\
5 &amp; 3 &amp; -3 &amp; -2 \\
5 &amp; -2 &amp; 2 &amp; -2 \\
5 &amp; -2 &amp; -3 &amp; 3
\end{bmatrix}
\]</span></p>
<p>对其对角化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">P, D = sp.Matrix([[<span class="number">3</span>, -<span class="number">2</span>, <span class="number">4</span>, -<span class="number">2</span>], [<span class="number">5</span>, <span class="number">3</span>, -<span class="number">3</span>, -<span class="number">2</span>], [<span class="number">5</span>, -<span class="number">2</span>, <span class="number">2</span>, -<span class="number">2</span>], [<span class="number">5</span>, -<span class="number">2</span>, -<span class="number">3</span>, <span class="number">3</span>]]).diagonalize()</span><br></pre></td></tr></table></figure>
<h2 id="微分方程">微分方程</h2>
<h3 id="定义未知函数">定义未知函数</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = sp.symbols(<span class="string">&#x27;f&#x27;</span>, cls=sp.Function)</span><br></pre></td></tr></table></figure>
<h3 id="求解微分方程">求解微分方程</h3>
<p><span class="math display">\[
\frac{\mathrm{d}^2}{\mathrm{d}x^2}f(x)+f(x)=0
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.dsolve(f(x).diff(x, x) + f(x), f(x))</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
x \frac{\mathrm{d}}{\mathrm{d} x} f(x)+f(x)-f^2(x)=0
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.dsolve(x * f(x).diff(x) + f(x) - f(x) ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
x \frac{\mathrm{d}}{\mathrm{d} x} f(x)+f(x)-f^2(x)=0
\]</span></p>
<p>这是一个伯努利类型的微分方程，我们可以暗示它：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.dsolve(x * f(x).diff(x) + f(x) - f(x) ** <span class="number">2</span>, f(x), hint=<span class="string">&#x27;Bernoulli&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="输出-latex">输出 LaTex</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">equation = sp.Eq(a * x ** <span class="number">2</span> + b * x + c, <span class="number">0</span>)</span><br><span class="line">solution = sp.solve(equation, x)</span><br><span class="line"><span class="built_in">print</span>(sp.latex(solution))</span><br></pre></td></tr></table></figure>
<h2 id="小结">小结</h2>
<p>尝试使用 <code>SymPy</code> 求解下面的积分吧：</p>
<p><span class="math display">\[
\int_0^1\left(x^2+\frac{x}{\sqrt{1+x^2}}\right)\left(1+\frac{x}{\left(1+x^2\right)
\sqrt{1+x^2}}\right) \mathrm{d} x
\]</span></p>
<p>参考答案：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sp.integrate((x ** <span class="number">2</span> + x / sp.sqrt(<span class="number">1</span> + x ** <span class="number">2</span>)) * (<span class="number">1</span> + x / (<span class="number">1</span> + x ** <span class="number">2</span>) / sp.sqrt(<span class="number">1</span> + x ** <span class="number">2</span>)), (x, <span class="number">0</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a
href="https://gochikika.ntt.com/Features/SymPy.html">SymPyの使い方</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>SymPy</tag>
      </tags>
  </entry>
  <entry>
    <title>Template</title>
    <url>/2023/07/16/Template/</url>
    <content><![CDATA[<h2 id="模板概述">模板概述</h2>
<p>类型以参数的形式指定，这样的函数或类称为函数模板或类模板。</p>
<p>模板的特点：</p>
<ul>
<li>模板不可以直接使用，它只是一个框架</li>
<li>模板的通用并不是万能的</li>
</ul>
<h2 id="函数模板">函数模板</h2>
<h3 id="函数模板语法">函数模板语法</h3>
<p>语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<p><code>template</code>：声明创建模板</p>
<p><code>typename</code>：表面其后面的符号是一种数据类型，可以用
<code>class</code> 代替</p>
<p><code>T</code>：通用的数据类型，名称可以替换，通常为大写字母。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mySwap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mySwap</span>&lt;<span class="type">int</span>&gt;(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>使用函数模板有两种方式：自动类型推导、显示指定类类型。</li>
</ul>
</blockquote>
<h3 id="普通函数与函数模板的区别">普通函数与函数模板的区别</h3>
<ul>
<li>普通函数调用时可以发生自动类型转换</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myAdd01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">myAdd01</span>(a, c)</span><br><span class="line">         &lt;&lt; endl; <span class="comment">// 正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">myAdd02</span>&lt;<span class="type">int</span>&gt;(a, c); <span class="comment">// 正确，如果用显示指定类型，可以发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="普通函数与函数模板的调用规则">普通函数与函数模板的调用规则</h3>
<p>调用规则如下：</p>
<ol type="1">
<li>如果函数模板和普通函数都可以实现，优先调用普通函数</li>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以发生重载</li>
<li>如果函数模板可以产生更好的匹配，优先调用函数模板</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用重载的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">myPrint</span>(a, b);</span><br><span class="line"></span><br><span class="line">    myPrint&lt;&gt;(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">myPrint</span>(a, b, c);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    <span class="built_in">myPrint</span>(c1, c2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/47ba3b3a-f042-419a-b52e-d78264729b1d"
alt="输出结果" />
<figcaption aria-hidden="true">输出结果</figcaption>
</figure>
<blockquote>
<p>既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p>
</blockquote>
<h3 id="模板具体化">模板具体化</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line">    string mName;</span><br><span class="line">    <span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三代具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span></span><br><span class="line"><span class="comment">// 具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">mySwap</span>&lt;Person&gt;(Person &amp;p1, Person &amp;p2) &#123;</span><br><span class="line">    string nameTemp;</span><br><span class="line">    <span class="type">int</span> ageTemp;</span><br><span class="line">    nameTemp = p1.mName;</span><br><span class="line">    p1.mName = p2.mName;</span><br><span class="line">    p2.mName = nameTemp;</span><br><span class="line"></span><br><span class="line">    ageTemp = p1.mAge;</span><br><span class="line">    p1.mAge = p2.mAge;</span><br><span class="line">    p2.mAge = ageTemp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">P1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">P2</span><span class="params">(<span class="string">&quot;Jerry&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P1 Name = &quot;</span> &lt;&lt; P1.mName &lt;&lt; <span class="string">&quot; P1 Age = &quot;</span> &lt;&lt; P1.mAge &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P2 Name = &quot;</span> &lt;&lt; P2.mName &lt;&lt; <span class="string">&quot; P2 Age = &quot;</span> &lt;&lt; P2.mAge &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">mySwap</span>(P1, P2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P1 Name = &quot;</span> &lt;&lt; P1.mName &lt;&lt; <span class="string">&quot; P1 Age = &quot;</span> &lt;&lt; P1.mAge &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P2 Name = &quot;</span> &lt;&lt; P2.mName &lt;&lt; <span class="string">&quot; P2 Age = &quot;</span> &lt;&lt; P2.mAge &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/5db85779-39da-4375-b6a0-5df97b9cb032"
alt="输出结果" />
<figcaption aria-hidden="true">输出结果</figcaption>
</figure>
<h2 id="类模板">类模板</h2>
<h3 id="类模板语法">类模板语法</h3>
<p>语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<p><code>template</code>：声明创建模板</p>
<p><code>typename</code>：表明其后面的符号是一种数据类型，可以用
<code>class</code> 代替</p>
<p><code>T</code>：通用的数据类型，名称可以替换，通常为大写字母。</p>
<h3 id="类模板与函数模板区别">类模板与函数模板区别</h3>
<p>类模板与函数模板区别主要有两点：</p>
<ol type="1">
<li>类模板没有自动类型推导的使用方式</li>
<li>类模板在模板参数列表中可以有默认参数</li>
</ol>
<h3 id="类模板中成员函数创建时机">类模板中成员函数创建时机</h3>
<p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建</li>
</ul>
<h3 id="类模板对象做函数参数">类模板对象做函数参数</h3>
<p>一共有三种传入方式：</p>
<ol type="1">
<li>指定传入的类型：直接显示对象的数据类型</li>
<li>参数模板化：将对象中的参数变为模板进行传递</li>
<li>整个类模板化：将这个对象类型 模板化进行传递</li>
</ol>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(NameType name, AgeType age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NameType mName;</span><br><span class="line">    AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、指定传入的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="type">int</span>&gt; &amp;p)</span> </span>&#123; p.<span class="built_in">showPerson</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、参数模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T &amp;p)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/f5a28448-c050-4ebc-95da-e91de12db7d2"
alt="输出结果" />
<figcaption aria-hidden="true">输出结果</figcaption>
</figure>
<h3 id="类模板与继承">类模板与继承</h3>
<p>当类模板碰到继承时，需要注意一下几点：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中 T
的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中 T 的类型，子类也需变为类模板。</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt; &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123; Son c; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> : <span class="keyword">public</span> Base&lt;T2&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son2</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123; Son2&lt;<span class="type">int</span>, <span class="type">char</span>&gt; child1; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类模板成员函数类外实现">类模板成员函数类外实现</h3>
<blockquote>
<p>类模板中成员函数类外实现时，需要加上模板参数列表。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/520be2b7-fcd8-4fb8-9f36-0a6bd19607d3"
alt="输出结果" />
<figcaption aria-hidden="true">输出结果</figcaption>
</figure>
<h3 id="类模板分文件编写">类模板分文件编写</h3>
<p>问题：</p>
<ul>
<li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li>
</ul>
<p>解决：</p>
<ul>
<li>解决方式 1：直接包含 <code>.cpp</code> 源文件</li>
<li>解决方式 2：将声明和实现写到同一个文件中，并更改后缀名为
<code>.hpp</code>，<code>hpp</code> 是约定的名称，并不是强制。</li>
</ul>
<h3 id="类模板与友元">类模板与友元</h3>
<p>全局函数类内实现：直接在类内声明友元即可</p>
<p>全局函数类外实现：需要提前让编译器知道全局函数的存在</p>
<blockquote>
<p>建议全局函数做类内实现，用法简单，而且编译器可以直接识别。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;类外实现 ---- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp;p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printPerson</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、全局函数在类外实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Jerry&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test01();</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++ 基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Template</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2023/07/16/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="位运算介绍">位运算介绍</h2>
<p>位运算由按位与、按位或、按位取反、按位异或、左移、右移。</p>
<p><strong>与（&amp;）</strong>：</p>
<p>与运算的真值表：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><code>a</code></th>
<th style="text-align: center;"><code>b</code></th>
<th style="text-align: center;"><code>a &amp; b</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<blockquote>
<p>与运算的特点是：有 0 得 0，全 1 得 1.</p>
</blockquote>
<p>例：对 35 和 47 进行与运算：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">    35:  0 0 1 0 0 0 1 1</span><br><span class="line">  &amp; 47:  0 0 1 0 1 1 1 1</span><br><span class="line">-----------------------</span><br><span class="line">         0 0 1 0 0 0 1 1</span><br></pre></td></tr></table></figure>
<p><strong>或（|）</strong>：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><code>a</code></th>
<th style="text-align: center;"><code>b</code></th>
<th style="text-align: center;"><code>a \| b</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<blockquote>
<p>或运算的特点：有 1 得 1，全 0 得 0.</p>
</blockquote>
<p>例：对 35 和 47 进行与运算：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">    35:  0 0 1 0 0 0 1 1</span><br><span class="line">  | 47:  0 0 1 0 1 1 1 1</span><br><span class="line">-----------------------</span><br><span class="line">         0 0 1 0 1 1 1 1</span><br></pre></td></tr></table></figure>
<p><strong>取反（~）</strong>：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><code>a</code></th>
<th style="text-align: center;"><code>~a</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<blockquote>
<p>反运算的特点是：1 变 0，0 变 1.</p>
</blockquote>
<p><strong>异或（^）</strong>：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><code>a</code></th>
<th style="text-align: center;"><code>b</code></th>
<th style="text-align: center;"><code>a ^ b</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<blockquote>
<p>异或运算的特点是：相同为 0，不同为 1.</p>
</blockquote>
<p>异或运算有如下性质：</p>
<ol type="1">
<li>交换律： <span class="math inline">\(a ^{\wedge} b = b ^{\wedge}
a\)</span>.</li>
<li>结合律： <span class="math inline">\((a ^{\wedge} b) ^{\wedge} c = a
^{\wedge} (b ^{\wedge} c)\)</span>.</li>
<li><span class="math inline">\(a_{1} ^{\wedge} a_{2} ^{\wedge} a_{3}
^{\wedge} \cdots ^{\wedge} a_{n}\)</span> 的结果与 <span
class="math inline">\(a_{1}, a_{2}, a_{3}, \cdots ,a_{n}\)</span>
的顺序无关。</li>
<li><code>0 ^ x = x</code>、<code>1 ^ x = ~x</code>.</li>
</ol>
<p><strong>右移（&gt;&gt;）</strong>：</p>
<p>右移有算术右移和逻辑右移两种，对于负数来说，算术右移在最高位补
1，逻辑右移在最高位补 0.</p>
<p><strong>左移（&lt;&lt;）</strong>：</p>
<p>右移丢弃最高位，在最低位补 0.</p>
<blockquote>
<p>右移相当于乘除 2，左移相当于乘 2.</p>
</blockquote>
<h2 id="位运算经典应用">位运算经典应用</h2>
<h3 id="置-1-与置-0">置 1 与置 0</h3>
<p>把一个 1 字节数据的第 3 位和第 4 位置 0，我们可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> data = <span class="number">0xff</span>;</span><br><span class="line">data &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span> | <span class="number">1</span> &lt;&lt; <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>把一个 1 字节数据的第 5 位和第 6 位置 1，我们可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> data = <span class="number">0xff</span>;</span><br><span class="line">data |= (<span class="number">1</span> &lt;&lt; <span class="number">5</span> | <span class="number">1</span> &lt;&lt; <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<p>把一个把一个 1 字节数据的第 3 位和第 4 位置 0，第 5 位和第 6 位置
1，我们可以这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> data = <span class="number">0x0f</span>;</span><br><span class="line">data = data &amp; ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span> | <span class="number">1</span> &lt;&lt; <span class="number">4</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">5</span> | <span class="number">1</span> &lt;&lt; <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<h3 id="实现加法">实现加法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="type">int</span> temp = a ^ b;</span><br><span class="line">        b = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        a = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3 id="去掉最后一位-1">去掉最后一位 1</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a &amp;= (a - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="统计二进制中-1-的个数">统计二进制中 1 的个数</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (a) &#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    a &amp;= (a - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断奇偶">判断奇偶</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a &amp; <span class="number">1</span> == <span class="number">0</span> <span class="comment">// 为 true 说明是偶数</span></span><br></pre></td></tr></table></figure>
<h3 id="反转指定位">反转指定位</h3>
<p>例如翻转 <code>data</code> 的第 3 位：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">data ^= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h3 id="交换两个数">交换两个数</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>
<h3 id="lowbit-函数">lowbit 函数</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span><br></pre></td></tr></table></figure>
<h3 id="奇数变偶数">奇数变偶数</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a &amp; -2</span><br></pre></td></tr></table></figure>
<p>如果 a 是偶数则不变，如果 a 是奇数则变为小 1 的偶数。</p>
<h2 id="位运算的一些题">位运算的一些题</h2>
<h3 id="题一">题一</h3>
<p><strong>题目描述</strong>：一个数组中有一种数出现了奇数次，其他数出现了偶数次，请你求出这个数。</p>
<p><strong>思路</strong>：把所有的数异或一遍即可。</p>
<p><strong>参考代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printOddTimesNum</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a : arr) &#123;</span><br><span class="line">        res ^= a;</span><br><span class="line">    &#125;</span><br><span class="line">   std::cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题二">题二</h3>
<blockquote>
<p>本题是题一的进阶题。</p>
</blockquote>
<p><strong>题目描述</strong>：一个数组中有两种数出现了奇数次，其他数出现了偶数次，请你求出这两个数</p>
<p><strong>思路</strong>：先假设所有这两个数为 a 和
b，将所有的数异或一遍得到 a ^ b，然后使用 <code>lowbit</code> 函数求出 a
或 b
的最低位，然后以这个最低位的数据为依据，将数据划分为两部分，将其中一部分全部异或一遍即可的到
a 或 b，然后就可以求出另外一个了。</p>
<p><strong>参考代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printOddTimesNum</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> eor &#123;&#125;;</span><br><span class="line">    <span class="type">int</span> rightOne &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : arr) &#123;</span><br><span class="line">        eor ^= a;</span><br><span class="line">    &#125;</span><br><span class="line">    rightOne = eor &amp; (~eor + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((c &amp; rightOne) == <span class="number">0</span>) &#123;</span><br><span class="line">            a ^= c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    b = a ^ eor;</span><br><span class="line">    std::cout &lt;&lt; std::format(<span class="string">&quot;&#123;&#125; &#123;&#125;\n&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<ul>
<li><a
href="https://graphics.stanford.edu/~seander/bithacks.html">Stanford |
Bit Twiddling Hacks</a></li>
<li><a
href="https://blog.hufeifei.cn/2017/07/DataStructure/bit-hacks/index.html">【译】位运算的奇技淫巧：Bit
Twiddling Hacks</a></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>光栅化</title>
    <url>/2023/07/16/%E5%85%89%E6%A0%85%E5%8C%96/</url>
    <content><![CDATA[<p>我们已经通过 MVP 变换将要显示到屏幕上的物体变换到 <span
class="math inline">\(\left[-1, 1\right]^3\)</span>
的立方体中，接下来要将 <span class="math inline">\(\left[-1,
1\right]^3\)</span>
的立方体中的物体绘制到屏幕上。首先定义屏幕（screen）：</p>
<ol type="1">
<li>屏幕是像素（pixels）的数组；</li>
<li>分辨率（resolution）是屏幕像素数组的尺寸；</li>
<li>屏幕是光栅成像设备。</li>
</ol>
<p><strong>光栅化</strong>指的是将物体绘制到屏幕上。像素是具有统一颜色的小方块，是由不同颜色组合而成的（例如
RGB）。</p>
<h2 id="屏幕空间">屏幕空间</h2>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/229706381-92102eb5-bbf8-4c1c-a262-ecac7f479ca3.png" alt="Img" style="zoom:100%;" />
</center>
<p>我们认为屏幕左下角为原点，向右为 <span
class="math inline">\(x\)</span> 轴，向上为 <span
class="math inline">\(y\)</span>
轴。建立平面直角坐标系。屏幕空间满足以下几点：</p>
<ol type="1">
<li>像素坐标 <span class="math inline">\(\left(x, y\right)\)</span>
为整数；</li>
<li>像素坐标覆盖范围为 <span class="math inline">\(\left(0,
0\right)\)</span> 到 <span class="math inline">\(\left(\text{width} - 1,
\text{height} - 1\right)\)</span>；</li>
<li>坐标为 <span class="math inline">\(\left(x, y\right)\)</span>
的像素的中心点的坐标为：<span
class="math inline">\(\left(x+0.5,y+0.5\right)\)</span>；</li>
<li>整个屏幕的覆盖范围为：<span
class="math inline">\(\left(0,0\right)\)</span> 到 <span
class="math inline">\(\left(\text{width},\text{height}\right)\)</span>.</li>
</ol>
<p>在这里，我们先忽略 <span class="math inline">\(z\)</span>
坐标，只考虑 <span class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 坐标。我们需要将 <span
class="math inline">\(\left[-1,1\right]\)</span> 变换到 <span
class="math inline">\(\left[0,\text{width}\right] \times \left[0,
\text{height}\right]\)</span>，称之为<strong>视口变换</strong>，变换矩阵为：
<span class="math display">\[
M_{viewport} = \begin{bmatrix}
\frac{width}{2} &amp; 0 &amp; 0 &amp; \frac{width}{2} \\
0 &amp; \frac{height}{2} &amp; 0 &amp; \frac{height}{2} \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}
\]</span></p>
<h2 id="三角形的光栅化">三角形的光栅化</h2>
<p>对于一个 3
维图形我们可以用三角形去表示一个一个小面。使用三角形的主要原因是：</p>
<ol type="1">
<li>三角形是最基本的多边形；</li>
<li>任何多边形都可以拆分成三角形；</li>
<li>空间内任何三个点的连线一定是平面；</li>
<li>三角形有清晰的内部和外部定义；</li>
<li>三角形只要定义顶点的属性就可以计算三角形内部点的渐变关系（三角形的内部插值）。</li>
</ol>
<p>对于一个三角形，如何映射在像素空间上问题，可以转换成判断一个像素和三角形的位置关系。最简单的方法就是进行<strong>采样</strong>（Sampling）。采样就是连续函数的离散化过程。下面的代码就是对函数
<span class="math inline">\(f(x)\)</span> 进行采样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; xmax; ++x)</span><br><span class="line">    output[x] = <span class="built_in">f</span>(x);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>采样是图形学中的一个核心思想，我们可以对时间（time）、面积（area）、方向（direction）、体积（volume）等进行采样。</p>
</blockquote>
<p>对于给定的三角形，定义一个函数，来判断某个坐标是否在三角形内部，函数定义如下：
<span class="math display">\[
\text { inside }(t, x, y)=\left\{\begin{array}{lc}
1 &amp; \text { point }(x, y) \text { in triangle } t \\
0 &amp; \text { otherwise }
\end{array}\right.
\]</span> 那么对三角形采样的代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; xmax; ++x)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; ymax; ++y)</span><br><span class="line">        image[x][y] = <span class="built_in">inside</span>(tri, x + <span class="number">0.5</span>, y + <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：判断某个像素是否在三角形内部实际上是判断像素的中心是否在三角形内部。</p>
</blockquote>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/229712533-69e42641-49bf-4ec9-9c44-3d45b768ead0.png" alt="Img" style="zoom:70%;" />
</center>
<p>判断某个像素是否在三角形内部，可以使用叉乘。对于三角形边界上的点，这里不做处理。</p>
<p>为了能够更快速的遍历像素点，我们可以用以下方法：</p>
<ul>
<li>使用包围盒（Bounding
box），只对三角形最大的包围正方形区进行遍历。但是不适用于窄长的三角形。</li>
<li>找到每一行三角形包围住最左和最右边的点进行遍历。</li>
</ul>
<h2 id="反走样">反走样</h2>
<p>光栅化的三角形可能会生成大量的据此，此时我们需要一些方式来消除锯齿。</p>
<h3 id="瑕疵">瑕疵</h3>
<p>在采样的过程中，我们会产生许多的锯齿。这些锯齿的学名就叫做<strong>走样</strong>（Alias）。之所以会产生走样的原因是因为信号的变化速度比较快（高频信号），但是我们的采样比较慢（低频采样）。常见的走样分为以下几种：</p>
<ul>
<li>锯齿：空间上采样产生的走样；</li>
<li>摩尔纹：空间上下采样产生的走样；</li>
<li>车轮效应：时间上采样产生的走样。</li>
</ul>
<p>这些我们也称为采样的<strong>瑕疵</strong>（Artifacts）。</p>
<h3 id="走样产生的原因">走样产生的原因</h3>
<h4 id="傅立叶变换">傅立叶变换</h4>
<p>任何一个信号都可以表示为一些正弦波和余弦波以及常数的线性表示，我们称之为<strong><a
href="https://zh.wikipedia.org/wiki/%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0">傅立叶展开</a></strong>。而<strong><a
href="https://zh.wikipedia.org/wiki/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2">傅立叶变换</a></strong>指的是将一个时域上的信号转换到频域的过程。</p>
<h4 id="走样和滤波">走样和滤波</h4>
<p>走样更为学术的定义是两个不同频率的信号在使用相同采样的方法后产生的结果无法进行区分。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/229715145-9eb2f23b-e5c8-4705-ab55-ee70f62b1928.png" alt="Img" style="zoom:100%;" />
</center>
<p>图中的红色信号和蓝色信号是两个频率不一样的信号，绿色虚线处是采样点，我们发现两个不同频率的信号在同一个采样方式下结果相同，这就产生了走样。</p>
<p><strong>滤波</strong>（Filter）是把特定频率的波过滤掉。如果仅保留高频信息，那么这称为高通滤波；如果仅保留低频信息称为低通滤波；如果既删除高频信息，还删除低频信息，只保留中频信息称为带通滤波。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/229715725-bb3283a8-9d43-4dfc-bcc0-91586603a77b.png" alt="Img" style="zoom:100%;" />
</center>
<p>对一个图片进行傅立叶变换后，得到的是上图右图的样子。中心代表了低频信息，边缘代表了高频信息，亮度代表对应频率的能量。对于图片而言，一般低频信息更加的丰富，而高频信息比较少。高频信息一般代表<strong>边缘信息</strong>，因为边缘信息频率比较高；低频信息是图片<strong>模糊后的结果</strong>，频率变化小。</p>
<h3 id="卷积和卷积定律">卷积和卷积定律</h3>
<p>滤波可以看作卷积操作，也可以看作平均操作。<strong>卷积</strong>（Convolution）操作是用一个卷积核在信号上不断地滑动，每一次卷积操作的结果是卷积核和对应位置信号乘积的和，可以看作一次加权平均的过程。</p>
<p>卷积定律：时域上的卷积等于频域上的乘积，频域上的乘积等于等于频域上的卷积。</p>
<h4 id="box-filter">Box Filter</h4>
<p>Box Filter 是一个格式如下的滤波器： <span class="math display">\[
\frac{1}{n^2} X^{n\times n}
\]</span> 其中，<span class="math inline">\(X\)</span> 是一个全 <span
class="math inline">\(1\)</span> 矩阵。这个卷积核对临近的 <span
class="math inline">\(n \times n\)</span> 的像素做平均。<span
class="math inline">\(n\)</span>
越大，滤波器得到的频率范围越低。下图是一个 <span class="math inline">\(3
\times 3\)</span> 的 Box Filter.</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/229717368-4b294929-ce87-4f8d-b741-a63a8b0220ac.png" alt="Img" style="zoom:60%;" />
</center>
<h4 id="深入了解采样">深入了解采样</h4>
<p>采样我们可以认为是一个连续函数乘以一系列的脉冲函数的结果。根据卷积定律我们知道，这相当于连续函数的傅立叶变换和脉冲函数傅立叶变换的卷积。脉冲函数的傅立叶变换还是脉冲函数。卷积的结果是信号的频谱在不断地重复。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/229717860-97bec33e-e0b5-4e65-8da0-046940764d1e.png" alt="Img" style="zoom:100%;" />
</center>
<p>当采样率不足时会使得频谱之间的间隔太小，导致频谱间产生重叠，这些重叠就是走样。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/229718235-28dffa88-75ca-488c-9c2e-37e3b161f12d.png" alt="频谱重叠示意图" style="zoom:75%;" />
</center>
<p>这也就解释了为什么使用高通滤波器可以帮助我们减少走样。这是因为使用高通滤波器只保留更窄的频率范围，可以减少频谱的重叠。</p>
<h3 id="反走样的方法">反走样的方法</h3>
<p>目前常用的反走样方法有两种：</p>
<ul>
<li>提高采样率（分辨率）。这是从物理层面上提高采样率来减少走样的方式，但是不够实用；</li>
<li>采用低通滤波器先进行模糊操作，再进行采样的操作。如下图所示：</li>
<li>超采样（Supersampling）。</li>
</ul>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/229804678-bc129ae7-9d27-4c36-997a-5dacc0f3cce6.png" alt="Img" style="zoom:75%;" />
</center>
<h3 id="超采样">超采样</h3>
<p>在实际的操作中，我们使用 MSAA（Multi-Sampling
Antialiasing）的方式来近似进行反走样的操作，具体的步骤如下：</p>
<ol type="1">
<li>把每一个像素点拆分成 <span class="math inline">\(n \times n\)</span>
的小像素点；</li>
<li>对每一个小像素点判断该点是否在图形中；</li>
<li>每一个像素点的结果都是这些小像素点的平均结果。</li>
</ol>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/229805927-c5acc8ea-b1a7-4dd3-b3a9-023beee63260.png" alt="Img" style="zoom:50%;" />
<img data-src="https://user-images.githubusercontent.com/62458905/229806033-26f6c6a2-8c9f-4795-88f8-2a5972eea2cc.png" alt="Img" style="zoom:50%;" />
<img data-src="https://user-images.githubusercontent.com/62458905/229806257-f6180162-949c-4e79-ac1f-fa1b912d1d57.png" alt="Img" style="zoom:50%;" />
</center>
<p>MSAA
仅仅指的是模糊的过程，并不包含采样的过程。这样的方法虽然简单，效果好，但是会增加计算量。在工业界中，一般会采用更为有效的方式拆分采样点，甚至会复用采样点以达到更好的效果。</p>
<p>除此之外，目前业界还有一些其他的方式进行反走样：</p>
<ul>
<li>FXAA（Fast approximate
AA）是通过后期处理的方式处理锯齿。先得到已经有锯齿的图像，找到边界后替换成没有锯齿的边界；</li>
<li>TAA（Temporal
AA）是通过抖动的方式进行多次采样，将多个帧合成就相当于多次采样。</li>
</ul>
<blockquote>
<p>超分辨率：将一个分辨率较小的图片还原成分辨率较大的图片。和反走样虽然意义不同，但是任务类似。对于超分辨率问题，最重要的是猜测缺失像素的内容，比较适合使用神经网络进行预测，即所谓的
DLSS（Deep-learning Super Sampling）。</p>
</blockquote>
<h2
id="可见性与遮挡性visibility-and-occlusion">可见性与遮挡性（Visibility
And Occlusion）</h2>
<p>当有多个三角形需要光栅化时，我们需要正确处理三角形的前后关系，以保证前面的三角形会正确地遮挡后面的三角形。</p>
<h3 id="画家算法painters-algorithm">画家算法（Painter’s Algorithm）</h3>
<p>画家算法是通过模拟油画家的作画方式来进行渲染。油画家们在画油画时，会先画处于远处的物体，然后再画处于近处的物体，这样处于近处的物体就会遮挡处于远处的物体。类似的，在光栅化三角形时，先光栅化处于远处的三角形，再光栅化处于近处的三角形。这个算法需要先将所有的三角形按照深度（即
<span class="math inline">\(z\)</span> 坐标）进行排序，假设有 <span
class="math inline">\(n\)</span> 个三角形，排序算法的复杂度为 <span
class="math inline">\(\Omicron\left(n \log
n\right)\)</span>。这个算法存在以下几个问题：</p>
<ol type="1">
<li>算法复杂度较高；</li>
<li>有时候不好确定各个三角形的远近，甚至会出现下图所示的情况。</li>
</ol>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/229811294-639cc1ee-355c-4d67-b12c-911f00ac2b96.png" alt="遮挡成环的情况" style="zoom:75%;" />
</center>
<h3 id="z-buffer">Z-Buffer</h3>
<p><strong>深度缓存</strong>（Z-Bufer）算法是处理远近的终极算法。</p>
<p>深度缓存会记录每个像素最小的深度值，会生成深度缓存（Depth
buffer）和颜色缓存（Frame
buffer）遍历所以三角形上的点，对于任意一个像素，我们记录下这个像素上深度最小的深度信息和颜色信息（假设深度是正数）。Z-Buffer
算法的描述如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (each triangle T) &#123;</span><br><span class="line">    <span class="keyword">for</span> (each <span class="built_in">sample</span>(x, y, z) in T) &#123;</span><br><span class="line">        <span class="keyword">if</span> (z &lt; zbuffer[x, y]) &#123;	<span class="comment">// closest sample so far</span></span><br><span class="line">            framebuffer[x, y] = rgb;	<span class="comment">// update color</span></span><br><span class="line">            zbuffer[x, y] = z;	<span class="comment">// update depth</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// do nothing, this sample is occluded</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>使用深度缓存生成的深度缓存图和颜色缓存图如下所示：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/229814214-df26dd9e-899e-453e-b78c-a25cd2d67668.png" alt="Img" style="zoom:100%;" />
</center>
<p>深度缓存技术的时间复杂度是 <span class="math inline">\(\Omicron
\left(n\right)\)</span>。这并不是一个排序算法，因此复杂度比排序算法要小。如果
MASS 中需要深度缓存技术，需要对每一个采样点应用 Z-Buffer 算法。</p>
]]></content>
      <categories>
        <category>GAMES 101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>光栅化</tag>
      </tags>
  </entry>
  <entry>
    <title>几何</title>
    <url>/2023/07/16/%E5%87%A0%E4%BD%95/</url>
    <content><![CDATA[<h2 id="几何的描述">几何的描述</h2>
<p>在图形学中几何的描述有两种方式，<strong>隐式几何</strong>（Implicit
Geometry）和<strong>显式几何</strong>（Explicit Geometry）</p>
<h3 id="隐式几何">隐式几何</h3>
<p>隐式几何对点的之间的关系进行描述，不直接给出点的位置。例如，对于一个球面，我们可以使用如下方程描述：
<span class="math display">\[
x^2 + y^2 + z^2 = 1
\]</span></p>
<p>几何的隐式表示很难看出其图像，但可以非常轻松地判断一个点是否在曲面上或者在图形内部。隐式几何</p>
<ul>
<li>数学方程表示；</li>
<li>CSG 表示；</li>
<li>距离函数；</li>
<li>分形；</li>
</ul>
<h4 id="数学方程表示">数学方程表示</h4>
<p>例如，一个球体可以表示为下面的方程： <span class="math display">\[
x^2 + y^2 + z^2 = 1
\]</span> 一般地，可以使用方程 <span class="math inline">\(f\left(x, y,
z\right) = 0\)</span> 一个曲面。</p>
<p>使用数学方程表示难以看出其图形，但可以快速判断一个点是否在曲面上，如果是一个封闭的曲面，还可以快速地判断一个点是否在曲面内。</p>
<h4 id="csg-表示">CSG 表示</h4>
<p>CSG（Constructive Solid
Geometry），通过对几何体进行布尔运算，即交、并、差等运算，用简单的几何集合体组合成复杂的集合体。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230601169-6e7588ce-2a49-4596-bbd4-67e4ae23f971.png" alt="Img" style="zoom:100%;" />
</center>
<p>下面是一个使用 CSG 得到复杂几何体的例子：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230601309-579bb648-3c37-4388-909b-58a71b891eec.png" alt="Img" style="zoom:50%;" />
</center>
<h4 id="距离函数">距离函数</h4>
<p>距离函数表现了空间内任意一点到物体的最短距离。两个距离函数的加和可以得到两个物体融合的中间态。非常适合在模拟水滴融合中使用，如下图所示：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230601529-44c67780-cb4f-41e6-9262-9d6b15c65d5d.png" alt="Img" style="zoom:100%;" />
</center>
<p>距离函数中距离为 0
的平面就是物体平面。下图是一个使用距离函数的例子：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230601664-33cc873d-f837-4519-8186-e39925c9c77d.png" alt="Img" style="zoom:100%;" />
</center>
<p>距离函数还可以使用<strong>水平集</strong>（Level
Set）来离散的表示：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230601735-44863632-a800-498f-8c4f-85a03befdce8.png" alt="Img" style="zoom:100%;" />
</center>
<h4 id="分形">分形</h4>
<p>指的是一个图形的一部分和自己整体相比高度相似，可以理解为一种递归的形式。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230601940-519df89f-10ce-4e19-9682-209324262955.png" alt="Img" style="zoom:100%;" />
</center>
<h3 id="显式几何">显式几何</h3>
<p>显示几何有 3 种标识方式：</p>
<ol type="1">
<li><p>参数映射（参数方程）；</p></li>
<li><p>点云；</p></li>
<li><p>多边形面。</p></li>
</ol>
<h4 id="参数映射">参数映射</h4>
<p>定义一个映射： <span class="math display">\[
f: \R^2 \rightarrow \R^3;\left(u, v\right) \mapsto\left(x, y, z\right)
\]</span></p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230602628-8a86e440-dd26-48b8-988a-5b5ce5919797.png" alt="Img" style="zoom:100%;" />
</center>
<p>这个映射将 <span class="math inline">\(\left(u, v\right)\)</span>
映射到 <span class="math inline">\(\left(x, y, z\right)\)</span>. 例如：
<span class="math display">\[
f\left(u, v\right) = \left((2 + \cos u)\cos v,(2 + \cos u)\sin v, \sin
u\right)
\]</span> 就是一个参数方程。在例如： <span class="math display">\[
f\left(u, v\right) = \left(\cos u \sin v, \sin u \sin v, \cos v\right)
\]</span> 表示一个球面。</p>
<h4 id="点云">点云</h4>
<p>用一系列空间中三维的坐标来表示物体。点越密集，所形成的模型效果越好。一般会使用点云生成三角形面。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230603483-b477ef8a-90dd-4553-9900-2603f0bc5ca5.png" alt="Img" style="zoom:50%;" />
</center>
<h4 id="多边形面">多边形面</h4>
<p>一般使用三角形或者四边形来表示。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230603598-8a2c946d-f980-4c3c-ada3-f4a438ff4d67.png" alt="Img" style="zoom:50%;" />
</center>
<p>使用 Wavefront Object File（.obj）格式的文件来存储。在 obj
文件中定义了顶点坐标，法线方向以及纹理坐标还有它们之间的关系，如下所示：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># This is a comment</span><br><span class="line"></span><br><span class="line">V 1.000000 -1.000000 -1.000000</span><br><span class="line">v 1.000000 -1.000000 1.000000</span><br><span class="line">V -1.000000 -1.000000 1.000000</span><br><span class="line">V -1.000000 -1.000000 -1.000000</span><br><span class="line">V 1.000000 1.000000 -1.000000</span><br><span class="line">V 0.999999 1.000000 1.000001</span><br><span class="line">v -1.000000 1.000000 1.000000</span><br><span class="line">v -1.000000 1.000000 -1.000000</span><br><span class="line"></span><br><span class="line">vt 0 748573 0.750412</span><br><span class="line">vt 0.749279 0.501284</span><br><span class="line">vt 0.999110 0.501077</span><br><span class="line">vt 0.999455 0.750380</span><br><span class="line">vt 0.250471 0.500702 </span><br><span class="line">vt 0.249682 0.749677</span><br><span class="line">vt 0.001085 0.750380</span><br><span class="line">vt 0.001517 0.499994</span><br><span class="line">vt 0.499422 0.500239</span><br><span class="line">vt 0.500149 0.750166</span><br><span class="line">vt 0.748355 0.998230</span><br><span class="line">vt 0.500193 0.998728</span><br><span class="line">vt 0.498993 0.250415</span><br><span class="line">vt 0.748953 0.250920 </span><br><span class="line"></span><br><span class="line">vn 0.000000 0.000000 -1.000000</span><br><span class="line">vn -1.000000 -0.000000 -0.000000</span><br><span class="line">vn -0.000000 -0.000000 1.000000</span><br><span class="line">vn -0.000001 0.000000 1.000000</span><br><span class="line">vn 1.000000 -0.000000 0.000000</span><br><span class="line">vn 1.000000 0.000000 0.000001</span><br><span class="line">vn 0.000000 1.000000 -0.000000</span><br><span class="line">vn 0.000000 -1.000000 0.000000</span><br><span class="line"></span><br><span class="line">f 5/1/1 1/2/1 4/3/1</span><br><span class="line">f 5/1/1 4/3/1 8/4/1</span><br><span class="line">f 3/5/2 7/6/2 8/7/2</span><br><span class="line">f 3/5/2 8/7/2 4/8/2</span><br><span class="line">f 2/9/3 6/10/3 3/5/3</span><br><span class="line">f 6/10/4 7/6/4 3/5/4 </span><br><span class="line">f 1/2/5 5/1/5 2/9/5</span><br><span class="line">f 5/1/6 6/10/6 2/9/6</span><br><span class="line">f 5/1/7 8/11/7 6/10/ 7</span><br><span class="line">f 8/11/7 7/12/7 6/10/7</span><br><span class="line">f 1/2/8 2/9/8 3/13/8</span><br><span class="line">f 1/2/8 3/13/8 4/ 14/8</span><br></pre></td></tr></table></figure>
<h2 id="曲线">曲线</h2>
<h3 id="贝塞尔曲线">贝塞尔曲线</h3>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230604540-760657ae-a8a6-41ee-b527-46f18f76e86a.png" alt="Img" style="zoom:75%;" />
</center>
<h4 id="de-casteljau-算法">de Casteljau 算法</h4>
<p>先考虑 3 个控制点的情况：使用 3
个控制点画出的贝塞尔曲线称为二次贝塞尔曲线（quadratic
Bézier），算法如下：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230604902-23497238-f7ad-4fe4-ba0d-8cb5035b04f0.png" alt="Img" style="zoom:75%;" />
</center>
<p>对于 <span class="math inline">\(b_0\)</span>、<span
class="math inline">\(b_1\)</span>、<span
class="math inline">\(b_2\)</span>
定义的贝塞尔曲线，我们将求贝塞尔曲线的过程转换成求在 <span
class="math inline">\(t\left(t\in\left[0,1\right]\right)\)</span>时刻，对应贝塞尔曲线上的点。</p>
<ol type="1">
<li>求出线段 <span class="math inline">\(b_0b_1\)</span> 和线段 <span
class="math inline">\(b_1b_2\)</span> 上对应 <span
class="math inline">\(t\)</span> 时刻的点 <span
class="math inline">\(b_0^1b_1^1\)</span>；</li>
<li>将 <span class="math inline">\(b_0^1b_1^1\)</span>
连接起来后，重复步骤 1 即可。点 <span
class="math inline">\(b_0^2\)</span> 就是我们得到的最终点。</li>
</ol>
<p>考虑多个点的情况：仿照三个点的情况，每一次都在对应线段上找到对应时刻
<span class="math inline">\(t\)</span>
所对应的点，并将相邻的点连成线段后重复上面的过程，直到得到最后一个点。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230605358-9e38bee6-ccb1-44a9-b403-37c34f216191.png" alt="Img" style="zoom:75%;" />
</center>
<p>可以看出，de Casteljau 算法是做了多次的线性插值。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230605536-42fe39b5-000c-4575-b584-3e9a292742a8.png" alt="Img" style="zoom:75%;" />
</center>
<h4 id="贝塞尔曲线的代数公式">贝塞尔曲线的代数公式</h4>
<p>贝塞尔曲线的代数公式为： <span class="math display">\[
b^n = b^n_0 = \sum ^n _{j = 0}b_jB_j^n(t)
\]</span> 其中 <span class="math inline">\(B^n_j\)</span> 是 Bernstein
多项式，它可视为对 <span class="math inline">\(\left[1 +
\left(1-t\right)\right]\)</span> 的二项展开。 <span
class="math display">\[
B_j^n(t)=\left(\begin{array}{l}
n \\
i
\end{array}\right) t^i(1-t)^{n-i}
\]</span></p>
<h4 id="贝塞尔曲线的性质">贝塞尔曲线的性质</h4>
<ol type="1">
<li>Bernstein 所有项的和为 1；</li>
<li>贝塞尔曲线必须过起点和终点；</li>
<li>对于 3 次贝塞尔曲线来说，起点处的切线为 <span
class="math inline">\(b&#39;(0) = 3(b_1 - b_0)\)</span>，终点处的切线为
<span class="math inline">\(b&#39;(1) = 3(b_3 - b_2)\)</span>。</li>
<li>仿射不变性。贝塞尔曲线做仿射变换生成的曲线等同于对贝塞尔曲线的控制点做仿射变换后再生成的贝塞尔曲线，这个规律不适用于投影变换。</li>
<li>凸包性。贝塞尔曲线一定在控制点所形成的凸包内。凸包是能够包围所有点的最小凸多边形。</li>
</ol>
<h4 id="逐段定义贝塞尔曲线">逐段定义贝塞尔曲线</h4>
<p>当我们使用过多的控制点定义一条曲线时，曲线会变得比较平滑，并且不便控制。因此我们一般使用逐段的方式定义贝塞尔曲线。我们每次使用
4 个控制点，把前两个点和后两个点各看作一个控制杆来控制整个曲线。这正是
Photoshop 中的钢笔工具的基本原理。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230606696-6027e7d9-db66-4e3c-9b71-aee384efaf2f.png" alt="Img" style="zoom:75%;" />
</center>
<h4 id="曲线的连续">曲线的连续</h4>
<p><span class="math inline">\(C^0\)</span> 连续：<span
class="math inline">\(a_n = b_0\)</span>.</p>
<p><span class="math inline">\(C^1\)</span> 连续：<span
class="math inline">\(a_n = b_0 = \frac{1}{2}(a_{n - 1} +
b_1)\)</span>.</p>
<h3 id="样条曲线">样条曲线</h3>
<p>https://www.bilibili.com/video/av66548502/?from=search&amp;seid=65256805876131485&amp;vd_source=76a5184e318e57fe3ff6a57c443142ad</p>
<h2 id="曲面">曲面</h2>
<p>可以将贝塞尔曲线拓展到贝塞尔曲面。</p>
<h4 id="贝塞尔曲面">贝塞尔曲面</h4>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230607503-574f0bd6-cdbf-4945-a4d7-379f31621a63.png" alt="Img" style="zoom:75%;" />
</center>
<p>贝塞尔曲面的计算类似于双线性插值的过程。我们使用 <span
class="math inline">\(4 \times 4\)</span>
个点形成贝塞尔曲面。首先，我们在每一行生成 4 条贝塞尔曲线，接下来在 4
条贝塞尔曲线上找到相同时刻对应的 4
个点生成一条新的贝塞尔曲线。这些贝塞尔曲线的集合形成了贝塞尔曲面。</p>
<p>对于贝塞尔曲面，我们需要两个变量 <span
class="math inline">\(u\)</span>、<span class="math inline">\(v\)</span>
对其进行数学表示。</p>
<h2 id="网格操作">网格操作</h2>
<ul>
<li>表面细分</li>
<li>表面简化</li>
<li>网格正则化</li>
</ul>
<h3 id="网格细分">网格细分</h3>
<h4 id="loop-细分">Loop 细分</h4>
<p>Loop
细分适用于只有三角形面的模型。首先，将将三角形三条边的中点连接起来，这样
1 个三角形就变成了 4
个三角形。称每条边上的中点为新顶点，三角形原来的三个点为旧顶点。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230607870-ab340623-e463-46fb-b2a5-b30813f28039.png" alt="Img" style="zoom:75%;" />
</center>
<p>对于新顶点，采用如下公式更新其位置：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230608151-80f38d0e-9cc6-4fa9-badf-365b1485d5f5.png" alt="Img" style="zoom:50%;" />
</center>
<p><span class="math display">\[
\frac{3}{8}\left(A+ B\right) + \frac{1}{8}\left(C + D\right)
\]</span></p>
<p>对于旧顶点，设其度为 <span
class="math inline">\(n\)</span>，其更新公式为：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230608540-c1777cd2-4f77-48b6-b756-83c47e6b045f.png" alt="Img" style="zoom:50%;" />
</center>
<p><span class="math display">\[
(1 - n\times u)\times  \text{original\_position} +  u\times
\text{neighbor\_position\_sum}
\]</span></p>
<p>其中： <span class="math display">\[
u =\left\{\begin{array}{lc}
\frac{3}{16} &amp; n = 3 \\
\frac{3}{8n} &amp; \text { otherwise }
\end{array}\right.
\]</span></p>
<h4 id="catmull-clerk-细分">Catmull-Clerk 细分</h4>
<p>Catmull-Clerk
细分适用于某些面是非三角形的时候进行细分。我们做出以下定义，如果一个面是四边形，那么称为四边形面，反之为非四边形面。任何一个度不是
4 的点都称为奇异点，反之为非奇异点。</p>
<p>每一次细分我们都在每一条边的中点产生新的顶点，并在每一个面上引入一个中点，将面的中点和边上的中点相连，这就是一次细分操作。这样的细分操作满足一下规律：</p>
<ol type="1">
<li>在第一次细分后，所有原本是非四边形内部都会引入奇异点，并且所有的面都变成了四边形面；</li>
<li>之后的细分，不会再引入新的奇异点，所有的面都是四边形面。</li>
</ol>
<p>对于面心的点 <span class="math inline">\(f\)</span>，计算公式为：
<span class="math display">\[
f = \frac{v_1 + v_2 + v_3 + v_4}{4}
\]</span></p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230609862-8b789389-9881-4d30-b7b9-669084f371a8.png" alt="Img" style="zoom:75%;" />
</center>
<p>对于边上新生成的中点 <span
class="math inline">\(e\)</span>，计算公式为: <span
class="math display">\[
e = \frac{v_1 + v_2 + f_1 + f_2}{4}
\]</span></p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230609877-8df8ace5-aa6c-441d-85d1-40d9bd2ad85e.png" alt="Img" style="zoom:75%;" />
</center>
<p>对于旧顶点 <span class="math inline">\(v\)</span>，计算公式为： <span
class="math display">\[
v = \frac{f_1 + f_2 + f_3 + f_4 + 2(m_1 + m_2 + m_3 + m_4) + 4p}{16}
\]</span></p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230609901-31a04399-52ba-4e9d-97b3-618503e7105d.png" alt="Img" style="zoom:75%;" />
</center>
<h3 id="网格简化">网格简化</h3>
<p>网格简化（Mesh
Simplify）通过减少模型的面数简化模型。对于一个模型，我们可以通过构造不同的层级，在不同的情况下选择不同的模型。</p>
<p>我们使用坍缩（Collapsing）的方式进行网格简化。我们将边坍缩变成一个点。我们希望这个点和旧顶点连接后与之前的形状差不多，因此我们引入二次误差度量（Quadric
Error
Metrics）来度量任意一点与旧顶点连接后与原来的相似程度，并选择最小值作为结果。</p>
<p>在模型中，当我们进行坍缩的时候，我们会对所有可以坍缩的点进行排序，每一次探索误差最小的点后，更新这个点周围的点新的误差值。这里采用堆或者优先队列的方式进行实现。</p>
<p>网格简化是一种贪心算法，我们使用局部的最优解并认为是全局最优的结果。</p>
]]></content>
      <categories>
        <category>GAMES 101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>几何</tag>
        <tag>贝塞尔曲线</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/2023/07/16/%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="函数的概念">函数的概念</h2>
<p>函数就是一段 C 语言语句的集合，通过将 C
语言函数封装到函数里可以实现代码复用和简化编程。</p>
<h2 id="函数的分类">函数的分类</h2>
<p><strong>从定义角度分类（即是库函数还是自定义函数）</strong>：</p>
<ol type="1">
<li>库函数；</li>
<li>自定义函数；</li>
<li>系统调用。</li>
</ol>
<p><strong>从参数角度分类</strong>：</p>
<ol type="1">
<li>有参函数；</li>
<li>无参数函数；</li>
</ol>
<p><strong>从返回值角度分类</strong>：</p>
<ol type="1">
<li>有返回值的函数；</li>
<li>无返回值的函数；</li>
</ol>
<blockquote>
<p>注意：</p>
<ol type="1">
<li>有返回值的函数必有一个 <code>return</code> 语句；</li>
<li>无返回值的函数可以有不必有 <code>return</code> 语句，可以使用
<code>return</code> 语句提取返回。</li>
</ol>
</blockquote>
<h2 id="函数的定义">函数的定义</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名(形参列表) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ol type="1">
<li>函数名要符合命名规则；</li>
<li>形成列表不是必须有；</li>
<li>返回值类型可以是所有的基本数据类型和自定义数据类型，或者
<code>void</code>，也可以是指针；</li>
<li>函数不能同名。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myfun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nihao beijing\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;welcome to 1000phone\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myfun2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    sum = a + b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>, a, b, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myfun3</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    sum = a + b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数声明">函数声明</h2>
<p>声明就是将函数头写在程序里。</p>
<blockquote>
<p>函数头就是函数去掉函数体和花括号加上 <code>;</code>
之后的东西，例如：<code>int sum(int, int)</code>，函数头的形参列表可以只声明参数类型而不给出参数名。</p>
</blockquote>
<p>编译器默认是自上而下进行编译的，如果主调函数在被调函数之上，这时候需要在主调函数声明前面声明被调函数，否则编译器找不到被调函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面情况就无需声明函数，而下面这种情况就必须要声明函数了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>); &#125;</span><br></pre></td></tr></table></figure>
<p>有时候一个函数的定义在另外一个 <code>.c</code>
文件里，这时候我们可以将函数声明在一个 <code>.h</code>
文件里，这样我们只需使用 <code>#include</code> 宏去引入这个
<code>.h</code> 文件就可以了，编译的时候将这两个 <code>.c</code>
文件一起编译，例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fun.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight h"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fun.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FUN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUN_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fun.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fun.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a + b; &#125;</span><br></pre></td></tr></table></figure>
<p>使用如下命令编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc main.c fun.c -o main</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fun.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a + b; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用如下命令编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc main.c fun.c -o main</span><br></pre></td></tr></table></figure>
<h2 id="函数的调用">函数的调用</h2>
<p>语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">变量 = 函数名(实参列表); <span class="comment">// 带返回值</span></span><br><span class="line">函数名(实参列表);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myfun1</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myfun2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">myfun3</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    myfun1();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**********************\n&quot;</span>);</span><br><span class="line">    myfun2(<span class="number">100</span>, <span class="number">90</span>);</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line">    myfun2(x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**********************\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    n = myfun3(<span class="number">100</span>, <span class="number">90</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n = %d\n&quot;</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum = %d\n&quot;</span>, myfun3(<span class="number">90</span>, <span class="number">66</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myfun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nihao beijing\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;welcome to 1000phone\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myfun2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    sum = a + b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>, a, b, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myfun3</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    sum = a + b;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/137eb380-3b1c-464b-9fcd-84e9bf391572"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="变量的存储类别">变量的存储类别</h2>
<h3 id="内存的分区">内存的分区</h3>
<p>内存分为<strong>物理内存</strong>和虚拟内存。</p>
<ul>
<li>物理内存：实实在在的存储设备；</li>
<li>虚拟内存：操作系统虚拟出来的内存。</li>
</ul>
<p>操作系统会将虚拟内存和物理内存进行映射。</p>
<p>在 32 位操作系统下，每个进程的寻址范围位
<code>0x00000000~0xffffffff</code>，即
4G，我们在编程时看到的内存地址都是虚拟地址。</p>
<p>在程序运行时，操作系统会将<strong>虚拟内存</strong>进行分区：</p>
<ul>
<li>堆：在动态申请内存时，会在堆区开辟空间；</li>
<li>栈：主要存放局部变量；</li>
<li>静态全局区：
<ul>
<li>位初始化的静态全局区：没有初始化的静态变量（<code>static</code>
修饰的变量），或全局变量存放在此区；</li>
<li>初始化了的静态全局区：初始化过的全局变量、静态变量存在此区。</li>
</ul></li>
<li>代码区：存放代码的区；</li>
<li>文字常量区：存放常量的区；</li>
</ul>
<h3 id="普通的全局变量">普通的全局变量</h3>
<p>在函数外部定义的变量就是一个全局变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">100</span>; <span class="comment">// num就是一个全局变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>作用范围：全局变量作用范围时整个程序，在其他文件中要使用这个变量，需要使用
<code>extern int num;</code> 声明，声明时不要赋值。</p>
<p>生命周期：从程序开始运行到程序结束。</p>
<blockquote>
<p>定义普通全局变量时，如果没有赋初始值，其有默认值 0.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myfun</span><span class="params">()</span> &#123; num = <span class="number">888</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line">    myfun();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/2b28f42c-b5ef-4002-8935-e1d2979cb9b3"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="静态全局变量">静态全局变量</h3>
<p><code>static</code> 修饰的全局变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> num = <span class="number">100</span>; <span class="comment">// num就是一个静态全局变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>作用范围：只在定义其的 <code>.c</code> 文件中有效。</p>
<p>生命周期：从程序开始运行，到程序结束。</p>
<blockquote>
<p>定义静态全局变量时如果没有赋初始值，其有默认值 0.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myfun</span><span class="params">()</span> &#123; num++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line">    myfun();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/09f005ad-8b82-4f05-814d-6ec2830decd2"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="普通的局部变量">普通的局部变量</h3>
<p>在函数内部定义的、或者在复合语句中定义的变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num; <span class="comment">// 局部变量</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a; <span class="comment">// 局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作用域：从定义其的语句那里开始，到包含它的花括号结束。</p>
<p>生命周期：调用函数时才为局部变量开辟空间，函数结束时释放空间。复合语句块亦如此。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myfun</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    myfun();</span><br><span class="line">    myfun();</span><br><span class="line">    myfun();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/d5185b23-4161-4b3d-846c-d99232e622de"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="静态的局部变量">静态的局部变量</h3>
<p><code>static</code> 修饰的局部变量。</p>
<p>作用范围：在定义它的函数或复合语句块中有效。</p>
<p>生命周期：第一次调用函数的时候为其开辟空间，函数结束时不释放空间，下次在调用函数时不再为其开辟空间，直接使用之前开辟的那个空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myfun</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myfun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num1 = <span class="number">100</span>;</span><br><span class="line">    num1++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num1 = %d\n&quot;</span>, num1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    myfun();</span><br><span class="line">    myfun1();</span><br><span class="line">    myfun1();</span><br><span class="line">    myfun1();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出·结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/19866be1-b130-4afc-86bc-0eb64b29ab03"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<blockquote>
<p>注意：定义普通局部变量时，如果不赋初始值其值时随着的（它那块内存里的脏数据）；定义静态局部变量时，如果不赋初始值，其值为
0.</p>
</blockquote>
<h3 id="外部函数">外部函数</h3>
<p>普通函数，都是外部函数。即函数可以在程序的任何一个文件中调用。</p>
<p>在分文件编程中，只需要将函数的实现过程写在指定的 <code>.c</code>
文件中，然后将其声明写在指定的 <code>.h</code>
文件中，其他文件只要包含了头文件，就可以使用外部函数。</p>
<h3 id="内部函数">内部函数</h3>
<p><code>static</code> 修饰的函数，又称静态函数。</p>
<p>内部函数只再定义其的 <code>.c</code> 文件中有效。</p>
<blockquote>
<p>扩展：</p>
<ol type="1">
<li>在同一作用范围内，不允许变量重名。</li>
<li>作用范围不同的可以重名。</li>
<li>局部范围内，重名的全局变量不起作用。（就近原则）</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>C 语言基础</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>光线追踪</title>
    <url>/2023/07/16/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/</url>
    <content><![CDATA[<p>光线追踪可以解决解决光栅化中没有解决的一些问题：</p>
<ul>
<li>全局的光照效果不好表示；</li>
<li>软阴影效果的产生；</li>
<li>光泽反射（Glossy reflection）；</li>
<li>间接光照，在漫反射场景中，有些光线在到达眼睛前反射不止一次。</li>
</ul>
<p>光栅化是一种快速、近似的一种渲染方式，用于实时渲染；光线追踪是比较准确但是比较慢的渲染方式，用于离线渲染。</p>
<h2 id="基本光线追踪方法">基本光线追踪方法</h2>
<p>我们假设光线满足下面 3 点要求：</p>
<ol type="1">
<li>光线沿直线传播；</li>
<li>光线与光线直接「无碰撞」；</li>
<li>光线从光源射入人眼中，但在路径反转的情况下，物理性质是不变的（光路的可逆性）。</li>
</ol>
<p>光的可逆性是光线追踪的重要思想（尽管它不符合实际物理学）。</p>
<ul>
<li>通过每像素投射一条光线生成图像</li>
<li>通过向灯光发送光线来检查阴影</li>
</ul>
<p>视眼睛（相机）为一个点，光源为点光源。对于每一个像素，我们从眼睛向像素画出一条光线，如果光线和物体有交点（这个交点要求是光线上的第一个交点，因为后面的交点都会被第一个交点遮挡），将这个交点和光源进行连线，如果可以连接到光源（即连线上无遮挡），那么这一点会被光源照亮，在这一点上要计算着色。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230715952-5e2915dd-a5ba-49c2-9e5c-55afb864f46c.png" alt="Img" style="zoom:75%;" />
</center>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230715967-91f702bd-2922-4d54-afad-2576002b432c.png" alt="Img" style="zoom:75%;" />
</center>
<h2 id="whitted-style-光线追踪">Whitted-Style 光线追踪</h2>
<p>从眼睛沿着像素连接一条光线，我们认为光线在传播过程中会发生反射和折射，且假设反射是完美的镜面反射。将所有反射、折射点和光源连接起来，如果可以连接，则这一点会被光源照亮，那么这一点的着色要叠加到这个像素上。对于一个像素，可能对应多个被照亮的点，<strong>需要将这些点的着色全部叠加到这个像素上</strong>。</p>
<p>我们认为光线在传播的过程中发生反射和折射现象。假设反射是完美的镜面反射。当我们将所有的反射（折射）点和光源连接起来。如果这一点可以被光源照亮，那么我们认为这一点的着色应当叠加在这个像素上。对于光线我们认为存在能量的消逝，不会一直反射。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230716051-fbd5333c-44fb-462d-9c4f-7b0f6c4f8ebd.png" alt="Img" style="zoom:75%;" />
</center>
<p>在上图中，通过了像素但还没通过反射、折射点的光线称为 primary
ray，经过了反射、折射点的光线称为 secondary
rays，从反射、折射点连接到光源的光线称为 shadow rays.</p>
<p>我们需要求出光线与物体表面的交点，才能确定反射点和折射点。</p>
<h2 id="光线-表面求交">光线-表面求交</h2>
<h3 id="光线方程">光线方程</h3>
<p>光线方程通过其光源实在的位置和一个方向向量定义，如下所示：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230716370-e32022af-4b56-4d12-ab60-3c55cbc956d5.png" alt="Img" style="zoom:100%;" />
</center>
<p>光线方程为： <span class="math display">\[
\mathbf{r}\left(t\right)=\mathbf{o}+t \mathbf{d} \quad 0 \leq
t&lt;\infty
\]</span></p>
<h3 id="光线与隐式表面求交">光线与隐式表面求交</h3>
<p>先来看光线如何和球面求交，已知光线方程为： <span
class="math display">\[
\mathbf{r}\left(t\right) = \mathbf{o} + t\mathbf{d} \quad 0 \leq
t&lt;\infty
\]</span> 球面方程为： <span class="math display">\[
\mathbf{p}: \left(\mathbf{p - c}\right)^2 - R^2 = 0
\]</span></p>
<p>那么光线和球面的交点满足： <span class="math display">\[
\left(\mathbf{o} + t\mathbf{d} - \mathbf{c}\right)^2 - R^2 = 0
\]</span> 这是一个二次方程，可以写为： <span class="math display">\[
\begin{align*}
&amp;at^2 + bt^2 + c = 0 \\
&amp;a = \mathbf{d} \cdot \mathbf{d}\\
&amp;b =  2 \left(\mathbf{o} - \mathbf{c}\right) \cdot \mathbf{d}\\
&amp;c = \left(\mathbf{o}-\mathbf{c}\right) \cdot
\left(\mathbf{o}-\mathbf{c}\right) - R^2
\end{align*}
\]</span> 这个方程的解为： <span class="math display">\[
t = \frac{-b \pm \sqrt{b^2 -4ac}}{2a}
\]</span> 解出的 <span class="math inline">\(t\)</span>
为正实数是光线与圆就有交点。</p>
<p>对于一般的隐式表面，其方程为： <span class="math display">\[
\mathbf{p} : f\left(\mathbf{b}\right) = 0
\]</span> 带入光线方程的： <span class="math display">\[
f\left(\mathbf{o} + t\mathbf{d}\right) = 0
\]</span> 只要求解出的 <span class="math inline">\(t\)</span>
为正实数，则光线与表面有交点。</p>
<h3 id="光线与显示三角形面求交">光线与显示三角形面求交</h3>
<blockquote>
<p>对于一个封闭的曲面，我们可以通过求光线与曲面的交点的个数来判断光源实在这个曲面的内部还是内部。如果光线与曲面的交点个数为奇数，则光源在曲面内部；如果光线与曲面的交点个数为偶数，则光源在曲面外部。</p>
</blockquote>
<p>三角形一点处于一个平面上，光线与三角形求交分为两步：</p>
<ol type="1">
<li>求出光线与三角形所在平面的交点；</li>
<li>判断这个交点是否在三角形内部。</li>
</ol>
<p>对于一个平面，我们可以使用平面的法向量和平面上的一点来表示这个平面的方程：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230717077-4c6a3992-0878-4892-a924-716d670140f3.png" alt="Img" style="zoom:100%;" />
</center>
<p>假设平面的法向量为 <span
class="math inline">\(\mathbf{N}\)</span>，平面上的一点为 <span
class="math inline">\(\mathbf{p&#39;}\)</span>，这平面方程为： <span
class="math display">\[
\mathbf{p}: \left(\mathbf{p} - \mathbf{p}&#39;\right) \cdot \mathbf{N} =
0
\]</span> 将光线方程带入平面方程得： <span class="math display">\[
\left(\mathbf{o} + t \mathbf{d} - \mathbf{p}\right)\cdot \mathbf{N} = 0
\]</span> 解得： <span class="math display">\[
t = \frac{\left(\mathbf{p}&#39; - \mathbf{o}\right) \cdot
\mathbf{N}}{\mathbf{d} \cdot \mathbf{N}}
\]</span> 然后检查 <span class="math inline">\(t\)</span>
是否为正实数。</p>
<h3 id="möller-trumbore-算法">Möller Trumbore 算法</h3>
<p>对于 <span class="math inline">\(\triangle
P_0P_1P_2\)</span>，在三角形平面上的点满足：</p>
<p><span class="math display">\[
\mathbf{P} = (1 - b_1 - b_2) \mathbf{P_0} + b_1\mathbf{P_1} +
b_2\mathbf{P_2}
\]</span></p>
<p>求交点得：</p>
<p><span class="math display">\[
\mathbf{O} + t\mathbf{D} = (1 - b_1 - b_2) \mathbf{P_0} +
b_1\mathbf{P_1} + b_2\mathbf{P_2}
\]</span></p>
<p>解得：</p>
<p><span class="math display">\[
\begin{bmatrix}
t \\
b_1\\
b_2
\end{bmatrix} = \frac{1}{\mathbf{S_1} \cdot \mathbf{E_1}}\begin{bmatrix}
\mathbf{S_2} \cdot \mathbf{E_2} \\
\mathbf{S_1} \cdot \mathbf{S} \\
\mathbf{S_2} \cdot \mathbf{D}
\end{bmatrix}
\]</span></p>
<p>其中： <span class="math display">\[
\begin{align*}
\mathbf{E_1} &amp;= \mathbf{P_1} - \mathbf{P_0} \\
\mathbf{E_2} &amp;= \mathbf{P_2} - \mathbf{P_0} \\
\mathbf{S} &amp;= \mathbf{O} - \mathbf{P_0} \\
\mathbf{S_1} &amp;= \mathbf{D} \times \mathbf{E_2} \\
\mathbf{S_2} &amp;= \mathbf{S} \times \mathbf{E_1}
\end{align*}
\]</span> 最后检查 <span class="math inline">\(b1 \ge 0\)</span>、<span
class="math inline">\(b2 \ge 0\)</span>、<span class="math inline">\(1 -
b_1 - b_2 \ge 0\)</span> 是否成立，成立则说明解是合理的。</p>
<h2 id="光线-表面求交加速">光线-表面求交加速</h2>
<p>简单的光线表面求交算法每一像素需要对每一个三角形都进行测试，然后找出深度最小的那个点，这个算法需要计算
<span class="math inline">\(\text{\#pixels} \times
\text{\#traingles}\)</span> 次，是非常慢的。</p>
<h3 id="包围盒bounding-volumes">包围盒（Bounding Volumes）</h3>
<p>将物体使用一个简单的包围盒包起来，如果光线与包围盒都没有交点，则一定与这个物体表面没有交点，所以我们可以先测试包围盒，如果光线与包围盒有交点，再测试物体。</p>
<p>我们常用的包围盒是<strong>轴对齐包围盒</strong>（Axis-Aligned
Bounding Box, AABB），包围盒的长宽高和坐标轴都是平行的。我们认为包围盒是
3 对无限大的平面。</p>
<p>先来看一下 2 维情况下光线与包围盒的求交：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230718152-4ac85887-f9e4-412e-8483-a33a306884b4.png" alt="Img" style="zoom:100%;" />
</center>
<p>我们求出光线在 x 平面上的两个交点以及 y
平面上的两个交点，那么最终光线在包围盒内部的部分是这些交点区间的交集。</p>
<p>可以认为：</p>
<ul>
<li>光线进入到三个面中，才可以进入到包围盒；</li>
<li>光线离开任意一个面，就会离开包围盒。</li>
</ul>
<p>在 3 维的情况下，我们对每对平面求一个 <span
class="math inline">\(t_{\text{min}}\)</span> 和 <span
class="math inline">\(t_{\text{max}}\)</span>，然后令 <span
class="math inline">\(t_{\text{enter}} =
\max{\left\{t_{\text{min}}\right\}}\)</span>，<span
class="math inline">\(t_{\text{exit}} =
\min{\left\{t_{\text{max}}\right\}}\)</span>.</p>
<p>如果 <span class="math inline">\(t_{\text{exit}} \lt
0\)</span>，则包围盒在光源的「背面」；如果 <span
class="math inline">\(t_{\text{exit}} \ge 0\)</span> 且 <span
class="math inline">\(t_\text{enter} \lt
0\)</span>，则光源在包围内。</p>
<p>综上所述，当 <span class="math inline">\(t_\text{enter} &lt;
t_\text{exit}\)</span> 且 <span class="math inline">\(t_\text{exit} \gt
0\)</span> 时，光源和包围盒有交点。</p>
<p>使用轴对齐包围盒可以非常快速地计算出 <span
class="math inline">\(t\)</span>，例如对于垂直于 <span
class="math inline">\(x\)</span> 轴的平面：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230718698-d6ea213d-a9ef-4c4b-9be9-403504b70eb6.png" alt="Img" style="zoom:100%;" />
</center>
<p><span class="math inline">\(t\)</span> 求出来为： <span
class="math display">\[
t = \frac{\mathbf{p}&#39;_x - \mathbf{o}_x}{\mathbf{d}_x}
\]</span></p>
<h3 id="空间划分">空间划分</h3>
<p>为了可以加速光线和物体求交点，我们可以使用大小相同的网格将原本比较大的包围盒进行划分。我们进行网格划分分为以下几个步骤：</p>
<ol type="1">
<li>找到场景中的包围盒；</li>
<li>将包围盒划分成一个一个小格子；</li>
<li>存储哪些小格子中包含物体（我们认为物体都是非实心的面，只记录包含面的小格子，物体内部不包含面的小格子不计入）；</li>
<li>判断光线是否和格子相交，如果光线和某个格子相交并且这个格子中包含物体，那么我们要对存储在这个网格内的所有物体进行求交。</li>
</ol>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230719150-05a4114f-3101-4056-b723-e60b2279813e.png" alt="Img" style="zoom:50%;" />
</center>
<p>在这个里，我们有两个假设：</p>
<ol type="1">
<li>判断光线和格子是否相交是很快的；</li>
<li>我们可以使用类似于光栅化直线的方式来判断直线与那些网格是相交的。</li>
</ol>
<p>一般来说，格子的划分不可以太稀疏也不可以太稠密，需要对格子的量进行控制。网格的数量
<span class="math inline">\(\text{\#cells} = C *
\text{\#objs}\)</span>，在 3 维情况下，<span
class="math inline">\(C\approx 27\)</span>.</p>
<p>这种划分方式对于物体分布均匀的场景比较合适。对于物体分布稀疏的场景需要多次和格子进行相交判断，这种方法相对不合适。</p>
<p>还有其他空间划分方法，包括八叉树（Oct-Tree），KD 树（KD-Tree）以及
BSP 树（BSP-Tree）。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230719373-97d6641d-fe3c-4540-a7b6-e70bf0105192.png" alt="Img" style="zoom:50%;" />
</center>
<ul>
<li><strong>八叉树</strong>（Oct-Tree），将一个包围盒切成八块（图中是二维情况，只有
4
块）。对于每一个小格子我们会继续进行划分直到小格子中没有物体或者物体的数量比较少；</li>
<li><strong>KD
树</strong>（KD-Tree），每一次都进行一次水平划分或者竖直划分，将包围盒分成两部分。可以形成一个二叉树的存储结构。水平划分和竖直划分交替进行，保证划分的空间是均匀的；</li>
<li><strong>BSP
树</strong>（BSP-Tree），每一次选择一个方向进行一次划分，并不是沿着轴平行方向划分。、</li>
</ul>
<p>三种划分方法，KD
树更常用并且使用起来比较方便，可以用二叉树来存储。在每一个二叉树节点中，我们都要储存以下信息：</p>
<ul>
<li>如果是非叶子结点，需要存储划分轴，划分的位置以及孩子节点的指针；</li>
<li>如果是叶子结点，需要存储格子中包含的物体。</li>
</ul>
<p>实际划分出的盒子均在叶子结点上。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230719487-4f0cc5a7-f806-4691-a4b0-ac8a901cef3d.png" alt="Img" style="zoom:50%;" />
</center>
<p>我们通过类似于二分查找的方式计算交点：</p>
<ul>
<li>如果光线和一个节点有交点，那么它和它的子节点也有交点；</li>
<li>如果光线和叶子结点有交点，那么它需要和格子内的所有物体求交点。</li>
</ul>
<p>这种方法存在两个问题，首先，格子和一个三角形面是否相交的判断比较复杂。其次，一个物体可能会在多个不同的格子中，需要多次存储。因此我们会使用更常用的物体划分的方式。</p>
<h3 id="物体划分">物体划分</h3>
<p><strong>物体划分</strong>（Bounding Volume
Hierarchy，BVH）的主要思想是对物体进行进行划分，并重新计算包围盒。BVH
中，每一个物体只属于一个包围盒。</p>
<p>BVH 的划分主要分为以下几步：</p>
<ol type="1">
<li>划分包围盒；</li>
<li>将物体组成的集合划分为两个子集合；</li>
<li>计算每个子集合的包围盒；</li>
<li>当叶子结点的三角形面数量足够少的时候，停止划分。</li>
</ol>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230719748-50bf164f-f9f5-43ea-b151-520f861e91d6.png" alt="Img" style="zoom:100%;" />
</center>
<p>当我们进行划分的时候，也有不同的划分技巧：</p>
<ol type="1">
<li>沿着最长的轴划分为两半（让长轴变短，分割更加均匀）；</li>
<li>取中间的物体进行划分，可以保证两边三角形数量差不多（找到第 <span
class="math inline">\(k\)</span> 个物体的算法可以在 <span
class="math inline">\(\Omicron(n)\)</span>
的时间内解决，被称作快速选择算法）；</li>
<li>当包围盒中的物体数量小于一定数量的时候停止划分。</li>
</ol>
<p>非叶子节点存储：</p>
<ul>
<li>包围盒</li>
<li>孩子节点的指针。</li>
</ul>
<p>叶子节点存储：</p>
<ul>
<li>包围盒；</li>
<li>包围盒中的物体。</li>
</ul>
<p>BVH 的遍历：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Intersect</span>(Ray ray, BVH node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ray misses node.bbox) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node is a leaf node) &#123;</span><br><span class="line">        test intersection with all objs;</span><br><span class="line">        <span class="keyword">return</span> closest intersection;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    hit1 = <span class="built_in">Intersect</span>(ray, node.child1);</span><br><span class="line">    hit2 = <span class="built_in">Intersect</span>(ray, node.child2);</span><br><span class="line">    <span class="keyword">return</span> the closer of hit1, hit2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="辐射度量学basic-radiometry">辐射度量学（Basic Radiometry）</h2>
<h3 id="radiant-energy-and-flux">Radiant Energy And Flux</h3>
<p><strong>Radiant energy</strong>：指的是电磁辐射的能量（The energy of
electromagnetic radiation），单位为焦耳，符号记为： <span
class="math display">\[
Q\,\left[\mathrm{J}=\text { Joule }\right]
\]</span> <strong>Radiant
flux（power）</strong>：指的是单位时间内的能量（The energy emitted,
reflected, transmitted or received, per unit time.），单位是瓦特： <span
class="math display">\[
\Phi \equiv \frac{\mathrm{d} Q}{\mathrm{d}
t}\,\left[\mathrm{W}=\mathrm{Watt}\right]\left[\operatorname{lm}=\text {
lumen }\right]^*
\]</span></p>
<blockquote>
<p>Radiant flux 是对单位时间内流过传感器的光子数目的度量。</p>
</blockquote>
<h3 id="radiant-intensity">Radiant Intensity</h3>
<p><strong>Radiant Intensity</strong>
指的是光源在单位立体角上的功率（The power per unit solid
angle）。数学定义为： <span class="math display">\[
I(\omega) \equiv \frac{\mathrm{d} \Phi}{\mathrm{d} \omega}
\,\left[\frac{\mathrm{W}}{\mathrm{sr}}\right]\left[\frac{\mathrm{lm}}{\mathrm{sr}}=\mathrm{cd}=\text
{ candela }\right]
\]</span></p>
<h4 id="立体角solid-angle">立体角（solid angle）</h4>
<p>在 2 维中，弧度制的定义如下： <span class="math display">\[
\theta = \frac{l}{r}
\]</span> 单位为 <span class="math inline">\(rad\)</span>. 整圆的角度为
<span class="math inline">\(2\pi\, rad\)</span>.</p>
<p>在 3 维中，立体角的定义如下： <span class="math display">\[
\omega = \frac{A}{r^2}
\]</span></p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230720351-28c5443d-496e-4212-b194-cdddae6370a0.png" alt="Img" style="zoom:75%;" />
</center>
<p>单位为 <span class="math inline">\(sr\)</span>，整球对应的立体角为
<span class="math inline">\(4 \pi \, sr\)</span>.</p>
<p>接下来我们推出单位立体角（Differential Solid Angles）的公式：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230720515-56305412-c91a-4af5-a4e0-2e31ebd1abb2.png" alt="Img" style="zoom:75%;" />
</center>
<p><span class="math display">\[
\begin{align*}
\mathrm{d}A &amp;= \left(r \mathrm{d} \theta \right)\left(r \sin
{\theta}\mathrm{d}\phi\right) \\
&amp;=r^2 \sin {\theta} \mathrm{d} \theta \mathrm{d} \phi \\
\mathrm{d}\omega &amp;= \frac{\mathrm{d} A}{r^2} = \sin \theta
\mathrm{d} \theta \mathrm{d}\phi
\end{align*}
\]</span></p>
<p>对整个球面的单位立体角进行积分： <span class="math display">\[
\Omega=\int_{S^2} d \omega=\int_0^{2 \pi} \int_0^\pi \sin \theta d
\theta d \phi=4 \pi
\]</span></p>
<p>对 <span class="math inline">\(\mathrm{d} \Phi\)</span> 积分得：</p>
<p><span class="math display">\[
\begin{align*}
\Phi &amp; = \int_{S^2} \mathrm{d} \Phi \\
&amp; = \int_{S^2} I \mathrm{~d} \omega \\
&amp; =4 \pi I \\
\end{align*}
\]</span></p>
<p>所以： <span class="math display">\[
I =\frac{\Phi}{4 \pi}
\]</span></p>
<h3 id="irradiance">Irradiance</h3>
<p>Irradiance：是指单位面积上所接收的功率（The power per unit area
incident on a surface point.）。 <span class="math display">\[
E(\mathbf{x}) \equiv \frac{\mathrm{d} \Phi(\mathbf{x})}{\mathrm{d} A
\cos \theta}  \,
\left[\frac{W}{\mathrm{~m}^2}\right]\left[\frac{\operatorname{lm}}{\mathrm{m}^2}=\operatorname{lux}\right]
\]</span> 上式中，<span class="math inline">\(\theta\)</span>
是光线与平面法线的夹角。</p>
<p>Lambert’s 余弦定理可以使用 Irradiance 来解释。</p>
<p>假设光线一功率 <span class="math inline">\(\Phi\)</span>
均匀向外均匀发出，一个球面上的 Irradiance
和这个球的半径成平方反比。假设在半径为 1 的球面上的 Irradiance 为 <span
class="math inline">\(E\)</span>，则在半径为 <span
class="math inline">\(r\)</span> 的球面上的 Irradiance 为： <span
class="math display">\[
\begin{align*}
E&#39; &amp;= \frac{\Phi}{4 \pi r^2} \\
&amp;= \frac{E} {r^2} \\
\end{align*}
\]</span></p>
<h3 id="radiance">Radiance</h3>
<p>Radiance 是描述光在环境中发布的基本场量。</p>
<ul>
<li>Radiance 是与光线相关的量</li>
<li>渲染就是在就算 Radiance.</li>
</ul>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230768937-da2153ee-d92e-4315-8249-879b1fa9e3c4.png" alt="Img" style="zoom:75%;" />
</center>
<p>Radiance 是单位立体角、单位面积上的功率（The power emitted,
reflected, transmitted or received by a surface, per unit solid angle,
per projected unit area.）。 <span class="math display">\[
L\left(\mathrm{p}, \omega\right) \equiv \frac{\mathrm{d}^2
\Phi(\mathrm{p}, \omega)}{\mathrm{d} \omega \mathrm{d} A \cos \theta} \,
\left[\frac{\mathrm{W}}{\mathrm{sr}
\mathrm{m}^2}\right]\left[\frac{\mathrm{cd}}{\mathrm{m}^2}=\frac{\mathrm{lm}}{\mathrm{sr}
\mathrm{m}^2}=\mathrm{nit}\right]
\]</span> 我们可以从两个方面来理解 Radiance。</p>
<ul>
<li>从入射角度来说（Incident Radiance），我们认为 Radiance
是单位立体角下的 Irradiance：</li>
</ul>
<p><span class="math display">\[
L\left(\mathrm{p}, \omega\right)  = \frac{\mathrm{d}
E\left(\mathrm{p}\right)}{\mathrm{d} \omega \cos \theta}
\]</span></p>
<blockquote>
<p>Incident radiance is the irradiance per unit solid angle arriving at
the surface.</p>
</blockquote>
<ul>
<li>从出射角度来说（Exiting Radiance），我们认为 Radiance 是单位面积下的
Intensity：</li>
</ul>
<p><span class="math display">\[
L\left(\mathrm{p}, \omega\right)  = \frac{\mathrm{d} I\left(\mathrm{p},
\omega\right)}{\mathrm{d} A \cos \theta}
\]</span></p>
<blockquote>
<p>Exiting surface radiance is the intensity per unit projected area
leaving the surface.</p>
</blockquote>
<h3 id="irradiance-vs.-radiance">Irradiance vs. Radiance</h3>
<p>Irradiance: total power received by area <span
class="math inline">\(\mathrm{d}A\)</span>.</p>
<p>Radiance: power received by area <span
class="math inline">\(\mathrm{d}A\)</span> from "direction" <span
class="math inline">\(\mathrm{d} \omega\)</span>.</p>
<p>那么 Irradiance 可以表示为 Radiance 在所有角度上的积分： <span
class="math display">\[
\begin{align*}
\mathrm{d} E(\mathrm{p}, \omega) &amp;=
L_i\left(\mathrm{p},\omega\right) \cos \theta \mathrm{d} \omega \\
E\left(\mathrm{p}\right)&amp; = \int_{H^2}
L_i\left(\mathrm{p},\omega\right) \cos \theta \mathrm{d} \omega
\end{align*}
\]</span>
我们这里只对上半求进行积分，下半球方向的光线对这一点没有任何贡献。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230769545-ddc3545f-a97a-4b14-bc5f-d9749674dbfb.png" alt="Img" style="zoom:75%;" />
</center>
<h2 id="brdf">BRDF</h2>
<h3 id="brdf-介绍">BRDF 介绍</h3>
<p>BRDF 的全称是：Bidirectional Reflectance Distribution Function.
翻译过来就是：双向反射分布函数。</p>
<p>BRDF 是一个函数，这个函数描述了一个点上的反射：将从 <span
class="math inline">\({\omega}_i\)</span> 方向来的 radiance 转换为 <span
class="math inline">\(\mathrm{d} A\)</span> 上接收的功率 <span
class="math inline">\(E\)</span>，任何功率 <span
class="math inline">\(E\)</span> 会变成其他任意方向 <span
class="math inline">\({\omega}_{0}\)</span> 方向的 radiance.</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230769778-cac70be3-5405-405a-85b2-864c1e22fa7a.png" alt="Img" style="zoom:75%;" />
</center>
<p>我们可以将反射分为两步：</p>
<ol type="1">
<li>光线入射某一点，得到了一部分能量；</li>
<li>这个点将得到的能量发射出去。</li>
</ol>
<p>Differential irradiance incoming: <span class="math display">\[
\mathrm{d}E\left(\omega_i\right) = L\left(\omega_i\right) \cos \theta_i
\mathrm{d} \omega_i
\]</span> Differential radiance exiting (due to <span
class="math inline">\(\mathrm{d} E\left(\omega_i\right)\)</span>): <span
class="math display">\[
\mathrm{d}L_r\left(\omega_r\right)
\]</span> The BRDF represents how much light is reflected into each
outgoing direction <span class="math inline">\(\omega_r\)</span> from
each incoming direction.</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230770394-9a04aab5-c10e-48a4-bec3-e9e23773c4b3.png" alt="Img" style="zoom:75%;" />
</center>
<p>BRDF 的定义如下： <span class="math display">\[
f_r\left(\omega_i \rightarrow \omega_r \right) = \frac{\mathrm{d}
L_r\left(\omega_r\right)}{\mathrm{d} E_i\left(\omega_i\right)} =
\frac{\mathrm{d}L_r\left(\omega_r\right)}{L\left(\omega_i\right) \cos
\theta_i \mathrm{d} \omega_i} \,\left[\frac{\text{1}}{\text{sr}}\right]
\]</span></p>
<h3 id="反射方程the-reflection-equation">反射方程（The Reflection
Equation）</h3>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230770613-845cc77b-6be1-4d3e-a98f-ae144a5d257d.png" alt="Img" style="zoom:75%;" />
</center>
<p>对于某一个出射方向，对于的能量应该是所有入射方向光线的叠加，于是乎我们可以得到反射方程：</p>
<p><span class="math display">\[
L_r\left(\mathrm{p}, \omega_r\right) = \int_{H^2}f_r\left(\mathrm{p},
\omega_i \rightarrow \omega_r \right)L_i\left(\mathrm{P},
\omega_i\right) \cos \theta_i \,\mathrm{d} \omega_i
\]</span></p>
<blockquote>
<p>反射 radiance 依赖于一个 入射 radiance，这个入射 radiance
又依赖于另外一个点出的反射 radiance，这是一个递归的过程。</p>
</blockquote>
<h3 id="渲染方程the-rendering-equation">渲染方程（The Rendering
Equation）</h3>
<p>反射方程为： <span class="math display">\[
L_r\left(\mathrm{p}, \omega_r\right) = \int_{H^2}f_r\left(\mathrm{p},
\omega_i \rightarrow \omega_r \right)L_i\left(\mathrm{P},
\omega_i\right) \cos \theta_i \,\mathrm{d} \omega_i
\]</span> 有些物体本来就会发光，于是乎我们加上发光项，便得到了渲染方程：
<span class="math display">\[
L_o\left(\mathrm{p}, \omega_o\right) = L_e\left(\mathrm{p},
\omega_o\right) + \int_{\Omega^+}L_i\left(\mathrm{p}, \omega_i\right)
f_r\left(\mathrm{p}, \omega_i, \omega_o\right)\left(n \cdot \omega_i
\right)\mathrm{d} \omega_i
\]</span></p>
<blockquote>
<p>注意，所有的方向都是向外的。</p>
</blockquote>
<p>我们可以认为 <span class="math inline">\(L_i\)</span>
包含其他点光源、面光源以及其他物体二次反射光线，最终结果我们使用积分的方式进行叠加。渲染方程可以简写为：
<span class="math display">\[
l\left(u\right) = e\left(u\right) + \int l\left(v\right)K\left(u,
v\right) \mathrm{d} v
\]</span> 我们可以通过矩阵再一次简化公式为： <span
class="math display">\[
L = E + KL
\]</span> 其中 <span class="math inline">\(K\)</span>
是反射操作符，上述方程是一个离散化的简单矩阵方程，<span
class="math inline">\(L\)</span>、<span class="math inline">\(E\)</span>
都是向量，<span class="math inline">\(K\)</span> 是 light transport
matrix.</p>
<p>求解得： <span class="math display">\[
L = (I - K)^{-1}E
\]</span> 泰勒展开得： <span class="math display">\[
\begin{align*}
L &amp;= (I + K + K^2 + K^3 + \cdots)E \\
&amp;= E + KE + K^2 E + K^3E + \cdots
\end{align*}
\]</span>
每一项分别代表的是：物体直接发出的光，光源经过一次反射的光，光源经过两次反射得到的间接光照……</p>
<p>着色是直接光照，对应 <span class="math inline">\(E\)</span> 和 <span
class="math inline">\(KE\)</span>；<span
class="math inline">\(KE\)</span> 对应直接光照，<span
class="math inline">\(K^2E\)</span> 对应间接光照；<span
class="math inline">\(KE + K^2E + K^3E + \cdots\)</span>
对应全局光照。</p>
<h2 id="蒙特卡罗积分monte-carlo-integration">蒙特卡罗积分（Monte Carlo
Integration）</h2>
<p>对于任意一个函数，无论其表达式复杂与否，我们都希望能够求出这个函数得积分值。在微积分中我们学习过黎曼积分，即：分隔、近似、求和、取极限，这对于表达式较为简单的函数很好操作，但对于表达式比较复杂的函数甚至表达式无法写出来的函数来说是不可行的。对于表达式比较复杂或者表达式无法写出来的函数我们可以采用数值方法求出其积分值，蒙特卡洛法就是这样的一种数值方法。</p>
<p>蒙特卡洛积分会进行多次随机采样，将采样点对应函数值除以采样点对应的概率，然后做一个平均，将这个结果作为积分结果。</p>
<p>对于下面这个积分： <span class="math display">\[
\int_a^b f\left(x\right) \,\mathrm{d} x
\]</span> 取一个随机变量： <span class="math display">\[
X_i \sim p\left(x\right)
\]</span></p>
<p>则蒙特卡洛积分为： <span class="math display">\[
F_N = \frac{1}{N} \sum^N_{i =
1}\frac{f\left(X_i\right)}{p\left(X_i\right)}
\]</span> 例如 <span class="math inline">\(X_i\)</span> 满足下列分布：
<span class="math display">\[
X_i\sim p\left(x\right) = \frac{1}{b - a}
\]</span> 则蒙特卡洛积分为： <span class="math display">\[
F_N = \frac{b- a}{N} \sum^N_{i = 1}f\left(X_i\right)
\]</span>
蒙特卡洛积分对于任何一种采样分布都是成立的。只要进行采样就可以得到对应的积分。使用蒙特卡洛积分要注意两点：</p>
<ol type="1">
<li>采样的次数越多，得到的结果越准确；</li>
<li>如果对 <span class="math inline">\(x\)</span> 进行采样，则要对 <span
class="math inline">\(x\)</span> 进行积分。</li>
</ol>
<h2 id="路径追踪path-tracing">路径追踪（Path Tracing）</h2>
<p>Whitted-style 光线追踪有两个问题：</p>
<ol type="1">
<li>只做镜面反射（折射），这样不能很好地表示 glossy 材质的物体。</li>
</ol>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230777534-d14b47f7-6eab-4ce4-92b0-6541436813af.png" alt="Img" style="zoom:75%;" />
</center>
<ol start="2" type="1">
<li>在漫反射材质直之间没有反射</li>
</ol>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230777593-a006e7c7-737d-4fbf-9c64-6fdf2516c242.png" alt="Img" style="zoom:75%;" />
</center>
<p>所以 Whitted-style 的路径追踪是有问题的。但渲染方程是绝对正确的：
<span class="math display">\[
L_o\left(\mathrm{p}, \omega_o\right) = L_e\left(\mathrm{p},
\omega_o\right) + \int_{\Omega^+}L_i\left(\mathrm{p}, \omega_i\right)
f_r\left(\mathrm{p}, \omega_i, \omega_o\right)\left(n \cdot \omega_i
\right)\mathrm{d} \omega_i
\]</span> 我们现在就要求出这个积分。</p>
<h3 id="积分求解">积分求解</h3>
<p>假设我们现在下面场景中渲染一个只有直接光照的像素：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230777873-ec1909a3-5177-4053-9949-f63cba371afa.png" alt="Img" style="zoom:75%;" />
</center>
<p>我们先忽略渲染方程中的非积分项好了： <span class="math display">\[
L_o\left(\mathrm{p}, \omega_o\right) =
\int_{\Omega^+}L_i\left(\mathrm{p}, \omega_i\right) f_r\left(\mathrm{p},
\omega_i, \omega_o\right)\left(n \cdot \omega_i \right)\mathrm{d}
\omega_i
\]</span> 我们使用蒙特卡洛积分求出这个积分值： <span
class="math display">\[
\int_a^b f\left(x\right) \, \mathrm{d}x \approx = \frac{1}{N}\sum^N_{k =
1}\frac{f\left(X_k\right)}{p\left(X_k\right)} \quad X_k \sim
p\left(x\right)
\]</span> <span class="math inline">\(f\left(x \right)\)</span> 是：
<span class="math display">\[
L_i\left(\mathrm{p}, \omega_i\right) f_r\left(\mathrm{p}, \omega_i,
\omega_o\right)\left(n \cdot \omega_i \right)
\]</span> pdf 选取半球上均匀分布： <span class="math display">\[
p\left(\omega_i\right) = \frac{1}{2\pi}
\]</span> 所以积分值求出来为： <span class="math display">\[
\begin{align*}
L_o\left(\mathrm{p}, \omega_o\right) &amp;=
\int_{\Omega^+}L_i\left(\mathrm{p}, \omega_i\right) f_r\left(\mathrm{p},
\omega_i, \omega_o\right)\left(n \cdot \omega_i \right)\,\mathrm{d}
\omega_i \\
&amp; \approx \frac{1}{N}\sum_{i = 1}^N \frac{L_i\left(\mathrm{p},
\omega_i\right) f_r\left(\mathrm{p}, \omega_i, \omega_o\right)\left(n
\cdot \omega_i \right)}{p\left(\omega_i\right)}
\end{align*}
\]</span>
这个算法就是一个<strong>适用于直接光照</strong>的正确着色算法，写出伪代码是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shade</span>(p, wo)</span><br><span class="line">    Randomly choose N directions wi~pdf</span><br><span class="line">    Lo = <span class="number">0.0</span></span><br><span class="line">    For each wi</span><br><span class="line">        Trace a ray <span class="built_in">r</span>(p, wi)</span><br><span class="line">        If ray r hit the light</span><br><span class="line">        	Lo += (<span class="number">1</span> / N) * L_i * f_r * cosine / <span class="built_in">pdf</span>(wi)</span><br><span class="line">    Return Lo</span><br></pre></td></tr></table></figure>
<h3 id="介绍全局光照">介绍全局光照</h3>
<p>对于间接光照，对于下图中的 <span class="math inline">\(P\)</span>
点，如果我们想要求出来自 <span class="math inline">\(Q\)</span>
点的光线，我们可以看作我们从 <span class="math inline">\(P\)</span>
点看向 <span class="math inline">\(Q\)</span>
点来自光源的光线反射得到的结果。那么以上的伪代码我们可以改写为递归的形式：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230778813-4eef39cf-255d-41cd-9721-6a90f96097af.png" alt="Img" style="zoom:75%;" />
</center>
<p>伪代码为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">    Randomly choose N directions wi~pdf</span><br><span class="line">    Lo = 0.0</span><br><span class="line">    For each wi</span><br><span class="line">        Trace a ray r(p, wi)</span><br><span class="line">        If ray r hit the light</span><br><span class="line">        	Lo += (1 / N) * L_i * f_r * cosine / pdf(wi)</span><br><span class="line">        Else If ray r hit an object at q</span><br><span class="line">        	Lo += (1 / n) * shade(q, -wi) * f_r * cosine / pdf(wi)</span><br><span class="line">    Return Lo</span><br></pre></td></tr></table></figure></p>
<h3 id="介绍路径追踪">介绍路径追踪</h3>
<h4 id="指数爆炸问题">指数爆炸问题</h4>
<p>如果我们采样 <span class="math inline">\(N\)</span> 次，那么在经过
<span class="math inline">\(r\)</span> 次反射后，光线的数目可以达到
<span class="math inline">\(N^r\)</span> 条，会使计算量大大增加。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230779152-6afad7f7-05c2-4eae-a619-571fb40c5e1a.png" alt="Img" style="zoom:75%;" />
</center>
<p>当且仅当 <span class="math inline">\(N = 1\)</span>
时，才不会出现指数爆炸的情况。也就是说，对每个着色点只追踪一条光线。这样做会产生噪声，no
problem，只需在每个像素中追踪更多路径，然后做一个平均即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shade</span>(p, wo)</span><br><span class="line">    Randomly choose one directions wi~<span class="built_in">pdf</span>(w)</span><br><span class="line">    <span class="function">Trace a ray <span class="title">r</span><span class="params">(p, wi)</span></span></span><br><span class="line"><span class="function">    If ray r hit the light</span></span><br><span class="line"><span class="function">    	Return L_i * f_r * consine / <span class="title">pdf</span><span class="params">(wi)</span></span></span><br><span class="line"><span class="function">    Else If ray r hit an object at q</span></span><br><span class="line"><span class="function">    	Return <span class="title">shade</span><span class="params">(q, -wi)</span> * f_r * cosine / <span class="title">pdf</span><span class="params">(wi)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>则会就是路径追踪，即 <span class="math inline">\(N = 1\)</span>，对于
<span class="math inline">\(N \neq 1\)</span> 的称为分布式光线追踪。</p>
</blockquote>
<p>对于路径追踪，使用如下的光线生成算法（与光线追踪中的光线投射很像）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ray_generation</span>(camPos, pixel)</span><br><span class="line">    Uniformly choose N sample positions within the pixel</span><br><span class="line">    pixel_radiance = <span class="number">0.0</span></span><br><span class="line">    For each sample in the pixel </span><br><span class="line">    	Shoot a ray <span class="built_in">r</span>(camPos, cam_to_sample)</span><br><span class="line">    	If ray r hit the scene at p</span><br><span class="line">    		pixel_radiance += <span class="number">1</span> / N * <span class="built_in">shade</span>(p, sample_to_cam)</span><br><span class="line">    Return pixel_radiance</span><br></pre></td></tr></table></figure>
<p>这个算法还有一个问题，递归永远不会结束，这样复合现实情况，但在程序里这样肯定是不行的，我们必须选取一个合适的时机让算法停下来。</p>
<h4 id="递归停止问题">递归停止问题</h4>
<p>引入俄罗斯轮盘赌（RR）来解决这个问题。对于，假设光线有 <span
class="math inline">\(P\)</span> 的概率能射出，这时候返回 Lo /
P，那么会有 1 - P 的概率不能射出，这时候返回 0 即可。</p>
<p>使用这种方式的到的期望是：E = P * (Lo / P) + (1 - P) * 0 = Lo.</p>
<p>引入 RR 后 shade 的伪代码是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shade</span>(p, wo)</span><br><span class="line">    Manually specify a probability P_RR</span><br><span class="line">    Randomly select ksi in a uniform dist. in [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="built_in">If</span> (ksi &gt; P_RR) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">	Randomly choose ONE direction wi~<span class="built_in">pdf</span>(w)</span><br><span class="line">    <span class="function">Trace a ray <span class="title">r</span><span class="params">(p, wi)</span></span></span><br><span class="line"><span class="function">    If ray r hit the light</span></span><br><span class="line"><span class="function">        Return L_i * f_r * cosine / <span class="title">pdf</span><span class="params">(wi)</span> / P_RR</span></span><br><span class="line"><span class="function">    Else If ray r hit an object at q</span></span><br><span class="line"><span class="function">        Return <span class="title">shade</span><span class="params">(q, -wi)</span> * f_r * cosine / <span class="title">pdf</span><span class="params">(wi)</span> / P_RR</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个算法就是正确的路径追踪算法！</p>
</blockquote>
<p>但很没用效率：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230780809-ce276ef6-27d3-4a9f-b22a-3e0585ee4d47.png" alt="Img" style="zoom:75%;" />
</center>
<p>如上图所示，在 Low SPP 下效果很差。</p>
<h4 id="对光源采样">对光源采样</h4>
<p>对于同一个点来说，光源面积大，那么我们使用较少的光线就可以接触到光源，但是如果光源面积太小，我们必须使用较多的光线才可以和光源发生接触。那么对于小光源计算量会上升。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230780988-87a2305f-978c-4f4d-a94e-1797514ae78c.png" alt="Img" style="zoom:75%;" />
</center>
<p>为了解决这个问题，我们直接在光源上采样，这样就不会有光线被浪费。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230781397-20e0341b-c35f-46ad-ad95-a3297ea25766.png" alt="Img" style="zoom:75%;" />
</center>
<p>假设对光源均匀采样，则： <span class="math display">\[
\text{pdf} = \frac{1}{A} \quad(\int \text{pdf} \, \mathrm{d} A = 1)
\]</span>
但是蒙特卡洛积分的采样必须在积分域上。此时积分域发生了变换，我们需要找到
<span class="math inline">\(\mathrm{\omega}\)</span> 和 <span
class="math inline">\(\mathrm{d} A\)</span> 之间的关系。<span
class="math inline">\(\mathrm{\omega}\)</span> 是 <span
class="math inline">\(\mathrm{d} A\)</span> 在对应单位球上的投影，因此：
<span class="math display">\[
\mathrm{d} \omega = \frac{\mathrm{d} A \cos \theta&#39;}{\left\|x&#39; -
x\right\| ^ 2}
\]</span> 如何就可以写出对光源的渲染方程啦： <span
class="math display">\[
\begin{align*}
L_o\left(\mathrm{x}, \omega_o\right) &amp;=
\int_{\Omega^+}L_i\left(\mathrm{x}, \omega_i\right) f_r\left(\mathrm{x},
\omega_i, \omega_o\right)\cos \theta \,\mathrm{d} \omega_i \\
&amp;= \int_A L_i\left(\mathrm{x}, \omega_i\right)f_r\left(\mathrm{x},
\omega_i, \omega_o\right)\frac{\cos \theta \cos
\theta&#39;}{\left\|x&#39; - x\right\| ^ 2} \, \mathrm{d} A
\end{align*}
\]</span>
以前，我们假设光是通过均匀半球采样「意外」射出的，现在我们考虑来自两个部分的辐射：</p>
<ol type="1">
<li>直接光照，不需要做 RR;</li>
<li>间接光照，需要做 RR.</li>
</ol>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230782074-a2f4cf9c-765a-4366-bb62-27a6c50d61e8.png" alt="Img" style="zoom:100%;" />
</center>
<p>对光源采样的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shade</span>(p, wo)</span><br><span class="line">	# Contribution from the light source.</span><br><span class="line">	Uniformly sample the light at x’ (pdf_light = <span class="number">1</span> / A)</span><br><span class="line">	L_dir = L_i * f_r * cos θ * cos θ’ / |x’ - p|^<span class="number">2</span> / pdf_light</span><br><span class="line">	</span><br><span class="line">	# Contribution from other reflectors.</span><br><span class="line">	L_indir = <span class="number">0.0</span></span><br><span class="line">	Test Russian Roulette with probability P_RR</span><br><span class="line">	Uniformly sample the hemisphere toward <span class="built_in">wi</span> (pdf_hemi = <span class="number">1</span> / <span class="number">2</span>pi)</span><br><span class="line">	Trace a ray <span class="built_in">r</span>(p, wi)</span><br><span class="line">	If ray r hit a non-emitting object at q</span><br><span class="line">		L_indir = <span class="built_in">shade</span>(q, -wi) * f_r * cos θ / pdf_hemi / P_RR</span><br><span class="line">    </span><br><span class="line">    Return L_dir + L_indir</span><br></pre></td></tr></table></figure>
<p>最后一件事，考虑遮挡：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230782286-908ef2a3-1968-421d-b9cb-a35f3155106a.png" alt="Img" style="zoom:100%;" />
</center>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shade</span>(p, wo)</span><br><span class="line">    # Contribute from the light source</span><br><span class="line">    L_dir = <span class="number">0.0</span></span><br><span class="line">    Uniformly sample the light at x’ (pdf_light = <span class="number">1</span> / A)</span><br><span class="line">    Shoot a ray from p to x’</span><br><span class="line">    If the ray is <span class="keyword">not</span> blocked in the middle</span><br><span class="line">		L_dir = L_i * f_r * cos θ * cos θ’ / |x’ - p|^<span class="number">2</span> / pdf_light</span><br><span class="line">    </span><br><span class="line">    # Contribution from other reflectors.</span><br><span class="line">	L_indir = <span class="number">0.0</span></span><br><span class="line">	Test Russian Roulette with probability P_RR</span><br><span class="line">	Uniformly sample the hemisphere toward <span class="built_in">wi</span> (pdf_hemi = <span class="number">1</span> / <span class="number">2</span>pi)</span><br><span class="line">	Trace a ray <span class="built_in">r</span>(p, wi)</span><br><span class="line">	If ray r hit a non-emitting object at q</span><br><span class="line">		L_indir = <span class="built_in">shade</span>(q, -wi) * f_r * cos θ / pdf_hemi / P_RR</span><br><span class="line">    </span><br><span class="line">    Return L_dir + L_indir</span><br></pre></td></tr></table></figure>
<p><strong>这就是最终的路径追踪算法！</strong></p>
<p>最后放一张 Cornell box 的图：</p>
<center>
<a href="http://www.graphics.cornell.edu/online/box/compare.html">
<img data-src="https://user-images.githubusercontent.com/62458905/230782906-053b6dec-f188-42c9-89db-2f1c06676d75.jpg" alt="Cornell box" style="zoom:100%;" />
</a>
</center>
<p>左边的是使用路径追踪的渲染图，右边是照片，可以看到渲染图和照片非常像。</p>
]]></content>
      <categories>
        <category>GAMES 101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>动态内存申请</title>
    <url>/2023/07/16/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7/</url>
    <content><![CDATA[<h2 id="动态分配内存的概述">动态分配内存的概述</h2>
<p>动态内存分配就是在堆区开辟空间。</p>
<blockquote>
<p>如果想动态分配数组的大小，必须使用动态内存分配。</p>
</blockquote>
<h2 id="静态分配动态分配">静态分配、动态分配</h2>
<p><strong>静态分配</strong>：</p>
<ol type="1">
<li>在程序编译或运行过程中，按事先规定的大小分配空间。</li>
<li>必须事先知道所需空间的大小。</li>
<li>分配在栈区或全局变量区。</li>
<li>按计划分配。</li>
</ol>
<p><strong>动态分配</strong>：</p>
<ol type="1">
<li>在程序运行过程中，工具需要自由分配空间。</li>
<li>按需分配</li>
<li>分配在堆区，一般使用特定的函数进行分配。</li>
</ol>
<h2 id="动态内存分配函数">动态内存分配函数</h2>
<p>与动态内存分配相关的函数有 4
个：<code>malloc</code>、<code>free</code>、<code>calloc</code>、<code>realloc</code>.</p>
<h3 id="malloc">malloc</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br><span class="line">功能：在堆区开辟指定长度的空间，并且空间是连续的</span><br><span class="line">参数：</span><br><span class="line">    size：要开辟的空间的大小</span><br><span class="line">返回值：</span><br><span class="line">    成功：开辟好的空间的首地址</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ol type="1">
<li>在调用 <code>malloc</code>
函数知乎，一定要判断一下，是否申请内存成功。</li>
<li>如果多次用 <code>malloc</code> 函数申请内存，第 1 次和第 2
次申请到的内存不一定是连续的。</li>
<li><code>malloc</code> 函数的返回值是
<code>void*</code>，所以在调用函数时要根据实际情况进行强制类型转换。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *str = (<span class="type">char</span> *)(<span class="built_in">malloc</span>(<span class="number">100</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>)));</span><br><span class="line"></span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">    str[<span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    str[<span class="number">2</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">    str[<span class="number">3</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">    str[<span class="number">4</span>] = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">    str[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p = fun();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %s\n&quot;</span>, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/d40381f2-6531-4539-84f9-57cbcbb3f95f"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="free">free</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">功能：释放堆区的空间</span><br><span class="line">参数：</span><br><span class="line"> ptr：开辟后使用完毕的堆区的空间的首地址</span><br><span class="line">返回值：</span><br><span class="line"> 无</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ol type="1">
<li><code>free</code> 函数只能释放堆区的空间，其他区域的空间无法使用
<code>free</code>.</li>
<li><code>free</code> 释放的空间必须是使用
<code>malloc</code>、<code>calloc</code> 或者 <code>realloc</code>
函数申请的空间，不能释放部分空间。</li>
<li>当使用 <code>free(p)</code> 释放 <code>p</code>
指向的空间后，<code>p</code>
还是会指向原来的地方，但原来的地方的空间已经被释放了，所以不能在使用，<code>p</code>
就成了野指针，所以一般来说，在释放完空间之后，要将指针置空，即
<code>p = NULL</code>.</li>
<li>一块空间只能释放一次，不能多次释放。</li>
</ol>
</blockquote>
<h3 id="calloc">calloc</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> * <span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span>;</span><br><span class="line">功能：在堆区申请指定大小的空间</span><br><span class="line">参数：</span><br><span class="line">    nmemb：要申请的空间的块数</span><br><span class="line">    size：每块的字节数</span><br><span class="line">返回值：</span><br><span class="line">    成功：申请空间的首地址</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>malloc</code> 函数和 <code>calloc</code>
函数都是用来申请内存的。</p>
<p>区别：</p>
<ol type="1">
<li>函数名字别一样；</li>
<li>函数参数个数不一样；</li>
<li><code>malloc</code> 申请的内存，内存中的内容是随机的，而
<code>calloc</code> 函数的申请的内存中的内存为 0。</li>
</ol>
</blockquote>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p = (<span class="type">char</span>*)<span class="built_in">calloc</span>(<span class="number">3</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>在堆区申请了 3 快空间，每块的大小为 100 个字节，共 300
个字节的连续空间。</p>
<h3 id="realloc">realloc</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">realloc</span><span class="params">(<span class="type">void</span> *s, <span class="type">unsigned</span> <span class="type">int</span> newsize)</span>;</span><br><span class="line">功能：在原本申请好的堆区空间的基础上重新申请内存，新的空间大小为函数的第二个参数如果原本申请好的空间的后面不足以增加指定的大小，系统会重新找一个足够大的位置开辟指定的空间，然后将原本空间中的数据拷贝过来，然后释放原本的空间。如果 newsize 比原先的内存小，则会释放原先内存的后面的存储空间，只留前面的 newsize 个字节</span><br><span class="line">参数：</span><br><span class="line">    s：原本开辟好的空间的首地址</span><br><span class="line">    newsize：重新开辟的空间的大小</span><br><span class="line">返回值：</span><br><span class="line">    新的空间的首地址</span><br></pre></td></tr></table></figure>
<p>增加空间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 想在100个字节后面追加50个字节</span></span><br><span class="line">    p = (<span class="type">char</span> *)<span class="built_in">realloc</span>(p, <span class="number">150</span>); <span class="comment">// p指向的内存的新的大小为150个字节</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>减少空间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 想重新申请内存,新的大小为50个字节</span></span><br><span class="line">    <span class="comment">// p指向的内存的新的大小为50个字节,100个字节的后50个字节的存储空间就被释放</span></span><br><span class="line">    p = (<span class="type">char</span> *)<span class="built_in">realloc</span>(p, <span class="number">50</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内存泄漏">内存泄漏</h2>
<p>内存泄漏是指，申请的空间的首地址丢失了，再也找不到了，这块内存没法用，也没法释放，则称这块内存被泄漏了。</p>
<p>案例 1：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 接下来，可以用p指向的内存了</span></span><br><span class="line">    p = <span class="string">&quot;hello world&quot;</span>; <span class="comment">// p指向别的地方了，保存字符串常量的首地址</span></span><br><span class="line">    <span class="comment">// 从此以后，再也找不到你申请的100个字节了。则动态申请的100个字节就被泄露了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>案例 2：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span> &#123; <span class="type">char</span> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 每调用一次fun泄露100个字节</span></span><br><span class="line">    fun();</span><br><span class="line">    fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>千万注意：申请的空间，一定不要把首地址弄丢了，在不用之前一定要释放空间。</p>
</blockquote>
]]></content>
      <categories>
        <category>C 语言基础</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>变换</title>
    <url>/2023/07/16/%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p>变换是计算机图形学中非常重要的一部分。变换包含<strong>模型变换</strong>（Modeling
transform、视图变换（View
transform）以及<strong>投影变换</strong>（Projection
transformation）。模型变换指的是变换模型（被拍摄物体）的位置，大小和角度；视图变换指的是变换照相机的位置和角度。从相对运动的角度来看，模型变换和投影变换是可以相互转化的。投影变换（Projection
transformation）是把 3 维模型投影到 2 维平面的变换。</p>
<h2 id="模型变换">模型变换</h2>
<h3 id="二维变换2d-transformations">二维变换（2D Transformations）</h3>
<h4 id="伸缩变换scale-transform">伸缩变换（Scale Transform）</h4>
<p>伸缩变换中，如果一个图片以原点 <span class="math inline">\(\left(0, 0
\right)\)</span> 为中心缩放 <span class="math inline">\(s\)</span>
倍。那么点 <span class="math inline">\(\left(x, y \right)\)</span>
变换后数学形式可以表示为：</p>
<p><span class="math display">\[
\begin{align*}
x^{\prime} &amp; =s x \\
y^{\prime} &amp; =s y
\end{align*}
\]</span></p>
<p>写成矩阵形式为：</p>
<p><span class="math display">\[
\begin{bmatrix}
x^{\prime} \\
y^{\prime}
\end{bmatrix} =
\begin{bmatrix}
s &amp; 0 \\
0 &amp; s
\end{bmatrix}
\begin{bmatrix}
x \\
y
\end{bmatrix}
\]</span></p>
<p>当然，我们也可以给 <span class="math inline">\(x\)</span> 轴和 <span
class="math inline">\(y\)</span> 轴不同的缩放倍数 <span
class="math inline">\(s_x\)</span> 和 <span
class="math inline">\(s_y\)</span>。在非均匀情况下，缩放变换的矩阵形式为：</p>
<p><span class="math display">\[
\begin{bmatrix}
x^{\prime} \\
y^{\prime}
\end{bmatrix} =
\begin{bmatrix}
s_x &amp; 0 \\
0 &amp; s_y
\end{bmatrix}
\begin{bmatrix}
x \\
y
\end{bmatrix}
\]</span></p>
<h4 id="反射变换reflection-transform">反射变换（Reflection
Transform）</h4>
<p>反射变换（Reflection）指的是图片对着 <span
class="math inline">\(x\)</span> 轴或者 <span
class="math inline">\(y\)</span> 轴做对称变换。对于图片上的点 <span
class="math inline">\(\left(x, y \right)\)</span> 在经过 <span
class="math inline">\(x\)</span>
轴的对称反射变换后，数学形式可以表示为： <span class="math display">\[
\begin{align*}
&amp; x^{\prime}=-x \\
&amp; y^{\prime}=y
\end{align*}
\]</span></p>
<p>表示成矩阵形式为：</p>
<p><span class="math display">\[
\begin{bmatrix}
x^{\prime} \\
y^{\prime}
\end{bmatrix} =
\begin{bmatrix}
-1 &amp; 0 \\
0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
x \\
y
\end{bmatrix}
\]</span></p>
<p>同理可以得到 <span class="math inline">\(y\)</span>
轴对称反射变换后的变换矩阵为：</p>
<p><span class="math display">\[
\begin{bmatrix}
x^{\prime} \\
y^{\prime}
\end{bmatrix} =
\begin{bmatrix}
1 &amp; 0 \\
0 &amp; -1
\end{bmatrix}
\begin{bmatrix}
x \\
y
\end{bmatrix}
\]</span></p>
<p>沿原点反射变换的变换矩阵为：</p>
<p><span class="math display">\[
\begin{bmatrix}
x^{\prime} \\
y^{\prime}
\end{bmatrix} =
\begin{bmatrix}
-1 &amp; 0 \\
0 &amp; -1
\end{bmatrix}
\begin{bmatrix}
x \\
y
\end{bmatrix}
\]</span></p>
<h4 id="错切变换shear-transform">错切变换（Shear Transform）</h4>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/229434074-f3ba1ffe-60c9-474e-bbda-8e992d1838ca.png" alt="Img" style="zoom:50%;" />
</center>
<p>水平方向的错切：</p>
<ul>
<li>对于 <span class="math inline">\(y = 0\)</span>
上的点来说，其<strong>水平移位</strong>（Horizontal shift）为 0.</li>
<li>对于 <span class="math inline">\(y = 1\)</span>
上的点来说，其<strong>水平移位</strong>（Horizontal shift）为 a.</li>
<li><strong>垂直移位</strong>（Vertical shift ）始终为 0.</li>
</ul>
<p>变换矩阵为：</p>
<p><span class="math display">\[
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime}
\end{array}\right]=\left[\begin{array}{ll}
1 &amp; a \\
0 &amp; 1
\end{array}\right]\left[\begin{array}{l}
x \\
y
\end{array}\right]
\]</span></p>
<p>垂直方向的错切变换，其变换矩阵为：</p>
<p><span class="math display">\[
\left[\begin{array}{l}
x^{\prime} \\
y^{\prime}
\end{array}\right]=\left[\begin{array}{ll}
1 &amp; 0 \\
b &amp; 1
\end{array}\right]\left[\begin{array}{l}
x \\
y
\end{array}\right]
\]</span></p>
<h4 id="旋转变换rotate-transform">旋转变换（Rotate Transform）</h4>
<p>默认情况下，都是考虑绕点 <span class="math inline">\(\left(0,
0\right)\)</span>
，<strong>逆时针（CCW）</strong>旋转。旋转矩阵的推导如下：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/229434981-be796343-4915-44fb-bcd0-404fa2dedf3a.png" alt="Img" style="zoom:100%;" />
</center>
<p>我们在直角坐标系中绘制一个边长为 <span
class="math inline">\(1\)</span> 的正方形，点 <span
class="math inline">\(A\)</span> 坐标为 <span
class="math inline">\(\left(1, 0\right)\)</span>，点 <span
class="math inline">\(B\)</span> 坐标为 <span
class="math inline">\(\left(0, 1\right)\)</span>。正方形沿着原点 <span
class="math inline">\(\left(0, 0\right)\)</span> 旋转的角度为 <span
class="math inline">\(\theta\)</span> 角。我们设：</p>
<p><span class="math display">\[
\begin{bmatrix}
x&#39; \\
y&#39;
\end{bmatrix} = \begin{bmatrix}
A &amp; B \\
C &amp; D
\end{bmatrix} = \begin{bmatrix}
x \\
y
\end{bmatrix}
\]</span></p>
<p>代入点 <span class="math inline">\(A\)</span> 的的值 <span
class="math inline">\(\left(1, 0\right)\)</span> 可以得到：</p>
<p><span class="math display">\[
\begin{bmatrix}
\sin \theta \\
\cos \theta
\end{bmatrix} = \begin{bmatrix}
A &amp; B \\
C &amp; D
\end{bmatrix} = \begin{bmatrix}
1 \\
0
\end{bmatrix}
\]</span></p>
<p>解方程得到：</p>
<p><span class="math display">\[
\begin{align*}
A &amp;= \cos \theta \\
C &amp;= \sin \theta
\end{align*}
\]</span></p>
<p>代入点 <span class="math inline">\(B\)</span> 的的值 <span
class="math inline">\(\left(0, 1\right)\)</span> 可以得到：</p>
<p><span class="math display">\[
\begin{bmatrix}
-\sin \theta \\
\cos \theta
\end{bmatrix} = \begin{bmatrix}
A &amp; B \\
C &amp; D
\end{bmatrix} = \begin{bmatrix}
0 \\
1
\end{bmatrix}
\]</span></p>
<p>解方程得到：</p>
<p><span class="math display">\[
\begin{align*}
B &amp;= -\sin \theta \\
D &amp;= \cos \theta
\end{align*}
\]</span></p>
<p>即旋转变换的变换矩阵为：</p>
<p><span class="math display">\[
\mathbf{R}_\theta = \begin{bmatrix}
\cos \theta &amp; -\sin \theta \\
\sin \theta &amp; \cos \theta
\end{bmatrix}
\]</span></p>
<h4 id="线性变换linear-transformations">线性变换（Linear
Transformations）</h4>
<p>对于任何一种变换如果可以写作：</p>
<p><span class="math display">\[
\begin{align*}
x^{\prime} &amp; =a x+b y \\
y^{\prime} &amp; =c x+d y
\end{align*}
\]</span></p>
<p>矩阵形式可以表示为：</p>
<p><span class="math display">\[
\begin{bmatrix}
x^{\prime} \\
y^{\prime}
\end{bmatrix} = \begin{bmatrix}
a &amp; b \\
c &amp; d
\end{bmatrix} \begin{bmatrix}
x \\
y
\end{bmatrix}
\]</span></p>
<p>那么我们认为这种变换是<strong>线性变换</strong>。</p>
<p>显然，伸缩变换，反射变换，错切变换和旋转变换都是线性变换。</p>
<p>设 <span class="math inline">\(f\)</span> 为一个线性变换变换，则
<span class="math inline">\(f\)</span> 满足有以下性质： <span
class="math display">\[
f\left(x + y\right) = f\left(x\right)  + f\left( y\right) \\
f\left(kx\right) = kf\left(x\right)
\]</span></p>
<h3 id="齐次坐标homogeneous-coordinates">齐次坐标（Homogeneous
Coordinates）</h3>
<h4 id="平移变换translation-transform">平移变换（Translation
Transform）</h4>
<p>平移变换（Translation）相比于以上的线性变换有特殊的地方。平移变换的数学形式为：</p>
<p><span class="math display">\[
\begin{align*}
x^{\prime} &amp; =x+t_x \\
y^{\prime} &amp; =y+t_y
\end{align*}
\]</span></p>
<p>这种数学表示不能写作线性变换的矩阵形式，只能记作：</p>
<p><span class="math display">\[
\begin{bmatrix}
x^{\prime} \\
y^{\prime}
\end{bmatrix}=\begin{bmatrix}
a &amp; b \\
c &amp; d
\end{bmatrix} \begin{bmatrix}
x \\
y
\end{bmatrix}+ \begin{bmatrix}
t_x \\
t_y
\end{bmatrix}
\]</span></p>
<p>说明平移操作不是线性变换。但是我们不希望把平移操作看作特殊变换，因此需要把这些变换统一起来，就引入了齐次坐标。</p>
<h4 id="齐次坐标homogenous-coordinates">齐次坐标（Homogenous
Coordinates）</h4>
<p>为了统一变换操作，我们引入一个新的维度。对于二维的点 <span
class="math inline">\(\left(0, 0\right)\)</span>
我们可以增加一个维度，对于 <span class="math inline">\(2\)</span>
维的点可以表示为 <span class="math inline">\(\left(x, y,
1\right)^{\mathrm{T}}\)</span>，2 维向量的 <span
class="math inline">\(\left(x, y,
0\right)^{\mathrm{T}}\)</span>。因此，一个点的平移可以用矩阵表示为：</p>
<p><span class="math display">\[
\begin{bmatrix}
x^{\prime} \\
y^{\prime} \\
w^{\prime}
\end{bmatrix} = \begin{bmatrix}
1 &amp; 0 &amp; t_x \\
0 &amp; 1 &amp; t_y \\
0 &amp; 0 &amp; 1
\end{bmatrix}\begin{bmatrix}
x \\
y \\
1
\end{bmatrix}=\begin{bmatrix}
x+t_x \\
y+t_y \\
1
\end{bmatrix}
\]</span></p>
<p>齐次坐标就是在原来的坐标上加上一个<strong>维度（w-coordinate）</strong>：</p>
<ul>
<li>2D point = <span class="math inline">\(\begin{bmatrix}x &amp; y
&amp; 1 \\ \end{bmatrix}\)</span>.</li>
<li>2D vector = <span class="math inline">\(\begin{bmatrix}x &amp; y
&amp; 0 \\ \end{bmatrix}\)</span>.</li>
</ul>
<p>用其次坐标表示平移变换： <span class="math display">\[
\begin{bmatrix}
x^{\prime} \\
y^{\prime} \\
w^{\prime}
\end{bmatrix}=\begin{bmatrix}
1 &amp; 0 &amp; t_x \\
0 &amp; 1 &amp; t_y \\
0 &amp; 0 &amp; 1
\end{bmatrix}\begin{bmatrix}
x \\
y \\
1
\end{bmatrix}=\begin{bmatrix}
x+t_x \\
y+t_y \\
1
\end{bmatrix}
\]</span></p>
<p>当求出来的 w-coordinate 为 1 或者 0 时才是一个有效的操作：</p>
<ul>
<li>vector + vector = vector</li>
<li>point – point = vector</li>
<li>point - vector = point</li>
<li>point - point = midpoint</li>
</ul>
<p>在齐次坐标中，<span class="math inline">\(\begin{bmatrix}x \\y \\w
\end{bmatrix}\)</span> 表示二维空间中的点： <span
class="math inline">\(\begin{bmatrix} \frac{x}{w} \\ \frac{y}{w} \\1
\end{bmatrix}\)</span>, <span class="math inline">\(w \neq
0\)</span>.</p>
<h4 id="仿射变换affine-transformations">仿射变换（Affine
Transformations）</h4>
<p>仿射变换 = 线性变换 + 平移变换。</p>
<p>对于平移变换：</p>
<p><span class="math display">\[
\begin{bmatrix}
x^{\prime} \\
y^{\prime}
\end{bmatrix}=\begin{bmatrix}
a &amp; b \\
c &amp; d
\end{bmatrix}\begin{bmatrix}
x \\
y
\end{bmatrix}+\begin{bmatrix}
t_x \\
t_y
\end{bmatrix}
\]</span> 使用齐次坐标表示如下： <span class="math display">\[
\begin{bmatrix}
x^{\prime} \\
y^{\prime} \\
1
\end{bmatrix}=\begin{bmatrix}
a &amp; b &amp; t_x \\
c &amp; d &amp; t_y \\
0 &amp; 0 &amp; 1
\end{bmatrix} \begin{bmatrix}
x \\
y \\
1
\end{bmatrix}
\]</span></p>
<p>二维空间仿射变换的齐次坐标表示：</p>
<p>错切变换：</p>
<p><span class="math display">\[
S\left(s_x, s_y\right)=\begin{bmatrix}
s_x &amp; 0 &amp; 0 \\
0 &amp; s_y &amp; 0 \\
0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<p>旋转变换：</p>
<p><span class="math display">\[
R(\alpha)=\begin{bmatrix}
\cos \alpha &amp; -\sin \alpha &amp; 0 \\
\sin \alpha &amp; \cos \alpha &amp; 0 \\
0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<p>平移变换：</p>
<p><span class="math display">\[
T\left(t_x, t_y\right)=\begin{bmatrix}
1 &amp; 0 &amp; t_x \\
0 &amp; 1 &amp; t_y \\
0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<h3 id="逆变换inverse-transform">逆变换（Inverse Transform）</h3>
<p>设 <span class="math inline">\(M\)</span> 为一个变换矩阵，对于 <span
class="math inline">\(M\)</span> 来说，<span
class="math inline">\({M}^{-1}\)</span> 为其在代数和几何上的逆变换。</p>
<h3
id="变换的复合和分解composing-transforms-and-decomposing-complex-transforms">变换的复合和分解（Composing
Transforms And Decomposing Complex Transforms）</h3>
<h4 id="变换的复合">变换的复合</h4>
<p>可以用矩阵的乘法进行变换的组合。变换的先后顺序不同，变换的结果不同。矩阵和向量的乘法是从右到左依次相乘，从右到左依次应用变化。有一个仿射变换序列：<span
class="math inline">\(A_{1}, A_{2}, A_{3}, \dots\)</span>
，依次应用到向量上，如下所示：</p>
<p><span class="math display">\[
A_n\left(\ldots A_2\left(A_1(x)\right)\right)=A_n \cdots A_2 \cdot A_1
\cdot \begin{bmatrix}
x \\
y \\
1
\end{bmatrix}
\]</span></p>
<p>根据矩阵运算的结合律,
我们可以先把变换矩阵乘在一起，接下来把这个矩阵的乘积和向量相乘。可以用一个矩阵表示一个复杂的变换。</p>
<h4 id="变换的分解">变换的分解</h4>
<p>所有的复杂变换都可以分解成多个普通的变换。</p>
<p>例如，如何绕着容易一个点旋转？</p>
<ol type="1">
<li>将旋转中心平移到<strong>原点（origin）</strong>；</li>
<li>旋转；</li>
<li>平移回去。</li>
</ol>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/229440719-c54a6999-5404-4978-9b89-3414935e4d5d.png" alt="Img" style="zoom:100%;" />
</center>
<p>变换矩阵为： <span class="math display">\[
T(c) \cdot R(\alpha) \cdot T(-c)
\]</span></p>
<h3 id="三维变换3d-transformations">三维变换（3D Transformations）</h3>
<p>用其次坐标表示点和向量：</p>
<ul>
<li>3D point = <span class="math inline">\(\begin{bmatrix}x &amp; y
&amp; z &amp; 1 \\ \end{bmatrix}^{T}\)</span></li>
<li>3D vector = <span class="math inline">\(\begin{bmatrix}x &amp; y
&amp; z &amp; 0 \\ \end{bmatrix}^{T}\)</span></li>
</ul>
<p>一般来说，<span class="math inline">\(\left[\begin{array}{l}x &amp; y
&amp; z &amp; 1 \\ \end{array}\right]^{T}(w \neq 0)\)</span>
表示三维空间的点：<span class="math inline">\(\left[\begin{array}{l}
\frac{x}{w} &amp; \frac{y}{w} &amp; \frac{z}{w} &amp; 1
\end{array}\right]^{T}\)</span>.</p>
<p>用 <span class="math inline">\(4 \times 4\)</span>
的矩阵表示仿射变换： <span class="math display">\[
\begin{bmatrix}
x^{\prime} \\
y^{\prime} \\
z^{\prime} \\
1
\end{bmatrix}=\begin{bmatrix}
a &amp; b &amp; c &amp; t_x \\
d &amp; e &amp; f &amp; t_y \\
g &amp; h &amp; i &amp; t_z \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix} \begin{bmatrix}
x \\
y \\
z \\
1
\end{bmatrix}
\]</span></p>
<p>左上角是一个 <span class="math inline">\(3 \times 3\)</span>
的线性变换矩阵。在仿射变换中的变换矩阵表示先做线性变换再做平移变换。</p>
<h4 id="伸缩变换">伸缩变换</h4>
<p><span class="math display">\[
S\left(s_x, s_y, s_z\right)=\begin{bmatrix}
s_x &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; s_y &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; s_z &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<h4 id="平移">平移</h4>
<p><span class="math display">\[
T \left(t_x, t_y, t_z\right)=\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; t_x \\
0 &amp; 1 &amp; 0 &amp; t_y \\
0 &amp; 0 &amp; 1 &amp; t_z \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<h5 id="旋转">旋转</h5>
<p>考虑绕着 <span class="math inline">\(x, y, z\)</span> CCW 旋转。</p>
<p><span class="math display">\[
\begin{align*}
&amp; {R}_x(\alpha)=\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \cos \alpha &amp; -\sin \alpha &amp; 0 \\
0 &amp; \sin \alpha &amp; \cos \alpha &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix} \\
&amp; R_y(\alpha)=\begin{bmatrix}
\cos \alpha &amp; 0 &amp; \sin \alpha &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
-\sin \alpha &amp; 0 &amp; \cos \alpha &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix} \\
&amp; R_z(\alpha)=\begin{bmatrix}
\cos \alpha &amp; -\sin \alpha &amp; 0 &amp; 0 \\
\sin \alpha &amp; \cos \alpha &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\end{align*}
\]</span></p>
<p>对于一般性的旋转问题，可以用简单的旋转描述复杂的旋转。用 <span
class="math inline">\(x\)</span> 轴。<span
class="math inline">\(y\)</span> 轴和 <span
class="math inline">\(z\)</span> 轴上的旋转来定义旋转： <span
class="math display">\[
R_{x y z}(\alpha, \beta, \gamma)=R_x(\alpha) R_y(\beta) R_z(\gamma)
\]</span> 称 <span class="math inline">\(\alpha, \beta, \gamma\)</span>
为<strong>欧拉角</strong>（Euler angles）。</p>
<h4
id="罗德里格斯旋转公式rodrigues-rotation-formula">罗德里格斯旋转公式（Rodrigues’
Rotation Formula）</h4>
<p>绕着旋转轴 <span class="math inline">\(\vec{n}\)</span> 旋转角度
<span
class="math inline">\(\alpha\)</span>。默认旋转轴是过原点的，对于不过原点的条件可以将图形平移到过原点的旋转轴上，旋转后再平移回去。罗德里格斯旋转公式是：
<span class="math display">\[
R(\boldsymbol{n}, \alpha)=\cos \alpha \cdot I+ (1-\cos \alpha)
\boldsymbol{n} \boldsymbol{n}^T+\sin \alpha
\cdot\left[\begin{array}{ccc}
0 &amp; -n_z &amp; n_y \\
n_z &amp; 0 &amp; -n_x \\
-n_y &amp; n_x &amp; 0
\end{array}\right]
\]</span></p>
<h2 id="视图变换">视图变换</h2>
<p>在 3
维物体变到二维平面的过程中，我们需要规定好相机的位置。对于相机所做的变换就是视图变换（Viewing
/ Camera transformation）。</p>
<p>我们需要对相机位置进行定义，对于一个相机我们要规定下面三个属性：</p>
<ul>
<li>相机位置（Position）： <span
class="math inline">\(\vec{e}\)</span>.</li>
<li>相机拍摄方向（Look-at / Gaze direction）：<span
class="math inline">\(\hat{g}\)</span>.</li>
<li>相机向上方向（Up direction）：<span
class="math inline">\(\hat{t}\)</span>.</li>
</ul>
<p>根据相对运动我们可以知道，只要相机和被拍摄物体相对位置不变，那么拍摄出来的照片应当是一样的。我们可以通过对被拍摄物体做相同的变换来把相机变换到标准位置。相机的标准位置为：</p>
<ol type="1">
<li>相机位置在原点：<span class="math inline">\(\left(0,
0\right)\)</span>.</li>
<li>相机拍摄方向是 <span class="math inline">\(-z\)</span> 轴方向.</li>
<li>相机的向上方向是 <span class="math inline">\(y\)</span> 轴方向.</li>
</ol>
<p>将任意位置的相机移动到标准位置需要以下操作：</p>
<ol type="1">
<li>将中心点 <span class="math inline">\(\vec{e}\)</span>
移动到原点；</li>
<li>把 <span class="math inline">\(\hat{g}\)</span> 旋转到 <span
class="math inline">\(-z\)</span> 轴方向；</li>
<li>把 <span class="math inline">\(\hat{t}\)</span> 旋转到 <span
class="math inline">\(y\)</span> 轴方向；</li>
<li>把 <span class="math inline">\(\hat{g} \times \hat{t}\)</span>
旋转到 <span class="math inline">\(x\)</span> 轴方向。</li>
</ol>
<p>操作 2～4
只要满足任意两个，另外一个条件就会满足。也就是说我们需要先做一次平移变换，再做一次旋转变换。</p>
<p>通过 <span class="math inline">\(M_{view}\)</span> 来变换相机。令
<span class="math inline">\(M_{view} = R_{view}T_{view}\)</span>. <span
class="math inline">\(T_{view}\)</span> 表示平移变换，<span
class="math inline">\(R_{view}\)</span> 表示旋转变换。<span
class="math inline">\(T_{view}\)</span> 的表示如下：</p>
<p><span class="math display">\[
T_{ view }=\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; -x_e \\
0 &amp; 1 &amp; 0 &amp; -y_e \\
0 &amp; 0 &amp; 1 &amp; -z_e \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<p>直接求 <span class="math inline">\(R_{view}\)</span>
比较难，可以考虑其逆变换： <span class="math display">\[
R_{view }^{-1}=\begin{bmatrix}
x_{\hat{g} \times \hat{t}} &amp; x_t &amp; x_{-g} &amp; 0 \\
y_{\hat{g} \times \hat{t}} &amp; y_t &amp; y_{-g} &amp; 0 \\
z_{\hat{g} \times \hat{t}} &amp; z_t &amp; z_{-g} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}\Leftrightarrow R_{view }=\begin{bmatrix}
x_{\hat{g} \times \hat{t}} &amp; y_{\hat{g} \times \hat{t}} &amp;
z_{\hat{g} \times \hat{t}} &amp; 0 \\
x_t &amp; y_t &amp; z_t &amp; 0 \\
x_{-g} &amp; y_{-g} &amp; z_{-g} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<blockquote>
<p>旋转变换矩阵是<a
href="https://en.wikipedia.org/wiki/Orthogonal_matrix">正交矩阵</a>。</p>
</blockquote>
<h2 id="投影变换projection-transformation">投影变换（Projection
Transformation）</h2>
<p>投影变换是把 3 维模型投影到 2
维平面的变换。投影变换分为<strong>正交投影</strong>（Orthographic
projection）以及<strong>透视投影</strong>（Perspective
projection）。正交投影中，投影后原本平行的线保持平行关系。但是透视投影中平行的线在投影后不一定能保持平行关系，会相交到某一点上（这也就是近大远小现象）。</p>
<center>
<a href="https://stackoverflow.com/questions/36573283/from-perspective-picture-to-orthographic-picture">
<img data-src="https://user-images.githubusercontent.com/62458905/229446825-70279e44-8dd8-4560-b4f5-420b9f8da403.png" alt="Img" style="zoom:100%;" />
</a>
</center>
<h3 id="正交投影">正交投影</h3>
<p>正交投影将相机放在原点上，拍摄方向是 <span
class="math inline">\(-z\)</span> 轴方向，向上方向是 <span
class="math inline">\(y\)</span> 轴方向。只需要去掉 <span
class="math inline">\(z\)</span> 轴后，<span
class="math inline">\(xy\)</span>
平面上的图像就是投影结果。为了能够正交投影，我们会把所有模型变换到 <span
class="math inline">\(\left[-1,1\right]^3\)</span> 的区间范围内。</p>
<p>在空间中描述一个立方体（立方体中包含了所有需要绘制的模型），将立方体变换到
<span class="math inline">\(\left[-1,1\right]^3\)</span>
的区间范围内。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/229449074-e6cc0be4-e96a-4171-bb2c-3b8b632bbaf9.png" alt="Img" style="zoom:100%;" />
</center>
<p>定义空间中的立方体的左右在 <span class="math inline">\(x\)</span>
轴的坐标，上下在 <span class="math inline">\(y\)</span> 轴的坐标，远近在
<span class="math inline">\(z\)</span> 轴的坐标。这个立方体就可以被描述
<span class="math inline">\(\left[l, r\right] \times \left[b, t \right]
\times \left[f, n\right]\)</span>。对于 <span
class="math inline">\(z\)</span> 轴来说，越远 <span
class="math inline">\(z\)</span> 值更小，越近 <span
class="math inline">\(z\)</span>
值更大。远是小于近的，保证了右手坐标系下从 <span
class="math inline">\(-z\)</span> 方向看过去 <span
class="math inline">\(z\)</span> 值的规律。</p>
<p>将这样的立方体映射到正则 / 标准 / 规范（canonical）立方体 <span
class="math inline">\(\left[-1, 1\right]\)</span> 中。</p>
<p>变换方法是先将中心平移到原点，之后对每个边进行缩放到大小为 2。</p>
<p>变换矩阵为：</p>
<p><span class="math display">\[
M_{\text {ortho }}=\begin{bmatrix}
\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; \frac{2}{n-f} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix} \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; -\frac{r+l}{2} \\
0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2} \\
0 &amp; 0 &amp; 1 &amp; -\frac{n+f}{2} \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span> ### 透视投影</p>
<p>透视投影是最为广泛的投影方式。透视投影满足近大远小的性质。接下来我们定义视锥。视锥就是一个透视相机渲染时能看到区域的形状，相机放在平面的中心，一个视锥包含
4 个元素：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/229450246-a44aee7c-e026-42e3-912b-c3e89d4cb02f.png" alt="Img" style="zoom:60%;" />
</center>
<ol type="1">
<li>近平面：渲染的区域里相机最近的平面；</li>
<li>远平面：渲染的区域里相机最远的平面；</li>
<li>视野（Field of view,
FOV）：平面顶部和底部中心到相机连线的夹角；</li>
<li>宽高比：平面宽度和高度之比。</li>
</ol>
<p>从一个点射出的四棱锥定义了远和近两个平面。我们可以把远平面缩小成和近平面一样大的长方形，这样视锥就会变成一个立方体。再做一次正交投影就可以得到最终的投影结果了。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/229450693-113e43c9-646a-49ee-a5bb-00a9eb0845c6.png" alt="Img" style="zoom:100%;" />
</center>
<p>我们需要对处于四棱锥中的点进行变换，变换满足三个条件：</p>
<ol type="1">
<li>任何一个在近平面上的点不会发生变化；</li>
<li>远平面处的点 <span class="math inline">\(z\)</span>
值不发生变化；</li>
</ol>
<p>先将四棱锥变换成长方体，然后再做正交投影变换即可，记将四棱锥变换成长方体的矩阵为：<span
class="math inline">\(M_{persp \rightarrow ortho}\)</span>.</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/229451208-e4282270-ad77-491d-b88c-5461b97c6ff5.png" alt="Img" style="zoom:100%;" />
</center>
<p>从 <span class="math inline">\(YZ\)</span>
平面看过去，对于远平面上的点 <span class="math inline">\(\left[x, y,
z\right]\)</span> 在投影变换后，根据相似三角形的性质，点的位置变为 <span
class="math inline">\(\left[\frac{n}{z}x, \frac{n}{z}y,
z\right]\)</span>. 对于任意一个点点 <span class="math inline">\(\left[x,
y, z\right]\)</span> 来说，变化过程为： <span class="math display">\[
\begin{bmatrix}
x \\
y \\
z \\
1
\end{bmatrix} \Rightarrow\begin{bmatrix}
n x / z \\
n y / z \\
\text { unknown } \\
1
\end{bmatrix} \stackrel{\times z}{=}\begin{bmatrix}
n x \\
n y \\
\text { still unknown } \\
z
\end{bmatrix}
\]</span> 中间点的 <span class="math inline">\(z\)</span>
值变化目前是不确定的。但是对于以上的变化结果我们可以得到变换矩阵的部分结果：
<span class="math display">\[
M_{persp \rightarrow ortho} = \begin{bmatrix}
n &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; n &amp; 0 &amp; 0 \\
? &amp; ? &amp; ? &amp; ? \\
0 &amp; 0 &amp; 1 &amp; 0
\end{bmatrix}
\]</span> 接下来求出未知量。对于近平面的上的点，应当满足变换： <span
class="math display">\[
\begin{bmatrix}
x \\
y \\
n \\
1
\end{bmatrix} \Rightarrow \begin{bmatrix}
x \\
y \\
n \\
1
\end{bmatrix}=\begin{bmatrix}
n x \\
n y \\
n^2 \\
n
\end{bmatrix}
\]</span> 因此可以得到方程： <span class="math display">\[
\begin{bmatrix}
0 &amp; 0 &amp; A &amp; B
\end{bmatrix} \begin{bmatrix}
x \\
y \\
n \\
1
\end{bmatrix}=n^2
\]</span> <span class="math inline">\(n^2\)</span> 显然和 <span
class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span>
的值没有什么关系，因此 <span class="math inline">\(x\)</span>，<span
class="math inline">\(y\)</span> 的系数为 <span
class="math inline">\(0\)</span>。但是方程不能解出，还需要一个方程。</p>
<p>对于远平面，我们选择中心点，变换应当满足： <span
class="math display">\[
\begin{bmatrix}
0 \\
0 \\
f \\
1
\end{bmatrix} \Rightarrow \begin{bmatrix}
0 \\
0 \\
f \\
1
\end{bmatrix} == \begin{bmatrix}
0 \\
0 \\
f^2 \\
f
\end{bmatrix}
\]</span> 可以得到方程： <span class="math display">\[
\begin{bmatrix}
0 &amp; 0 &amp; A &amp; B
\end{bmatrix} \begin{bmatrix}
0 \\
0 \\
f \\
1
\end{bmatrix}=f^2
\]</span> 方程展开后可以得到： <span class="math display">\[
\begin{align*}
&amp; A n+B=n^2 \\
&amp; A f+B=f^2
\end{align*}
\]</span> 解得： <span class="math display">\[
\begin{aligned}
&amp; A=n+f \\
&amp; B=-n f
\end{aligned}
\]</span> 因此我们就解出了变换矩阵： <span class="math display">\[
M_{persp \rightarrow ortho} = \begin{bmatrix}
n &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; n &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; n + f &amp; -nf \\
0 &amp; 0 &amp; 1 &amp; 0
\end{bmatrix}
\]</span></p>
<p>所以： <span class="math display">\[
\begin{align*}
M_{persp} &amp;= M_{ortho}M_{persp \rightarrow ortho}\\
\end{align*}
\]</span></p>
<h3
id="透视投影的变换后的正交投影变换矩阵">透视投影的变换后的正交投影变换矩阵</h3>
<p>对于定义好的视锥，我们定义视野角度为 <span
class="math inline">\(\alpha\)</span>，宽高比为 <span
class="math inline">\(radio\)</span>，近平面 <span
class="math inline">\(z\)</span> 值为 <span
class="math inline">\(n\)</span>，那么投影变换后的长方体的中 <span
class="math inline">\(t = n \tan{\frac{\alpha}{2}}\)</span>，<span
class="math inline">\(b=-n\tan{\frac{\alpha}{2}}\)</span>，<span
class="math inline">\(r = radio * n
\tan{\frac{\alpha}{2}}\)</span>，<span class="math inline">\(l=-radio *
n \tan{\frac{\alpha }{2}}\)</span> 代入正交投影变化公式中即可。</p>
]]></content>
      <categories>
        <category>GAMES 101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>变换</tag>
      </tags>
  </entry>
  <entry>
    <title>动画</title>
    <url>/2023/07/16/%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p>动画（Animation）是一门「让物体变活」的技术。可以理解为模型在不同的时间具有不同的几何形状。根据人眼的视觉暂留效应，动画只需要在一定时间内连续播放多张图片就有物体在连续运动的效果。例如对于视觉暂留只需要
24 fps 就可以达到动画效果，视频的帧率为 24 fps，而虚拟现实需要达到 90
fps 才不会产生眩晕感。</p>
<h2 id="关键帧动画">关键帧动画</h2>
<p>关键帧动画（Keyframe
Animation）包含两个部分，一部分是关键帧（Keyframe），是动画中比较重要的部分。两个关键帧之间是过渡帧（Tweens）。关键帧动画的问题的重要问题就是插值问题。</p>
<p>插值方法有很多，例如线性插值，样条插值等方法。我们希望能有更加自然的插值方式，因此会更多地使用样条插值的方法。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231698547-bdcfb866-545d-4269-a6cb-e98501935f24.png" alt="Img" style="zoom:100%;" />
</center>
<h2 id="physical-simulation">Physical Simulation</h2>
<p>牛顿第二定律： <span class="math display">\[
F = ma
\]</span> 所谓 Physical simulation
就是通过模拟出不同的物理公式来仿真出不同的物理效果。</p>
<h3 id="mass-spring-system">Mass Spring System</h3>
<p>质点弹簧系统中最基本的单元是一根弹簧以及左右连接的两个质点。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231699528-749adc11-d0c9-48df-a570-e9690f0594c4.png" alt="Img" style="zoom:100%;" />
</center>
<p>假设弹簧没有长度，根据胡克定律可以得到： <span
class="math display">\[
\boldsymbol{f}_{a \rightarrow b}=k_s(\boldsymbol{b}-\boldsymbol{a})
\]</span> 显然有： <span class="math display">\[
\boldsymbol{f}_{a \rightarrow b}=-\boldsymbol{f}_{b \rightarrow a}
\]</span> 但实际上弹簧在不受力时也有一定的长度，因此胡克定律应该改写为：
<span class="math display">\[
\boldsymbol{f}_{a \rightarrow b}=k_s
\frac{\boldsymbol{b}-\boldsymbol{a}}{\|\boldsymbol{b}-\boldsymbol{a}\|}(\|\boldsymbol{b}-\boldsymbol{a}\|-l)
\]</span> 但这种系统会一种震动下去，对于实际的 mass spring system
来说会受到阻力，能量会有衰减。</p>
<p>在 mass spring system 中一个质点的阻力为：</p>
<p><span class="math display">\[
\boldsymbol{f}=-k_d \dot{\boldsymbol{b}}
\]</span> 其中 <span class="math inline">\(k_d\)</span> 为 damping
coefficient.</p>
<p>这样的描述带来的问题是会让所有的质点运动停下。如果出现一个弹簧的两个端点同时进行匀速直线运动，这个时候外部摩擦力就会让整个运动停下，但是实际上弹簧并没有发生震动，因此我们需要引入内部摩擦力：
<span class="math display">\[
\boldsymbol{f}_{\boldsymbol{b}}=-k_d \frac{\boldsymbol{b -
a}}{\|\boldsymbol{b}-\boldsymbol{a}\|}(\dot{\boldsymbol{b}}-\dot{\boldsymbol{a}})
\cdot
\frac{\boldsymbol{b}-\boldsymbol{a}}{\|\boldsymbol{b}-\boldsymbol{a}\|}
\]</span>
在这个式子中，我们考虑两个质点间的相对速度（这样可以避免相对运动的问题）。同时，只有在两个质点连线方向上的速度投影才可以引起弹簧长度改变。例如
<span class="math inline">\(a\)</span> 不动，<span
class="math inline">\(b\)</span> 相对于 <span
class="math inline">\(a\)</span>
做圆周运动，这个时候并没有使弹簧长度发生改变，这个速度不引起弹簧内部的能量损耗。</p>
<h3 id="structures-from-springs">Structures from Springs</h3>
<p>通过这些弹簧进行连接，我们可以得到各种材料。例如，可以使用质点弹簧系统对布料进行模拟：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231702264-adc9e04e-6e93-4bba-8036-fb2d7af7f0e6.png" alt="Img" style="zoom:100%;" />
</center>
<p>对于图(a)，不能很好的抵抗切变，同时布料很难被折叠，但是这个结构可以进行折叠（Out-of-planeBending）。因此这样的设计是不合理的。在图(b)
中加入斜的对角线来抵抗切变，但是依然不能解决折叠的问题，并且整个布是各向异性的。在图(c)
中再加入一条对角线，这样就可以抵抗对角线上折叠的力，并且整个布料是各向同性的。但是在水平和垂直方向依然可以折叠。在图(d)
中，都在间隔一个点两个点之间加入一条线，这样就可以抵抗水平和垂直的折叠。在这里，蓝线是比较强的抵抗，但是红线的抵抗比较弱。</p>
<h2 id="particle-systems">Particle Systems</h2>
<p>现实生活中很多物体都是由大量的粒子组成的，我们称之为粒子系统。对于粒子系统，可能需要大量的粒子来模拟复杂的现象，并且需要一些加速结构加快粒子作用力的计算。粒子系统的计算分为以下几个步骤：</p>
<ol type="1">
<li>产生新的粒子（如果有需要）；</li>
<li>计算每一个粒子受到的作用力；</li>
<li>更新每一个粒子的位置和速度；</li>
<li>移除死亡的粒子（如果有需要）；</li>
<li>渲染粒子。</li>
</ol>
<p>在粒子系统中可以考虑许多力作用，引力和斥力，包括万有引力，电磁力，弹力，推进力。阻尼力包括摩擦力，空气阻力，以及黏力。同时还要考虑碰撞产生的力。</p>
<h2 id="kinematics">Kinematics</h2>
<p>动力学包括正向动力学以及逆向动力学。如下图所示是一个人体骨骼的抽象。在正向动力学中，我们会知道所有关节的旋转角度，推断出尖端所在的位置。在逆向动力学中，已知尖端的位置，需要推断出关节的旋转方式（角度）。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231703823-212ddb0c-9c5a-47b4-b2c0-3186bcd89152.png" alt="Img" style="zoom:50%;" />
</center>
<h3 id="forward-kinematics">Forward Kinematics</h3>
<p>在正向动力学中，计算尖端位置主要通过三角函数进行计算。以下图为例，是一个简单的骨骼系统计算尖端位置的方法。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231704072-ef449d80-a800-40ed-bdd6-6aa852dd9163.png" alt="Img" style="zoom:50%;" />
</center>
<p>正向动力学能够方便的控制骨骼方向，并且计算方便，但是得到的物理模拟不一定连续，并且对于艺术家来说，调整工作非常浪费时间。</p>
<h3 id="inverse-kinematics">Inverse Kinematics</h3>
<p>反向动力学中，在得到尖端位置后我们需要计算各个关节的旋转角度。下图提供了一个简单关节的计算方式。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231704442-0e5f1477-72d0-4570-8e8c-c862f2c83951.png" alt="Img" style="zoom:50%;" />
</center>
<p>在反向动力学中主要面对以下几个问题：</p>
<ul>
<li>解不一定唯一：</li>
</ul>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231704652-49275eeb-7dca-4f67-9a82-13c4523f08d0.png" alt="Img" style="zoom:50%;" />
</center>
<ul>
<li>关节连接越多，计算越麻烦。</li>
<li>在某些地方可能不存在解：</li>
</ul>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231704764-4203928b-6984-4783-b5c8-11aa7f5cdc6f.png" alt="Img" style="zoom:50%;" />
</center>
<p>目前有很多方法解决这些问题，例如对于 N 连接的 IK 问题：</p>
<ul>
<li>选择初始设定；</li>
<li>定义错误度量方式；</li>
<li>将错误的梯度作为设定之一；</li>
<li>使用梯度下降计算梯度。</li>
</ul>
<h2 id="单粒子模拟">单粒子模拟</h2>
<p>我们假设粒子在一个力场之中，力场中的任何一个点都定义了这个点处粒子收到的力的大小和方向，目的是在知道粒子的起点后，我们需要计算出力在场中的运动轨迹。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231705661-b99467a5-e11f-4abf-9ff6-c5fab69a9d79.png" alt="Img" style="zoom:50%;" />
</center>
<p>在这样的系统中，我们需要解的是 <span class="math inline">\(x\)</span>
关于 <span class="math inline">\(t\)</span> 的常微分方程，也就是：</p>
<p><span class="math display">\[
\frac{\mathrm{d}x}{\mathrm{d} t} = \dot{x} = v\left(x, t\right)
\]</span></p>
<h3 id="欧拉方法">欧拉方法</h3>
<p>欧拉方法（Euler‘s
Method）非常的简单且常用，但是往往不稳定，欧拉方法的公式为： <span
class="math display">\[
\begin{aligned}
\boldsymbol{x}^{t+\Delta t} &amp; =\boldsymbol{x}^t+\Delta t
\dot{\boldsymbol{x}}^t \\
\dot{\boldsymbol{x}}^{t+\Delta t} &amp; =\dot{\boldsymbol{x}}^t+\Delta t
\ddot{\boldsymbol{x}}^t
\end{aligned}
\]</span>
欧拉方法错误的多少和步长的选择有关，步长越小，模拟出的路径误差越小。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231706740-36489687-33f6-4ba4-a1e3-5579c41f1685.png" alt="Img" style="zoom:50%;" />
</center>
<p>另一方面，即使是减小步长，在某些力场中依然会有不稳定的情况产生。例如在匀速圆周运动的力场中，粒子可以做匀速圆周运动。但是使用欧拉方法后，模拟出的路径会一步一步远离力场中心。这被称作不稳定性。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231706995-3fd7e598-950c-4b76-8d2e-3f9ade32571b.png" alt="Img" style="zoom:50%;" />
</center>
<p>错误和不稳定性是衡量路径模拟的指标。错误会在每一步积累，降低路径模拟的准确性。而不稳定性也是影响路径模拟效果的因素之一。目前也有一些方法来解决模拟中的不稳定性。</p>
<h3 id="中点法">中点法</h3>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231707559-70d29e8c-02f8-4533-a31e-ebb47fd20ab0.png" alt="Img" style="zoom:50%;" />
</center>
<p>中点法的步骤如下：</p>
<ol type="1">
<li>使用欧拉方法计算下一步粒子的位置；</li>
<li>计算中点下一步移动的梯度；</li>
<li>使用中点的梯度更新该点的位置。</li>
</ol>
<p>写出数学公式为： <span class="math display">\[
\begin{aligned}
\boldsymbol{x}^{t+\Delta t} &amp; =\boldsymbol{x}^t+\frac{\Delta
t}{2}\left(\dot{\boldsymbol{x}}^t+\dot{\boldsymbol{x}}^{t+\Delta
t}\right) \\
\dot{\boldsymbol{x}}^{t+\Delta t} &amp; =\dot{\boldsymbol{x}}^t+\Delta t
\ddot{\boldsymbol{x}}^t \\
\boldsymbol{x}^{t+\Delta t} &amp; =\boldsymbol{x}^t+\Delta t
\dot{\boldsymbol{x}}^t+\frac{(\Delta t)^2}{2} \ddot{\boldsymbol{x}}^t
\end{aligned}
\]</span></p>
<h3 id="自适应步长">自适应步长</h3>
<p>自适应步长的方法可以通过误差分析计算所需要步长的大小，具体的步骤如下：</p>
<ol type="1">
<li>计算步长为 T 时欧拉方法移动的位置 <span
class="math inline">\(x_T\)</span>；<br />
</li>
<li>计算步长为 <span class="math inline">\(\frac{T}{2}\)</span>
时欧拉方法移动的位置 <span
class="math inline">\(x_\frac{T}{2}\)</span>;</li>
<li>计算误差 <span class="math inline">\(\left\|x_T -
x_{\frac{T}{2}}\right\|\)</span>；</li>
<li>如果误差大于阈值，减小步长并重复以上过程。</li>
</ol>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231708362-a724c43d-10a1-4adc-94cf-a17e73d68c57.png" alt="Img" style="zoom:50%;" />
</center>
<h3 id="隐式欧拉方法">隐式欧拉方法</h3>
<p>在隐式欧拉方法中，我们需要计算出 <span
class="math inline">\(\boldsymbol{x}^{t+\Delta t}\)</span> 以及 <span
class="math inline">\(\dot{\boldsymbol{x}}^{t+\Delta t}\)</span>
的结果。可以使用牛顿法求解，但是求解相对不方便。但是具有更好地稳定性。
<span class="math display">\[
\begin{aligned}
&amp; \boldsymbol{x}^{t+\Delta t}=\boldsymbol{x}^t+\Delta t
\dot{\boldsymbol{x}}^{t+\Delta t} \\
&amp; \dot{\boldsymbol{x}}^{t+\Delta t}=\dot{\boldsymbol{x}}^t+\Delta t
\ddot{\boldsymbol{x}}^{t+\Delta t}
\end{aligned}
\]</span>
这里我们可以对稳定性进行定义。我们使用每一步的误差以及整体累计的误差表示方法的稳定性。误差本身没有太多意义，但是误差的阶可以衡量误差。隐式欧拉方法是
1 阶的，因此每一步的误差为 <span
class="math inline">\(\Omicron\left(h^2\right)\)</span>，整体累计的误差为
<span class="math inline">\(\Omicron\left(h\right)\)</span>. 其中 h
可以看作步长 <span class="math inline">\(\Delta t\)</span>.</p>
<h3 id="runge-kutta-方法">Runge-Kutta 方法</h3>
<p>RK 方法适合于非线性 ODE 的求解，其中 4 阶的方法（RK4）最为常用：</p>
<p>初始条件： <span class="math display">\[
\frac{\mathrm{d}y}{\mathrm{d}t} = f\left(t, y\right), \quad
y\left(t_0\right)  =y_0
\]</span> 求解得： <span class="math display">\[
\begin{aligned}
&amp; y_{n+1}=y_n+\frac{1}{6} h\left(k_1+2 k_2+2 k_3+k_4\right) \\
&amp; t_{n+1}=t_n+h
\end{aligned}
\]</span> 其中： <span class="math display">\[
\begin{aligned}
&amp; k_1=f\left(t_n, y_n\right) \\
&amp; k_2=f\left(t_n+\frac{h}{2}, y_n+h \frac{k_1}{2}\right) \\
&amp; k_3=f\left(t_n+\frac{h}{2}, y_n+h \frac{k_2}{2}\right) \\
&amp; k_4=f\left(t_n+h, y_n+h k_3\right)
\end{aligned}
\]</span></p>
<h3 id="position-based-方法">Position-Based 方法</h3>
<p>不是基于物理的方法，而是不断的调整物体的位置保证物体运动能够满足最后的要求。这种方法速度快并且简单，但是这种方法无法保证能量守恒。</p>
<h2 id="刚体模拟rigid-body-simulation">刚体模拟（Rigid Body
Simulation）</h2>
<p>刚体不会发生形变，因此刚体中的点会按照同一种方式进行运动。刚体的运动就可以看作一个粒子的模拟。但是在刚体中会对更多的物理量进行模拟：
<span class="math display">\[
\frac{d}{d t}\left(\begin{array}{c}
\mathrm{X} \\
\theta \\
\dot{\mathrm{X}} \\
\omega
\end{array}\right)=\left(\begin{array}{c}
\dot{\mathrm{X}} \\
\omega \\
\mathrm{F} / M \\
\Gamma / I
\end{array}\right)
\]</span> 这里：<span class="math inline">\(X\)</span> 是位置，<span
class="math inline">\(\theta\)</span> 是角度，<span
class="math inline">\(\dot{X}\)</span> 是速度，<span
class="math inline">\(\omega\)</span> 是角速度，<span
class="math inline">\(F\)</span> 是力，<span
class="math inline">\(M\)</span> 是质量，<span
class="math inline">\(\Gamma\)</span> 是扭矩，<span
class="math inline">\(I\)</span> 是转动惯量。</p>
<h2 id="流体模拟fluid-simulation">流体模拟（Fluid Simulation）</h2>
<p>在流体模拟中，我们有以下基本思想：</p>
<ul>
<li>假设液体由很小的刚体球组成；</li>
<li>假设液体不能被压缩（密度是不变的）；</li>
<li>一旦某些地方的密度发生改变，就需要通过更改小球的位置保证密度一致；</li>
<li>需要知道每一个点的密度的梯度；</li>
<li>调整的过程就是梯度下降的过程。</li>
</ul>
<p>在流体模拟中包含了两种方法，分别是<strong>质点法</strong>（Lagrangian
Approach）和网格法（Eulerian
Ap-proach）。质点法就是精确模拟每一个物体随着时间如何进行变换。网格法将整个空间分成多个网格，只考虑每一个网格在每一个时刻的变化。</p>
<p>目前还产生了新的方法，被称为
Hybrid，是结合质点法以及网格法。其主要思想是对于每一个粒子都有其属性，我们让粒子在网格中进行变换，但是在变换后需要将属性重新写回到粒子上。这种方法叫做物质点方法（Material
Point Method，MPM）。</p>
]]></content>
      <categories>
        <category>GAMES 101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串处理函数</title>
    <url>/2023/07/16/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="获取字符串长度的函数">获取字符串长度的函数</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br><span class="line">功能：计算一个字符串的长度</span><br><span class="line">参数：</span><br><span class="line">	s：指定的字符串 </span><br><span class="line">返回值：</span><br><span class="line">	当前字符串的长度</span><br><span class="line">注意：<span class="built_in">strlen</span> 获取的字符串长度遇到第一个\<span class="number">0</span>结束且\<span class="number">0</span>不计算</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> s1[<span class="number">100</span>] = <span class="string">&quot;hel\0lo&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1_len = %d\n&quot;</span>, <span class="built_in">strlen</span>(s1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1_size = %d\n&quot;</span>, <span class="keyword">sizeof</span>(s1));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *s2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2_len = %d\n&quot;</span>, <span class="built_in">strlen</span>(s2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2_size = %d\n&quot;</span>, <span class="keyword">sizeof</span>(s2));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/f3a0c0d4-bde6-49f1-9c9a-06e3453cf506"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>获取字符串长度可以通过如下方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (str[len] &amp;&amp; ++len);</span><br></pre></td></tr></table></figure>
<h2 id="字符串拷贝函数">字符串拷贝函数</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line">功能：将 src 复制给 dest</span><br><span class="line">参数：</span><br><span class="line">    dest：目标字符串</span><br><span class="line">    src：源字符串</span><br><span class="line">返回值：</span><br><span class="line">    保存 dest 字符串的首地址</span><br><span class="line">注意：使用 <span class="built_in">strcpy</span> 函数复制字符串时必须保证 dest 足够大，否则会内存溢出。<span class="built_in">strcpy</span> 是将 src 字符串中第一个 \<span class="number">0</span> 之前包括 \<span class="number">0</span> 复制给 dest</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line">函数的说明：</span><br><span class="line">	将 src 指向的字符串前 n 个字节，拷贝到 dest 指向的内存中</span><br><span class="line">返回值:</span><br><span class="line">	目的内存的首地址</span><br><span class="line">注意：</span><br><span class="line"><span class="number">1</span>、<span class="built_in">strncpy</span> 不拷贝 <span class="string">&#x27;\0&#x27;</span></span><br><span class="line"><span class="number">2</span>、如果n大于src指向的字符串中的字符个数，则在dest后面填充n‐<span class="built_in">strlen</span>(src)个<span class="string">&#x27;\0&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 使用strcpy函数拷贝字符串</span></span><br><span class="line">    <span class="type">char</span> s1[<span class="number">32</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="comment">// 使用strcpy函数时，必须保证第一个参数的内存足够大</span></span><br><span class="line">    <span class="type">char</span> s2[<span class="number">32</span>] = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(s1, s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1 = %s\n&quot;</span>, s1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%c] ‐ %d\n&quot;</span>, s1[i], s1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/ab35b5bf-9034-4903-a630-1e9469f9e7f1"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="字符串追加函数">字符串追加函数</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line">功能：将src追加到dest的后面</span><br><span class="line">参数：</span><br><span class="line">    dest：目的字符串</span><br><span class="line">    src：源字符串</span><br><span class="line">返回值：</span><br><span class="line">    保存dest字符串的首地址</span><br><span class="line">    </span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line">追加src指向的字符串的前n个字符，到dest指向的字符串的后面。</span><br><span class="line">注意如果n大于src的字符个数，则只将src字符串追加到dest指向的字符串的后面</span><br><span class="line">追加的时候会追加’\<span class="number">0</span>’</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 使用strcat函数追加字符串</span></span><br><span class="line">    <span class="type">char</span> s1[<span class="number">32</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s2[<span class="number">32</span>] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">    <span class="comment">// strcat是从s1的\0的位置开始追加，直到s2的第一个\0复制完毕后结束</span></span><br><span class="line">    <span class="built_in">strcat</span>(s1, s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1 = %s\n&quot;</span>, s1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/61168d3b-68bf-40b9-a08d-755dd171a827"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="字符串比较函数">字符串比较函数</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2, <span class="type">size_t</span> n)</span>;</span><br><span class="line">功能：<span class="built_in">strcmp</span>是比较两个字符串的内容，<span class="built_in">strncmp</span>是比较两个字符串的前n个字节是否一样</span><br><span class="line">参数：</span><br><span class="line">    s1、s2：要比较的两个字符串</span><br><span class="line">    n：<span class="built_in">strncmp</span>中的参数n表示要比较的字节数</span><br><span class="line">返回值：</span><br><span class="line">    <span class="number">0</span> s1 = s2</span><br><span class="line">    &gt;<span class="number">0</span> s1 &gt; s2</span><br><span class="line">    &lt;<span class="number">0</span> s1 &lt; s2</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 使用strcmp比较两个字符串的内容是否一致</span></span><br><span class="line">    <span class="comment">// strcmp函数一个字符一个字符比较，只要出现不一样的，就会立即返回</span></span><br><span class="line">    <span class="type">char</span> s1[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s2[] = <span class="string">&quot;w&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">strcmp</span>(s1, s2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 = s2\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 &gt; s2\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s1 &lt; s2\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/5d6e620b-9143-4194-802c-4fef41eb552e"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="字符查找函数">字符查找函数</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> c)</span>;</span><br><span class="line">功能：在字符指针s指向的字符串中，找ascii 码为c的字符</span><br><span class="line">参数：</span><br><span class="line">    s：指定的字符串</span><br><span class="line">    c：要查找的字符</span><br><span class="line">返回值：</span><br><span class="line">    成功：找到的字符的地址</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br><span class="line">注意：s指向的字符串中有多个ASCII为c的字符，则找的是第<span class="number">1</span>个字符</span><br><span class="line">    </span><br><span class="line"><span class="type">char</span> *<span class="title function_">strrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> c)</span>;</span><br><span class="line">功能：在s指向的字符串中，找最后一次出现的ASCII为c的字符</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 使用strchr函数在一个字符串中查找字符</span></span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;hel6lo wor6ld&quot;</span>;</span><br><span class="line">    <span class="comment">// 找第一个匹配的字符</span></span><br><span class="line">    <span class="type">char</span> *ret = <span class="built_in">strchr</span>(s, <span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">    <span class="comment">// 找最后一个匹配的字符</span></span><br><span class="line">    <span class="comment">// char *ret = strrchr(s, &#x27;6&#x27;);</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有找到\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了，在数组的第%d个位置\n&quot;</span>, ret - s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/c7d6eefd-6a5d-4ee5-8532-469dc906b913"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="字符串匹配函数">字符串匹配函数</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *haystack, <span class="type">const</span> <span class="type">char</span> *needle)</span>;</span><br><span class="line">函数说明：</span><br><span class="line">	在haystack指向的字符串中查找needle指向的字符串，也是首次匹配</span><br><span class="line">返回值：</span><br><span class="line">    找到了：找到的字符串的首地址</span><br><span class="line">    没找到：返回<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 使用strstr函数在一个字符串中查找另一个字符串</span></span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;1234:4567:666:789:666:7777&quot;</span>;</span><br><span class="line">    <span class="comment">// strstr查找的时候，查找的是第二个参数的第一个\0之前的内容</span></span><br><span class="line">    <span class="type">char</span> *ret = <span class="built_in">strstr</span>(s, <span class="string">&quot;666&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没找到\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了，在当前字符串的第%d个位置\n&quot;</span>, ret - s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/50c60c29-b244-4647-b4da-38da048a16b0"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="字符串转换数值">字符串转换数值</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span>;</span><br><span class="line">功能：将一个数字型字符串转化为整形数据</span><br><span class="line">参数：</span><br><span class="line">    nptr：指定的字符串</span><br><span class="line">返回值：</span><br><span class="line">    获取到的整形数据</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 使用atoi将数字型字符串转化为整形数据</span></span><br><span class="line">    <span class="type">char</span> s1[] = <span class="string">&quot;7856&quot;</span>;</span><br><span class="line">    <span class="type">int</span> ret1 = atoi(s1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret1 = %d\n&quot;</span>, ret1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用atof将浮点型的字符串转化为浮点型数据</span></span><br><span class="line">    <span class="type">char</span> s2[] = <span class="string">&quot;3.1415926&quot;</span>;</span><br><span class="line">    <span class="type">double</span> ret2 = atof(s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret2 = %lf\n&quot;</span>, ret2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/3820eef5-b26c-4e53-a408-a0d19f955b2c"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="字符串切割函数">字符串切割函数</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strtok</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *delim)</span>;</span><br><span class="line">功能：对字符串进行切割</span><br><span class="line">参数：</span><br><span class="line">    str：要切割的字符串</span><br><span class="line">    第一次切割，传入指定的字符串，后面所有的切割传<span class="literal">NULL</span></span><br><span class="line">delim：标识符，要根据指定的delim进行切割，切割的结果不包含delim</span><br><span class="line">返回值：</span><br><span class="line">	返回切割下来的字符串的首地址，如果都切割完毕，则返回<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 使用strtok函数切割字符串</span></span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;111:22222:33:4444444444:5555555555555&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *ret;</span><br><span class="line">    <span class="comment">// 第一次切割</span></span><br><span class="line">    ret = strtok(s, <span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ret = %s\n&quot;</span>, ret);</span><br><span class="line">    <span class="comment">// 后面所有切割时都要将strtok的第一个参数传NULL</span></span><br><span class="line">    <span class="keyword">while</span> ((ret = strtok(<span class="literal">NULL</span>, <span class="string">&quot;:&quot;</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %s\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/5a49aeb6-cb88-455a-aea9-8dbce560dafb"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="格式化字符串操作函数">格式化字符串操作函数</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line">功能：将按照格式保存的字符串复制给str</span><br><span class="line">参数：</span><br><span class="line">    str：保存字符串</span><br><span class="line">    format：同<span class="built_in">printf</span></span><br><span class="line">返回值：</span><br><span class="line">保存的字符串的字节数</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line">功能：<span class="built_in">scanf</span>是从终端读取数据并赋值给对应变量，而<span class="built_in">sscanf</span>是从第一个参数中读取数据</span><br><span class="line">参数：</span><br><span class="line">    str：指定要获取内容的字符串</span><br><span class="line">    format：按照格式获取数据保存在变量中</span><br><span class="line">返回值：</span><br><span class="line">    成功获取的个数</span><br></pre></td></tr></table></figure>
<p><strong><code>sprintf</code> 和 <code>sscanf</code>
的基本用法：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d:%d:%d&quot;</span>, <span class="number">2013</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">sscanf</span>(<span class="string">&quot;2013:10:1&quot;</span>, <span class="string">&quot;%d:%d:%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d,c=%d\n&quot;</span>, a, b, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/d20fb5ab-2389-4437-acae-9da1ba55b9b1"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p><strong><code>sscanf</code> 高级用法：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1、跳过数据：%*s或%*d</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">sscanf</span>(<span class="string">&quot;1234 5678&quot;</span>, <span class="string">&quot;%*d %s&quot;</span>, buf1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf1);</span><br><span class="line">    <span class="comment">// 2、读指定宽度的数据：%[width]s</span></span><br><span class="line">    <span class="type">char</span> buf2[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">sscanf</span>(<span class="string">&quot;12345678&quot;</span>, <span class="string">&quot;%4s &quot;</span>, buf2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf2);</span><br><span class="line">    <span class="comment">// 3、支持集合操作：只支持获取字符串</span></span><br><span class="line">    <span class="comment">//  %[a‐z] 表示匹配a到z中任意字符(尽可能多的匹配)</span></span><br><span class="line">    <span class="comment">//  %[aBc] 匹配a、B、c中一员，贪婪性</span></span><br><span class="line">    <span class="comment">//  %[^aFc] 匹配非a、F、c的任意字符，贪婪性</span></span><br><span class="line">    <span class="comment">//  %[^a‐z] 表示读取除a‐z以外的所有字符</span></span><br><span class="line">    <span class="type">char</span> buf3[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">sscanf</span>(<span class="string">&quot;agcd32DajfDdFF&quot;</span>, <span class="string">&quot;%[a-z]&quot;</span>, buf3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/781fe874-8ac0-4233-9a4a-6b94da409c7a"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="const">const</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const修饰全局变量</span></span><br><span class="line"><span class="comment">// 此时全局变量只能使用但是不能修改，</span></span><br><span class="line"><span class="comment">// 如果直接拿全局变量修改值，编译直接报错</span></span><br><span class="line"><span class="comment">// 如果使用全局变量的地址修改值，运行时程序异常结束</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    <span class="comment">// a = 666;</span></span><br><span class="line">    <span class="comment">// printf(&quot;a = %d\n&quot;, a);</span></span><br><span class="line">    <span class="type">int</span> *p = &amp;a;</span><br><span class="line">    *p = <span class="number">888</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const修饰普通局部变量</span></span><br><span class="line"><span class="comment">// 可以读取变量的值</span></span><br><span class="line"><span class="comment">// 不能直接通过变量进行修改值，编译报错</span></span><br><span class="line"><span class="comment">// 可以通过变量的地址修改值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line">    <span class="comment">// b = 666;</span></span><br><span class="line">    <span class="comment">// printf(&quot;b = %d\n&quot;, b);</span></span><br><span class="line">    <span class="type">int</span> *p = &amp;b;</span><br><span class="line">    *p = <span class="number">888</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const修饰指针变量</span></span><br><span class="line"><span class="comment">// 如果const修饰指针变量的类型，无法通过指针变量修改地址里面的值</span></span><br><span class="line"><span class="comment">// 如果const修饰指针变量，无法修改指针变量保存的地址</span></span><br><span class="line"><span class="comment">// 如果const既修饰指针变量的类型，又修饰指针变量，则只能通过原本变量修改值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// const修饰指针变量的类型</span></span><br><span class="line">    <span class="comment">// const int * p = &amp;c;</span></span><br><span class="line">    <span class="comment">// const修饰指针变量</span></span><br><span class="line">    <span class="comment">// int * const p = &amp;c;</span></span><br><span class="line">    <span class="comment">// const既修饰指针变量的类型，又修饰指针变量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p = &amp;c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">    c = <span class="number">666</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">    *p = <span class="number">777</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">    <span class="type">int</span> d = <span class="number">888</span>;</span><br><span class="line">    p = &amp;d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    test3();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C 语言基础</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程——函数式编程术语</title>
    <url>/2024/07/23/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<!-- # 函数式编程术语 -->
<blockquote>
<p>译者注：本项目译自 <a
href="https://github.com/hemanth/functional-programming-jargon">functional-programing-jargon</a>，专业术语居多，如有错误，可以提
pr 更正。除了术语翻译，针对每项术语，也有代码示例，位于 /demos
目录下。另外，这里也有几份不错的文章和仓库。 + <a
href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html">函数式编程入门教程</a>
+ <a
href="https://github.com/MostlyAdequate/mostly-adequate-guide">mostly-adequate-guide
(10749 stars)</a> + <a
href="https://github.com/llh911001/mostly-adequate-guide-chinese">mostly-adequate-guide-chinese
(602 stars)</a> + <a
href="https://github.com/fantasyland/fantasy-land">fantasy-land</a></p>
</blockquote>
<p>函数式编程有许多优势，由此越来越受欢迎。然而每个编程范式 (paradigm)
都有自己唯一的术语，函数式编程也不例外。我们提供一张术语表，希望使你学习函数式编程变得容易些。</p>
<p>示例均为 javascript (ES2015)。<a
href="https://github.com/hemanth/functional-programming-jargon/wiki/Why-JavaScript%3F">为什么使用JavaScript?</a></p>
<p><em>尚在 WIP 阶段，欢迎 pr。</em></p>
<p>如果适用，本篇文档使用定义在 <a
href="https://github.com/fantasyland/fantasy-land">Fantasy Land spec</a>
中的术语。</p>
<p><strong>目录</strong></p>
<ul>
<li><a href="#arity">Arity</a></li>
<li><a href="#高阶函数-higher-order-function--hof">高阶函数
(Higher-Order Function / HOF)</a></li>
<li><a href="#闭包-closure">闭包 (Closure)</a></li>
<li><a href="#偏函数应用-partial-application">偏函数应用 (Partial
Application)</a></li>
<li><a href="#柯里化-currying">柯里化 (Currying)</a></li>
<li><a href="#自动柯里化-auto-currying">自动柯里化 (Auto Currying)</a>
<ul>
<li><a href="#进一步阅读">进一步阅读</a></li>
</ul></li>
<li><a href="#函数组合-function-composition">函数组合 (Function
Composition)</a></li>
<li><a href="#continuation-后续">Continuation (后续)</a></li>
<li><a href="#纯函数-purity">纯函数 (Purity)</a></li>
<li><a href="#副作用-side-effects">副作用 (Side effects)</a></li>
<li><a href="#幂等-idempotent">幂等 (Idempotent)</a></li>
<li><a href="#point-free-风格-point-free-style">Point-Free 风格
(Point-Free Style)</a></li>
<li><a href="#断定-predicate">断定 (Predicate)</a></li>
<li><a href="#契约-contracts">契约 (Contracts)</a></li>
<li><a href="#范畴-category">范畴 (Category)</a>
<ul>
<li><a href="#进一步阅读-1">进一步阅读</a></li>
</ul></li>
<li><a href="#值-value">值 (Value)</a></li>
<li><a href="#常量-constant">常量 (Constant)</a></li>
<li><a href="#函子-functor">函子 (Functor)</a>
<ul>
<li><a href="#一致性-preserves-identity">一致性 (Preserves
identity)</a></li>
<li><a href="#组合性-composable">组合性 (Composable)</a></li>
<li><a href="#指向函子-pointed-functor">指向函子 (Pointed
Functor)</a></li>
</ul></li>
<li><a href="#抬升-lift">抬升 (Lift)</a></li>
<li><a href="#引用透明性-referential-transparency">引用透明性
(Referential Transparency)</a></li>
<li><a href="#等式推理-equational-reasoning">等式推理 (Equational
Reasoning)</a></li>
<li><a href="#lambda">Lambda</a></li>
<li><a href="#lambda演算-lambda-calculus">Lambda演算 (Lambda
Calculus)</a></li>
<li><a href="#惰性求值-lazy-evaluation">惰性求值 (Lazy
evaluation)</a></li>
<li><a href="#幺半群-monoid">幺半群 (Monoid)</a></li>
<li><a href="#单子-monad">单子 (Monad)</a></li>
<li><a href="#余单子-comonad">余单子 (Comonad)</a></li>
<li><a href="#应用函子-applicative-functor">应用函子 (Applicative
Functor)</a></li>
<li><a href="#态射-morphism">态射 (Morphism)</a>
<ul>
<li><a href="#endomorphism-自同态">Endomorphism (自同态)</a></li>
<li><a href="#isomorphism-同构">Isomorphism (同构)</a></li>
<li><a href="#homomorphism-同态">Homomorphism (同态)</a></li>
<li><a href="#catamorphism">Catamorphism</a></li>
<li><a href="#anamorphism">Anamorphism</a></li>
<li><a href="#hylomorphism">Hylomorphism</a></li>
<li><a href="#paramorphism">Paramorphism</a></li>
<li><a href="#apomorphism">Apomorphism</a></li>
</ul></li>
<li><a href="#setoid">Setoid</a></li>
<li><a href="#半群-semigroup">半群 (Semigroup)</a></li>
<li><a href="#可折叠性-foldable">可折叠性 (Foldable)</a></li>
<li><a href="#透镜-lens">透镜 (Lens)</a></li>
<li><a href="#类型签名-type-signatures">类型签名 (Type
Signatures)</a></li>
<li><a href="#代数数据类型-algebraic-data-type">代数数据类型 (Algebraic
data type)</a>
<ul>
<li><a href="#和类型-sum-type">和类型 (Sum type)</a></li>
<li><a href="#product-type">Product type</a></li>
</ul></li>
<li><a href="#可选类型-option">可选类型 (Option)</a></li>
<li><a href="#function">Function</a></li>
<li><a href="#偏函数-partial-function">偏函数 (Partial function)</a>
<ul>
<li><a href="#处理偏函数">处理偏函数</a></li>
</ul></li>
<li><a href="#在-js-中的函数式编程库">在 js 中的函数式编程库</a></li>
</ul>
<div id="arity">

</div>
<h2 id="arity">Arity</h2>
<p>函数参数的个数。来自于单词 unary(一元), binary(二元), ternary(三元)
等等。这个单词是由 -ary 与 -ity
两个后缀拼接而成。例如，加法函数有两个参数，因此它被定义为二元函数(<code>binary function</code>)，或者说它的
<code>arity</code> 是2。它也被那些更喜欢希腊词根而非拉丁词根的人称为
<code>dyadic</code>。同样地，带有可变数量的参数的函数被称为
<code>variadic</code>，而二元函数只能且必须带两个参数，尽管有柯里化(currying)和偏函数应用(partial
application)的存在(见下文)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">a, b</span>) =&gt; a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arity = sum.<span class="property">length</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arity)        <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数sum的arity为2。</span></span><br></pre></td></tr></table></figure>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/arity.js">示例</a></p>
<div id="higher-order-functions-hof">

</div>
<h2 id="高阶函数-higher-order-function-hof">高阶函数 (Higher-Order
Function / HOF)</h2>
<p>以函数为参数或/和返回值的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">filter</span> = (<span class="params">predicate, xs</span>) =&gt; xs.<span class="title function_">filter</span>(predicate)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">is</span> = (<span class="params">type</span>) =&gt; <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="title class_">Object</span>(x) <span class="keyword">instanceof</span> type</span><br><span class="line"></span><br><span class="line"><span class="title function_">filter</span>(<span class="title function_">is</span>(<span class="title class_">Number</span>), [<span class="number">0</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">2</span>, <span class="literal">null</span>]) <span class="comment">// 0, 2</span></span><br></pre></td></tr></table></figure>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/hoc.js">示例</a></p>
<div id="closure">

</div>
<h2 id="闭包-closure">闭包 (Closure)</h2>
<p>闭包是访问在其作用域外的变量的一种方式。正式地说，闭包是一种用于实现词法作用域命名绑定的技术。它是存储一个函数和它的环境的一种方法。</p>
<p>闭包是一个作用域，它会捕获函数的局部变量，因此即使执行过程已经移出了定义它的那个代码块，也可以访问它们。也就是说，它们允许在声明变量的代码块已经执行完成之后，还是可以引用这个作用域。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">addTo</span> = x =&gt; <span class="function"><span class="params">y</span> =&gt;</span> x + y;</span><br><span class="line"><span class="keyword">var</span> addToFive = <span class="title function_">addTo</span>(<span class="number">5</span>);</span><br><span class="line"><span class="title function_">addToFive</span>(<span class="number">3</span>); <span class="comment">//返回 8</span></span><br></pre></td></tr></table></figure>
<p>函数<code>addTo()</code>返回了一个函数(在内部调用了<code>add()</code>)，我们将它保存在了一个叫做<code>addToFive</code>的变量中，并且柯里化地用一个参数5来调用它。</p>
<p>理想情况下，当函数<code>addTo</code>执行完成后，它的作用域，包括本地变量add(即+)，x，y，都应该无法访问了。但是，<code>addToFive()</code>的调用返回了8。这说明，<code>addTo</code>函数的状态被保存了，即使在代码块已经完成执行之后。否则，就不会知道<code>addTo</code>曾经被<code>addTo(5)</code>这样调用过，且x的值被设为了5。</p>
<p>词法作用域(lexical
scoping)是它能找到x和add这两个已经完成执行的父级私有变量的原因。这个值就称为闭包。</p>
<p>栈和函数的词法作用域被以父函数的引用的形式存储。这可以防止闭包和底层的变量被垃圾回收(因为至少有一个对它的有效引用)。</p>
<p>Lambda Vs
闭包：Lambda本质上是一个内联定义的函数，而不是声明函数的标准方法。Lambda经常可以作为对象被传递。</p>
<p>闭包是通过引用其主体外部的字段来将其周围的状态包裹进来的函数。被包裹的状态在闭包调用期间保持不变。</p>
<div id="partial-application">

</div>
<h2 id="偏函数应用-partial-application">偏函数应用 (Partial
Application)</h2>
<p>"部分地"应用一个函数，即预设原始函数的部分参数来创建一个新的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建偏函数，固定一些参数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">partial</span> = (<span class="params">f, ...args</span>) =&gt;</span><br><span class="line">  <span class="comment">// 返回一个带有剩余参数的函数</span></span><br><span class="line">  <span class="function">(<span class="params">...moreArgs</span>) =&gt;</span></span><br><span class="line">    <span class="comment">// 调用原始函数</span></span><br><span class="line">    <span class="title function_">f</span>(...args, ...moreArgs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add3</span> = (<span class="params">a, b, c</span>) =&gt; a + b + c <span class="comment">// (c) =&gt; 2 + 3 + c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分地将`2`和`3`应用于`add3`，得到一个只有一个参数的函数</span></span><br><span class="line"><span class="keyword">const</span> fivePlus = <span class="title function_">partial</span>(add3, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">fivePlus</span>(<span class="number">4</span>)  <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>Function.prototype.bind</code> 实现偏函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add1More = add3.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// (c) =&gt; 2 + 3 + c</span></span><br></pre></td></tr></table></figure>
<p>偏函数应用通过对复杂的函数填充一部分数据来构成一个简单的函数。柯里化就是自动实现的偏函数。</p>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/partial.js">示例</a></p>
<div id="currying">

</div>
<h2 id="柯里化-currying">柯里化 (Currying)</h2>
<p>将一个多元函数转变为一元函数的过程。
每当函数被调用时，它仅仅接收一个参数并且返回带有一个参数的函数，直到传递完所有的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">a, b</span>) =&gt; a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">curriedSum</span> = (<span class="params">a</span>) =&gt; <span class="function">(<span class="params">b</span>) =&gt;</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="title function_">curriedSum</span>(<span class="number">3</span>)(<span class="number">4</span>)         <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add2 = <span class="title function_">curriedSum</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">add2</span>(<span class="number">10</span>)     <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/curry.js">示例</a></p>
<div id="auto-currying">

</div>
<h2 id="自动柯里化-auto-currying">自动柯里化 (Auto Currying)</h2>
<p>将一个包含多个参数的函数转换成另一个函数，这个函数如果被给到的参数少于正确的数量，就会返回一个接受剩余参数的函数。</p>
<p>lodash &amp; Ramda 有一个<code>curry</code>函数可以做到这一点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">x, y</span>) =&gt; x + y</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> curriedAdd = _.<span class="title function_">curry</span>(add)</span><br><span class="line"></span><br><span class="line"><span class="title function_">curriedAdd</span>(<span class="number">1</span>, <span class="number">2</span>)   <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">curriedAdd</span>(<span class="number">1</span>)(<span class="number">2</span>)   <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">curriedAdd</span>(<span class="number">1</span>)      <span class="comment">// (y) =&gt; 1 + y</span></span><br></pre></td></tr></table></figure>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/curry2.js">示例</a></p>
<h4 id="进一步阅读">进一步阅读</h4>
<ul>
<li><a href="http://fr.umio.us/favoring-curry/">Favoring Curry</a></li>
<li><a href="https://www.youtube.com/watch?v=m3svKOdZijA">Hey
Underscore, You're Doing It Wrong!</a></li>
</ul>
<div id="function-composition">

</div>
<h2 id="函数组合-function-composition">函数组合 (Function
Composition)</h2>
<p>把两个函数放在一起形成第三个函数的行为，一个函数的输入为另一个函数的输出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">compose</span> = (<span class="params">f, g</span>) =&gt; <span class="function">(<span class="params">a</span>) =&gt;</span> <span class="title function_">f</span>(<span class="title function_">g</span>(a))    <span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">const</span> floorAndToString = <span class="title function_">compose</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> val.<span class="title function_">toString</span>(), <span class="title class_">Math</span>.<span class="property">floor</span>) <span class="comment">// 使用</span></span><br><span class="line"><span class="title function_">floorAndToString</span>(<span class="number">12.12</span>)   <span class="comment">// &#x27;12&#x27;</span></span><br></pre></td></tr></table></figure>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/compose.js">示例</a></p>
<div id="continuation">

</div>
<h2 id="continuation-后续">Continuation (后续)</h2>
<p>在一个程序执行的任意时刻，尚未执行的代码称为 Continuation。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">printAsString</span> = (<span class="params">num</span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Given <span class="subst">$&#123;num&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addOneAndContinue</span> = (<span class="params">num, cc</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> result = num + <span class="number">1</span></span><br><span class="line">  <span class="title function_">cc</span>(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addOneAndContinue</span>(<span class="number">2</span>, printAsString) <span class="comment">// &#x27;Given 3&#x27;</span></span><br></pre></td></tr></table></figure>
<p>Continuation
在异步编程中很常见，比如当程序需要接收到数据才能够继续执行。请求的响应通常作为代码的剩余执行部分，一旦接收到数据，对数据的处理被作为
Continuation。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">continueProgramWith</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 继续执行程序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">readFileAsync</span>(<span class="string">&#x27;path/to/file&#x27;</span>, <span class="function">(<span class="params">err, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">continueProgramWith</span>(response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<div id="purity">

</div>
<h2 id="纯函数-purity">纯函数 (Purity)</h2>
<p>输出仅由输入决定，且不产生副作用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">greet</span> = (<span class="params">name</span>) =&gt; <span class="string">`hello, <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&#x27;world&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>以下代码不是纯函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;Brianne&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">greet</span> = (<span class="params"></span>) =&gt; <span class="string">`Hi, <span class="subst">$&#123;<span class="variable language_">window</span>.name&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>() <span class="comment">// &quot;Hi, Brianne&quot;</span></span><br></pre></td></tr></table></figure>
<p>以上示例中，函数输出基于在函数外部存储的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">greet</span> = (<span class="params">name</span>) =&gt; &#123;</span><br><span class="line">    greeting = <span class="string">`Hi, <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&#x27;Brianne&#x27;</span>)</span><br><span class="line">greeting <span class="comment">// &quot;Hi, Brianne&quot;</span></span><br></pre></td></tr></table></figure>
<p>以上示例中，函数修改了外部状态。</p>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/purity.js">示例</a></p>
<div id="side-effects">

</div>
<h2 id="副作用-side-effects">副作用 (Side effects)</h2>
<p>如果一个函数或者表达式除了返回一个值之外，还与外部可变状态进行了交互（读取或写入），则它是有副作用的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> differentEveryTime = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;IO就是一种副作用!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/sideEffect.js">示例</a></p>
<div id="idempotent">

</div>
<h2 id="幂等-idempotent">幂等 (Idempotent)</h2>
<p>如果一个函数执行多次皆返回相同的结果，则它是幂等的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">f</span>(<span class="title function_">f</span>(x)) ≍ <span class="title function_">f</span>(x)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">sort</span>(<span class="title function_">sort</span>(<span class="title function_">sort</span>([<span class="number">2</span>, <span class="number">1</span>])))</span><br></pre></td></tr></table></figure>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/idempotent.js">示例</a></p>
<div id="point-free-style">

</div>
<h2 id="point-free-风格-point-free-style">Point-Free 风格 (Point-Free
Style)</h2>
<p>定义函数时，不显式地指出函数所带参数。这种风格通常需要柯里化或者高阶函数。也叫
Tacit programming。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 已知：</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">map</span> = (<span class="params">fn</span>) =&gt; <span class="function">(<span class="params">list</span>) =&gt;</span> list.<span class="title function_">map</span>(fn)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a</span>) =&gt; <span class="function">(<span class="params">b</span>) =&gt;</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非Points-Free —— number 是显式参数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">incrementAll</span> = (<span class="params">numbers</span>) =&gt; <span class="title function_">map</span>(<span class="title function_">add</span>(<span class="number">1</span>))(numbers)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Points-Free —— list 是隐式参数</span></span><br><span class="line"><span class="keyword">const</span> incrementAll2 = <span class="title function_">map</span>(<span class="title function_">add</span>(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p><code>incrementAll</code> 识别并且使用了 <code>numbers</code>
参数，因此它不是 Point-Free 风格的。 <code>incrementAll2</code>
仅连接函数与值，并不提及它所使用的参数，因为它是 Point-Free 风格的。</p>
<p>Point-Free 风格的函数就像平常的赋值，不使用 <code>function</code>
或者 <code>=&gt;</code>。</p>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/pointFree.js">示例</a></p>
<div id="predicate">

</div>
<h2 id="断定-predicate">断定 (Predicate)</h2>
<p>根据输入返回 true 或 false。通常用在 array filter 的回调函数中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">predicate</span> = (<span class="params">a</span>) =&gt; a &gt; <span class="number">2</span></span><br><span class="line"></span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].<span class="title function_">filter</span>(predicate)</span><br></pre></td></tr></table></figure>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/predicate.js">示例</a></p>
<div id="contracts">

</div>
<h2 id="契约-contracts">契约 (Contracts)</h2>
<p>契约规定了函数或表达式在运行时的行为的职责和保障。它表现为一组规则，这些规则是对函数或表达式的输入和输出的期望。当违反契约时，将抛出一个错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义的contract: int -&gt; boolean</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">contract</span> = (<span class="params">input</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> input === <span class="string">&#x27;number&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Contract Violated: expected int -&gt; int&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addOne</span> = (<span class="params">num</span>) =&gt; <span class="title function_">contract</span>(num) &amp;&amp; num + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">addOne</span>(<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">addOne</span>(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// 违反了contract: int -&gt; boolean</span></span><br></pre></td></tr></table></figure>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/contracts.js">示例</a></p>
<div id="category">

</div>
<h2 id="范畴-category">范畴 (Category)</h2>
<p>在范畴论中，范畴是指对象集合及它们之间的态射
(morphism)。在编程中，数据类型作为对象，函数作为态射。</p>
<p>一个有效的范畴遵从以下三个原则：</p>
<ol type="1">
<li>必有一个同一态射（identity morphism）将一个对象映射到它自身。即当
<code>a</code> 是范畴里的一个对象时，必有一个函数使
<code>a -&gt; a</code>。</li>
<li>态射必是可组合的。<code>a</code>，<code>b</code>，<code>c</code>
是范畴里的对象，<code>f</code> 是态射
<code>a -&gt; b</code>，<code>g</code> 是 <code>b -&gt; c</code>
态射。<code>g(f(x))</code> 一定与 <code>(g • f)(x)</code>
是等价的。</li>
<li>组合满足结合律。<code>f • (g • h)</code> 与 <code>(f • g) • h</code>
是等价的。</li>
</ol>
<p>由于这些准则是在非常抽象的层面控制着组合方式，因此范畴论对于发现组合的新方法来说是伟大的。</p>
<h4 id="进一步阅读-1">进一步阅读</h4>
<ul>
<li><a
href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">Category
Theory for Programmers</a></li>
</ul>
<div id="value">

</div>
<h2 id="值-value">值 (Value)</h2>
<p>任何可以赋给变量的东西叫做值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;)</span><br><span class="line">;<span class="function">(<span class="params">a</span>) =&gt;</span> a</span><br><span class="line">;[<span class="number">1</span>]</span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/value.js">示例</a></p>
<div id="constant">

</div>
<h2 id="常量-constant">常量 (Constant)</h2>
<p>一旦被定义之后就不可以被重新赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> five = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> john = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>常量是<a
href="#referential-transparency">引用透明</a>的，也就是说，它们可以被它们所代表的值替代而不影响结果。</p>
<p>对于以上两个常量，以下语句总会返回 true。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">john.<span class="property">age</span> + five === (&#123;<span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;).<span class="property">age</span> + (<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/constant.js">示例</a></p>
<div id="functor">

</div>
<h2 id="函子-functor">函子 (Functor)</h2>
<p>函子是一个实现了 <code>map</code> 函数的对象。<code>map</code>
函数会遍历对象中的每个值并生成一个新的对象，遵守两个准则:</p>
<div id="preserves-identity">

</div>
<h3 id="一致性-preserves-identity">一致性 (Preserves identity)</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">object.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x) ≍ object</span><br></pre></td></tr></table></figure>
<div id="composable">

</div>
<h3 id="组合性-composable">组合性 (Composable)</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">object.<span class="title function_">map</span>(<span class="title function_">compose</span>(f, g)) ≍ object.<span class="title function_">map</span>(g).<span class="title function_">map</span>(f)  <span class="comment">// f, g 为任意函数</span></span><br></pre></td></tr></table></figure>
<p>(<code>f</code>, <code>g</code> 是任意的函数)</p>
<p>在 javascript 中一个常见的函子是 Array,
因为它遵守因子的两个准则。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = x =&gt; x + <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">g</span> = x =&gt; x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="title function_">f</span>(<span class="title function_">g</span>(x)))</span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(g).<span class="title function_">map</span>(f)</span><br></pre></td></tr></table></figure>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/functor.js">示例</a></p>
<div id="pointed-functor">

</div>
<h3 id="指向函子-pointed-functor">指向函子 (Pointed Functor)</h3>
<p>一个对象，拥有一个<code>of</code>函数，可以将一个任何值放入它自身。</p>
<p>ES2015 添加了 <code>Array.of</code>，使 Array 成为了 Pointed
Functor。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<div id="lift">

</div>
<h2 id="抬升-lift">抬升 (Lift)</h2>
<p>抬升是指将一个值放进一个对象（如<a
href="#functor">函子</a>）中。如果你将一个函数抬升到一个<a
href="#applicative-functor">应用函子</a>中，那么就可以将它作用于该函子中的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">liftA2</span> = (<span class="params">f</span>) =&gt; <span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="title function_">map</span>(f).<span class="title function_">ap</span>(b) <span class="comment">// 注意这里是 ap 而不是 map.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mult</span> = a =&gt; <span class="function"><span class="params">b</span> =&gt;</span> a * b</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> liftedMult = <span class="title function_">liftA2</span>(mult) <span class="comment">// 这个函数现在可以作用于函子，如Array</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">liftedMult</span>([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>]) <span class="comment">// [3, 6]</span></span><br><span class="line"><span class="title function_">liftA2</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="function"><span class="params">b</span> =&gt;</span> a + b)([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]) <span class="comment">// [4, 5, 5, 6]</span></span><br></pre></td></tr></table></figure>
<p>抬升并应用一个单参数的函数的作用等同于 <code>map</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params">x</span>) =&gt; x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">lift</span>(increment)([<span class="number">2</span>]) <span class="comment">// [3]</span></span><br><span class="line">;[<span class="number">2</span>].<span class="title function_">map</span>(increment) <span class="comment">// [3]</span></span><br></pre></td></tr></table></figure>
<div id="referential-transparency">

</div>
<h2 id="引用透明性-referential-transparency">引用透明性 (Referential
Transparency)</h2>
<p>如果一个表达式能够被它的值替代而不改变程序的行为，则它是引用透明的。</p>
<p>例如我们有 greet 函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">greet</span> = (<span class="params"></span>) =&gt; <span class="string">&#x27;hello, world.&#x27;</span></span><br></pre></td></tr></table></figure>
<p>任何对 <code>greet()</code> 的调用都可以被替换为
<code>Hello World!</code>, 因此 greet 是引用透明的。</p>
<div id="equational-reasoning">

</div>
<h2 id="等式推理-equational-reasoning">等式推理 (Equational
Reasoning)</h2>
<p>当一个应用程序由表达式组成并且没有副作用时，我们可以从这些组成部分中得知系统的真相。</p>
<div id="lambda">

</div>
<h2 id="lambda">Lambda</h2>
<p>一种可以被视作一个值的匿名函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;(<span class="keyword">function</span> (<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">;<span class="function">(<span class="params">a</span>) =&gt;</span> a + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>Lambda 通常作为参数被传递给高阶函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">a</span>) =&gt;</span> a + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>可以把 Lambda 赋值给一个变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add1</span> = (<span class="params">a</span>) =&gt; a + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<div id="lambda-calculus">

</div>
<h2 id="lambda演算-lambda-calculus">Lambda演算 (Lambda Calculus)</h2>
<p>数学的一个分支，使用函数创造 <a
href="https://en.wikipedia.org/wiki/Lambda_calculus">通用计算模型</a></p>
<div id="lazy-evaluation">

</div>
<h2 id="惰性求值-lazy-evaluation">惰性求值 (Lazy evaluation)</h2>
<p>惰性求值是一种按需调用的求值机制，它将表达式的求值延迟到需要它的值为止，在函数式语言中，允许类似无限列表这样的结构存在，而这在非常重视命令顺序的命令式语言中通常是不可用的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> rand = <span class="keyword">function</span>* () &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title class_">Math</span>.<span class="title function_">random</span>()  </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> randIter = <span class="title function_">rand</span>()</span><br><span class="line">randIter.<span class="title function_">next</span>() <span class="comment">// 每次执行产生一个随机值，表达式会在需要时求值。</span></span><br></pre></td></tr></table></figure>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/functor.js">示例</a></p>
<div id="monoid">

</div>
<h2 id="幺半群-monoid">幺半群 (Monoid)</h2>
<p>一个对象，它拥有一个函数，这个函数用来与另一个相同类型的对象"结合"。对象的类型（<a
href="#semigroup">半群</a>）必须具有一个"identity"值。</p>
<p>数值加法是一个简单的幺半群:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">1</span>   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>以上示例中，数是对象而 <code>+</code> 是函数。</p>
<p>当任何一个值与"identity"值结合时，结果一定是原始的值。"identity"也是可换位的（即排列次序不影响结果）。</p>
<p>加法的特征值是 0。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">0</span>   <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>操作的组合不会影响结果（必须满足结合律）:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + (<span class="number">2</span> + <span class="number">3</span>) === (<span class="number">1</span> + <span class="number">2</span>) + <span class="number">3</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>数组的结合也是幺半群:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;[<span class="number">1</span>, <span class="number">2</span>].<span class="title function_">concat</span>([<span class="number">3</span>, <span class="number">4</span>]) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p><code>identity</code> 值为空数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;[<span class="number">1</span>, <span class="number">2</span>].<span class="title function_">concat</span>([])</span><br></pre></td></tr></table></figure>
<p>减法作为一个反例，不形成幺半群，因为不存在可以换位的"identity"值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> - <span class="number">4</span> === <span class="number">4</span> - <span class="number">0</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/monoid.js">示例</a></p>
<div id="monad">

</div>
<h2 id="单子-monad">单子 (Monad)</h2>
<p>拥有 <code>of</code> 和 <code>chain</code>
函数的对象即为单子。<code>chain</code> 很像 <code>map</code>，
不同的是它可以展平嵌套数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">chain</span> = <span class="keyword">function</span> (<span class="params">f</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, it</span>) =&gt;</span> acc.<span class="title function_">concat</span>(<span class="title function_">f</span>(it)), [])  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">;<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="string">&#x27;cat,dog&#x27;</span>, <span class="string">&#x27;fish,bird&#x27;</span>).<span class="title function_">chain</span>(<span class="function"><span class="params">s</span> =&gt;</span> s.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)) <span class="comment">// [&#x27;cat&#x27;, &#x27;dog&#x27;, &#x27;fish&#x27;, &#x27;bird&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 和 map 相比</span></span><br><span class="line">;<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="string">&#x27;cat,dog&#x27;</span>, <span class="string">&#x27;fish,bird&#x27;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">s</span> =&gt;</span> s.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>)) <span class="comment">// [[&#x27;cat&#x27;, &#x27;dog&#x27;], [&#x27;fish&#x27;, &#x27;bird&#x27;]]</span></span><br></pre></td></tr></table></figure>
<p>在有些函数式语言中，<code>of</code> 也称为
<code>return</code>，<code>chain</code> 也称为 <code>flatmap</code> 与
<code>bind</code>。</p>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/monad.js">示例</a></p>
<div id="comonad">

</div>
<h2 id="余单子-comonad">余单子 (Comonad)</h2>
<p>拥有 <code>extract</code> 与 <code>extend</code> 函数的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">CoIdentity</span> = (<span class="params">v</span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">val</span>: v,</span><br><span class="line">  extract () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">val</span>  </span><br><span class="line">  &#125;,</span><br><span class="line">  extend (f) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">CoIdentity</span>(<span class="title function_">f</span>(<span class="variable language_">this</span>))  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Extract 将值从余单子中取出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">CoIdentity</span>(<span class="number">1</span>).<span class="title function_">extract</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>Extends
在余单子上运行一个函数。这个函数会返回和余单子相同的类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">CoIdentity</span>(<span class="number">1</span>).<span class="title function_">extend</span>(<span class="function"><span class="params">x</span> =&gt;</span> x.<span class="title function_">extract</span>() + <span class="number">1</span>) <span class="comment">// CoIdentity(2)</span></span><br></pre></td></tr></table></figure>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/comonad.js">示例</a></p>
<div id="applicative-functor">

</div>
<h2 id="应用函子-applicative-functor">应用函子 (Applicative
Functor)</h2>
<p>一个拥有 <code>ap</code> 函数的对象称为应用函子。<code>ap</code>
将对象中的函数应用于另一个同样类型的对象中的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">ap</span> = <span class="keyword">function</span> (<span class="params">xs</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, f</span>) =&gt;</span> acc.<span class="title function_">concat</span>(xs.<span class="title function_">map</span>(f)), [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">;[<span class="function">(<span class="params">a</span>) =&gt;</span> a + <span class="number">1</span>].<span class="title function_">ap</span>([<span class="number">1</span>]) <span class="comment">// [2]</span></span><br></pre></td></tr></table></figure>
<p>如果你有两个对象，并需要对他们的元素执行一个二元函数，这将会很有用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 你想要组合的两个数组</span></span><br><span class="line"><span class="keyword">const</span> arg1 = [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> arg2 = [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合函数 - 必须要柯里化</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">x</span>) =&gt; <span class="function">(<span class="params">y</span>) =&gt;</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> partiallyAppliedAdds = [add].<span class="title function_">ap</span>(arg1) <span class="comment">// [(y) =&gt; 1 + y, (y) =&gt; 3 + y]</span></span><br></pre></td></tr></table></figure>
<p>由此得到了一个函数数组，并且可以调用 <code>ap</code>
函数得到结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">partiallyAppliedAdds.<span class="title function_">ap</span>(arg2) <span class="comment">// [5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/applicativeFunctor.js">示例</a></p>
<div id="morphism">

</div>
<h2 id="态射-morphism">态射 (Morphism)</h2>
<p>一个变形函数。</p>
<div id="endomorphism">

</div>
<h3 id="endomorphism-自同态">Endomorphism (自同态)</h3>
<p>输入输出是相同类型的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// uppercase :: String -&gt; String</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">uppercase</span> = (<span class="params">str</span>) =&gt; str.<span class="title function_">toUpperCase</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// decrement :: Number -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params">x</span>) =&gt; x - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<div id="isomorphism">

</div>
<h3 id="isomorphism-同构">Isomorphism (同构)</h3>
<p>两个不用类型的对象之间的变换，保持结构并且不丢失数据。</p>
<p>例如，一个二维坐标既可以表示为数组
<code>[2, 3]</code>，也可以表示为对象 <code>&#123;x: 2, y: 3&#125;</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提供函数在两种类型间互相转换</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">pairToCoords</span> = (<span class="params">pair</span>) =&gt; (&#123;<span class="attr">x</span>: pair[<span class="number">0</span>], <span class="attr">y</span>: pair[<span class="number">1</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">coordsToPair</span> = (<span class="params">coords</span>) =&gt; [coords.<span class="property">x</span>, coords.<span class="property">y</span>]</span><br><span class="line"></span><br><span class="line"><span class="title function_">coordsToPair</span>(<span class="title function_">pairToCoords</span>([<span class="number">1</span>, <span class="number">2</span>])) <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">pairToCoords</span>(<span class="title function_">coordsToPair</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;)) <span class="comment">// &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure>
<div id="homomorphism">

</div>
<h3 id="homomorphism-同态">Homomorphism (同态)</h3>
<p>同态只是一个保持结构的映射，实际上，函子只是<a
href="#category">范畴</a>之间的同态，因为它在映射下保持了原范畴的结构。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">A.<span class="title function_">of</span>(f).<span class="title function_">ap</span>(A.<span class="title function_">of</span>(x)) == A.<span class="title function_">of</span>(<span class="title function_">f</span>(x))</span><br><span class="line"></span><br><span class="line"><span class="title class_">Either</span>.<span class="title function_">of</span>(_.<span class="property">toUpper</span>).<span class="title function_">ap</span>(<span class="title class_">Either</span>.<span class="title function_">of</span>(<span class="string">&quot;oreos&quot;</span>)) == <span class="title class_">Either</span>.<span class="title function_">of</span>(_.<span class="title function_">toUpper</span>(<span class="string">&quot;oreos&quot;</span>))</span><br></pre></td></tr></table></figure>
<div id="catamorphism">

</div>
<h3 id="catamorphism">Catamorphism</h3>
<p>一个 <code>reduceRight</code>
函数，它应用于累加器(accumulator)和数组中的每个值（从右到左），来将其缩减为一个单一的值。</p>
<div id="anamorphism">

</div>
<h3 id="anamorphism">Anamorphism</h3>
<p>一个 <code>unfold</code> 函数。<code>unfold</code> 是
<code>fold</code>（<code>ruduce</code>）的反面。它从一个值生成一个列表。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">unfold</span> = (<span class="params">f, seed</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">go</span>(<span class="params">f, seed, acc</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="title function_">f</span>(seed);</span><br><span class="line">    <span class="keyword">return</span> res ? <span class="title function_">go</span>(f, res[<span class="number">1</span>], acc.<span class="title function_">concat</span>([res[<span class="number">0</span>]])) : acc;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">go</span>(f, seed, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">countDown</span> = n =&gt; <span class="title function_">unfold</span>(<span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> n &lt;= <span class="number">0</span> ? <span class="literal">undefined</span> : [n, n - <span class="number">1</span>]</span><br><span class="line">&#125;, n)</span><br><span class="line"></span><br><span class="line"><span class="title function_">countDown</span>(<span class="number">5</span>) <span class="comment">// [5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure>
<div id="hylomorphism">

</div>
<h3 id="hylomorphism">Hylomorphism</h3>
<p>Anamorphism 和 catamorphism 的结合。</p>
<div id="paramorphism">

</div>
<h3 id="paramorphism">Paramorphism</h3>
<p>一类类似于 <code>reduceRight</code> 的函数，不过还是有区别的：</p>
<p>在Paramorphism中，reducer的参数是当前的值、所有先前的值的缩减(reduction，即reduce的结果)、以及形成该缩减的值的列表。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包含 undefined 对于列表来说显然是不安全的，</span></span><br><span class="line"><span class="comment">// 但是足以说明问题。</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">para</span> = (<span class="params">reducer, accumulator, elements</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (elements.<span class="property">length</span> === <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> accumulator</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> head = elements[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> tail = elements.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">reducer</span>(head, tail, <span class="title function_">para</span>(reducer, accumulator, tail))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">suffixes</span> = list =&gt; <span class="title function_">para</span>(</span><br><span class="line">  <span class="function">(<span class="params">x, xs, suffxs</span>) =&gt;</span> [xs, ... suffxs],</span><br><span class="line">  [],</span><br><span class="line">  list</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="title function_">suffixes</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) <span class="comment">// [[2, 3, 4, 5], [3, 4, 5], [4, 5], [5], []]</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中的
reducer（<code>[x, ... xs]</code>）的第三个参数有点像一个"如何达到你当前的
acc 值"的历史记录。</p>
<div id="apomorphism">

</div>
<h3 id="apomorphism">Apomorphism</h3>
<p>paramorphism 的反面。就像 anamorphism 是 catamorphism
的反面一样。对于
paramorphism，我们结合了对累加器的访问和已经累加的东西，而apomorphism让我们可以
unfold（展开）并且具有提早return的可能性。</p>
<div id="setoid">

</div>
<h2 id="setoid">Setoid</h2>
<p>拥有 <code>equals</code> 函数的对象。<code>equals</code>
可以用来和其它相同类型的对象比较。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">equals</span> = <span class="keyword">function</span> (<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> len = <span class="variable language_">this</span>.<span class="property">length</span></span><br><span class="line">  <span class="keyword">if</span> (len !== arr.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>[i] !== arr[i]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>].<span class="title function_">equals</span>([<span class="number">1</span>, <span class="number">2</span>])   <span class="comment">// true</span></span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>].<span class="title function_">equals</span>([<span class="number">3</span>, <span class="number">4</span>])   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/setoid.js">示例</a></p>
<div id="semigroup">

</div>
<h2 id="半群-semigroup">半群 (Semigroup)</h2>
<p>一个拥有 <code>concat</code> 函数的对象。<code>concat</code>
可以连接相同类型的两个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;[<span class="number">1</span>].<span class="title function_">concat</span>([<span class="number">2</span>]) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/semigroup.js">示例</a></p>
<div id="foldable">

</div>
<h2 id="可折叠性-foldable">可折叠性 (Foldable)</h2>
<p>一个拥有 <code>reduce</code>
函数的对象具有可折叠性。<code>reduce</code>
可以把一种类型的对象转化为另一种类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">list</span>) =&gt; list.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc + val, <span class="number">0</span>)</span><br><span class="line"><span class="title function_">sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])        <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<div id="lens">

</div>
<h2 id="透镜-lens">透镜 (Lens)</h2>
<p>Lens是一种结构（通常是一个对象或者函数），他为其他数据结构对 getter
和非可变的 setter 进行配对。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 [Ramda&#x27;s lens](http://ramdajs.com/docs/#lens)</span></span><br><span class="line"><span class="keyword">const</span> nameLens = R.<span class="title function_">lens</span>(</span><br><span class="line">  <span class="comment">// 一个对象的 name 属性的 getter</span></span><br><span class="line">  <span class="function">(<span class="params">obj</span>) =&gt;</span> obj.<span class="property">name</span>,</span><br><span class="line">  <span class="comment">// name 属性的 setter</span></span><br><span class="line">  <span class="function">(<span class="params">val, obj</span>) =&gt;</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj, &#123;<span class="attr">name</span>: val&#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>为给定的数据结构设置 <code>get</code> 和 <code>set</code>
可以实现一些关键特性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;Gertrude Blanch&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 getter</span></span><br><span class="line">R.<span class="title function_">view</span>(nameLens, person) <span class="comment">// &#x27;Gertrude Blanch&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 setter</span></span><br><span class="line">R.<span class="title function_">set</span>(nameLens, <span class="string">&#x27;Shafi Goldwasser&#x27;</span>, person) <span class="comment">// &#123;name: &#x27;Shafi Goldwasser&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将函数应用于结构中的值</span></span><br><span class="line">R.<span class="title function_">over</span>(nameLens, uppercase, person) <span class="comment">// &#123;name: &#x27;GERTRUDE BLANCH&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<p>lens
也是可以组合的。这让我们可以对深度嵌套的数据进行简单的不可变更新。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个 lens 关注一个非空数组中的第一个元素</span></span><br><span class="line"><span class="keyword">const</span> firstLens = R.<span class="title function_">lens</span>(</span><br><span class="line">  <span class="comment">// 获取数组的第一个元素</span></span><br><span class="line">  <span class="function"><span class="params">xs</span> =&gt;</span> xs[<span class="number">0</span>],</span><br><span class="line">  <span class="comment">// 数组的第一个元素的非可变 setter</span></span><br><span class="line">  <span class="function">(<span class="params">val, [__, ...xs]</span>) =&gt;</span> [val, ...xs]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> people = [&#123;<span class="attr">name</span>: <span class="string">&#x27;Gertrude Blanch&#x27;</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">&#x27;Shafi Goldwasser&#x27;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无论你怎么想，lens 是从左到右合成的</span></span><br><span class="line">R.<span class="title function_">over</span>(<span class="title function_">compose</span>(firstLens, nameLens), uppercase, people) <span class="comment">// [&#123;&#x27;name&#x27;: &#x27;GERTRUDE BLANCH&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;Shafi Goldwasser&#x27;&#125;]</span></span><br></pre></td></tr></table></figure>
<p>其他实现:</p>
<p><a
href="https://github.com/calmm-js/partial.lenses">partial.lenses</a> -
"好吃"的语法糖和很多强大功能</p>
<p><a href="http://www.kovach.me/nanoscope/">nanoscope</a> -
流畅接口</p>
<div id="type-signatures">

</div>
<h2 id="类型签名-type-signatures">类型签名 (Type Signatures)</h2>
<p>通常 js 中的函数会在注释中指出参数与返回值的类型。</p>
<p>在整个社区内存在很大的差异，但通常遵循以下模式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// functionName :: firstArgType -&gt; secondArgType -&gt; returnType</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add :: Number -&gt; Number -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">x</span>) =&gt; <span class="function">(<span class="params">y</span>) =&gt;</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment">// increment :: Number -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params">x</span>) =&gt; x + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果函数接受其他函数作为参数，那么这个函数需要用括号括起来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call :: (a -&gt; b) -&gt; a -&gt; b</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">call</span> = (<span class="params">f</span>) =&gt; <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="title function_">f</span>(x)</span><br></pre></td></tr></table></figure>
<p>字符 <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>
表明参数可以是任意类型。以下版本的 <code>map</code> 的函数类型的参数
<code>f</code>，把一种类型 <code>a</code> 的数组转化为另一种类型
<code>b</code> 的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map :: (a -&gt; b) -&gt; [a] -&gt; [b]</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">map</span> = (<span class="params">f</span>) =&gt; <span class="function">(<span class="params">list</span>) =&gt;</span> list.<span class="title function_">map</span>(f)</span><br></pre></td></tr></table></figure>
<p>进一步阅读：</p>
<ul>
<li><a
href="https://github.com/ramda/ramda/wiki/Type-Signatures">Ramda's type
signatures</a></li>
<li><a
href="https://stackoverflow.com/questions/399312/what-is-hindley-milner/399392#399392">What
is Hindley-Milner?</a> on Stack Overflow</li>
</ul>
<div id="algebraic-data-type">

</div>
<h2 id="代数数据类型-algebraic-data-type">代数数据类型 (Algebraic data
type)</h2>
<p>一种由其他类型组合而成的复合类型。两种常见的代数类型是<a
href="#sum-type">sum</a>和<a href="#product-type">product</a>。</p>
<div id="sum-type">

</div>
<h3 id="和类型-sum-type">和类型 (Sum type)</h3>
<p>和类型是将两种类型组合成另一种类型。之所以称为和，是因为结果类型的可能的值的数目是两种输入类型的值的数目的和。</p>
<p>js 中没有这种类型，但是我们可以用 set 来假装：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 想象这些不是 set，而是仅包含这些值的某种类型。</span></span><br><span class="line"><span class="keyword">const</span> bools = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="literal">true</span>, <span class="literal">false</span>])</span><br><span class="line"><span class="keyword">const</span> halfTrue = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;half-true&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 weakLogic 类型包含 bools 类型和 halfTrue 类型的和。</span></span><br><span class="line"><span class="keyword">const</span> weakLogicValues = <span class="keyword">new</span> <span class="title class_">Set</span>([...bools, ...halfTrue])</span><br></pre></td></tr></table></figure>
<p>和类型有时也称作联合类型（union type）、区分联合（discriminated
union）或标记联合（tagged unions）。</p>
<p>JS中有一些库可以帮助定义和使用联合类型。</p>
<p>流（flow）包括联合类型，而TypeScript具有提供相同能力的枚举（enum）。</p>
<div id="product-type">

</div>
<h3 id="product-type">Product type</h3>
<p>用一种你可能更熟悉的方式把数据类型联合起来:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// point :: (Number, Number) -&gt; &#123;x: Number, y: Number&#125;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">point</span> = (<span class="params">x, y</span>) =&gt; (&#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;)</span><br></pre></td></tr></table></figure>
<p>之所以称之为积，是因为数据结构的总的可能值是不同值的乘积。许多语言都有
tuple 类型，这是积类型的最简单形式。</p>
<p>另见 <a href="https://en.wikipedia.org/wiki/Set_theory">Set
theory</a></p>
<div id="option">

</div>
<h2 id="可选类型-option">可选类型 (Option)</h2>
<p>Option 是一种联合类型，它有两种情况，<code>Some</code> 或者
<code>None</code>。</p>
<p>Option对于一些可能不会返回值的组合函数非常有用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单的定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Some</span> = (<span class="params">v</span>) =&gt; (&#123;</span><br><span class="line">  <span class="attr">val</span>: v,</span><br><span class="line">  map (f) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Some</span>(<span class="title function_">f</span>(<span class="variable language_">this</span>.<span class="property">val</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">  chain (f) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">f</span>(<span class="variable language_">this</span>.<span class="property">val</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">None</span> = (<span class="params"></span>) =&gt; (&#123;</span><br><span class="line">  map (f) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;,</span><br><span class="line">  chain (f) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// maybeProp :: (String, &#123;a&#125;) -&gt; Option a</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">maybeProp</span> = (<span class="params">key, obj</span>) =&gt; <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;undefined&#x27;</span> ? <span class="title class_">None</span>() : <span class="title class_">Some</span>(obj[key])</span><br></pre></td></tr></table></figure>
<p>使用 <code>chain</code> 可以序列化返回 <code>Option</code>
的函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getItem :: Cart -&gt; Option CartItem</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getItem</span> = (<span class="params">cart</span>) =&gt; <span class="title function_">maybeProp</span>(<span class="string">&#x27;item&#x27;</span>, cart)</span><br><span class="line"></span><br><span class="line"><span class="comment">// getPrice :: Item -&gt; Option Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getPrice</span> = (<span class="params">item</span>) =&gt; <span class="title function_">maybeProp</span>(<span class="string">&#x27;price&#x27;</span>, item)</span><br><span class="line"></span><br><span class="line"><span class="comment">// getNestedPrice :: cart -&gt; Option a</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getNestedPrice</span> = (<span class="params">cart</span>) =&gt; <span class="title function_">getItem</span>(obj).<span class="title function_">chain</span>(getPrice)</span><br><span class="line"></span><br><span class="line"><span class="title function_">getNestedPrice</span>(&#123;&#125;) <span class="comment">// None()</span></span><br><span class="line"><span class="title function_">getNestedPrice</span>(&#123;<span class="attr">item</span>: &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;&#125;) <span class="comment">// None()</span></span><br><span class="line"><span class="title function_">getNestedPrice</span>(&#123;<span class="attr">item</span>: &#123;<span class="attr">price</span>: <span class="number">9.99</span>&#125;&#125;) <span class="comment">// Some(9.99)</span></span><br></pre></td></tr></table></figure>
<p>在其它的一些地方，<code>Option</code> 也称为
<code>Maybe</code>，<code>Some</code> 也称为
<code>Just</code>，<code>None</code> 也称为 <code>Nothing</code>。</p>
<p><a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/option.js">示例
option.js</a> <a
href="https://github.com/shfshanyue/fp-jargon-zh/blob/master/demos/maybe.js">示例
maybe.js</a></p>
<div id="function">

</div>
<h2 id="function">Function</h2>
<p>一个函数 <code>f :: A =&gt; B</code> 是一个表达式，通常称为 arrow
或者 lambda 表达式——只能有<strong>一个</strong>（这点是不可变的）的
<code>A</code> 类型参数和<strong>一个</strong> <code>B</code>
类型返回值。该返回值完全取决于参数，使函数独立于上下文，或者说<a
href="#referential-transparency">引用透明</a>。这里暗示的是一个函数不能产生任何隐藏的<a
href="#side-effects">副作用</a>——根据定义，函数总是<a
href="#purity">纯</a>的。这些属性使函数易于使用：它们是完全确定的，因此也是可以预测的。函数可以将代码作为数据进行处理，对行为进行抽象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// times2 :: Number -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">times2</span> = n =&gt; n * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(times2) <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>
<div id="partial-function">

</div>
<h2 id="偏函数-partial-function">偏函数 (Partial function)</h2>
<p>偏函数是没有为全部参数定义的函数——它可能返回意料之外的结果或者永远不会终止。偏函数增加了认知开销，它们更难推理，并可能导致运行时错误。一些例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例1: 列表的和</span></span><br><span class="line"><span class="comment">// sum :: [Number] -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = arr =&gt; arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line"><span class="title function_">sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">sum</span>([]) <span class="comment">// TypeError: Reduce of empty array with no initial value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2: 获取列表的第一个值</span></span><br><span class="line"><span class="comment">// first :: [A] -&gt; A</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">first</span> = a =&gt; a[<span class="number">0</span>]</span><br><span class="line"><span class="title function_">first</span>([<span class="number">42</span>]) <span class="comment">// 42</span></span><br><span class="line"><span class="title function_">first</span>([]) <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 甚至更糟: </span></span><br><span class="line"><span class="title function_">first</span>([[<span class="number">42</span>]])[<span class="number">0</span>] <span class="comment">// 42</span></span><br><span class="line"><span class="title function_">first</span>([])[<span class="number">0</span>] <span class="comment">// Uncaught TypeError: Cannot read property &#x27;0&#x27; of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例3: 将函数重复 N 次</span></span><br><span class="line"><span class="comment">// times :: Number -&gt; (Number -&gt; Number) -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">times</span> = n =&gt; <span class="function"><span class="params">fn</span> =&gt;</span> n &amp;&amp; (<span class="title function_">fn</span>(n), <span class="title function_">times</span>(n - <span class="number">1</span>)(fn))</span><br><span class="line"><span class="title function_">times</span>(<span class="number">3</span>)(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="title function_">times</span>(-<span class="number">1</span>)(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line"><span class="comment">// RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>
<h3 id="处理偏函数">处理偏函数</h3>
<p>偏函数是危险的，它们需要被非常谨慎地对待。你可能会得到意料之外的（错误的）结果或遇到运行时错误。有时偏函数可能根本不会返回。意识到并相应地处理所有这些边缘情况可能会变得非常乏味。幸运的是，部分函数可以转换为常规函数。我们可以提供默认值或使用
guard 来处理偏函数未定义的输入。利用 option
类型，我们可以在可能会出现意外行为的地方使用 yield
<code>Some(value)</code> 或 <code>None</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例1: 列表的和</span></span><br><span class="line"><span class="comment">// 我们可以提供默认值，使它总会返回结果</span></span><br><span class="line"><span class="comment">// sum :: [Number] -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = arr =&gt; arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>)</span><br><span class="line"><span class="title function_">sum</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">sum</span>([]) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2: 获取列表的第一个值</span></span><br><span class="line"><span class="comment">// 将结果改为 Option</span></span><br><span class="line"><span class="comment">// first :: [A] -&gt; A</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">first</span> = a =&gt; a.<span class="property">length</span> ? <span class="title class_">Some</span>(a[<span class="number">0</span>]) : <span class="title class_">None</span>()</span><br><span class="line"><span class="title function_">first</span>([<span class="number">42</span>]).<span class="title function_">map</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a)) <span class="comment">// 42</span></span><br><span class="line"><span class="title function_">first</span>([]).<span class="title function_">map</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a)) <span class="comment">// console.log 不会执行</span></span><br><span class="line"><span class="comment">//我们之前的糟糕情况</span></span><br><span class="line"><span class="title function_">first</span>([[<span class="number">42</span>]]).<span class="title function_">map</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="number">0</span>])) <span class="comment">// 42</span></span><br><span class="line"><span class="title function_">first</span>([]).<span class="title function_">map</span>(<span class="function"><span class="params">a</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="number">0</span>])) <span class="comment">// 不会执行，所以不会有 error</span></span><br><span class="line"><span class="comment">// 更重要的是，通过返回类型 (Option) ，我们会知道：</span></span><br><span class="line"><span class="comment">// 我们应该使用 .map 方法来访问数据，所以我们不会忘记检查输入，</span></span><br><span class="line"><span class="comment">// 因为这样的检查会被内建在函数中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例3: 将函数重复 N 次</span></span><br><span class="line"><span class="comment">// 我们需要通过改变条件来确保函数总会终止: </span></span><br><span class="line"><span class="comment">// times :: Number -&gt; (Number -&gt; Number) -&gt; Number</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">times</span> = n =&gt; <span class="function"><span class="params">fn</span> =&gt;</span> n &gt; <span class="number">0</span> &amp;&amp; (<span class="title function_">fn</span>(n), <span class="title function_">times</span>(n - <span class="number">1</span>)(fn))</span><br><span class="line"><span class="title function_">times</span>(<span class="number">3</span>)(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="title function_">times</span>(-<span class="number">1</span>)(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line"><span class="comment">// 不会再执行</span></span><br></pre></td></tr></table></figure>
<p>将偏函数改成全函数可以防止此类运行时错误。总是返回一个"值"也会使得代码更容易维护和推理。</p>
<div id="functional-programing-libraries-in-javascript">

</div>
<h2 id="在-js-中的函数式编程库">在 js 中的函数式编程库</h2>
<ul>
<li><a href="https://github.com/swannodette/mori">mori</a></li>
<li><a
href="https://github.com/facebook/immutable-js/">Immutable</a></li>
<li><a href="https://github.com/immerjs/immer">Immer</a></li>
<li><a href="https://github.com/ramda/ramda">Ramda</a></li>
<li><a
href="https://github.com/char0n/ramda-adjunct">ramda-adjunct</a></li>
<li><a href="http://folktalejs.org">Folktale</a></li>
<li><a href="https://cwmyers.github.io/monet.js/">monet.js</a></li>
<li><a href="https://github.com/lodash/lodash">lodash</a></li>
<li><a
href="https://github.com/jashkenas/underscore">Underscore.js</a></li>
<li><a href="https://github.com/dtao/lazy.js">Lazy.js</a></li>
<li><a
href="https://github.com/sjsyrek/maryamyriameliamurphies.js">maryamyriameliamurphies.js</a></li>
<li><a href="https://github.com/casualjavascript/haskell-in-es6">Haskell
in ES6</a></li>
<li><a
href="https://github.com/sanctuary-js/sanctuary">Sanctuary</a></li>
<li><a href="https://github.com/evilsoft/crocks">Crocks</a></li>
<li><a href="https://github.com/fluture-js/Fluture">Fluture</a></li>
<li><a href="https://github.com/gcanti/fp-ts">fp-ts</a></li>
</ul>
]]></content>
      <categories>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>范畴论</tag>
      </tags>
  </entry>
  <entry>
    <title>四元数与 3D 旋转</title>
    <url>/2024/02/17/%E5%9B%9B%E5%85%83%E6%95%B0%E4%B8%8E3%E7%BB%B4%E6%97%8B%E8%BD%AC/</url>
    <content><![CDATA[<h2 id="矩阵表示旋转">矩阵表示旋转</h2>
<p>绕着 <span class="math inline">\(x\)</span> 轴旋转：</p>
<p><span class="math display">\[
R_x\left(\alpha\right)=\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \cos \alpha &amp; -\sin \alpha &amp; 0 \\
0 &amp; \sin \alpha &amp; \cos \alpha &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<p>绕着 <span class="math inline">\(y\)</span> 轴旋转：</p>
<p><span class="math display">\[
R_y\left(\beta\right)=\begin{bmatrix}
\cos \beta &amp; 0 &amp; \sin \beta &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
-\sin \beta &amp; 0 &amp; \cos \beta &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<p>绕着 <span class="math inline">\(z\)</span> 轴旋转：</p>
<p><span class="math display">\[
R_z\left(\gamma\right)=\begin{bmatrix}
\cos \gamma &amp; -\sin \gamma &amp; 0 &amp; 0 \\
\sin \gamma &amp; \cos \gamma &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<h2 id="复数">复数</h2>
<h3 id="定义">定义</h3>
<p>复数域使用 <span class="math inline">\(\mathbb{C}\)</span>
表示，<span class="math inline">\(\forall z \in
\mathbb{C}\)</span>，都可以表示成 <span
class="math inline">\(z=a+b\mathrm{i}\)</span>，其中 <span
class="math inline">\(\mathrm{i}^2 = -1\)</span>，<span
class="math inline">\(a, b \in \mathbb{R}\)</span>。<span
class="math inline">\(a\)</span> 称为复数 <span
class="math inline">\(z\)</span> 的<strong>实部</strong>（Real
Part），<span class="math inline">\(b\)</span> 称为复数 <span
class="math inline">\(z\)</span> 的<strong>虚部</strong>（Imaginary
Part）。<span class="math inline">\(a\)</span> 可表示为 <span
class="math inline">\(\mathrm{Re}z\)</span>，<span
class="math inline">\(b\)</span> 可以表示为 <span
class="math inline">\(\mathrm{Im}z\)</span>。</p>
<p><span class="math inline">\(z = a+b\mathrm{i}\)</span> 实际上是对
<span class="math inline">\(\left\{1,\mathrm{i}\right\}\)</span>
这个<strong>基</strong>（Basis）的<strong>线性组合</strong>（Linear
Combination），可以使用二维向量来表示复数：</p>
<p><span class="math display">\[
z=\begin{bmatrix}
a   \\
b  
\end{bmatrix}
\]</span></p>
<p>既然是一个二维向量，就我们可以非常轻松地把它在平面直角坐标系上画出来：</p>
<figure>
<img data-src="https://github.com/XinranSix/computer-graphics/assets/62458905/28207773-fe34-47c2-8ddf-279efe8f5f79"
alt="复数可视化" />
<figcaption aria-hidden="true">复数可视化</figcaption>
</figure>
<h3 id="复数的运算">复数的运算</h3>
<h4 id="加减法">加减法</h4>
<p>设 <span class="math inline">\(z_1 = a + b \mathrm{i}\)</span>，<span
class="math inline">\(z_2=c+d\mathrm{i}\)</span>，则：</p>
<p><span class="math display">\[
z_1 \pm z_2=\left(a\pm c\right)+\left(b\pm d\right)\mathrm{i}
\]</span></p>
<h4 id="乘法">乘法</h4>
<p>设 <span class="math inline">\(z_1 = a + b \mathrm{i}\)</span>，<span
class="math inline">\(z_2=c+d\mathrm{i}\)</span>，则：</p>
<p><span class="math display">\[
\begin{align*}
    z_1z_2 &amp;=\left(a+b\mathrm{i}\right)\left(c+d\mathrm{i}\right)\\
     &amp; =ac+ad\mathrm{i}+bc\mathrm{i}+bd\mathrm{i}^2 \\
        &amp; =\left(ac-bd\right)+\left(bc+ad\right)\mathrm{i}
\end{align*}
\]</span></p>
<p>瞪眼法发现，fuck，这不就是矩阵乘法吗？所以，我们可以把复数看成是一个
<span class="math inline">\(2\times 2\)</span>
的矩阵作用于一个向量。即：</p>
<p><span class="math display">\[
\begin{align*}
    z_1z_2 &amp;=\left(ac-bd\right)+\left(bc+ad\right)\mathrm{i}\\
    &amp;= \begin{bmatrix}
    a &amp; -b \\
    b &amp; a
    \end{bmatrix}\begin{bmatrix}
     c  \\d
    \end{bmatrix}
\end{align*}
\]</span></p>
<p>右侧的 <span class="math inline">\(\begin{bmatrix} c
\\d\end{bmatrix}\)</span> 是 <span class="math inline">\(z_2\)</span>
的向量形式，而左侧的 <span class="math inline">\(\begin{bmatrix}a &amp;
-b \\b &amp; a \end{bmatrix}\)</span> 则是 <span
class="math inline">\(z_1\)</span> 的矩阵形式。</p>
<p>可以看到，复数的乘法，于矩阵 <span
class="math inline">\(\begin{bmatrix}a &amp; -b \\b &amp; a
\end{bmatrix}\)</span>
表示的变换是等价的（复数于矩阵的关系不止如此）。</p>
<p>如果 <span class="math inline">\(z_1\)</span>、<span
class="math inline">\(z_2\)</span>
都使用矩阵形式来表示的话，复数的乘法可以就变成了矩阵的乘法，得到的结果矩阵表示
<span class="math inline">\(z_2\)</span>、<span
class="math inline">\(z_1\)</span> 的表示的变换的复合变换。即：</p>
<p><span class="math display">\[
\begin{align*}
z_1z_2 &amp;= \begin{bmatrix}
a &amp;-b  \\
b&amp;a  
\end{bmatrix}\begin{bmatrix}
c &amp;-d  \\
d&amp;c  
\end{bmatrix}\\
&amp;= \begin{bmatrix}
ac-bd &amp;-(bc+ad)  \\
bc+ad &amp; ac-bd  
\end{bmatrix}
\end{align*}
\]</span></p>
<blockquote>
<p>注意：复数的乘法是满足交换律的，矩阵的乘法一般是不可交换的，显然复数的矩阵形式也是可以交换的。</p>
</blockquote>
<p>来看一些特殊的复数的矩阵形式：</p>
<p><span class="math display">\[
\begin{align*}
1 &amp;= \begin{bmatrix}
1 &amp; 0 \\
0 &amp; 1
\end{bmatrix} = I \\
\mathrm{i} &amp;= \begin{bmatrix}
0 &amp; -1 \\
1 &amp; 0
\end{bmatrix} .
\end{align*}
\]</span></p>
<p>即：实数单位 <span class="math inline">\(1\)</span>
与单位矩阵是等价的，虚数单位 <span
class="math inline">\(\mathrm{i}\)</span> 与矩阵 <span
class="math inline">\(\begin{bmatrix}0 &amp; -1 \\1 &amp; 0
\end{bmatrix}\)</span> 是等价的。</p>
<p>我们都知道，<span class="math inline">\(\mathrm{i}^2 =
-1\)</span>，用矩阵形式表示就说：</p>
<p><span class="math display">\[
\mathrm{i}^2 = \begin{bmatrix}0 &amp; -1\\1&amp; 0
\end{bmatrix}  \begin{bmatrix}0 &amp; -1\\1&amp; 0 \end{bmatrix} =
\begin{bmatrix}-1 &amp; 0\\0&amp; -1 \end{bmatrix} = -I = -1
\]</span></p>
<p>可以矩阵形式也满足 <span class="math inline">\(\mathrm{i}^2 =
-1\)</span>.</p>
<h4 id="模长与共轭">模长与共轭</h4>
<p>设复数 <span class="math inline">\(z=a+b\mathrm{i}\)</span>，则 <span
class="math inline">\(z\)</span>
的<strong>模长</strong>（Magnitude）定义为：</p>
<p><span class="math display">\[
\|z\|=\sqrt{a^2+b^2}
\]</span></p>
<p><span class="math inline">\(z\)</span>
的<strong>共轭</strong>（Conjugate）定义为：</p>
<p><span class="math display">\[
\overline{z}=a-b\mathrm{i}
\]</span></p>
<p>可以发现：</p>
<p><span class="math display">\[
z\overline{z}=\left(a+b\mathrm{i}\right)\left(a-b\mathrm{i}\right)=a^2+b^2=\|z\|^2
\]</span></p>
<p>所以：</p>
<p><span class="math display">\[
\|z\|=\sqrt{z\overline{z}}
\]</span></p>
<p>同时我们发现：</p>
<p><span class="math display">\[
a = \frac{z+\overline{z}}{2}, b = \frac{z-\overline{z}}{2\mathrm{i}}
\]</span></p>
<h3 id="复数的指数形式">复数的指数形式</h3>
<p>根据<a
href="https://en.wikipedia.org/wiki/Euler%27s_formula">欧拉公式</a>：</p>
<p><span class="math display">\[
\mathrm{e}^{\mathrm{i}\theta}=\cos \theta + \mathrm{i}\sin \theta
\]</span></p>
<p>可以得到复数的指数形式。</p>
<p>设复数 <span
class="math inline">\(z=a+b\mathrm{i}\)</span>，则其复数矩阵形式和复数形式为：</p>
<p><span class="math display">\[
\begin{align*}
z &amp;= \|z\|\begin{bmatrix}
\cos \theta &amp; -\sin \theta  \\
\sin \theta &amp;  \cos \theta
\end{bmatrix} \\
&amp;= \|z\|\left(\cos \theta + \mathrm{i}\sin \theta\right) \\
&amp;= \|z\|\mathrm{e}^{\mathrm{i}\theta}
\end{align*}
\]</span></p>
<p>其中： <span class="math display">\[\theta =
\mathrm{atan2}\left(\frac{b}{a}\right)\]</span></p>
<p>我们可以得到：</p>
<p><span class="math display">\[
\sin x =
\frac{\mathrm{e}^{\mathrm{i}x}-\mathrm{e}^{-\mathrm{i}x}}{2\mathrm{i}},\cos
x = \frac{\mathrm{e}^{\mathrm{i}x}+\mathrm{e}^{-\mathrm{i}x}}{2}
\]</span></p>
<p>如果使用复数的指数形式，复数的乘法就变得非常简单，设 <span
class="math inline">\(z_1
=r_1\mathrm{e}^{\mathrm{i}\theta_1}\)</span>，<span
class="math inline">\(z_2
=r_2\mathrm{e}^{\mathrm{i}\theta_2}\)</span>，则：</p>
<p><span class="math display">\[
z_1z_2=r_1r_2\mathrm{e}^{\mathrm{i}\left(\theta_1+\theta_2\right)}
\]</span></p>
<p>使用三角函数的复数形式可以很方便地证明三角函数的一些公式。</p>
<h3 id="复数与-2d-旋转">复数与 2D 旋转</h3>
<p>前面讨论了复数的矩阵形式，复数 <span
class="math inline">\(z=a+b\mathrm{i}\)</span> 的矩阵形式为 <span
class="math inline">\(\begin{bmatrix}a &amp; -b \\b &amp; a
\end{bmatrix}\)</span>.</p>
<p>将这个矩阵稍微变形一下：</p>
<p><span class="math display">\[
\begin{align*}
    \begin{bmatrix}a &amp; -b \\b &amp; a \end{bmatrix} &amp;=
\sqrt{a^2+b^2}\begin{bmatrix}
\frac{a}{\sqrt{a^2+b^2}} &amp; \frac{-b}{\sqrt{a^2+b^2}} \\
\frac{b}{\sqrt{a^2+b^2}} &amp; \frac{a}{\sqrt{a^2+b^2}}  
\end{bmatrix}\\ &amp;= \|z\|\begin{bmatrix}    \cos \theta &amp; -\sin
\theta  \\
\sin \theta &amp;  \cos \theta \end{bmatrix}  \\
&amp;= \begin{bmatrix}
\|z\|  &amp; 0 \\
0  &amp;  \|z\|
\end{bmatrix}\begin{bmatrix}    \cos \theta &amp; -\sin \theta  \\
\sin \theta &amp;  \cos \theta \end{bmatrix}
\end{align*}
\]</span></p>
<p>哦~，原来这个矩阵表示是一个旋转矩阵和一个缩放矩阵的复合啊（实际上我早就看出来了）。</p>
<p>即：复数 <span class="math inline">\(z=a+b\mathrm{i}\)</span>
可以表示一个平面上的旋转和缩放变换。缩放因子为：<span
class="math inline">\(\|z\|\)</span>，旋转角度为：<span
class="math inline">\(\mathrm{atan2}\left(\frac{b}{a}\right)\)</span>（CCW）。</p>
<p>如果 <span class="math inline">\(\|z\|=1\)</span>，即 <span
class="math inline">\(a^2+b^2=1\)</span> 当如何，即 <span
class="math inline">\(z\)</span>
是一个单位复数，那么这个变换就是一个纯粹的旋转变换：</p>
<p><span class="math display">\[
z=\begin{bmatrix}
\cos \theta &amp;  -\sin \theta\\
\sin \theta &amp;  \cos \theta
\end{bmatrix}
\]</span></p>
<p>如果我们想旋转一个二维向量，可以使用矩阵进行变换：</p>
<p><span class="math display">\[
\mathbf{v}&#39;=\begin{bmatrix}
\cos \theta &amp;  -\sin \theta\\
\sin \theta &amp;  \cos \theta
\end{bmatrix}\mathbf{v}
\]</span></p>
<p>矩阵 <span class="math inline">\(\begin{bmatrix} \cos \theta &amp;
-\sin \theta\\ \sin \theta &amp; \cos \theta \end{bmatrix}\)</span>
的复数形式为：<span class="math inline">\(\cos \theta +\mathrm{i}\sin
\theta\)</span>.</p>
<p>将向量 <span class="math inline">\(\mathbf{v}=\begin{bmatrix} x \\ y
\end{bmatrix}\)</span> 看成一个复数 <span
class="math inline">\(v=x+y\mathrm{i}\)</span>，我们可以构造一个复数
<span class="math inline">\(z=\cos \theta + \mathrm{i} \sin
\theta\)</span>，那么可以使用复数的乘法来表示旋转变换：</p>
<p><span class="math display">\[
v&#39;=zv=\left(\cos \theta + \mathrm{i} \sin \theta \right) v
\]</span></p>
<p>我们还可以使用复数的指数形式来表示旋转变换：</p>
<p><span class="math display">\[
v&#39;=r\mathrm{e}^{\mathrm{i}\theta}v
\]</span></p>
<p>当然 <span
class="math inline">\(r\mathrm{e}^{\mathrm{i}\theta}\)</span>
表示一个旋转和缩放的复合，如果只需要表示旋转，可以使 <span
class="math inline">\(r=1\)</span>.</p>
<h3 id="旋转的复合">旋转的复合</h3>
<p>假设有两个表示 2D 旋转的单位复数 <span class="math inline">\(z_1=\cos
\theta + \mathrm{i} \sin \theta\)</span>、<span
class="math inline">\(z_2=\cos \phi + \mathrm{i} \sin
\phi\)</span>，那么这两个旋转的复合变换可以表示为：</p>
<p><span class="math display">\[
\begin{align*}
z_1z_2 &amp;= \left(\cos \theta + \mathrm{i} \sin
\theta\right)\left(\cos \phi + \mathrm{i} \sin \phi\right)\\
&amp;= \left(\cos \theta \cos \phi - \sin \theta \sin \phi\right) +
\mathrm{i}\left(\cos \theta \sin \phi + \sin \theta \cos \phi\right)\\
&amp;= \cos \left(\theta + \phi\right) + \mathrm{i} \sin \left(\theta +
\phi\right)
\end{align*}
\]</span></p>
<h2 id="d-空间中的旋转">3D 空间中的旋转</h2>
<blockquote>
<p>这里讨论的是绕 3D 空间某一条过原点的轴旋转指定角度。</p>
<p>如果这个轴不过原点咋办？我们可以先将轴平移到原点，然后旋转，最后再平移回去。</p>
</blockquote>
<p>假设我们有一个过原点的旋转轴 <span
class="math inline">\(\mathbf{u}\)</span>，我们希望将一个向量 <span
class="math inline">\(\mathbf{v}\)</span> 绕这个轴旋转 <span
class="math inline">\(\theta\)</span> 角度，得到 <span
class="math inline">\(\mathbf{v}&#39;\)</span>：</p>
<figure>
<img data-src="https://github.com/XinranSix/comment/assets/62458905/0937c561-2f42-4716-a604-1ca94ea08173"
alt="绕特定轴旋转" />
<figcaption aria-hidden="true">绕特定轴旋转</figcaption>
</figure>
<blockquote>
<p>以下讨论默认为右手坐标系。</p>
</blockquote>
<p>我们发现，如果使用轴 <span class="math inline">\(\mathbf{u}\)</span>
和 角度 <span class="math inline">\(\theta\)</span>
来表示一个旋转，这我们一共有 4
个自由度，但如果使用欧拉角来表示旋转，显然只有 3
个自由度。捏是什么回事。</p>
<p>实际上这是因为向量既有大小，又有方向。但如果我们只考虑旋转，则向量的大小无所谓。例如，绕着
<span class="math inline">\(\left[0,0,1\right]^{\mathrm{T}}\)</span>
旋转和绕着 <span
class="math inline">\(\left[0,0,2\right]^{\mathrm{T}}\)</span>
有什么区别吗？绕着 <span
class="math inline">\(\left[x,y,z\right]^{\mathrm{T}}\)</span>
旋转和绕着 <span
class="math inline">\(k\left[x,y,z\right]^{\mathrm{T}}\)</span>
有什么区别吗？显然没有。</p>
<p>实际上在 3D
空间中定义一个方向只需要两个量就可以了（想想球坐标系或经纬度）。</p>
<p>既然向量的长度没有影响，若无特殊说明，后面讨论的向量 <span
class="math inline">\(\mathrm{u}\)</span> 都为单位向量，即：</p>
<p><span class="math display">\[
\|\mathbf{u}\| = \sqrt{x^2+y^2+z^2} = 1
\]</span></p>
<blockquote>
<p>在编程时，拿到的 <span class="math inline">\(\mathbf{u}\)</span>
很有可能不是单位向量，所以在使用前需要先将其归一化：</p>
<p><span class="math display">\[
\mathbf{\hat{u}} = \frac{\mathbf{u}}{\|\mathbf{u}\|}
\]</span></p>
</blockquote>
<h3 id="旋转的分解">旋转的分解</h3>
<p>可以将 <span class="math inline">\(\mathbf{v}\)</span>
分解为平行于旋转轴 <span class="math inline">\(\mathbf{u}\)</span>
和正交与旋转轴 <span class="math inline">\(\mathbf{u}\)</span>
的两个分量 <span class="math inline">\(\mathbf{v}_{\parallel}\)</span>
和 <span class="math inline">\(\mathbf{v}_{\perp}\)</span></p>
<p><span class="math display">\[
\mathbf{v}=\mathbf{v}_{\parallel}+\mathbf{v}_{\perp}
\]</span></p>
<figure>
<img data-src="https://github.com/XinranSix/comment/assets/62458905/42933dab-ad4a-4bfa-b3dd-4388a9a0b613"
alt="向量的正交分解" />
<figcaption aria-hidden="true">向量的正交分解</figcaption>
</figure>
<p>分别旋转这两部分，在将它们的旋转结果加起来就可以的得到旋转后的向量：</p>
<p><span class="math display">\[
\mathbf{v}&#39;=\mathbf{v}&#39;_{\parallel}+\mathbf{v}&#39;_{\perp}
\]</span></p>
<p><span class="math inline">\(\mathbf{v}_{\parallel}\)</span> 实际上就
<span class="math inline">\(\mathbf{v}\)</span> 在 <span
class="math inline">\(\mathbf{u}\)</span>
上的投影，那我们就快点把他算出来吧：</p>
<p><span class="math display">\[
\mathbf{v}_{\parallel} = \mathrm{proj}_{\mathbf{u}} \mathbf{v} =
\left(\mathbf{u} \cdot \mathbf{v}\right) \mathbf{u}
\]</span></p>
<blockquote>
<p>向量 <span class="math inline">\(\mathbf{a}\)</span> 在向量 <span
class="math inline">\(\mathbf{b}\)</span> 上的投影为：</p>
<p><span class="math display">\[
\mathrm{proj}_{\mathbf{b}} \mathbf{a} = \frac{\mathbf{a} \cdot
\mathbf{b}}{\| \mathbf{b} \|^2} \mathbf{b}
\]</span></p>
<p>如果 <span class="math inline">\(\| \mathbf{b}
\|=1\)</span>，则：</p>
<p><span class="math display">\[
\mathrm{proj}_{\mathbf{b}} \mathbf{a} = \left(\mathbf{a} \cdot
\mathbf{b} \right) \mathbf{b}
\]</span></p>
</blockquote>
<p>因为 <span
class="math inline">\(\mathbf{v}=\mathbf{v}_{\parallel}+\mathbf{v}_{\perp}\)</span>，那么：</p>
<p><span class="math display">\[
\begin{align*}
    \mathbf{v}_{\perp}&amp;=\mathbf{v}-\mathbf{v}_{\parallel}\\
     &amp;=\left(\mathbf{u} \cdot \mathbf{v}\right) \mathbf{u}
\end{align*}
\]</span></p>
<p>接下来只需分别讨论 <span
class="math inline">\(\mathbf{v}_{\parallel}\)</span> 和 <span
class="math inline">\(\mathbf{v}_{\perp}\)</span> 的旋转即可。</p>
<h3 id="mathbfv_parallel-的旋转"><span
class="math inline">\(\mathbf{v}_{\parallel}\)</span> 的旋转</h3>
<p>显然：</p>
<p><span class="math display">\[
\mathbf{v}_{\parallel}&#39;=\mathbf{v}_{\parallel}
\]</span></p>
<h3 id="mathbfv_perp-的旋转"><span
class="math inline">\(\mathbf{v}_{\perp}\)</span> 的旋转</h3>
<p><span class="math inline">\(\mathbf{v}_{\perp}\)</span> 正交于 <span
class="math inline">\(\mathbf{u}\)</span>，所以这个旋转实际上在一个平面内。因为旋转不改变向量的长度，所以路径是一个圆，如下图所示：</p>
<figure>
<img data-src="https://github.com/XinranSix/comment/assets/62458905/12a9a2ee-2721-45e5-9d6f-d6110d40cb62"
alt="旋转示意图" />
<figcaption aria-hidden="true">旋转示意图</figcaption>
</figure>
<p>再构造一个向量 <span class="math inline">\(\mathbf{w} = \mathbf{u}
\times \mathbf{v}_{\perp}\)</span>.</p>
<p>实际上向量 <span class="math inline">\(\mathbf{w}\)</span> 是向量
<span class="math inline">\(\mathbf{v}_{\perp}\)</span> 逆时针旋转 <span
class="math inline">\(\pi / 2\)</span> 之后得到的结果。可以发现：</p>
<p><span class="math display">\[
\begin{align*}
    \|\mathbf{w}\| &amp;=\|\mathbf{u} \times \mathbf{v}_{\perp}\|\\
    &amp;= \|\mathbf{u}\|  \|\mathbf{v}_{\perp}\| \sin \frac{\pi}{2} \\
    &amp;= \|\mathbf{v}_{\perp}\|
\end{align*}
\]</span></p>
<p>也就是说，<span
class="math inline">\(\|\mathbf{w}\|=\|\mathbf{v}_{\perp}\|\)</span>，即
<span class="math inline">\(\mathbf{w}\)</span> 也在圆上。所以：</p>
<p><span class="math display">\[
\begin{align*}
    \mathbf{v}_{\perp}&#39; &amp;= \mathbf{v}_{\perp} \cos \theta\ +
\mathbf{w} \sin \theta \\
    &amp;= \mathbf{v}_{\perp} \cos \theta\ + \left(\mathbf{u}\times
\mathbf{\mathbf{v}_{\perp}}\right) \sin \theta
\end{align*}
\]</span></p>
<h3 id="mathbfv-的旋转"><span class="math inline">\(\mathbf{v}\)</span>
的旋转</h3>
<p>根据上面的讨论：</p>
<p><span class="math display">\[
\begin{align*}
    \mathbf{v}&#39;&amp;=\mathbf{v}_{\parallel}&#39;+\mathbf{v}_{\perp}&#39;\\
    &amp;= \mathbf{v}_{\parallel} + \mathbf{v}_{\perp} \cos \theta\ +
\left(\mathbf{u}\times \mathbf{\mathbf{v}_{\perp}}\right) \sin \theta
\end{align*}
\]</span></p>
<p>叉乘具有结合律：</p>
<p><span class="math display">\[
\begin{align*}
    \mathbf{u}\times \mathbf{\mathbf{v}_{\perp}}&amp;= \mathbf{u}\times
\left(\mathbf{v}-\mathbf{v}_{\parallel}\right)\\
    &amp;=\mathbf{u}\times \mathbf{v} - \mathbf{u}\times
\mathbf{v}_{\parallel}\\
    &amp;= \mathbf{u}\times \mathbf{v}
\end{align*}
\]</span></p>
<p>最后，将 <span class="math inline">\(\mathbf{v}_{\parallel} =
\left(\mathbf{u}\cdot \mathbf{v}\right)\mathbf{u}\)</span> 和 <span
class="math inline">\(\mathbf{v}_{\perp} = \mathbf{v} -
\left(\mathbf{u}\cdot \mathbf{v}\right)\mathbf{u}\)</span> 带入得：</p>
<p><span class="math display">\[
\begin{align*}
    \mathbf{v}&#39;&amp;= \left(\mathbf{u}\cdot
\mathbf{v}\right)\mathbf{u} + \left(\mathbf{v} - \left(\mathbf{u}\cdot
\mathbf{v}\right)\mathbf{u}\right) \cos \theta\ + \left(\mathbf{u}\times
\mathbf{\mathbf{v}}\right) \sin \theta\\
    &amp;= \mathbf{v} \cos \theta + \left(1- \cos \theta\right)
\left(\mathbf{u}\cdot \mathbf{v}\right)\mathbf{u} +
\left(\mathbf{u}\times \mathbf{v}\right) \sin \theta
\end{align*}
\]</span></p>
<p>即 3D 空间中任意一个向量 <span
class="math inline">\(\mathbf{v}\)</span> 沿单位向量 <span
class="math inline">\(\mathbf{u}\)</span> 旋转 <span
class="math inline">\(\theta\)</span> 之后得到的 <span
class="math inline">\(\mathbf{v}&#39;\)</span> 为：</p>
<p><span class="math display">\[
\mathbf{v}&#39;=\mathbf{v} \cos \theta + \left(1- \cos \theta\right)
\left(\mathbf{u}\cdot \mathbf{v}\right)\mathbf{u} +
\left(\mathbf{u}\times \mathbf{v}\right) \sin \theta
\]</span></p>
<p>这个公式叫做 Rodrigues' rotation formula.</p>
<h2 id="四元数">四元数</h2>
<p>四元数与复数像，不同的是，复数只有 1 个虚部，而四元数有 3
个虚部。</p>
<p>四元数的定义为：</p>
<p><span class="math display">\[
q = a + b \mathrm{i} + c \mathrm{j} + d \mathrm{k}
\]</span></p>
<p>其中 <span
class="math inline">\(\mathrm{i}^2=\mathrm{j}^2=\mathrm{k}^2=\mathrm{i}\mathrm{j}\mathrm{k}=-1\)</span>，且
<span class="math inline">\(a,b,c,d\in \mathbb{R}\)</span>.</p>
<p>四元数的集合用 <span class="math inline">\(\mathbb{H}\)</span>
表示，即：<span class="math inline">\(q\in \mathbb{H}\)</span>.</p>
<p>与复数类似，四元数是对 <span
class="math inline">\(\left\{1,\mathrm{i},\mathrm{j},\mathrm{k}\right\}\)</span>
这个基的线性组合，四元数可以写成向量形式：</p>
<p><span class="math display">\[
q=\begin{bmatrix}
a\\b\\c\\d
\end{bmatrix}
\]</span></p>
<p>还可以将四元数的实部和虚部分开，用一个三维的向量来表示虚部，将四元数表示为标量和向量的有序对：</p>
<p><span class="math display">\[
q = \left[s, \mathbf{v}\right]
\]</span></p>
<p>其中：<span
class="math inline">\(\mathbf{v}=\left[x,y,z\right]^{\mathrm{T}}\)</span>，且
<span class="math inline">\(s,x,y,z \in \mathbb{R}\)</span>.</p>
<h3 id="四元数的运算与性质">四元数的运算与性质</h3>
<h4 id="模长">模长</h4>
<p>设四元数 <span
class="math inline">\(q=a+b\mathrm{i}+c\mathrm{j}+d\mathrm{k}\)</span>，则
<span class="math inline">\(q\)</span> 的模长定义为：</p>
<p><span class="math display">\[
\|q\|=\sqrt{a^2+b^2+c^2+d^2}
\]</span></p>
<p>如果使用标量向量的形式来表示的话，设 <span
class="math inline">\(q=\left[s,\mathbf{v}\right]\)</span>，则：</p>
<p><span class="math display">\[
\|q\|=\sqrt{s^2+\|\mathbf{v}\|^2}
\]</span></p>
<h4 id="加减法-1">加减法</h4>
<p>设 <span class="math inline">\(q_1 = a + b \mathrm{i} + c \mathrm{j}
+ d \mathrm{k}\)</span>、<span
class="math inline">\(q_2=e+f\mathrm{i}+g\mathrm{j}+h\mathrm{k}\)</span>，则：</p>
<p><span class="math display">\[
q_1 \pm q_2=\left(a\pm e\right)+\left(b\pm f\right)\mathrm{i}+\left(c\pm
g\right)\mathrm{j}+\left(d\pm h\right)\mathrm{k}
\]</span></p>
<p>使用标量向量有序对形式表示，设 <span
class="math inline">\(q_1=\left[s_1,\mathbf{v}_1\right]\)</span>、<span
class="math inline">\(q_2=\left[s_2,\mathbf{v}_2\right]\)</span>，则：</p>
<p><span class="math display">\[
q_1 \pm q_2=\left[s_1\pm s_2,\mathbf{v}_1\pm \mathbf{v}_2\right]
\]</span></p>
<h4 id="数乘">数乘</h4>
<p>设四元数 <span
class="math inline">\(q=a+b\mathrm{i}+c\mathrm{j}+d\mathrm{k}\)</span>，<span
class="math inline">\(k\in \mathbb{R}\)</span>，则：</p>
<p><span class="math display">\[
kq=ka+kb\mathrm{i}+kc\mathrm{j}+kd\mathrm{k}
\]</span></p>
<blockquote>
<p>四元数的数乘是可交换的，即：<span
class="math inline">\(kq=qk\)</span>，其中 <span
class="math inline">\(k\in \mathbb{R}\)</span> 且 <span
class="math inline">\(q\in \mathbb{H}\)</span>.</p>
</blockquote>
<h4 id="四元数乘法">四元数乘法</h4>
<p>四元数乘法是不可交换的。即，一般情况下，对于 <span
class="math inline">\(q_1,q_2\in \mathbb{H}\)</span>，一般情况下 <span
class="math inline">\(q_1q_2\neq q_2q_1\)</span>.</p>
<p>对于 <span class="math inline">\(q_1q_2\)</span>，称之为「<span
class="math inline">\(q_2\)</span> 左乘以 <span
class="math inline">\(q_1\)</span>」，对于 <span
class="math inline">\(q_2q_1\)</span>，称之为「<span
class="math inline">\(q_2\)</span> 右乘以 <span
class="math inline">\(q_1\)</span>」。</p>
<p>虽然四元数乘法不可交换，但是满足结合律和分配律。</p>
<p>设 $q_1=a+b + c +d , <span class="math inline">\(q_2=e+f \mathrm{i} +
g \mathrm{j}+h \mathrm{k}\)</span>$，则：</p>
<p><span class="math display">\[
\begin{align*}
q_1 q_2= &amp; (a+b \mathrm{i}+c \mathrm{j}+d \mathrm{k})(e+f
\mathrm{i}+g \mathrm{j}+h \mathrm{k}) \\
= &amp; a e+a f \mathrm{i}+a g \mathrm{j}+a h \mathrm{k}+ \\
&amp; b e \mathrm{i}+b f \mathrm{i}^2+b g \mathrm{i} \mathrm{j}+b h
\mathrm{i} \mathrm{k}+ \\
&amp; c e \mathrm{j}+c f \mathrm{j} \mathrm{i}+c g \mathrm{j}^2+c h
\mathrm{j} \mathrm{k}+ \\
&amp; d e \mathrm{k}+d f \mathrm{k} \mathrm{i}+d g \mathrm{k}
\mathrm{j}+d h \mathrm{k}^2
\end{align*}
\]</span></p>
<p>根据以下表格对上述公式进行简化：</p>
<p><span class="math display">\[
\begin{array}{|c|c|c|c|c|}
\hline \times &amp; 1 &amp; \mathrm{i} &amp; \mathrm{j} &amp; \mathrm{k}
\\
\hline 1 &amp; 1 &amp; \mathrm{i} &amp; \mathrm{j} &amp; \mathrm{k} \\
\hline \mathrm{i} &amp; \mathrm{i} &amp; -1 &amp; \mathrm{k} &amp;
-\mathrm{j} \\
\hline \mathrm{j} &amp; \mathrm{j} &amp; -\mathrm{k} &amp; -1 &amp;
\mathrm{i} \\
\hline \mathrm{k} &amp; \mathrm{k} &amp; \mathrm{j} &amp; -\mathrm{i}
&amp; -1 \\
\hline
\end{array}
\]</span></p>
<p>化简后得：</p>
<p><span class="math display">\[
\begin{align*}
q_1 q_2
= &amp; (a e-b f-c g-d h)+ \\
&amp; (b e+a f-d g+c h) \mathrm{i}+ \\
&amp; (c e+d f+a g-b h) \mathrm{j}+ \\
&amp; (d e-c f+b g+a h)\mathrm{k}
\end{align*}
\]</span></p>
<h4 id="四元数乘法的矩阵形式">四元数乘法的矩阵形式</h4>
<p>类似于复数的乘法，四元数的乘法也可以使用矩阵来表示。</p>
<p>设 <span
class="math inline">\(q_1=a+b\mathrm{i}+c\mathrm{j}+d\mathrm{k}\)</span>，<span
class="math inline">\(q_2=e+f\mathrm{i}+g\mathrm{j}+h\mathrm{k}\)</span>，则：</p>
<p><span class="math display">\[
q_1q_2=\begin{bmatrix}
a &amp; -b &amp; -c &amp; -d \\
b &amp; a &amp; -d &amp; c \\
c &amp; d &amp; a &amp; -b \\
d &amp; -c &amp; b &amp; a
\end{bmatrix}  \begin{bmatrix}
e \\
f \\
g \\
h \end{bmatrix}
\]</span></p>
<p>注意：这个矩阵表示左乘 <span class="math inline">\(q_1\)</span>，右乘
<span class="math inline">\(q_1\)</span> 的矩阵表示为：</p>
<p><span class="math display">\[
q_2 q_1=\begin{bmatrix}
a &amp; -b &amp; -c &amp; -d \\
b &amp; a &amp; d &amp; -c \\
c &amp; -d &amp; a &amp; b \\
d &amp; c &amp; -b &amp; a
\end{bmatrix} \begin{bmatrix}
e \\
f \\
g \\
h
\end{bmatrix}
\]</span></p>
<h4 id="grassmann-积">Grassmann 积</h4>
<p>前面已经得到：</p>
<p><span class="math display">\[
\begin{align*}
q_1 q_2
= &amp; (a e-b f-c g-d h)+ \\
&amp; (b e+a f-d g+c h) \mathrm{i}+ \\
&amp; (c e+d f+a g-b h) \mathrm{j}+ \\
&amp; (d e-c f+b g+a h)\mathrm{k}
\end{align*}
\]</span></p>
<p>我们都知道，如果 <span
class="math inline">\(\mathbf{v}=[b,c,d]^{\mathrm{T}}\)</span>，<span
class="math inline">\(\mathbf{u}=[f,g,h]^{\mathrm{T}}\)</span>，则：</p>
<p><span class="math display">\[
\begin{align*}
\mathbf{v} \cdot \mathbf{u} &amp;= b f + c g + d h \\
\mathbf{v} \times \mathbf{u} &amp;= \begin{bmatrix}
\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\
b &amp; c &amp; d \\
f &amp; g &amp; h
\end{bmatrix}
\end{align*}
\]</span></p>
<p>所以：</p>
<p><span class="math display">\[
q_1q_2=ae - \mathbf{v} \cdot \mathbf{u} + a \mathbf{u} + e \mathbf{v} +
\mathbf{v} \times \mathbf{u}
\]</span></p>
<p>如果 <span class="math inline">\(q_1 = \left[s_1,
\mathbf{v}_1\right]\)</span>，<span class="math inline">\(q_2 =
\left[s_2, \mathbf{v}_2\right]\)</span>，则：</p>
<p><span class="math display">\[
q_1q_2=\left[s_1s_2 - \mathbf{v}_1 \cdot \mathbf{v}_2, s_1\mathbf{v}_2 +
s_2\mathbf{v}_1 + \mathbf{v}_1 \times \mathbf{v}_2\right]
\]</span></p>
<p>这个结果叫做 Grassmann 积 (Grassmann Product)</p>
<h4 id="纯四元数">纯四元数</h4>
<p>如果一个四元数的实部为 0，那么这个四元数就是一个纯四元数。即如果
<span class="math inline">\(v=\left[0,\mathbf{v}\right]\)</span>，则 v
是一个纯四元数。</p>
<p>我们可以将一个纯四元数和一个 3D 向量等价起来。</p>
<p>在后文中，如果 <span class="math inline">\(\mathbf{v}\)</span>
表示一个向量，则使用 <span class="math inline">\(v\)</span> 表示 <span
class="math inline">\(\mathbf{v}\)</span> 对于的纯四元数，即：<span
class="math inline">\(v=\left[0,\mathbf{v}\right]\)</span>.</p>
<h4 id="逆和共轭">逆和共轭</h4>
<p>对于四元数 <span
class="math inline">\(q=a+b\mathrm{i}+c\mathrm{j}+d\mathrm{k}\)</span>，其共轭定义为：</p>
<p><span class="math display">\[
q^{\star}=a-b\mathrm{i}-c\mathrm{j}-d\mathrm{k}
\]</span></p>
<p>四元数 <span class="math inline">\(q\)</span> 的逆记为：<span
class="math inline">\(q^{-1}\)</span>. 它要满足：</p>
<p><span class="math display">\[
qq^{-1}=q^{-1}q=1
\]</span></p>
<blockquote>
<p>只有当 <span class="math inline">\(q \neq 0\)</span> 时才可逆。</p>
</blockquote>
<p>设 <span class="math inline">\(q = \left[s,
\mathbf{v}\right]\)</span>，则 <span class="math inline">\(q^{\star} =
\left[s, -\mathbf{v}\right]\)</span>，那么：</p>
<p><span class="math display">\[
\begin{align*}
qq^{\star} &amp;= \left[s, \mathbf{v}\right]\left[s, -\mathbf{v}\right]
\\
&amp;=  \left[s^2 + \mathbf{v} \cdot \mathbf{v}, 0\right]
\end{align*}
\]</span></p>
<p>且：</p>
<p><span class="math display">\[
\begin{align*}
q^{\star}q &amp;= \left[s, -\mathbf{v}\right]\left[s, \mathbf{v}\right]
\\
&amp;=  \left[s^2 + \mathbf{v} \cdot \mathbf{v}, 0\right]
\end{align*}
\]</span></p>
<p>那么：</p>
<p><span class="math display">\[
\begin{align*}
qq^{-1}&amp;=1\\
q^{\star}qq^{-1}&amp;=q^{\star}\\
\|q\|^2 q^{-1}&amp;=q^{\star}\\
q^{-1}&amp;=\frac{q^{\star}}{\|q\|^2}
\end{align*}
\]</span></p>
<p>这样就求得了四元数的逆。</p>
<p>如果 <span class="math inline">\(\|q\|=1\)</span>，则 <span
class="math inline">\(q\)</span> 是一个单位四元数，那么：</p>
<p><span class="math display">\[
q^{-1} = \frac{q^{\star}}{\|1\|^2} = q^{\star}
\]</span></p>
<h3 id="四元数与-3d-旋转">四元数与 3D 旋转</h3>
<p>在前面以后讨论过如何将一个向量 <span
class="math inline">\(\mathbf{v}\)</span> 绕一个用单位向量表示的旋转轴
<span class="math inline">\(\mathbf{u}\)</span> 逆时针旋转旋转 <span
class="math inline">\(\theta\)</span> 度，即：将 <span
class="math inline">\(\mathbf{v}\)</span> 分解成平行于 <span
class="math inline">\(\mathbf{u}\)</span> 的向量 <span
class="math inline">\(\mathbf{v}_{\parallel}\)</span> 和正交于 <span
class="math inline">\(\mathbf{u}\)</span> 的向量 <span
class="math inline">\(\mathbf{v}_{\perp}\)</span>，然后分别旋转这两部分，得到
<span class="math inline">\(\mathbf{v}&#39;_{\parallel}\)</span> 和
<span
class="math inline">\(\mathbf{v}&#39;_{\perp}\)</span>，最后将这两部分加起来得到
<span class="math inline">\(\mathbf{v}&#39;\)</span>.</p>
<p>我们可以将这些向量定义为纯四元数：</p>
<p><span class="math display">\[
\begin{align*}
v &amp;= \left[0, \mathbf{v}\right] \\
v_{\parallel}&amp;= \left[0, \mathbf{v}_{\parallel}\right] \\
v_{\perp}&amp;= \left[0, \mathbf{v}_{\perp}\right] \\
v&#39; &amp;= \left[0, \mathbf{v&#39;}\right] \\
v&#39;_{\parallel}&amp;= \left[0, \mathbf{v}&#39;_{\parallel}\right] \\
v&#39;_{\perp}&amp;= \left[0, \mathbf{v}&#39;_{\perp}\right] \\
u&amp;= \left[0, \mathbf{u}\right]
\end{align*}
\]</span></p>
<p>那么有：</p>
<p><span class="math display">\[
\begin{align*}
v &amp;= v_{\parallel} + v_{\perp} \\
v&#39; &amp;= v&#39;_{\parallel} + v&#39;_{\perp}
\end{align*}
\]</span></p>
<p>下面分别讨论 <span class="math inline">\(v_{\parallel}\)</span> 和
<span class="math inline">\(v_{\perp}\)</span>.</p>
<h4 id="v_parallel-的旋转"><span
class="math inline">\(v_{\parallel}\)</span> 的旋转</h4>
<p>显然：</p>
<p><span class="math display">\[
v&#39;_{\parallel}=v_{\parallel}
\]</span></p>
<h4 id="v_perp-的旋转"><span class="math inline">\(v_{\perp}\)</span>
的旋转</h4>
<p>我们正确推到过：</p>
<p><span class="math display">\[
\mathbf{v}_{\perp}&#39; = \mathbf{v}_{\perp} \cos \theta\ +
\left(\mathbf{u}\times \mathbf{\mathbf{v}_{\perp}}\right) \sin \theta
\]</span></p>
<p>我们可以非常容易地将 <span
class="math inline">\(\mathbf{v}&#39;_{\perp}\)</span> 和 <span
class="math inline">\(\mathbf{v}_{\perp}\)</span> 替换为 <span
class="math inline">\(v&#39;_{\perp}\)</span> 和 <span
class="math inline">\(v_{\perp}\)</span>，但 <span
class="math inline">\(\mathbf{u}\times
\mathbf{\mathbf{v}_{\perp}}\)</span> 又当如何？实际上也很 easy
啦，下面给出推导。</p>
<p>前面已经得到，对于纯四元数 <span
class="math inline">\(v=\left[0,\mathbf{v}\right]\)</span> 和 <span
class="math inline">\(u=\left[0,\mathbf{u}\right]\)</span>，有：<span
class="math inline">\(vu=\left[-\mathbf{v}\cdot \mathbf{u},
\mathbf{v}\times \mathbf{u}\right]\)</span>。那么</p>
<p><span class="math display">\[
\begin{align*}
uv_{\perp}&amp;= \left[-\mathbf{u}\cdot \mathbf{v}_{\perp},
\mathbf{u}\times \mathbf{v}_{\perp} \right]\\
&amp;=\left[0, \mathbf{u}\times \mathbf{v}_{\perp}\right]\\
&amp;=\mathbf{u}\times \mathbf{v}_{\perp}
\end{align*}
\]</span></p>
<p>注意：<span class="math inline">\(uv_{\perp}\)</span>
也是一个纯四元数。</p>
<p>那么我们就可以得到：</p>
<p><span class="math display">\[
\begin{align*}
v&#39;_{\perp} &amp;= v_{\perp} \cos \theta\ + uv_{\perp} \sin \theta\\
&amp;= \left(\cos \theta +u \sin \theta\right)v_{\perp}
\end{align*}
\]</span></p>
<p>我们可以将 <span class="math inline">\(\cos \theta +u \sin
\theta\)</span> 看做为一个四元数。令 <span class="math inline">\(q=\cos
\theta +u \sin \theta\)</span>，则：</p>
<p><span class="math display">\[
v&#39;_{\perp}=qv_{\perp}
\]</span></p>
<p>对 <span class="math inline">\(q\)</span> 稍微变形：</p>
<p><span class="math display">\[
\begin{align*}
q&amp;=\cos \theta +u \sin \theta\\
&amp;=\left[\cos \theta, 0\right] + \left[0, \mathbf{u} \sin
\theta\right] \\
&amp;=\left[\cos \theta, \mathbf{u} \sin \theta\right]
\end{align*}
\]</span></p>
<p>也就是说，如果 <span
class="math inline">\(\mathbf{u}=\begin{bmatrix}u_x, u_y, u_z
\end{bmatrix}^{\mathrm{T}}\)</span>，旋转角为 <span
class="math inline">\(\theta\)</span>，那么完全这一旋转所需的四元数
<span class="math inline">\(q\)</span> 为：</p>
<p><span class="math display">\[
q=\cos \theta +  u_{x} \sin \theta \mathrm{i} + u_{y} \sin
\theta  \mathrm{j} + u_{z} \sin \theta  \mathrm{k}
\]</span></p>
<p>即，对于正交于旋转轴 <span class="math inline">\(\mathbf{u}\)</span>
的向量 <span class="math inline">\(\mathbf{v}_{\perp}\)</span>，旋转
<span class="math inline">\(\theta\)</span> 角度之后得到 <span
class="math inline">\(\mathbf{v}&#39;_{\perp}\)</span>，令 <span
class="math inline">\(v_{\perp}=\left[0,\mathbf{v}_{\perp}\right]\)</span>，<span
class="math inline">\(q=\left[\cos \theta,
\mathbf{u}\sin\theta\right]\)</span>，那么：</p>
<p><span class="math display">\[
v&#39;_{\perp}=qv_{\perp}
\]</span></p>
<p>我们可以发现：</p>
<p><span class="math display">\[
\|q\|= 1
\]</span></p>
<blockquote>
<p>一个普通的四元数表示一个旋转变换和一个缩放变换的复合，而单位四元数表示一个纯粹的旋转变换，这一点和复数非常类似。</p>
</blockquote>
<h4 id="v-的旋转"><span class="math inline">\(v\)</span> 的旋转</h4>
<p><span class="math display">\[
\begin{align*}
v&#39;&amp;=v&#39;_{\parallel}+v&#39;_{\perp}\\
&amp;=v_{\parallel}+qv_{\perp}
\end{align*}
\]</span></p>
<p>其中 <span
class="math inline">\(q=\left[\cos\theta,\mathbf{u}\sin\theta\right]\)</span>.</p>
<p>接下来要对上面的公式进行简化，在简化之前像给出两个引理。</p>
<p>引理 1：如果 <span
class="math inline">\(q=\left[\cos\theta,\mathbf{u}\sin\theta\right]\)</span>，且
<span class="math inline">\(\|\mathbf{u}\|=1\)</span>，那么：</p>
<p><span class="math display">\[
q^2=qq=\left[\cos 2\theta,\mathbf{u}\sin 2\theta\right]
\]</span></p>
<p>在证明之前我们可以简单思考一下，<span
class="math inline">\(q\)</span> 表示绕 <span
class="math inline">\(\mathbf{u}\)</span> 旋转 <span
class="math inline">\(\theta\)</span>，那么 <span
class="math inline">\(q^2\)</span> 表示绕 <span
class="math inline">\(\mathbf{u}\)</span> 旋转 <span
class="math inline">\(2\theta\)</span>，这是不是很合理？</p>
<p>证明：</p>
<p><span class="math display">\[
\begin{align*}
q^2 &amp; =[\cos \theta,  \mathbf{u}\sin \theta] [\cos
\theta,  \mathbf{u}\sin \theta] \\
&amp; =\left[\cos ^2\theta-(\mathbf{u}\sin \theta)  \cdot (\mathbf{u}
\sin \theta ),(\cos \theta \sin \theta+\sin \theta \cos \theta)
\mathbf{u}+(\sin \theta \mathbf{u}) \times (\sin \theta
\mathbf{u})\right] \\
&amp; =\left[\cos ^2\theta-\|\mathbf{u}\|^2\sin ^2\theta, 2
\mathbf{u}\sin \theta \cos \theta +\mathbf{0}\right] \\
&amp; =\left[\cos ^2\theta-\sin ^2\theta, 2 \mathbf{u} \sin \theta \cos
\theta \right] \\
&amp; =[\cos 2 \theta, \mathbf{u} \sin 2 \theta ]
\end{align*}
\]</span></p>
<p>接下来利用上面的引理，我们可以对 <span
class="math inline">\(v&#39;\)</span> 进行简化，先令 <span
class="math inline">\(p=\left[\cos \frac{\theta}{2}, \mathbf{u} \sin
\frac{\theta}{2}\right]\)</span>，显然 <span class="math inline">\(q =
p^2\)</span> 且 <span class="math inline">\(\|p\|=1\)</span>，即 <span
class="math inline">\(p^{-1}=p^{\star}\)</span> 那么：</p>
<p><span class="math display">\[
\begin{align*}
v&#39;&amp;=v_{\parallel}+qv_{\perp}\\
&amp;=pp^{-1}v_{\parallel} + ppv_{\perp}\\
&amp;=pp^{\star}v_{\parallel} + ppv_{\perp}
\end{align*}
\]</span></p>
<p>继续简化之前来看第二个引理：</p>
<p>引理 2：对于平行于 <span class="math inline">\(\mathbf{u}\)</span>
的向量 <span
class="math inline">\(\mathbf{v}_{\parallel}\)</span>，其四元数为：<span
class="math inline">\(v_{\parallel}=\left[0,\mathbf{v}_{\parallel}\right]\)</span>，且
<span class="math inline">\(\|\mathbf{u}\|=1\)</span>。设 <span
class="math inline">\(q=\left[\alpha,\beta
\mathbf{u}\right]\)</span>，那么：<span
class="math inline">\(qv_{\parallel}=v_{\parallel}q\)</span></p>
<p>证明：</p>
<p><span class="math display">\[
\begin{align*}
\text{LHS}  &amp;= qv_{\parallel} \\
&amp;= \left[\alpha,\beta
\mathbf{u}\right]\left[0,\mathbf{v}_{\parallel}\right]\\
&amp;= \left[-\beta \mathbf{u}\cdot \mathbf{v}_{\parallel}, \alpha
\mathbf{v}_{\parallel}\right]
\end{align*}
\]</span></p>
<p><span class="math display">\[
\begin{align*}
\text{RHS}  &amp;= v_{\parallel}q \\
&amp;= \left[0,\mathbf{v}_{\parallel}\right]\left[\alpha,\beta
\mathbf{u}\right]\\
&amp;= \left[-\beta \mathbf{u}\cdot \mathbf{v}_{\parallel}, \alpha
\mathbf{v}_{\parallel}\right]
\end{align*}
\]</span></p>
<p>引理 3：对于正交于 <span class="math inline">\(\mathbf{u}\)</span>
的向量 <span
class="math inline">\(\mathbf{v}_{\perp}\)</span>，其四元数为：<span
class="math inline">\(v_{\perp}=\left[0,\mathbf{v}_{\perp}\right]\)</span>，且
<span class="math inline">\(\|\mathbf{u}\|=1\)</span>。设 <span
class="math inline">\(q=\left[\alpha,\beta
\mathbf{u}\right]\)</span>，那么：<span
class="math inline">\(qv_{\perp}=v_{\perp}q^{\star}\)</span></p>
<p>证明：</p>
<p><span class="math display">\[
\begin{align*}
\text { LHS } &amp; =q v_{\perp} \\
&amp; =[\alpha, \beta \mathbf{u}] \left[0, \mathbf{v}_{\perp}\right] \\
&amp; =\left[0-\beta \mathbf{u} \cdot \mathbf{v}_{\perp}, \alpha
\mathbf{v}_{\perp}+\mathbf{0}+\beta \mathbf{u} \times
\mathbf{v}_{\perp}\right] \\
&amp; =\left[0, \alpha \mathbf{v}_{\perp}+\beta \mathbf{u} \times
\mathbf{v}_{\perp}\right]
\end{align*}
\]</span></p>
<p><span class="math display">\[
\begin{align*}
\mathrm{RHS} &amp; =v_{\perp} q^{\star} \\
&amp; =\left[0, \mathbf{v}_{\perp}\right][\alpha,-\beta \mathbf{u}] \\
&amp; =\left[0+\mathbf{v}_{\perp} \cdot \beta \mathbf{u},
\mathbf{0}+\alpha \mathbf{v}_{\perp}+\mathbf{v}_{\perp} \times(-\beta
\mathbf{u})\right]  \\
&amp; =\left[0, \alpha \mathbf{v}_{\perp}+\mathbf{v}_{\perp}
\times(-\beta \mathbf{u})\right] \\
&amp; =\left[0, \alpha \mathbf{v}_{\perp}-(-\beta \mathbf{u}) \times
\mathbf{v}_{\perp}\right]  \\
&amp; =\left[0, \alpha \mathbf{v}_{\perp}+\beta \mathbf{u} \times
\mathbf{v}_{\perp}\right]
\end{align*}
\]</span></p>
<p>现在，我们就能对之前的公式做出最后的变形了：</p>
<p><span class="math display">\[
\begin{align*}
v&#39; &amp; =p p^{\star} v_{\|}+p p v_{\perp} \\
&amp; =p v_{\|} p^*+p v_{\perp} p^{\star} \\
&amp; =p\left(v_{\|}+v_{\perp}\right) p^{\star}\\
&amp;= pvp^{\star}
\end{align*}
\]</span></p>
<p>到这里终于导出了四元数与 3D 旋转的关系，即：</p>
<p>任意向量 <span class="math inline">\(\mathbf{v}\)</span>
绕以单位向量定义的旋转轴 <span class="math inline">\(\mathbf{u}\)</span>
旋转 <span class="math inline">\(theta\)</span> 度之后得到的 <span
class="math inline">\(\mathbf{v}&#39;\)</span> 可以用四元数来表示。令
<span class="math inline">\(v=\left[0,\mathbf{0}\right]\)</span>，<span
class="math inline">\(q=\left[\cos\frac{\theta}{2},\mathbf{u}\sin\frac{\theta}{2}\right]\)</span>，则：</p>
<p><span class="math display">\[
v&#39;=q v q^{\star}=q v q^{-1}
\]</span></p>
<p>这个公式非常简介，比矩阵形式的旋转变换要简单很多。</p>
<p>如果 <span
class="math inline">\(q==\left[\cos\theta,\mathbf{u}\sin\theta\right]\)</span>，那么
<span class="math inline">\(q v q^{\star}\)</span> 表示 <span
class="math inline">\(\mathbf{v}\)</span> 绕着 <span
class="math inline">\(\mathbf{u}\)</span> 旋转 <span
class="math inline">\(2\theta\)</span> 度。</p>
<p>再来看看这个公式，稍微变形下：</p>
<p><span class="math display">\[
v&#39;=q v q^{\star}=qq^{\star}v_{\parallel}+qqv_{\perp}= v_{\parallel}
+ q^2v_{\perp}
\]</span></p>
<p>也就是说，<span class="math inline">\(q v q^{\star}\)</span>
这个变换实际上对平行于旋转轴的分量 <span
class="math inline">\(v_{\parallel}\)</span> 做的变换为 <span
class="math inline">\(qq^{\star}\)</span>，相当于啥也没做。而对于正交于旋转轴的分量
<span class="math inline">\(v_{\perp}\)</span> 则是做了两次变换 <span
class="math inline">\(q^2=qq\)</span>，即旋转了 <span
class="math inline">\(\frac{\theta}{2}+\frac{\theta}{2}=\theta\)</span>
度。</p>
<p>实际上：</p>
<p><span class="math display">\[
qvq^{\star}=\left[0,\mathbf{v}\cos\theta + (1-\cos
\theta)(\mathbf{u}\cdot \mathbf{v})\mathbf{u}
+\left(\mathbf{u}\times\mathbf{v}\right) \sin \theta \right]
\]</span></p>
<blockquote>
<p>证明上述公式可能会用到：<span
class="math inline">\(\mathbf{a}\times\left(\mathbf{b}\times
\mathbf{c}\right)=\left(\mathbf{a}\cdot
\mathbf{c}\right)\mathbf{b}-\left(\mathbf{a}\cdot
\mathbf{b}\right)\mathbf{c}\)</span></p>
</blockquote>
<p>如果有一个单位四元数 <span
class="math inline">\(q=\left[a,\mathbf{b}\right]\)</span>，我们像获取它对应的旋转角度和旋转轴，可以直接得到：</p>
<p>$$ <span class="math display">\[\begin{align*}
\frac{\theta}{2}&amp;=\arccos a\\
\mathbf{u}&amp;=\frac{\mathbf{b}}{\sin
\frac{\theta}{2}}=\frac{\mathbf{b}}{\sin \arccos a}

\end{align*}\]</span> $$</p>
<h3 id="d-旋转的矩阵形式">3D 旋转的矩阵形式</h3>
<p>在实际的应用中，我们可能会需要将旋转与平移和缩放进行复合，所以需
要用到四元数旋转的矩阵形式。前面讨论过，左乘一个四元数 <span
class="math inline">\(q=a+b \mathrm{i} + c \mathrm{j} + d
\mathrm{k}\)</span> 等同于下面这个矩阵：</p>
<p><span class="math display">\[
L\left(q\right)=\begin{bmatrix}
a &amp; -b &amp; -c &amp; -d \\
b &amp; a &amp; -d &amp; c \\
c &amp; d &amp; a &amp; -b \\
d &amp; -c &amp; b &amp; a \\
\end{bmatrix}
\]</span></p>
<p>而右乘 <span class="math inline">\(q\)</span> 等价于：</p>
<p><span class="math display">\[
R\left(q\right)=\begin{bmatrix}
a &amp; -b &amp; -c &amp; -d \\
b &amp; a &amp; d &amp; -c \\
c &amp; -d &amp; a &amp; -b \\
d &amp; c &amp; -b &amp; a \\
\end{bmatrix}
\]</span></p>
<p>所以，我们可以利用这两个公式将 <span
class="math inline">\(v&#39;=qvq^{\star}\)</span> 写成矩阵形式。设 <span
class="math inline">\(a=\cos \frac{\theta}{2}\)</span>、<span
class="math inline">\(b=u_x\sin\frac{\theta}{2}\)</span>、<span
class="math inline">\(c=u_y\sin\frac{\theta}{2}\)</span>、<span
class="math inline">\(d=u_z\sin\frac{\theta}{2}\)</span>、<span
class="math inline">\(q=a+b \mathbf{i} + c \mathbf{j} + d
\mathbf{k}\)</span> 则：</p>
<p><span class="math display">\[
\begin{align*}
q v q^{\star}&amp;=L(q) R\left(q^*\right) v  \\
&amp; =\begin{bmatrix}
a &amp; -b &amp; -c &amp; -d \\
b &amp; a &amp; -d &amp; c \\
c &amp; d &amp; a &amp; -b \\
d &amp; -c &amp; b &amp; a
\end{bmatrix}\begin{bmatrix}
a &amp; b &amp; c &amp; d \\
-b &amp; a &amp; -d &amp; c \\
-c &amp; d &amp; a &amp; -b \\
-d &amp; -c &amp; b &amp; a
\end{bmatrix} v \\
&amp; =\begin{bmatrix}
a^2+b^2+c^2+d^2 &amp; a b-a b-c d+c d &amp; a c+b d-a c-b d &amp; a d-b
c+b c-a d \\
a b-a b+c d-c d &amp; b^2+a^2-d^2-c^2 &amp; b c-a d-a d+b c &amp; b d+a
c+b d+a c \\
a c-b d-a c+b d &amp; b c+a d+a d+b c &amp; c^2-d^2+a^2-b^2 &amp; c d+c
d-a b-a b \\
a d+b c-b c-a d &amp; b d-a c+b d-a c &amp; c d+c d+a b+a b &amp;
d^2-c^2-b^2+a^2
\end{bmatrix}v  \\
\end{align*}
\]</span></p>
<p>将 <span
class="math inline">\(a^2+b^2+c^2+d^2=1\)</span>，带入化简得：</p>
<p><span class="math display">\[
q v q^{\star}=\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1-2 c^2-2 d^2 &amp; 2 b c-2 a d &amp; 2 a c+2 b d \\
0 &amp; 2 b c+2 a d &amp; 1-2 b^2-2 d^2 &amp; 2 c d-2 a b \\
0 &amp; 2 b d-2 a c &amp; 2 a b+2 c d &amp; 1-2 b^2-2 c^2
\end{bmatrix} v
\]</span></p>
<p>我们就得到了矩阵形式得旋转公式：</p>
<p>任意向量 <span class="math inline">\(\mathbf{v}\)</span>
绕以单位向量定义的旋转轴 <span class="math inline">\(\mathbf{u}\)</span>
旋转 <span class="math inline">\(\theta\)</span> 角度之后得 <span
class="math inline">\(\mathbf{v}&#39;\)</span>
可以使用矩阵乘法来表示。令 <span class="math inline">\(a=\cos
\frac{\theta}{2}\)</span>、<span
class="math inline">\(b=u_x\sin\frac{\theta}{2}\)</span>、<span
class="math inline">\(c=u_y\sin\frac{\theta}{2}\)</span>、<span
class="math inline">\(d=u_z\sin\frac{\theta}{2}\)</span>，则：</p>
<p><span class="math display">\[
\mathbf{v}&#39;=\begin{bmatrix}
1-2 c^2-2 d^2 &amp; 2 b c-2 a d &amp; 2 a c+2 b d \\
2 b c+2 a d &amp; 1-2 b^2-2 d^2 &amp; 2 c d-2 a b \\
2 b d-2 a c &amp; 2 a b+2 c d &amp; 1-2 b^2-2 c^2
\end{bmatrix} \mathbf{v}
\]</span></p>
<p>这就是 3D 旋转得矩阵形式。</p>
<h3 id="旋转的复合-1">旋转的复合</h3>
<p>假设有两个表示旋转的四元数 <span
class="math inline">\(q_1\)</span>、<span
class="math inline">\(q_2\)</span>，先对 <span
class="math inline">\(v\)</span> 进行 <span
class="math inline">\(q_1\)</span> 变换，在对 <span
class="math inline">\(v\)</span> 进行 <span
class="math inline">\(q_2\)</span> 变换，变换的结果是什么？</p>
<p>先进行 <span class="math inline">\(q_1\)</span> 变换得到 <span
class="math inline">\(v&#39;\)</span>：</p>
<p><span class="math display">\[
v&#39;=q_1vq_1^{\star}
\]</span></p>
<p>在进行 <span class="math inline">\(q_2\)</span> 变换得到 <span
class="math inline">\(v&#39;&#39;\)</span>：</p>
<p><span class="math display">\[
\begin{align*}
v&#39;&#39;&amp;=q_2v&#39;q_2^{\star}\\
&amp;=q_2q_1vq_1^{\star}q_2^{\star}
\end{align*}
\]</span></p>
<p>考虑到对于四元数 <span class="math inline">\(q_1\)</span> 和 <span
class="math inline">\(q_2\)</span>，有</p>
<p><span class="math display">\[
q_1^{\star}q_2^{\star}=\left(q_2q_1\right)^{\star}
\]</span></p>
<p>这个证明非常简单，只需把两边的 Grassmann
积算出来即可，这里就不证明了。</p>
<p>所以：</p>
<p><span class="math display">\[
v&#39;&#39;=\left(q_2q_1v\right)\left(q_2q_1\right)^{\star}
\]</span></p>
<p>也就是说，两次旋转可以先计算两个四元数的乘积，然后再对 <span
class="math inline">\(v\)</span> 进行变换。</p>
<p>需要注意的是，<span class="math inline">\(q_2q_1\)</span>
这个旋转变换不是分别沿着 <span class="math inline">\(q_1\)</span> 和
<span class="math inline">\(q_2\)</span>
两个旋转轴旋转两次，而是沿着一个全新的旋转轴进行一次旋转，不过结果是一样的</p>
<p>同样地，进行三次旋转：</p>
<p><span class="math display">\[
v&#39;&#39;&#39;=\left(q_3q_2q_1v\right)\left(q_3q_2q_1\right)^{\star}
\]</span></p>
<h3 id="双倍覆盖">双倍覆盖</h3>
<p>四元数与 3D 旋转的关系不是一一对应的。例如，四元数 <span
class="math inline">\(q\)</span> 和 <span
class="math inline">\(-q\)</span> 表示同一个旋转。如果 <span
class="math inline">\(q\)</span> 表示绕着旋转轴 <span
class="math inline">\(\mathbf{u}\)</span> 旋转 <span
class="math inline">\(\theta\)</span> 度，则 <span
class="math inline">\(-q\)</span> 表示沿着旋转轴 <span
class="math inline">\(-\mathbf{u}\)</span> 旋转 <span
class="math inline">\(2\pi-\theta\)</span> 度。</p>
<p><span class="math display">\[
\begin{align*}
-q&amp;=\left[-\cos\frac{\theta}{2},-\mathbf{u}\sin\frac{\theta}{2}\right]\\
&amp;=\left[\cos
\left(\pi-\frac{\theta}{2}\right),(-\mathbf{u})\sin\left(\pi-\frac{\theta}{2}\right)\right]
\end{align*}
\]</span></p>
<p>即：这个四元数旋转角度为：<span
class="math inline">\(2\left(\pi-\frac{\theta}{2}\right)=2\pi-\theta\)</span>，从下图可以看出，<span
class="math inline">\(q\)</span> 和 <span
class="math inline">\(-q\)</span> 表示同一个旋转。</p>
<figure>
<img data-src="https://github.com/XinranSix/comment/assets/62458905/185b146f-0185-48c0-b197-6b7ec0ff2cd6"
alt="双倍覆盖" />
<figcaption aria-hidden="true">双倍覆盖</figcaption>
</figure>
<p>其实从四元数的旋转公式也能到初同样的结果：</p>
<p><span class="math display">\[
(-q)v(-q)^{\star}=(-1)^2qvq^{\star}=qvq^{\star}
\]</span></p>
<p>所以，单位四元数与 3D 旋转有一个「2 对 1 Surjective
Homomorphism）」的关系，或者说单位四元数双倍覆盖了 3D 旋转。</p>
<h3 id="指数形式">指数形式</h3>
<p>类似与复数，四元数也有指数形式。如果 <span
class="math inline">\(\mathbf{u}\)</span>
是一个单位向量，那么对单位四元数 <span
class="math inline">\(u=\left[0,\mathbf{u}\right]\)</span>，有：</p>
<p><span class="math display">\[
\mathrm{e}^{u\theta}=\cos\theta
+u\sin\theta=\cos\theta+\mathbf{u}\sin\theta
\]</span></p>
<p>也就是说，四元数 <span
class="math inline">\(q=\left[\cos\theta,\mathbf{u}\sin\theta\right]\)</span>
可以使用指数表示为：<span
class="math inline">\(\mathrm{e}^{u\theta}\)</span>.</p>
<p>那么任意向量 <span class="math inline">\(v\)</span> 绕以单位向量
<span class="math inline">\(\mathbf{u}\)</span> 旋转 <span
class="math inline">\(\theta\)</span> 角度之后得到的 <span
class="math inline">\(v&#39;\)</span> 可以使用四元数的指数表示。设 <span
class="math inline">\(v=\left[0,\mathbf{v}\right]\)</span>、<span
class="math inline">\(u=\left[0,\mathbf{u}\right]\)</span>，则：</p>
<p><span class="math display">\[
v&#39;=\mathrm{e}^{u\theta}v\mathrm{e}^{-u\theta}
\]</span></p>
<p>有了四元数的指数定义，我们就可以定义四元数的更多运算了。首先是自然对数，对于任意单位四元数
<span
class="math inline">\(q=\left[\cos\theta,\mathbf{u}\sin\theta\right]\)</span>：</p>
<p><span class="math display">\[
\ln q=\ln(\mathrm{e}^{u\theta})=\left[0,\mathbf{u}\theta\right]
\]</span></p>
<p>也可以定义四元数的幂运算：</p>
<p><span class="math display">\[
q^t=\left(\mathrm{e}^{u\theta}\right)^t=\mathrm{e}^{u(\theta
t)}=\left[\cos t\theta,\mathbf{u}\sin t\theta\right]
\]</span></p>
<h2 id="四元数插值">四元数插值</h2>
<p><span class="math display">\[
q_t=\mathrm{Slerp}\left(q_0,q_1,y\right) =
\left(q_1q_0^{\star}\right)^tq_0
\]</span></p>
<blockquote>
<p>先就这样吧，更多细节以后再补充。</p>
</blockquote>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Quaternion">Quaternion |
Wikipedia</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/157721160">四元数指数映射 |
知乎</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>四元数</tag>
        <tag>旋转</tag>
        <tag>欧拉角</tag>
      </tags>
  </entry>
  <entry>
    <title>指针</title>
    <url>/2023/07/16/%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="内存相关概念">内存相关概念</h2>
<p><strong>外存</strong>：又称拓展存储器，长期存放数据，是可掉电的设备，常见的外存设备有：硬盘、flash、ROM、U
盘、光盘、磁带。</p>
<p><strong>内存</strong>：暂时存放数据的设备，掉电丢失数据，厂家的内存有：RAM，DDR.</p>
<p>内存分为<strong>物理内存</strong>和虚拟内存。</p>
<ul>
<li>物理内存：实实在在的存储设备；</li>
<li>虚拟内存：操作系统虚拟出来的内存。</li>
</ul>
<p>操作系统会将虚拟内存和物理内存进行映射。</p>
<p>在 32 位操作系统下，每个进程的寻址范围位
<code>0x00000000~0xffffffff</code>，即
4G，我们在编程时看到的内存地址都是虚拟地址。</p>
<p>在程序运行时，操作系统会将<strong>虚拟内存</strong>进行分区：</p>
<ul>
<li>堆：在动态申请内存时，会在堆区开辟空间；</li>
<li>栈：主要存放局部变量；</li>
<li>静态全局区：
<ul>
<li>位初始化的静态全局区：没有初始化的静态变量（<code>static</code>
修饰的变量），或全局变量存放在此区；</li>
<li>初始化了的静态全局区：初始化过的全局变量、静态变量存在此区。</li>
</ul></li>
<li>代码区：存放代码的区；</li>
<li>文字常量区：存放常量的区；</li>
</ul>
<h2 id="指针的相关概念">指针的相关概念</h2>
<blockquote>
<p>本文均在 32 为平台上进行讨论。</p>
</blockquote>
<p>系统给每个存储单元分配了一个编号，从
<code>0x00000000~0xffffffff</code>，这个编号就是地址。</p>
<blockquote>
<p>指针就是地址。</p>
</blockquote>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/51a85890-ee89-4e25-9489-6545d4a5f796"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>指针变量：一个存放地址编号的变量。</p>
<p>在 32 位平台下，地址总线是 32 位的，所以地址是 32 位编号，占用 4
个字节，所以在 32 位平台下指针变量占用 4 个字节。</p>
<blockquote>
<p>鱼代表鱼，虾代表虾，乌龟代表是王八。对应指针变量只能存放对应类型变量的地址，例如
<code>int</code> 类型的指针只能存放 <code>int</code>
类型变量的地址。</p>
</blockquote>
<p><code>char</code> 占 1
个字节，它有一个地址编号，这个地址编号就是其地址；<code>int</code> 占 4
个字节，它占有 4 个字节的存储单元，有 4 个地址编号。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/67036c70-1ee8-4729-8dbf-3df54f568cd7"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="指针的定义方法">指针的定义方法</h2>
<p>定义指针的语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">数据类型 *指针变量名;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> *p1, p2;</span><br></pre></td></tr></table></figure>
<p>与指针相关的运算符：<code>&amp;</code>、<code>*</code>.</p>
<p><code>&amp;</code> 是取地址运算符，<code>*</code> 是取值运算符。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/1139ce2c-7536-4c61-a440-9ed2d47bd911"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p = &amp;a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d %d\n&quot;</span>, a, *p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p %p\n&quot;</span>, &amp;a, p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/921666e3-b0bc-40a4-8b5e-3577d2859315"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>指针大小：在 32 位系统下，所有类型的指针都是 4 个字节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> *a;</span><br><span class="line">    <span class="type">short</span> *b;</span><br><span class="line">    <span class="type">int</span> *c;</span><br><span class="line">    <span class="type">long</span> *d;</span><br><span class="line">    <span class="type">float</span> *e;</span><br><span class="line">    <span class="type">double</span> *f;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a) = %lld\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(b) = %lld\n&quot;</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(c) = %lld\n&quot;</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(d) = %lld\n&quot;</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(e) = %lld\n&quot;</span>, <span class="keyword">sizeof</span>(e));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(f) = %lld\n&quot;</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/4c425eb6-d0c4-418d-be0a-5ac63d3b2ddc"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="指针的分类">指针的分类</h2>
<ol type="1">
<li><code>char</code> 型指针；</li>
<li><code>short int</code> 型指针；</li>
<li><code>int</code> 指针；</li>
<li><code>long</code> 指针；</li>
<li><code>float</code> 型指针；</li>
<li><code>double</code> 型指针；</li>
<li>函数指针；</li>
<li>结构体指针；</li>
<li>指针的指针；</li>
<li>数组指针。</li>
</ol>
<blockquote>
<p>不管是声明指针，在 32 位操作系统上，均占有 4 个字节。</p>
</blockquote>
<h2 id="指针和变量的关系">指针和变量的关系</h2>
<p>指针可以存放变量的地址。</p>
<p>在程序中，访问变量的值可以字节使用变量名，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line">a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>也可以通过指针来访问变量的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = &amp;a;</span><br><span class="line">*p = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ol type="1">
<li>指针在试用期一定要初始化。</li>
<li>指针只能指向开辟好空间的地址，不能随意保存地址。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p1, *p2, temp, a, b;</span><br><span class="line">    p1 = &amp;a;</span><br><span class="line">    p2 = &amp;b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入:a b的值:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, p1, p2); <span class="comment">// 给p1和p2指向的变量赋值</span></span><br><span class="line">    temp = *p1;             <span class="comment">// 用p1指向的变量（a）给temp赋值</span></span><br><span class="line">    *p1 = *p2;  <span class="comment">// 用p2指向的变量（b）给p1指向的变量（a）赋值</span></span><br><span class="line">    *p2 = temp; <span class="comment">// temp给p2指向的变量（b）赋值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p1=%d *p2=%d\n&quot;</span>, *p1, *p2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/e6af8b05-742b-47a4-b2b0-08926a1105d6"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<blockquote>
<p>注意：对应类型的指针，只能保持对应类型数据的地址，如果想让不同类型的指针互相赋值，需要强制类型转换。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x1234</span>, b = <span class="number">0x5678</span>;</span><br><span class="line">    <span class="type">char</span> *p1, *p2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x %#x\n&quot;</span>, a, b);</span><br><span class="line">    p1 = (<span class="type">char</span> *)&amp;a;</span><br><span class="line">    p2 = (<span class="type">char</span> *)&amp;b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x %#x\n&quot;</span>, *p1, *p2);</span><br><span class="line">    p1++;</span><br><span class="line">    p2++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%#x %#x\n&quot;</span>, *p1, *p2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/a9cbbfec-00d8-43d2-afd0-8618d8d8ec3e"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<blockquote>
<p>注意：</p>
<ol type="1">
<li>使用 <code>*</code>
对指针取值时，取几个字节，由指针类型决定，<code>int</code> 类型的指针取
4 个字节，<code>double</code> 类型的指针取 8 个字节。</li>
<li>对指针进行 <code>+1</code>
操作时，指针会跳过若干字节，跳过的字节的大小有指针类型决定，例如
<code>int</code> 类型的指针会跳过 4 个字节。</li>
</ol>
</blockquote>
<h2 id="指针和数组元素之间的关系">指针和数组元素之间的关系</h2>
<h3 id="数组元素与指针的基本关系">数组元素与指针的基本关系</h3>
<p>变量存放在内存中，有自己的地址编号。数组时多个相同类型变量的集合，每个变量都占用内存空间，都有自己的内存编号，数组在内存中是连续存放的。</p>
<p>指针变量可以指向存放数组元素的地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    p = &amp;a[<span class="number">0</span>]; <span class="comment">// 指针变量p保存了数组a中第0个元素的地址，即a[0]的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问数组数组元素的方法">访问数组数组元素的方法</h3>
<p><strong>方式 1：</strong><code>数组名[索引]</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p><strong>方式 2：</strong><code>指针名 + 下标</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = a;</span><br><span class="line">p[<span class="number">2</span>] = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 C 语言中，数组名就是数组的首地址，即第 0
个元素的地址，是个常量。</p>
</blockquote>
<blockquote>
<p>注意：p 和 a 不同，p 是指针变量，而 a 是个常量。所以可以使用等号给 p
赋值，但不能给 a 赋值。例如：<code>int a[10]; a++;</code>
这种用法是错误的，因为 a 是数组名，是一种地址常量。</p>
</blockquote>
<p><strong>方式 3：</strong>通过指针运算加取值的方法来引用数组的元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = a;</span><br><span class="line">*(p + <span class="number">2</span>) = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p><code>p</code> 是第 个元素的地址，<code>p + 2</code> 是
<code>a[2]</code> 这个元素的地址，对第二个元素的地址取值，即
<code>a[2]</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要将数组名赋值给同类型的指针变量，则此时的指针变量与数组名可</span></span><br><span class="line">    <span class="comment">// 以用相同的方法操作数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a[2]=%d\n&quot;</span>, a[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p[2]=%d\n&quot;</span>, p[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*(a + n) &lt;==&gt; *(p + n) &lt;==&gt; a[n] &lt;==&gt; p[n]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*(p+2) = %d\n&quot;</span>, *(p + <span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*(a+2) = %d\n&quot;</span>, *(a + <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p=%p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p+2=%p\n&quot;</span>, p + <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[0] = %p\n&quot;</span>, &amp;a[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a[2] = %p\n&quot;</span>, &amp;a[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/e1579dc7-a6f4-458f-b131-da3e6d227fc8"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="指针的运算">指针的运算</h2>
<h3 id="指针可以加一个整数">指针可以加一个整数</h3>
<p>往后指几个它指向的变量，结果还是个地址。</p>
<blockquote>
<p>注意：一般来说，指针指向数组是加一个整数才有意义。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> *p, *q;</span><br><span class="line">    <span class="comment">// p和q间隔8个字节，意味着加一个整数最终移动的字节数与指针变量的类型也有关系</span></span><br><span class="line">    p = a;</span><br><span class="line">    q = p + <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;q = %p\n&quot;</span>, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/0796e556-3cb2-4464-9a0b-aba79d814d8f"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="两个相同类型指针可以比较大小">两个相同类型指针可以比较大小</h3>
<blockquote>
<p>注意：只有相同类型的指针指向同一个数组里的元素，比较大小才有意义。</p>
</blockquote>
<p>指向前面元素的指针小于指向后面元素的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> *p, *q;</span><br><span class="line">    p = &amp;a[<span class="number">1</span>];</span><br><span class="line">    q = &amp;a[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">if</span> (p &lt; q) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p &lt; q\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p &gt; q) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p &gt; q\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p = q\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/70dfe7a9-6152-40fd-887a-5f883ed571c6"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="两个相同类型的指针可以做减法">两个相同类型的指针可以做减法</h3>
<blockquote>
<p>注意：只有相同类型的指针指向同一个数组里的元素，做减法才有意义。</p>
</blockquote>
<p>做减法的结果是两个指针之间有多少个元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> *p, *q;</span><br><span class="line">    p = &amp;a[<span class="number">0</span>];</span><br><span class="line">    q = &amp;a[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, q - p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/94c08063-3ba2-4c90-b368-5170dbafb76f"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3
id="两个相同类型的指针可以相互赋值">两个相同类型的指针可以相互赋值</h3>
<blockquote>
<p>注意：只有相同类型的指针才可以互相赋值（<code>void *</code>
类型的除外）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> *p, *q;</span><br><span class="line">    p = &amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d %d\n&quot;</span>, a, *p);</span><br><span class="line">    q = p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*q = %d\n&quot;</span>, *q);</span><br><span class="line">    *q = <span class="number">999</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/06eaf1c8-1cb9-4b39-9819-8302fb3a1b4b"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="指针数组">指针数组</h2>
<p>指针可以保存数组元素的地址，也可以定义一个数组，数组中的元素是若干个相同类型的指针变量，这个数组就是<strong>指针数组</strong>。</p>
<p>定义指针数组的语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">类型说明符 *数组名[元素个数];</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">p[<span class="number">1</span>] = &amp;a;</span><br><span class="line"><span class="type">int</span> b[<span class="number">10</span>];</span><br><span class="line">p[<span class="number">2</span>] = &amp;b[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// p[2] 和 *(p + 2) 是等价的，都是指针数组中的第 2 个元素。</span></span><br></pre></td></tr></table></figure>
<p>指针数组按照其元素进行分类。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *name[<span class="number">5</span>] = &#123;<span class="string">&quot;Follw me&quot;</span>, <span class="string">&quot;BASIC&quot;</span>, <span class="string">&quot;Greatwall&quot;</span>, <span class="string">&quot;FORTRAN&quot;</span>, <span class="string">&quot;Computer&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, name[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/f14afb71-5e32-4fc7-8753-45f8e5e3d07d"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="指针的指针">指针的指针</h2>
<p>指针的指针又称为二级指针。</p>
<p>指针本身也是一个变量，也有地址，可以用二级指针保存其地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;a;</span><br><span class="line">    <span class="type">int</span> **q = &amp;p;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d %d %d\n&quot;</span>, a, *p, **q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p %p %p\n&quot;</span>, &amp;a, p, *q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;p = %p %p\n&quot;</span>, &amp;p, q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;q = %p\n&quot;</span>, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/beb44686-257b-4683-9fdc-00174129116e"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="字符串和指针">字符串和指针</h2>
<p>在 C 语言中，字符串是以 <code>'\0'</code> 结尾的若干字符的集合。</p>
<p>字符串的存储形式：数组、字符串指针、堆。</p>
<ol type="1">
<li><code>char string[100] = "I love C!";</code>， 定义了一个字符数组
<code>string</code>，用来存放多个字符，并且使用 <code>I love C!\0</code>
给 <code>string</code> 数组初始化。</li>
<li><code>char *str = "I love C!"</code>，定义了一个指针变量
<code>str</code>，这个字符串中的字符不能存放在 <code>str</code>
变量中，<code>str</code> 只存放了字符 <code>I</code>
的地址，<code>"I love C!"</code> 存放在文字常量区。</li>
<li><code>char *str = (char*)malloc(10 * sizeof(char));</code>，动态申请了
10 个字节的存储空间，使用首地址个给 <code>str</code> 赋值，可以使用
<code>strcpy(str, "I love C")</code> 的方式将字符串
<code>"I love C!"</code> 拷贝到 <code>str</code> 指向的内存中。</li>
</ol>
<p><strong>可修改性：</strong></p>
<ol type="1">
<li>栈区和全局区内存中的内容是可修改的。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>] = <span class="string">&quot;I love C!&quot;</span>;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;y&#x27;</span>; <span class="comment">// 这是 ok 的</span></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>文字常量区的内容是不可修改的。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *str = <span class="string">&quot;I love C!&quot;</span>;</span><br><span class="line">*str = <span class="string">&#x27;y&#x27;</span>; <span class="comment">// 这是不行的</span></span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>堆区的内容是可以修改的。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *str = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br></pre></td></tr></table></figure>
<p><strong>初始化：</strong></p>
<p>字符数组、指向字符串的指针可以在定义时初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf_aver[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">char</span> *buf_point = <span class="string">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>堆中存放的字符串不能初始化，只能使用
<code>strcpy</code>、<code>scanf</code> 进行赋值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *buf_heap;</span><br><span class="line">buf_heap = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">15</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(buf_heap, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf_heap);</span><br></pre></td></tr></table></figure>
<p><strong>使用时赋值：</strong></p>
<p>字符数组使用 <code>scanf</code> 或者 <code>strcpy</code>
进行赋值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf_aver[<span class="number">128</span>];</span><br><span class="line">buf_aver = <span class="string">&quot;hello kitty&quot;</span>; <span class="comment">//这样是错误的，数组名是个常量</span></span><br><span class="line"><span class="built_in">strcpy</span>(buf_aver, <span class="string">&quot;hello kitty&quot;</span>); <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf_aver); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<p>指向字符串的指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *buf_point;</span><br><span class="line">buf_point = <span class="string">&quot;hello kitty&quot;</span>; <span class="comment">// 正确，buf_point 指向另外一个字符串</span></span><br><span class="line"><span class="built_in">strcpy</span>(buf_point, <span class="string">&quot;hello kitty&quot;</span>); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<h2 id="数组指针">数组指针</h2>
<h3 id="二维数组">二维数组</h3>
<p>二维数组，有行，有列。二维数组可以看成有多个一维数组构成的，是多个一维数组的集合。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>定义了一个 3 行 5 列的二维数组。</p>
<p>可以认为二维数组 a 由 3 个一维数组构成，每个元素是一个一维数组。</p>
<p>二维数组 a 中，<code>a + 1</code>
指向下一个元素，即下一个一维数组，即下一行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a+1=%p\n&quot;</span>, a + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/fab7d608-941e-4bc2-b41a-3e1869c52f0a"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="数组指针的概念">数组指针的概念</h3>
<p>数组本身是一个指针，指向一个数组，对数组指针加
1，指向下一个数组。</p>
<p>数组指针可以用来保存二维数组的首地址。</p>
<h3 id="数组指针的定义方法">数组指针的定义方法</h3>
<p>数组指针的定义语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">指向的数组的类型 (*指针名)[指向的数组元素的个数]</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>定义了一个指向有 5 个元素的 <code>int</code> 类型的指针
p，<code>p + 1</code> 会跳过一个有 5 个数组元素的数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span>(*p)[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a+1=%p\n&quot;</span>, a + <span class="number">1</span>);</span><br><span class="line">    p = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p=%p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p+1=%p\n&quot;</span>, p + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/63a00439-b8df-4193-84fa-a96de3a6930d"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>数组指针的用法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> (*p)[<span class="number">5</span>], <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; p[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">101</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fun(a, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/3faa7ff5-4fc7-42ca-8a17-52750dc99701"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="各种数组指针的定义">各种数组指针的定义</h3>
<p><strong>一维数组指针</strong></p>
<p>一维数组指针，加 1 后指向下一个一维数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>配合每行有 5 个 <code>int</code> 类型的二维数组来用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> c[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> d[<span class="number">6</span>][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">p = a;</span><br><span class="line">p = b;</span><br><span class="line">p = c;</span><br><span class="line">p = d;</span><br></pre></td></tr></table></figure>
<p>上述操作都是可以的。</p>
<p><strong>二维数组指针</strong></p>
<p>二维数组指针，加 1 后指向下一个二维数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">4</span>][<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>配合三维数组来用，三维数组由若干 4 行 5 列的二维数组组成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">4</span>][<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> c[<span class="number">5</span>][<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> d[<span class="number">6</span>][<span class="number">4</span>][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">p = a;</span><br><span class="line">p = b;</span><br><span class="line">p = c;</span><br><span class="line">p = d;</span><br></pre></td></tr></table></figure>
<p>上述操作都是可以的。</p>
<p><strong>三维数组指针</strong></p>
<p>三维数组指针，加 1 后指向下一个三维数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">4</span>][<span class="number">5</span>][<span class="number">6</span>];</span><br></pre></td></tr></table></figure>
<p><code>p + 1</code> 跳一个三维数组，配合
<code>int a[7][4][5][6];</code> 使用。</p>
<h3 id="容易混淆的内容">容易混淆的内容</h3>
<p><strong>指针数组：</strong>是个数组，数组元素是指针。</p>
<p><strong>数组指针：</strong>是个指针，指向一个数组。</p>
<p><strong>指针的指针：</strong>是指向指针的指针。</p>
<h3 id="数组名字取地址">数组名字取地址</h3>
<p>对一维数组名取地址，变成一位数组指针，即加 1 跳一个一维数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p><code>a + 1</code> 跳一个 <code>int</code> 元素，即 <code>a[1]</code>
的地址，<code>a</code> 和 <code>a + 1</code> 相差一个元素，4
个字节。</p>
<p><code>&amp;a</code> 就变成了一个一维数组指针，是
<code>int(*p)[10]</code> 类型的，<code>(&amp;a) + 1</code> 和
<code>&amp;a</code> 相差一个数组，10 个元素，40 个字节。</p>
<h3 id="数组名字和指针变量的区别">数组名字和指针变量的区别</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = a;</span><br></pre></td></tr></table></figure>
<p><strong>相同点：</strong><code>a</code> 是数组的名字，是
<code>a[0]</code> 的地址，<code>p</code> 也保存了 <code>a[0]</code>
的地址，即 <code>a</code> 和 <code>p</code> 都指向
<code>a[0]</code>，所以在访问数组元素时，<code>a</code> 和
<code>p</code> 是等价的。</p>
<p><strong>不同点：</strong></p>
<ol type="1">
<li><code>a</code> 是常量，<code>p</code> 是变量，可以使用
<code>=</code> 运算符为 <code>p</code> 赋值，但是不能为 <code>a</code>
赋值；</li>
<li>对 <code>a</code> 取地址和对 <code>p</code> 取地址得到的结果不同。对
<code>a</code> 取地址得到的是指针数组，对 <code>p</code>
取地址得到的是指针的指针。</li>
</ol>
<h3 id="多维数组中指针的转换">多维数组中指针的转换</h3>
<p>在二维数组中，行地址取 <code>*</code>
会将指针降级，由行地址变成指向这一行第 0 个元素的指针，取 <code>*</code>
之后还是会指向同一个地方，但指针类型不一样了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a +1=%p\n&quot;</span>, a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*a =%p\n&quot;</span>, *a); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(*a)+1 =%p\n&quot;</span>, (*a) + <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img data-src="https://github.com/XinranSix/docs/assets/62458905/4cdf558d-d9fd-4187-aa9c-c45318b1e1aa" alt="image"  /></p>
<h2 id="指针与函数的关系">指针与函数的关系</h2>
<h3 id="指针作为函数的参数">指针作为函数的参数</h3>
<p>指针可以作为函数的参数。</p>
<p>C 语言中的参数传递方式：复制传参、地址传参。</p>
<p><strong>复制传参：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in fun: a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p, &amp;b = %p\n&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before fun: a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p, &amp;b = %p\n&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    fun(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after fun: a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/fbf8f802-cc9d-4b0b-bdff-85cfcbc1f2e2"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p><strong>地址传参：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> *q)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = *p;</span><br><span class="line">    *p = *q;</span><br><span class="line">    *q = temp;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in fun: *p = %d, *q = %d\n&quot;</span>, *p, *q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %p, q = %p\n&quot;</span>, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before fun: a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p, &amp;b = %p\n&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    fun(&amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after fun: a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/9d3569fb-81eb-4624-81cf-a1e8b4a7a155"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="传数组">传数组</h3>
<p>将数组为参数传递给函数，传递的是数组的地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传一维数组</span></span><br><span class="line"><span class="comment">// void fun1(int p[])//形式1</span></span><br><span class="line"><span class="comment">// 形式2(常用)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">(<span class="type">int</span> *p)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(p + <span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    fun1(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传二维数组</span></span><br><span class="line"><span class="comment">// void fun2( int p[][4] )//形式1</span></span><br><span class="line"><span class="comment">// 形式2：通过数组指针</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun2</span><span class="params">(<span class="type">int</span> (*p)[<span class="number">4</span>])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p[<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(*(p + <span class="number">1</span>) + <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    fun2(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun3</span><span class="params">(<span class="type">char</span> **q)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p[<span class="number">3</span>] = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;kitty&quot;</span>&#125;;</span><br><span class="line">    fun3(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    test1();</span><br><span class="line">    test2();</span><br><span class="line">    test3();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/2b905c47-9548-49fe-8ac8-0f28d3d07d49"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="指针函数">指针函数</h3>
<p>返回值为指针的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针函数：指针作为函数的返回值</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fun</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 栈区开辟的空间会随着当前代码段的结束而释放空间</span></span><br><span class="line">    <span class="comment">// char str[100] = &quot;hello world&quot;;</span></span><br><span class="line">    <span class="comment">// 静态区的空间不会随着当前代码段的结束而释放空间</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> str[<span class="number">100</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    p = fun();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = %s\n&quot;</span>, p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/73160357-c6c7-4219-9769-aae6d1ae19c6"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="函数指针">函数指针</h3>
<p>在 C
语言中，函数名就是函数的首地址，可以定义一个函数指针变量指向这个函数。</p>
<p><strong>函数指针的定义语法：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">返回值类型 (*指针名)(形参列表);</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    p = max;</span><br><span class="line">    p = min;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>调用函数的方法：</strong></p>
<p>通过函数的名字调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    num = max(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过函数指针调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">    p = max;</span><br><span class="line">    num = p(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数指针数组：</strong></p>
<p>是一个数组，每个元素都是一个函数指针。</p>
<p>定义方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">返回值类型 (*指针名)[函数指针的个数](形参列表);</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*p)[<span class="number">10</span>](<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<p>定义了一个函数指针数组，有 10 个元素，每个元素指向一个返回值为
<code>int</code>，有两个 <code>int</code> 类型的参数的指针。</p>
<p><strong>函数指针最常用的地方：</strong>将函数作为另外一个是函数的参数传递过去，即回调函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mux</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dive</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="keyword">return</span> x / y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = (*p)(a, b);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    num = process(add, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line">    num = process(sub, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line">    num = process(mux, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line">    num = process(dive, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/0381f37e-89f5-4ae6-9252-e1c0c0099cc8"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="特殊指针">特殊指针</h2>
<p><strong><code>void</code>
类型的指针：</strong>万能指针，可以将任意类型的指针赋值给他，但
<code>void</code>
类型的指针要转换成其他类型的指针必须要强转。有些函数的参数或者返回值就是
<code>void *</code> 类型。</p>
<p><code>NULL</code>：空指针，编号为 0 的指针，地址为
<code>0x00000000</code>，一般用 <code>NULL</code> 给指针初始化。</p>
<h2 id="main-函数传参">main 函数传参</h2>
<p>C 语言中主函数的头为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>;</span><br></pre></td></tr></table></figure>
<p><code>argv</code>：记录输入的参数个数。</p>
<p><code>argv</code>：记录输入的参数值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc=%d\n&quot;</span>, argc);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]=%s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用如下命令运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">main10.exe nihao hello world</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/80b7aaf2-06bb-483a-9e42-7002dfcf88f2"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>可以看到第一个参数是程序在计算机上的绝对路径，从第 2
个参数开始才是我们输入的值。</p>
]]></content>
      <categories>
        <category>C 语言基础</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2023/07/16/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="数组的概念">数组的概念</h2>
<p>数组是若干相同类型的数据的在内存中有序存储的集合。</p>
<ul>
<li>数组用于存储一组数据。</li>
<li>数组中存储的数据类型必须相同。</li>
<li>数组会在内存开辟一块连续的空间。</li>
</ul>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<p>定义了一个整型数组 a，a 是数组名，数组中每个元素类型都是
<code>int</code>，而且在内存中连续储存，这 10
个元素分别是：<code>a[0]</code>、...、<code>a[9]</code>，数组索引从 0
开始。</p>
<h2 id="数组的分类">数组的分类</h2>
<h3 id="按元素类型分类">按元素类型分类</h3>
<ol type="1">
<li>字符数组：<code>char s[10];</code></li>
<li>短整型数组：<code>short int a[10];</code></li>
<li>整形数组：<code>int a[10];</code></li>
<li>长整型数组：<code>long int a[5];</code></li>
<li>浮点型数组：<code>float a[6];</code>、<code>double a[8];</code></li>
<li>指针数组：<code>char *a[10];</code>、<code>int *a[10];</code></li>
<li>结构体数组：<code>struct stu boy[10];</code></li>
</ol>
<h3 id="按维数分类">按维数分类</h3>
<ul>
<li>一维数组：<code>int a[30];</code></li>
<li>二维数组：<code>int a[2][30];</code>，有行有列，是一维数组的数组。</li>
<li>多维数组：<code>int a[4][2][10];</code>，三维数组由多个相同的二维数组构成。</li>
</ul>
<h2 id="数组的定义">数组的定义</h2>
<h3 id="一维数组的定义">一维数组的定义</h3>
<p>语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">数据类型 数组名[数组元素个数];</span><br><span class="line">数据类型 数组名[] = &#123;元素<span class="number">1</span>, 元素<span class="number">2</span>, 元素<span class="number">3</span>, ...&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>定义数组是数组元素个数必须为整型常量。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(a) = %lld %lld\n&quot;</span>, <span class="keyword">sizeof</span>(a), <span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> b[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(b) = %lld\n&quot;</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/notes/assets/62458905/f1759384-7f0b-47c6-8c4c-db1de36fbb0a"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="二维数组的定义">二维数组的定义</h3>
<p>语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">数据类型 数组名[行数][列数];</span><br><span class="line">数据类型 数组名[][列数] = &#123;元素<span class="number">1</span>, 元素<span class="number">2</span>, 元素<span class="number">3</span>, ...&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>二位数组的行数可以省略，但列数不能省略。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c[<span class="number">2</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(c) = %lld %lld\n&quot;</span>, <span class="keyword">sizeof</span>(c), <span class="number">2</span> * <span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> d[][<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(d) = %lld\n&quot;</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/notes/assets/62458905/b9fe76a8-a4a1-464b-9027-e3fbd621d88b"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="定义并初始化">定义并初始化</h2>
<h3 id="一维数组的初始化">一维数组的初始化</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以一维数组的初始化</span></span><br><span class="line">    <span class="comment">// 如果不初始化，直接使用会是随机值</span></span><br><span class="line">    <span class="comment">// int a[4];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化方式1：全部初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int a[4] = &#123;123, 78, 666, 476&#125;;</span></span><br><span class="line">    <span class="comment">// 如果是全部 初始化，可以不指定数组元素的个数，系统会自动分配</span></span><br><span class="line">    <span class="comment">// int a[] = &#123;10, 20, 30, 40&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化方式2：局部初始化</span></span><br><span class="line">    <span class="comment">// 未初始化的位置的元素自动赋值为0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a[<span class="number">4</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/notes/assets/62458905/deaba5ad-6bf5-493d-b720-2891846d8203"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>一维数组还可以按位置初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    int i = 0;</span><br><span class="line">    int arr[5] = &#123;[1] = 10, [3] = 20&#125;;</span><br><span class="line"></span><br><span class="line">    printf(&quot;count: %ld&quot;, sizeof(arr) / sizeof(arr[0]));</span><br><span class="line">    for (int i = 0; i &lt; sizeof(arr) / sizeof(arr[0]); ++i) &#123;</span><br><span class="line">        printf(&quot;arr[%d] = %d\n&quot;, i, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维数组的初始化">二维数组的初始化</h3>
<p><strong>按行初始化</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全部初始化</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 部分初始化</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>逐个初始化</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全部初始化：</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">// 部分初始化：</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>按钮：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二维数组的初始化</span></span><br><span class="line">    <span class="comment">// int a[2][3];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化方式1：按行初始化</span></span><br><span class="line">    <span class="comment">// 全部初始化</span></span><br><span class="line">    <span class="comment">// int a[2][3] = &#123;&#123;10, 20, 30&#125;, &#123;666, 777, 888&#125;&#125;;</span></span><br><span class="line">    <span class="comment">// 局部初始化</span></span><br><span class="line">    <span class="comment">// 没有赋值的位置的元素自动为0</span></span><br><span class="line">    <span class="comment">// int a[2][3] = &#123;&#123;10, 20&#125;, &#123;666&#125;&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化方式2：逐个初始化</span></span><br><span class="line">    <span class="comment">// 全部初始化</span></span><br><span class="line">    <span class="comment">// int a[2][3] = &#123;1, 2, 3, 4, 5, 6&#125;;</span></span><br><span class="line">    <span class="comment">// 局部初始化</span></span><br><span class="line">    <span class="comment">// 没有赋值的位置的元素自动为0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/notes/assets/62458905/4db0e9e4-6530-4403-9040-b816257133d4"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="数组元素的引用方法">数组元素的引用方法</h2>
<p>一维数组元素的引用方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">数组名[索引];</span><br></pre></td></tr></table></figure>
<p>二维数组元素的引用方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">数组名[行索引][列索引];</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a[<span class="number">6</span>] = &#123;<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>, <span class="number">444</span>, <span class="number">555</span>, <span class="number">666</span>&#125;;</span><br><span class="line">    a[<span class="number">3</span>] = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="type">int</span>); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a[%d] = %d\n&quot;</span>, i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**********************\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">                   <span class="number">5</span>, <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,</span><br><span class="line"></span><br><span class="line">                   <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;</span><br><span class="line"></span><br><span class="line">    b[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; <span class="number">3</span>; m++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">4</span>; n++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%-4d&quot;</span>, b[m][n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/notes/assets/62458905/7fcce4a7-b2dd-4771-802a-dd9e6367d944"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="字符数组的定义和初始化问题">字符数组的定义和初始化问题</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c1[] = &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> c2[] = <span class="string">&quot;c prog&quot;</span>;</span><br><span class="line"><span class="type">char</span> a1[][<span class="number">5</span>] = &#123;&#123;<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;, &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125;&#125;;</span><br><span class="line"><span class="type">char</span> a2[][<span class="number">6</span>] = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>字符数组的引用：</p>
<ol type="1">
<li>用字符串方式赋值比用字符逐个赋值要多占 1
个字节，用于存放字符串结束标志 <code>\0</code>.</li>
<li>上面的数组 c2 在内存中的实际存放情况为：</li>
</ol>
<figure>
<img data-src="https://github.com/XinranSix/notes/assets/62458905/f680e8aa-4ca1-4fbf-b09e-d499cda6f151"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<ol start="3" type="1">
<li>由于采用了 <code>\0</code>
标志，字符数组的输入输出将变得简单方便。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ch[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ch = %s\n&quot;</span>, ch);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure>
<img data-src="https://github.com/XinranSix/notes/assets/62458905/78d4fef7-5eb8-4aa6-a0dd-53d206fec4c6"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
]]></content>
      <categories>
        <category>C 语言基础</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2023/07/16/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="排序算法概述">排序算法概述</h2>
<p>对排序严格点得到定义是：假设含有 <span
class="math inline">\(n\)</span> 个记录的序列为 <span
class="math inline">\(\left\{r_1, r_2, \cdots,
r_n\right\}\)</span>，其相对应的关键字分别为：<span
class="math inline">\(\left\{k_1, k_2, \cdots,
k_n\right\}\)</span>，需确定 <span
class="math inline">\(1,2,3,\cdots,n\)</span> 的一种排列 <span
class="math inline">\(p_1,p_2,\cdots,p_n\)</span>，使其相应的关键字满足
<span class="math inline">\(k_{p_1} \leqslant k_{p_2} \leqslant \cdots
\leqslant k_{p_n}\)</span>
非递减（或非递增）关系，即使得序列成为一个按关键字有序的序列：<span
class="math inline">\(\left\{r_{p_1},r_{p_2},\cdots,r_{p_n}\right\}\)</span>，这样的操作就成为排序。</p>
<p>排序算法的稳定性：对于一个排序算法，假设 <span
class="math inline">\(k_i=k_j \left(1\leqslant i \leqslant n, 1\leqslant
j\leqslant n,i \neq j\right)\)</span>，且在排序前的序列中 <span
class="math inline">\(r_i\)</span> 领先于 <span
class="math inline">\(r_j\)</span>（即 <span class="math inline">\(i \lt
j\)</span>）。如果排序后 <span class="math inline">\(r_i\)</span>
仍领先于 <span
class="math inline">\(r_j\)</span>，则称所用的排序算法是稳定的，否则是不稳定的</p>
<p>排序可分为<strong>内排序</strong>与<strong>外排序</strong>，内排序在排序过程中数据全部放置在内存中，外排序由于数据太对，不能将数据一次性加载在内存中，在排序过程中需要多次在内外存直接交换数据。</p>
<p>十种常见排序算法可以分为两大类：</p>
<ul>
<li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破
<span class="math inline">\(\Omicron \left(n \log
n\right)\)</span>，因此也称为非线性时间比较类排序。</li>
<li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</li>
</ul>
<p>对于排序算法的评价也是从时间和空间的角度出发，即排序的时间和所用的额外空间。排序算法的时间开销主要由比较和移动产生。额外空间的产生是因为有些算法需要借助辅助空间才能完成。</p>
<p>本文会介绍冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、桶排序、计数排序和基数排序，其中冒泡排序、选择排序和插入排序是简单的排序算法，希尔排序、归并排序、堆排序、快速快速排序是改进算法。</p>
<p>排序算法性能总结表：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/71546103-e328-4cbb-ae49-126208452285"
alt="排序算法性能" />
<figcaption aria-hidden="true">排序算法性能</figcaption>
</figure>
<h2 id="冒泡排序">冒泡排序</h2>
<p>冒泡排序是一种简单的排序算法。它重复地遍历要排序的数组，一次比较两个元素，如果它们逆序就把它们交换过来。遍历数组的工作是重复地进行直到没有再需要交换的相邻元素，也就是说该数组已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢「浮」到数组的后面。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/eb2cea36-58d0-4622-9856-b1bcce77093c"
alt="v2-33a947c71ad62b254cab62e5364d2813_b" />
<figcaption
aria-hidden="true">v2-33a947c71ad62b254cab62e5364d2813_b</figcaption>
</figure>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上如果在某一轮中没有进行交换操作，则说明数组已经有序，所以此时可结束排序，可利用这一点进行代码优化，优化后的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>复杂度分析：对于改进后的算法，最好的情况是数组本来就是有序的，只是进行了
<span class="math inline">\(n - 1\)</span> 次的比较，所以时间复杂度为
<span class="math inline">\(\Omicron
\left(n\right)\)</span>；最坏的情况就是数组是逆序的时候，此时比较次数为：
<span class="math display">\[
\sum_{i=2}^{n}\left(i - 1\right) = \frac{n \left(n - 1\right)}{2}
\]</span> 比较次数也是相同数量级的，所以时间复杂度为 <span
class="math inline">\(\Omicron \left(n^2\right)\)</span>.</p>
<p>在相邻元素相等时，不交换它们的位置可保证算法是稳定的算法。</p>
<h2 id="选择排序">选择排序</h2>
<p>选择排序是一种简单直观的排序算法，它也是一种交换排序算法，和冒泡排序有一定的相似度，可以认为选择排序是冒泡排序的一种改进。</p>
<p>选择排序进行进行 <span class="math inline">\(n - 1\)</span>
次遍历，每次遍历从 <span class="math inline">\(\left[i + 1
,n\right]\)</span> 这个区间中选出最小值与第 <span
class="math inline">\(i\)</span> 个元素交换（当然如果第 <span
class="math inline">\(i\)</span> 个元素是最小的则无需交换）。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/adea5408-a1cb-425b-bc51-9bc2e6970ab8"
alt="v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b" />
<figcaption
aria-hidden="true">v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b</figcaption>
</figure>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void selection_sort(int *arr, int n) &#123;</span><br><span class="line">    if (arr == nullptr)</span><br><span class="line">        return;</span><br><span class="line">    if (n &lt;= 1)</span><br><span class="line">        return;</span><br><span class="line">    for (int i = 0; i &lt; n - 1; ++i) &#123;</span><br><span class="line">        int idx = i;</span><br><span class="line">        for (int j = i + 1; j &lt; n; ++j) &#123;</span><br><span class="line">            if (arr[j] &lt; arr[idx]) &#123;</span><br><span class="line">                idx = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (idx != i) &#123;</span><br><span class="line">            int t = arr[idx];</span><br><span class="line">            arr[idx] = arr[i];</span><br><span class="line">            arr[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>复杂度分析：无论什么情况，比较次数是一样多的，第 <span
class="math inline">\(i\)</span> 趟排序的需要比较 <span
class="math inline">\(n - i\)</span> 次，比较次数为： <span
class="math display">\[
\sum_{i=1}^{n-1}\left(n - i\right) = \frac{n \left(n - 1\right)}{2}
\]</span> 最好情况下交换次数为 <span
class="math inline">\(0\)</span>，最坏情况下交换次数为 <span
class="math inline">\(n - 1\)</span>，所以时间复杂度为 <span
class="math inline">\(\Omicron \left(n^2\right)\)</span>.
选择排序的略优于冒泡排序。</p>
<h2 id="插入排序">插入排序</h2>
<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/4dd2245a-49a1-40cc-9165-45056a7e931a"
alt="insertionSort" />
<figcaption aria-hidden="true">insertionSort</figcaption>
</figure>
<p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>
<p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">nullptr</span> || n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = arr[i];</span><br><span class="line">        <span class="type">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; tmp &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">            arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：最好情况下做了 <span class="math inline">\(n - 1\)</span>
次比较，没有移动操作，时间复杂度为 <span class="math inline">\(\Omicron
\left(n^2\right)\)</span>. 最坏的情况下，即数组是逆序的，比较次数为：
<span class="math display">\[
\sum_{i=2}^{n}i = \frac{\left(n + 2\right)\left(n - 1\right)}{2}
\]</span> 移动次数也达到最大值： <span class="math display">\[
\sum_{i=2}^{n}\left(i + 1\right) = \frac{\left(n + 4\right)\left(n -
1\right)}{2}
\]</span> 平均比较和移动次数约为 <span
class="math inline">\(\frac{n^2}{4}\)</span>. 所以，插入排序的复杂度为
<span class="math inline">\(\Omicron \left(n^2\right)\)</span>.</p>
<p>插入排序优于冒泡排序和选择排序。</p>
<h2 id="希尔排序">希尔排序</h2>
<p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>
</ul>
<p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录「基本有序」时，再对全体记录进行依次直接插入排序。</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/ca6c68c6-e779-4c84-928a-b92afed05af9"
alt="687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31393430" />
<figcaption
aria-hidden="true">687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31393430</figcaption>
</figure>
<p>选择一个增量序列 <span class="math inline">\(t_1,
t_2，\cdots,t_k\)</span>，其中对于 <span class="math inline">\(i \gt
j\)</span>，有 <span class="math inline">\(t_i \gt t_j\)</span>，且
<span class="math inline">\(t_k = 1\)</span>。按增量序列个数 <span
class="math inline">\(k\)</span>，对序列进行 <span
class="math inline">\(k\)</span> 趟排序；每趟排序，根据对应的增量 <span
class="math inline">\(t_i\)</span>，将待排序列分割成若干长度为 <span
class="math inline">\(m\)</span>
的子序列，分别对各子表进行直接插入排序。仅增量因子为 1
时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shell_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; n / <span class="number">3</span>) &#123;</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= h &amp;&amp; arr[j] &lt; arr[j - h]; j -= h) &#123;</span><br><span class="line">                <span class="type">int</span> tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j - h];</span><br><span class="line">                arr[j - h] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：对增量的选取很重要，这里增量通过
<code>h = 3 * h + 1</code>
的方式得到，但迄今为止没有找到一个非常好的增量选取方式。不过大量研究表明，当增量序列为
<span class="math inline">\(\text{delta[k]} = 2^{t-k+1}-1\left(0
\leqslant k \leqslant \lfloor\log_2{(n+1)}\rfloor\right)\)</span>
时，可以获得不错的效果，时间复杂度为 <span
class="math inline">\(\Omicron
\left(n^{\frac{3}{2}}\right)\)</span>，要好于直接插入排序的 <span
class="math inline">\(\Omicron
\left(n^2\right)\)</span>。需要注意的是，增量排序的最好一个增量值必须等于
1 才行。由于数据是跳跃式的移动，希尔排序不是稳定的排序算法。</p>
<blockquote>
<p>希尔排序是第一个突破 <span class="math inline">\(\Omicron
\left(n^2\right)\)</span> 的排序算法。</p>
</blockquote>
<h2 id="归并排序">归并排序</h2>
<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。</p>
<p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ul>
<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2
种方法）；</li>
<li>自下而上的迭代。</li>
</ul>
<p><strong>算法步骤：</strong></p>
<ol type="1">
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/463ae480-61e2-42c7-a2dc-5676015516ab"
alt="mergeSort" />
<figcaption aria-hidden="true">mergeSort</figcaption>
</figure>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">meger_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> tmp[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">meger_sort</span>(arr, tmp, l, mid);</span><br><span class="line">    <span class="built_in">meger_sort</span>(arr, tmp, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="type">int</span> i = l;</span><br><span class="line">    <span class="type">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">            tmp[k++] = arr[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        tmp[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) &#123;</span><br><span class="line">        tmp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; ++i, ++j) &#123;</span><br><span class="line">        arr[i] = tmp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，我这里给出的代码的区间的边界值都是可以取到的</p>
</blockquote>
<p>复杂度分析：递归树的每层的时间为 <span class="math inline">\(\Omicron
\left(n\right)\)</span>，树的高度为 <span
class="math inline">\(\lceil\log_2{(n)}\rceil\)</span>，所以时间复杂度为
<span class="math inline">\(\Omicron \left(n \log n \right)\)</span>.
这是归并排序最好、最坏和平均时间复杂度。由于归并排序需要递归和借助一个数组，所以空间复杂度为
<span class="math inline">\(\Omicron \left(n + \log
n\right)\)</span>。可以看出，归并排序是一个稳定的排序算法，是一个比较占用空间但效率较高的算法。</p>
<p>当然有非递归的归并排序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *a = arr;</span><br><span class="line">    <span class="type">int</span> *b = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i += i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j += i + i) &#123;</span><br><span class="line">            <span class="type">int</span> mid = <span class="built_in">min</span>(i + j, n) - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> k = j;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> l1 = j, r1 = mid;</span><br><span class="line">            <span class="type">int</span> l2 = mid + <span class="number">1</span>, r2 = <span class="built_in">min</span>(j + i + i, n) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (l1 &lt;= r1 &amp;&amp; l2 &lt;= r2) &#123;</span><br><span class="line">                b[k++] = a[l1] &lt; a[l2] ? a[l1++] : a[l2++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l1 &lt;= r1) &#123;</span><br><span class="line">                b[k++] = a[l1++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l2 &lt;= r2) &#123;</span><br><span class="line">                b[k++] = a[l2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> *temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归的归并排序的空间复杂度为 <span class="math inline">\(\Omicron
\left(n \right)\)</span>.</p>
<h2 id="快速排序">快速排序</h2>
<p>快速排序是由东尼 · 霍尔所发展的一种排序算法。在平均状况下，排序 <span
class="math inline">\(n\)</span> 个项目要 <span
class="math inline">\(\Omicron \left(n \log n \right)\)</span>
次比较。在最坏状况下则需要 <span class="math inline">\(\Omicron
\left(n^2 \right)\)</span>
次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 <span
class="math inline">\(\Omicron \left(n \log n \right)\)</span>
算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。</p>
<p>快速排序的基本思想是：通过一趟排序将待排序记录分隔成独立的两部分，其中一部分记录的关键字均比另外一部分记录关键字小，则可对这两部分记录继续进行排序，以达到整个序列有序的目的。</p>
<p>快速排序使用分治法策略来把一个串行分为两个子串行。</p>
<p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p>
<p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然
Worst Case 的时间复杂度达到了 <span class="math inline">\(\Omicron
\left(n^2
\right)\)</span>，但是人家就是优秀，在大多数情况下都比平均时间复杂度为
<span class="math inline">\(\Omicron \left(n \log n \right)\)</span>
的排序算法表现要更好，可是这是为什么呢，《算法艺术与信息学竞赛》上说：</p>
<blockquote>
<p>快速排序的最坏运行情况是 <span class="math inline">\(\Omicron
\left(n^2 \right)\)</span>，比如说顺序数列的快排。但它的平摊期望时间是
<span class="math inline">\(\Omicron \left(n \log n \right)\)</span>，且
<span class="math inline">\(\Omicron \left(n \log n \right)\)</span>
记号中隐含的常数因子很小，比复杂度稳定等于 <span
class="math inline">\(\Omicron \left(n \log n \right)\)</span>
的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>
</blockquote>
<p><strong>算法步骤：</strong></p>
<ol type="1">
<li>从数列中挑出一个元素，称为「基准」（pivot）;</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li>
</ol>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/824c46ec-f579-4e81-8921-b77e4ff1f611"
alt="quickSort" />
<figcaption aria-hidden="true">quickSort</figcaption>
</figure>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = arr[(l + r) / <span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[++i] &lt; x)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">while</span> (arr[--j] &gt; x)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，我这里给出的代码的区间的边界值都是可以取到的。</p>
</blockquote>
<p>复杂度分析：在最好的情况下，基准值每次划分的很均匀，如果排序 <span
class="math inline">\(n\)</span> 个关键字，其递归树的深度为 <span
class="math inline">\(\lfloor\log_2{n} + 1\rfloor\)</span>，需递归 <span
class="math inline">\(\log_2\)</span> 次，需要的时间为 <span
class="math inline">\(T\left(n\right)\)</span>
的话，第一个划分时需要将整个数组扫描一遍，做 <span
class="math inline">\(n\)</span>
次比较，基准值将数组一分为二，那么各种还需要 <span
class="math inline">\(T\left(\frac{n}{2}\right)\)</span>
的时间。于是乎我们可以得到如下公式： <span class="math display">\[
\begin{aligned}
T\left(n\right) &amp;\leqslant
T\left(\frac{n}{2}\right),T\left(1\right)=0\\
T\left(n\right) &amp;\leqslant 2\left(2T\left(\frac{n}{4}\right) +
\frac{n}{2}\right) = 4T\left(\frac{n}{4}\right) + 2n\\
T\left(n\right) &amp;\leqslant 4\left(2T\left(\frac{n}{8}\right) +
\frac{n}{4}\right) = 8T\left(\frac{n}{8}\right) + 3n \\
\cdots \\
T\left(n\right) &amp;\leqslant nT\left(1\right) + \left(\log_2 n\right)
\times n = \Omicron \left(n \log n \right)
\end{aligned}
\]</span></p>
<p>也就是说，在最优的情况下，快速排序算法的时间复杂度是 <span
class="math inline">\(\Omicron \left(n \log n \right)\)</span>.</p>
<p>在最坏的情况下，待排序的序列为正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，另外一个为空。把递归树画出来，他就是一颗斜树。此时需要执行
<span class="math inline">\(n - 1\)</span> 次递归调用，且第 <span
class="math inline">\(i\)</span> 次划分需要经过 <span
class="math inline">\(n - i\)</span> 次关键字的比较才能找到第 <span
class="math inline">\(i\)</span> 个记录，因此比较次数为： <span
class="math display">\[
\sum_{i=1}^{n - 1}\left(n - i\right) = n  -1 + n - 2 + \cdots + 1 =
\frac{n(n - 1)}{2}
\]</span> 其最终时间复杂度为 <span class="math inline">\(\Omicron \left(
n^2 \right)\)</span>.</p>
<p>平均情况下，时间复杂度也为 <span class="math inline">\(\Omicron
\left(n \log n \right)\)</span>.</p>
<p>基准值的选取对快速排序的效率较大，我们可以使用随机化算法，每次随机选取一个基准值，以达到更平均的效果。同时，我们也要注意避免不必要的比较。</p>
<p>在数据量较小的时候，我们可考虑使用直接插入排序。</p>
<h2 id="堆排序">堆排序</h2>
<p>如果有一个关键码的集合 <span class="math inline">\(K =
\left\{k_0,k_1,k_2,\cdots,k_{n-1}\right\}\)</span>，把它的所有元素按完全二叉树的顺序存储在一个一维数组中，并满足：$k_i
k_{2i+1} $ 且 <span class="math inline">\(k_i \leqslant K_{2i =
2}\)</span>，则称为小根堆（还有大根堆）。</p>
<blockquote>
<p>下面只讨论小根堆。</p>
</blockquote>
<p>堆有如下性质：</p>
<ol type="1">
<li>堆中某个节点不大于其父节点的值。</li>
<li>堆总是一颗完全二叉树（这也是我们能将其放入一个一维数组中的前提）。</li>
<li>堆以层序遍历的顺序存在数组中，有些文章不使用数组的第 <span
class="math inline">\(0\)</span>
个元素，而从数组的第一个元素开始存，我这里从第 0 个元素开始存。</li>
<li>对于第 <span class="math inline">\(i\)</span>
个元素，其父节点的索引为 <span class="math inline">\(\lfloor \frac{i -
1}{2}\rfloor\)</span>，左孩子的索引为 <span class="math inline">\(2i +
1\)</span>，右孩子的索引为 <span class="math inline">\(2i
+2\)</span>.</li>
</ol>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/d66bf8bd-2fca-4674-a442-af22c3130f9a"
alt="20210125144956737" />
<figcaption aria-hidden="true">20210125144956737</figcaption>
</figure>
<p>堆的两个重要操作是向上调整算法和向下调整算法。</p>
<p>向下调整算法：</p>
<ol type="1">
<li>先设定根节点为当前节点（通过下标获取，标记为cur），比较左右子树的值，找出更小的值，用
child 来标记。</li>
<li>比较 child 和 cur 的值，如果 child 比 cur
小，则不满足小堆的规则，需要进行交换。</li>
<li>如果 child 比 cur 大，满足小堆的规则，不需要交换，调整结束。</li>
<li>处理完一个节点之后，从当前的 child 出发，循环之前的过程。</li>
</ol>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/dd378c36-fb6b-4602-8c08-00145dfbe44e"
alt="20210125150116725" />
<figcaption aria-hidden="true">20210125150116725</figcaption>
</figure>
<p>向下调整的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n, <span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树</span></span><br><span class="line">    <span class="type">int</span> child = <span class="number">2</span> * cur + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (child &lt; n) &#123;</span><br><span class="line">        <span class="comment">// 比较左右子树，找到较小值</span></span><br><span class="line">        <span class="keyword">if</span> (child + <span class="number">1</span> &lt; n &amp;&amp; arr[child + <span class="number">1</span>] &lt; arr[child]) &#123;</span><br><span class="line">            ++child;</span><br><span class="line">            <span class="comment">// child时刻保存较小值的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[child] &lt; arr[cur]) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> tmp = arr[child];</span><br><span class="line">            arr[child] = arr[cur];</span><br><span class="line">            arr[cur] = tmp;</span><br><span class="line"></span><br><span class="line">            cur = child;</span><br><span class="line">            child = <span class="number">2</span> * cur + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向上调整算法：</p>
<ol type="1">
<li>先设定倒数的第一个叶子节点为当前节点（通过下标获取，标记为cur），找出他的父亲节点，用
parent 来标记。</li>
<li>比较 parent 和 cur 的值，如果 cur 比 parent
小，则不满足小堆的规则，需要进行交换。</li>
<li>如果 cur 比 parent 大，满足小堆的规则，不需要交换，调整结束。</li>
<li>处理完一个节点之后，从当前的 parent 出发，循环之前的过程。</li>
</ol>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/485f1d1a-6bba-4170-abac-846f711221f7"
alt="20210125151546127" />
<figcaption aria-hidden="true">20210125151546127</figcaption>
</figure>
<p>向上调整的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n, <span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> parent = (cur - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] &lt; arr[parent]) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> tmp = arr[cur];</span><br><span class="line">            arr[cur] = arr[parent];</span><br><span class="line">            arr[parent] = tmp;</span><br><span class="line"></span><br><span class="line">            cur = parent;</span><br><span class="line">            parent = (cur - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>堆的插入是将数据插入到数组最后，做一次 <code>up()</code>
操作；删除堆的数据是删除堆顶的数据，先将堆顶元素与最后一个元素交换，将数组最后一个元素删除，然后堆堆顶元素做一次
<code>down()</code> 操作。</p>
<p>堆排序就是将将数据存储到堆里，然后将一一拿出堆顶的元素，就可以完成排序。</p>
<p>完整代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">                                      <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n, <span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左子树</span></span><br><span class="line">    <span class="type">int</span> child = <span class="number">2</span> * cur + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (child &lt; n) &#123;</span><br><span class="line">        <span class="comment">// 比较左右子树，找到较小值</span></span><br><span class="line">        <span class="keyword">if</span> (child + <span class="number">1</span> &lt; n &amp;&amp; arr[child + <span class="number">1</span>] &lt; arr[child]) &#123;</span><br><span class="line">            ++child;</span><br><span class="line">            <span class="comment">// child时刻保存较小值的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[child] &lt; arr[cur]) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> tmp = arr[child];</span><br><span class="line">            arr[child] = arr[cur];</span><br><span class="line">            arr[cur] = tmp;</span><br><span class="line"></span><br><span class="line">            cur = child;</span><br><span class="line">            child = <span class="number">2</span> * cur + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n, <span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> parent = (cur - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[cur] &lt; arr[parent]) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> tmp = arr[cur];</span><br><span class="line">            arr[cur] = arr[parent];</span><br><span class="line">            arr[parent] = tmp;</span><br><span class="line"></span><br><span class="line">            cur = parent;</span><br><span class="line">            parent = (cur - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">down</span>(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> end = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (end &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> tmp = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[end];</span><br><span class="line">        arr[end] = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">down</span>(arr, end, <span class="number">0</span>);</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>,</span><br><span class="line">                 <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = (<span class="type">int</span>)<span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    <span class="built_in">heapify</span>(arr, len);</span><br><span class="line">    <span class="built_in">heap_sort</span>(arr, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：这里使用的是小根堆进行原地排序，所以排序结果是逆序的，如果想要正序的结果，请使用辅助空间、大根堆或者排序之后进行逆序。</p>
<p>显然，堆排序的时间复杂度为 <span class="math inline">\(\Omicron
\left(n \log n \right)\)</span>.</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Sorting_algorithm">Wikipedia
| Sorting algorithm</a></li>
<li><a
href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">维基百科
| 排序算法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/42586566">[算法总结]
十大排序算法 | vivia</a></li>
<li><a
href="https://www.cnblogs.com/onepixel/articles/7674659.html">十大经典排序算法（动图演示）|
一像素 | 博客园</a></li>
<li><a
href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">十大经典排序算法
| 菜鸟教程</a></li>
<li><a
href="https://github.com/MisterBooo/Article">十大经典排序算法动画与解析，看我就够了！（配代码完全版）
| Github | MisterBooo</a></li>
<li><a
href="http://www.x-lab.info/post/sort-algorithm/">十大经典排序算法整理汇总
| X-lab</a></li>
<li><a
href="https://lumingdong.cn/detailed-explanation-of-ten-classic-sorting-algorithms.html">十大经典排序算法详解
| 卢明冬 | 卢明冬的博客</a></li>
<li><a
href="https://blog.csdn.net/SoftpaseFar/article/details/103129395">C++实现计数排序
| 赵延超 | CSDN</a></li>
<li>算法导论</li>
<li>大话数据结构</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>文件</title>
    <url>/2023/07/16/%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="文件的概念">文件的概念</h2>
<h3 id="文件的定义">文件的定义</h3>
<p>磁盘文件：指一组相关数据的有序集合，通常存储在外部介质上，使用时才调入内存。</p>
<p>设备文件：在操作系统中把每一个与主机相连的输入、输出设备看作是一个文件，把它们的输入、输出等同于对磁盘文件的读和写。</p>
<p>在 Linux 操作系统中，每一个外部设备都在 /dev
目录下对应着一个设备文件，在程序中操作设备，就必须对与其对应的 /dev
下的设备文件进行操作。</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/3ec4f64e-8ecb-4f5f-9f2a-848f55c1e693"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>我就豁出去是库函数申请的一段内存，由库函数对其进行操作，程序员没有必要找到存放在哪里，只需要知道对文件操作时的一些缓冲特点即可。</p>
<p><strong>行缓冲：</strong></p>
<p>标准 IO 库函数，往标准输出输出东西时是行缓冲的。</p>
<p>所谓行缓冲就是缓冲区碰到换行符时才刷新缓冲区。。</p>
<p>如果不刷新缓冲区，无法对文件进行读写操作。</p>
<p>行缓冲的刷新条件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 由于printf函数是一个标准io，所以只有刷新缓冲区才可以将数据输出到终端</span></span><br><span class="line">    <span class="comment">// printf(&quot;hello world&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新缓冲区方法1：使用\n</span></span><br><span class="line">    <span class="comment">// printf(&quot;hello world\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新缓冲区方法2：程序正常结束</span></span><br><span class="line">    <span class="comment">// printf(&quot;hello world&quot;);</span></span><br><span class="line">    <span class="comment">// return 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新缓冲区方法3：使用fflush函数刷新缓冲区</span></span><br><span class="line">    <span class="comment">// printf(&quot;hello world&quot;);</span></span><br><span class="line">    <span class="comment">// fflush：刷新函数。可以刷新指定的缓冲区</span></span><br><span class="line">    <span class="comment">// stdout：标准输出，就是对终端进行写操作</span></span><br><span class="line">    <span class="comment">// fflush(stdout);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新缓冲区方法4：当缓冲区满的时候自动刷新</span></span><br><span class="line">    <span class="comment">// 默认行缓冲的大小为1024个字节</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%03d &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>全缓冲：</strong></p>
<p>标准 IO
库函数，往普通文件读写数据时，是全缓冲的，碰到换行符也不刷新缓冲区，只有缓冲区满了才刷新缓冲区。</p>
<p>刷新缓冲区的情况：</p>
<ol type="1">
<li>缓冲区满了，刷新缓冲区；</li>
<li>使用 <code>fflush</code> 函数刷新缓冲区。</li>
<li>程序正常结束，刷新缓冲区。</li>
</ol>
<p><strong>无缓冲：</strong></p>
<p>在读写文件时通过系统调用 IO
对文件进行读写操作，这个时候是无缓冲的，即写数据会立马进入文件，读数据会立马进入内存。</p>
<p><strong>写文件的流程：</strong></p>
<p>应用程序空间-&gt;内核空间-&gt;驱动程序-&gt;硬盘</p>
<p>应用程序和内核程序运行在不同的空间里，目的是为了保护内核。</p>
<blockquote>
<p>设置缓存区可以减少进出内核的次数，提高效率。</p>
</blockquote>
<h3 id="磁盘文件的分类">磁盘文件的分类</h3>
<p>一个文件通常是磁盘上一段命名的存储区，计算机的存储在物理上是二进制的。</p>
<p>物理上所有的磁盘文件本质上都是一样的：以字节为单位进行顺序存储。</p>
<p>从用户或者操作系统的角度来说把文件分为：</p>
<ul>
<li>文本文件：基于字符编码的文件；</li>
<li>二进制文件：基于值编码的文件。</li>
</ul>
<p><strong>文本文件、二进制文件对比：</strong></p>
<p>译码：文本文件基于字符，译码容易些；二进制文件编码是边长的，译码难一些。（不同的二进制文件有不同的编码方式）</p>
<p>空间利用率：二进制文件的基本单位是
bit，而文本文件的基本单位是字符，所有二进制文件的空间利用率高。</p>
<p>可读性：文本文件可以用记事本的等软件阅读，二进制文件需要用特定的译码器。</p>
<h2 id="文件指针">文件指针</h2>
<p>文件指针用来标识一个文件，所有对文件的操作都是通过对文件指针来完成的。</p>
<p>定义文件指针的语法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *指针名;</span><br></pre></td></tr></table></figure>
<p>文件指针是一个结构体指针，结构体中包含了与文件相关的很多信息，但在编程时无需结构体的成员，只需使用文件指针即可。</p>
<p><strong>对文件操作的步骤：</strong></p>
<ol type="1">
<li>对文件进行读写等操作之前要打开文件得到文件指针；</li>
<li>通过文件指针对文件进行读写操作；</li>
<li>操作结束后，要关闭文件，关闭文件后，就不能再通过此文件指针对文件进行操作了。</li>
</ol>
<p><strong>C 语言中有三个定义好的特殊文件指针：</strong></p>
<ol type="1">
<li><code>stdin</code>：标准输入，使用
<code>scanf</code>、<code>getchar</code> 函数默认从 <code>stdin</code>
中输入；</li>
<li><code>stdout</code>：标准输出，使用
<code>printf</code>、<code>puts</code> 函数默认输出到
<code>stdout</code>；</li>
<li><code>stderr</code>：标准错误输出，使用 <code>perror</code>
函数默认输出到 <code>stderr</code>.</li>
</ol>
<h2 id="打开文件-fopen">打开文件 <code>fopen</code></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line">功能：创建或者打开一个文件</span><br><span class="line">参数：</span><br><span class="line">    path：文件名，如果只写文件名，默认就是当前路径，也可以添加路径</span><br><span class="line">    mode：文件权限</span><br><span class="line">        r 只读，如果文件不存在则报错</span><br><span class="line">        r+ 读写，如果文件不存在则报错</span><br><span class="line">        w 只写，如果文件不存在则创建，如果文件存在则清空</span><br><span class="line">        w+ 读写，如果文件不存在则创建，如果文件存在则清空</span><br><span class="line">        a 只写，如果文件不存在则创建，如果文件存在则追加</span><br><span class="line">        a+ 读写，如果文件不存在则创建，如果文件存在则追加</span><br><span class="line">返回值：</span><br><span class="line">    成功：文件指针</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;./file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to fopen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关闭文件-fclose">关闭文件 <code>fclose</code></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *stream)</span>;</span><br><span class="line">功能：关闭一个文件指针，无法在对当前文件进行操作</span><br><span class="line">参数：</span><br><span class="line">    stream：指定的文件指针，fopen函数的返回值</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：EOF</span><br><span class="line">注意：注意一个文件只能关闭一次，不能多次关闭。</span><br><span class="line">关闭文件之后就不能再文件指针对文件进行读写等操作了</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;./file.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to fopen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一次读写一个字符">一次读写一个字符</h2>
<h3 id="fgetc"><code>fgetc</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line">功能：从文件指针标识的文件中读取一个字符</span><br><span class="line">参数：</span><br><span class="line">    stream：指定的文件指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：读取的字符</span><br><span class="line">    失败：EOF</span><br><span class="line">如果文件读取完毕，也会返回EOF</span><br></pre></td></tr></table></figure>
<p>文件内容：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/db2f7510-086a-4a50-866b-0e4a0eedbb0e"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;./file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to fopen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = fgetc(fp)) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;c = [%c] - %d\n&quot;</span>, c, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/704fa56c-97ab-47b3-8421-67913d928911"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="fputc"><code>fputc</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br><span class="line">功能：向文件指针标识的文件中写入一个字符</span><br><span class="line">参数：</span><br><span class="line">    c：要写入的字符</span><br><span class="line">    stream：指定的文件指针</span><br><span class="line">返回值：</span><br><span class="line">成功：要写入的字符</span><br><span class="line">    失败：EOF</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;./file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to fopen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fputc(<span class="string">&#x27;w&#x27;</span>, fp);</span><br><span class="line">    fputc(<span class="string">&#x27;h&#x27;</span>, fp);</span><br><span class="line">    fputc(<span class="string">&#x27;a&#x27;</span>, fp);</span><br><span class="line">    fputc(<span class="string">&#x27;t&#x27;</span>, fp);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, fp);</span><br><span class="line">    fputc(<span class="string">&#x27;o&#x27;</span>, fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/9359f70e-e6cd-4451-a976-6956ca7eac05"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="一次读写一个字符串">一次读写一个字符串</h2>
<h3 id="fgets"><code>fgets</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> size, FILE *stream)</span>;</span><br><span class="line">功能：从文件中读取内容</span><br><span class="line">参数：</span><br><span class="line">    s：保存读取到的内容</span><br><span class="line">    size：每次读取的最大个数</span><br><span class="line">    stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：读取的数据的首地址</span><br><span class="line">    失败：<span class="literal">NULL</span></span><br><span class="line">    如果文件内容读取完毕，也返回<span class="literal">NULL</span></span><br><span class="line">注意：从stream所指的文件中读取字符，在读取的时候碰到换行符或者是碰到文件的末尾停止读取，或者是读取了size‐<span class="number">1</span>个字节停止读取，在读取的内容后面会加一个\<span class="number">0</span>,作为字符串的结尾</span><br></pre></td></tr></table></figure>
<p>文件内容：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/bc68401f-ebaf-49a2-9ac4-1d5572b0829a"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;./file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to fopen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    fgets(buf, <span class="number">32</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/408b3cc0-d479-49ba-9140-d2a55b6836ca"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="fputs"><code>fputs</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, FILE *stream)</span>;</span><br><span class="line">功能：向文件写入数据</span><br><span class="line">参数：</span><br><span class="line">    s：要写入的内容</span><br><span class="line">    stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：写入文件内容的字节数</span><br><span class="line">    失败：EOF</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;./file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to fopen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;66666666666666\n&quot;</span>, fp);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;nihao&quot;</span>, fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/e91690c0-d36e-4b12-a405-a2f6c4466460"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="读文件-fread">读文件 <code>fread</code></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line">功能：从文件中读取数据</span><br><span class="line">参数：</span><br><span class="line">    ptr：保存读取的数据</span><br><span class="line">    size：每次读取的字节数</span><br><span class="line">    nmemb：一共读取的次数</span><br><span class="line">    stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：实际读取的次数（对象数、块数）</span><br><span class="line">    失败：<span class="number">0</span></span><br><span class="line">    如果文件内容读取完毕，返回<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = fread(str,<span class="number">100</span>,<span class="number">3</span>,fp);</span><br><span class="line">从fp所代表的文件中读取内容存放到str指向的内存中，读取的字节数为 ，每块<span class="number">100</span>个字节，<span class="number">3</span>块。</span><br><span class="line">返回值num，如果读到<span class="number">300</span>个字节返回值num为<span class="number">3</span></span><br><span class="line">如果读到了大于等于<span class="number">200</span>个字节小于<span class="number">300</span>个字节 返回值为<span class="number">2</span></span><br><span class="line">读到的字节数，大于等于<span class="number">100</span>个字节小于<span class="number">200</span>个字节 返回<span class="number">1</span></span><br><span class="line">不到<span class="number">100</span>个字节返回<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>文件内容：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/8f7a09bb-0e48-4d41-b33c-f68cc156d116"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(<span class="string">&quot;./file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to fopen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    num = fread(buf, <span class="number">5</span>, <span class="number">4</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buf = %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/9d0e4d82-9950-4f1a-a57f-5a15e783c1c4"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="写文件-fwrite">写文件 <code>fwrite</code></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line">功能：向文件中写入数据</span><br><span class="line">参数：</span><br><span class="line">    ptr：要写入的数据</span><br><span class="line">    size：一次写入的字节数</span><br><span class="line">    nmemb：一共写入的次数</span><br><span class="line">    stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">    成功：实际写入的次数</span><br><span class="line">    失败：<span class="number">0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125; MSG;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;./file.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to fopen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MSG msg[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="string">&#x27;c&#x27;</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">    fwrite(msg, <span class="keyword">sizeof</span>(MSG), <span class="number">4</span>, fp);</span><br><span class="line">    rewind(fp);</span><br><span class="line">    MSG rcv[<span class="number">4</span>];</span><br><span class="line">    fread(rcv, <span class="keyword">sizeof</span>(MSG), <span class="number">4</span>, fp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d - %d - %c\n&quot;</span>, rcv[i].a, rcv[i].b, rcv[i].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/8189a143-ca58-4d92-9784-c178e2fbf695"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>输出的文件内容：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/09f49c19-e832-485a-ac93-7abe4ab65327"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="格式化读写文件函数">格式化读写文件函数</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">函数调用:</span><br><span class="line"><span class="built_in">fprintf</span>(文件指针, 格式字符串, 输出表列);</span><br><span class="line"><span class="built_in">fscanf</span>(文件指针, 格式字符串, 输入表列);</span><br><span class="line"></span><br><span class="line">函数功能:</span><br><span class="line">    从磁盘文件中读入或输出字符</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span> 和<span class="built_in">printf</span>函数类似：</span><br><span class="line"><span class="built_in">printf</span>是将数据输出到屏幕上（标准输出），</span><br><span class="line"><span class="built_in">fprintf</span>函数是将数据输出到文件指针所指定的文件中。</span><br><span class="line"></span><br><span class="line"><span class="built_in">fscanf</span>和<span class="built_in">scanf</span> 函数类似：</span><br><span class="line"><span class="built_in">scanf</span>是从键盘（标准输入）获取输入，</span><br><span class="line"><span class="built_in">fscanf</span>是从文件指针所标示的文件中获取输入。</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> ch1 = <span class="string">&#x27;a&#x27;</span>, ch2;</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">50</span>, num2;</span><br><span class="line">    <span class="type">char</span> string1[<span class="number">20</span>] = <span class="string">&quot;hello&quot;</span>, string2[<span class="number">20</span>];</span><br><span class="line">    <span class="type">float</span> score1 = <span class="number">85.5</span>, score2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">&quot;./file.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to fopen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%c %d %s %f\n&quot;</span>, ch1, num1, string1, score1);</span><br><span class="line">    rewind(fp);</span><br><span class="line">    <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%c %d %s %f\n&quot;</span>, &amp;ch2, &amp;num2, string2, &amp;score2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c %d %s %f\n&quot;</span>, ch2, num2, string2, score2);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/1d4ce40b-4ea8-42b1-b3e2-8492e3d2a93c"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>文件内容：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/6679d044-3000-4abc-b795-44e9b47758f4"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="随机读写">随机读写</h2>
<h3 id="rewind"><code>rewind</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE *stream)</span>;</span><br><span class="line">    功能：将文件位置定位到起始位置</span><br><span class="line">参数：</span><br><span class="line">    stream：文件指针</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure>
<h3 id="ftell"><code>ftell</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br><span class="line">功能：获取当前文件的偏移量</span><br><span class="line">参数：</span><br><span class="line">    stream：文件指针</span><br><span class="line">返回值：</span><br><span class="line">    获取当前文件的偏移量</span><br></pre></td></tr></table></figure>
<h3 id="fseek"><code>fseek</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line">功能：设置文件位置指针的偏移量</span><br><span class="line">参数：</span><br><span class="line">    stream：文件指针</span><br><span class="line">    offset：偏移量，可正可负也可为<span class="number">0</span></span><br><span class="line">    whence：相对位置</span><br><span class="line">        SEEK_SET 文件起始位置</span><br><span class="line">        SEEK_CUR 文件当前位置</span><br><span class="line">        SEEK_END 文件末尾位置（最后一个字符后面一个位置）</span><br><span class="line">返回值：</span><br><span class="line">    成功：<span class="number">0</span></span><br><span class="line">    失败：‐<span class="number">1</span></span><br><span class="line"></span><br><span class="line">rewind(fp) &lt;==&gt; fseek(fp, <span class="number">0</span>, SEEK_SET);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">&quot;./file.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fail to fopen\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;123456789\n&quot;</span>, fp);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;abcdefghijklmn&quot;</span>, fp);</span><br><span class="line">    <span class="comment">// 获取当前文件指针的读写位置</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;offset = %ld\n&quot;</span>, ftell(fp));</span><br><span class="line">    <span class="comment">// 将当前文件的读写文件设置到文件的起始位置</span></span><br><span class="line">    <span class="comment">// rewind(fp);</span></span><br><span class="line">    <span class="comment">// fseek(fp, 0, SEEK_SET);</span></span><br><span class="line">    <span class="comment">// 将当前文件的读写位置设置为倒数第五个位置</span></span><br><span class="line">    fseek(fp, <span class="number">-5</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, <span class="number">32</span>, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%s]\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/ed85fbcf-ec37-4964-8754-958e588e4e77"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>文件内容：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/66b1da96-8dc3-4818-a30a-83bb46e30029"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
]]></content>
      <categories>
        <category>C 语言基础</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title>材质与外观</title>
    <url>/2023/07/16/%E6%9D%90%E8%B4%A8%E4%B8%8E%E5%A4%96%E8%A7%82/</url>
    <content><![CDATA[<p>材质与外观是渲染物体时非常重要的属性之一，光线的传播和材质具有密切的关系。</p>
<blockquote>
<p>外观是光线与材质共同作用的结果。</p>
</blockquote>
<h2 id="材质的定义">材质的定义</h2>
<p>在渲染方程中，分析各个参数可以知道材质和 BRDF 具有密切的关系。BRDF
定了物体的材质属性。下图中，从左到右依次是：漫反射材质、光泽表面材质以及折射材质。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231369893-cd808616-b0dd-4320-b9b7-a3f20e4febd8.png" alt="漫反射材质、光泽表面材质以及折射材质" style="zoom:100%;" />
</center>
<blockquote>
<p>材质 = BRDF.</p>
</blockquote>
<h3 id="漫反射材质">漫反射材质</h3>
<p>漫反射材质（Diffuse / Lambertian
Material）的性质是当一束光线从任意方向射向材质表面时，将会向各个方向均匀的反射光。</p>
<p>对于漫反射材质，其 BRDF 为：<span class="math inline">\(f_r\)</span>.
所以反射方程为：</p>
<p><span class="math display">\[
\begin{align*}
L_o\left(\omega_o\right) &amp;= \int_{H^2}f_rL_i\left(\omega_i\right)
\cos \theta_i \, \mathrm{d} \omega_i \\
&amp;= f_rL_i\int_{H^2}\cos\theta_i \mathrm{d} \omega_i \\
&amp;= \pi f_rL_i
\end{align*}
\]</span></p>
<p>所以：</p>
<p><span class="math display">\[
f_r = \frac{1}{\pi}
\]</span> 引入一个漫反射系数（albedo）来表示颜色（能量的衰减）： <span
class="math display">\[
f_r= \frac{\rho}{\pi}
\]</span></p>
<p>其中 <span class="math inline">\(\rho \in \left[0,
1\right]\)</span>。</p>
<blockquote>
<p>漫反射系数一方面可以表示能量的衰减，另外一方面也可表示颜色。</p>
</blockquote>
<h2 id="光泽表面材质和折射材质">光泽表面材质和折射材质</h2>
<p><strong>光泽表面材质</strong>（Glossy material
）：一般表示的是金属材质。这些材质相比于镜面来说没有那么光滑，但是依然可以产生非常类似于镜面反射的效果（光线的出射方向非常的集中）。</p>
<p><strong>折射材质</strong>（Ideal reflective / refractive
material）：可以折射一定量的光线。这种材质通常是透明材质，例如玻璃和水。</p>
<h3 id="反射与折射">反射与折射</h3>
<h4 id="反射定律">反射定律</h4>
<p>反射定律（Reflection Law）：入射角等于出射角。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231373522-73f017fa-f6ec-4626-a07e-5be9ddf64d21.png" alt="反射定律" style="zoom:100%;" />
</center>
<p>由出射角等于入射角可知：</p>
<p><span class="math display">\[
\begin{align*}
\omega_o + \omega_i &amp;= 2 \cos \theta \vec{n} = 2\left(\omega_i\cdot
\vec{n}\right) \vec{n} \\
\omega_o  &amp;=-\omega_i + 2\left(\omega_i \cdot \vec{n}\right) \vec{n}
\end{align*}
\]</span></p>
<p>如果从平面上面往下看，入射光线和反射光线方向完全相反，也就是 <span
class="math inline">\(\phi_o = \left(\phi_i + \pi\right)\mod 2
\pi\)</span></p>
<h4 id="折射定律">折射定律</h4>
<p>折射定律（Snell’s Law）反映了折射角和入射角的关系。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231375068-b734066a-bfb0-453d-8c9d-951d78421dda.png" alt="折射定律" style="zoom:100%;" />
</center>
<p>折射定律的公式如下：</p>
<p><span class="math display">\[
\eta_i \sin \theta_i=\eta_t \sin \theta_t
\]</span></p>
<p>其中 <span class="math inline">\(\eta\)</span>
是材质的折射率。如果从平面上面往下看，两条光线方向是相反的。</p>
<p>常见的材质的折射率如下表所示：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">材质</th>
<th style="text-align: center;"><span
class="math inline">\(\eta\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">真空</td>
<td style="text-align: center;">1.0</td>
</tr>
<tr class="even">
<td style="text-align: center;">空气（海平面）</td>
<td style="text-align: center;">1.00029</td>
</tr>
<tr class="odd">
<td style="text-align: center;">水（20 摄氏度）</td>
<td style="text-align: center;">1.333</td>
</tr>
<tr class="even">
<td style="text-align: center;">玻璃</td>
<td style="text-align: center;">1.5-1.6</td>
</tr>
<tr class="odd">
<td style="text-align: center;">钻石</td>
<td style="text-align: center;">2.42</td>
</tr>
</tbody>
</table>
<p>根据折射定律，我们在知道入射角和法线方向以及材质的折射率的时候就可以求出出射角方向：</p>
<p><span class="math display">\[
\begin{align*}
\cos \theta_t &amp; =\sqrt{1-\sin ^2 \theta_t} \\
&amp; =\sqrt{1-\left(\frac{\eta_i}{\eta_t}\right)^2 \sin ^2 \theta_i} \\
&amp; =\sqrt{1-\left(\frac{\eta_i}{\eta_t}\right)^2\left(1-\cos ^2
\theta_i\right)}
\end{align*}
\]</span></p>
<p>根号下要为正数才有意义，如果 <span
class="math inline">\(\frac{\eta_i}{\eta_t} &gt;
1\)</span>，也就是说当入射介质的折射率大于反射介质的折射率时，有可能发生全反射现象。下图是一个全反射的例子：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231377241-d65d11cd-4730-4de8-8350-7d4baead363f.png" alt="全反射" style="zoom:100%;" />
</center>
<h2 id="菲涅耳项fresnel-reflection-term">菲涅耳项（Fresnel Reflection /
Term）</h2>
<p>在现实生活中，我们发现有这样的现象：当我们在不同的视角下进行观察的时候会用不同的现象。如下图所示，当我们从不同的视角观察桌子的时候，桌子对书反射的程度也不尽相同。这就是菲涅耳带来的结果。</p>
<center>
<img data-src="https://github.com/XinranSix/computer-graphics/assets/62458905/ffc186ff-0dee-4b8e-a9aa-1818f4315d69
" alt="菲涅耳带来的结果" style="zoom:100%;" />
</center>
<p>对于导体和非导体，菲涅耳项满足：</p>
<ul>
<li>对于非导体，入射光线和入射平面越近（入射角越大），被反射出去的光线越多。下图是非导体的反射率和入射角的关系图：</li>
</ul>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231378308-ce0da876-e7c6-420a-951e-bf775a9d1c09.png" alt="非导体的反射率和入射角的关系" style="zoom:75%;" />
</center>
<ul>
<li>对于导体，反射出来光线的多少和入射角度没有直接关系，光线都可以被大量反射出去。下图是导体的反射率和入射角的关系图：</li>
</ul>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231378374-608c50bf-54ae-423c-9bdf-efc3bb377a2f.png" alt="导体的反射率和入射角" style="zoom:75%;" />
</center>
<p>菲涅耳项的准确计算公式为：</p>
<p><span class="math display">\[
\begin{gathered}
R_{\mathrm{s}}=\left|\frac{n_1 \cos \theta_{\mathrm{i}}-n_2 \cos
\theta_{\mathrm{t}}}{n_1 \cos \theta_{\mathrm{i}}+n_2 \cos
\theta_{\mathrm{t}}}\right|^2=\left|\frac{n_1 \cos
\theta_{\mathrm{i}}-n_2 \sqrt{1-\left(\frac{n_1}{n_2} \sin
\theta_{\mathrm{i}}\right)^2}}{n_1 \cos \theta_{\mathrm{i}}+n_2
\sqrt{1-\left(\frac{n_1}{n_2} \sin
\theta_{\mathrm{i}}\right)^2}}\right|^2, \\
R_{\mathrm{p}}=\left|\frac{n_1 \cos \theta_{\mathrm{t}}-n_2 \cos
\theta_{\mathrm{i}}}{n_1 \cos \theta_{\mathrm{t}}+n_2 \cos
\theta_{\mathrm{i}}}\right|^2=\left|\frac{n_1
\sqrt{1-\left(\frac{n_1}{n_2} \sin \theta_{\mathrm{i}}\right)^2}-n_2
\cos \theta_{\mathrm{i}}}{n_1 \sqrt{1-\left(\frac{n_1}{n_2} \sin
\theta_{\mathrm{i}}\right)^2}+n_2 \cos \theta_{\mathrm{i}}}\right|^2 .
\end{gathered}
\]</span></p>
<p><span class="math inline">\(R_s\)</span> 和 <span
class="math inline">\(R_p\)</span> 是在 s 极点和 p
极点的菲涅耳项，将他们平均一下可得到不极化的菲涅尔项：</p>
<p><span class="math display">\[
R_{\text{eff}} = \frac{1}{2}\left(R_\mathrm{s} + R_\mathrm{p}\right)
\]</span></p>
<p>上述计算太复杂，我们可以做一个近似计算：</p>
<p><span class="math display">\[
\begin{align*}
R\left(\theta\right) &amp;= R_0 + \left(1 - R_0\right)\left(1- \cos
\theta\right)^5 \\
R_0 &amp;= \left(\frac{n_1 - n_2}{n_1 + n_2}\right)^2
\end{align*}
\]</span></p>
<h2 id="微表面模型microfacet-material">微表面模型（Microfacet
Material）</h2>
<p>微表面模型是更接近于物理的材质描述。我们认为<strong>广表面</strong>（Macroscale）是平坦且粗糙的，但是<strong>微表面</strong>（Microsurface）是凹凸不平但是光滑的（每一个小的面都是光滑平坦的），那么整体的光线反射情况应当是所有微表面反射情况的总和。从近处看是几何，从远处看就是一种材质。</p>
<p>对于任何一种材质，我们使用法线分布来描述其材质。如果是光滑的表面，那么法线分布比较集中；否则，法线会分布在四处。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231381176-6ecca7de-fe78-41e8-89ac-9ad41fd26a40.png" alt="法线分布与材质效果" style="zoom:75%;" />
</center>
<p>在微表面的情况下 BDRF 可以写作：</p>
<p><span class="math display">\[
f(\mathbf{i}, \mathbf{o})=\frac{\mathbf{F}(\mathbf{i}, \mathbf{h})
\mathbf{G}(\mathbf{i}, \mathbf{o}, \mathbf{h})
\mathbf{D}(\mathbf{h})}{4(\mathbf{n}, \mathbf{i})(\mathbf{n},
\mathbf{o})}
\]</span> 其中，<span class="math inline">\(\mathbf{F}(\mathbf{i},
\mathbf{h})\)</span> 是菲涅尔项，<span
class="math inline">\(\mathbf{D}(\mathbf{h})\)</span>
是沿着半程向量方向的法线分布，<span
class="math inline">\(\mathbf{G}(\mathbf{i}, \mathbf{o},
\mathbf{h})\)</span>
是一个集合项，微表面内部可能会有几何遮挡，使一些微表面失去了作用。自遮挡容易发生在几乎和反射面平行入射的方
向（Grazing angle）。</p>
<h2 id="材质的分类">材质的分类</h2>
<p>将材质分类为<strong>各向同性材质</strong>（Isotropic
Material）和<strong>各向异性材质</strong>（Anisotropic Material）。</p>
<ul>
<li>各向同性材质（Isotropic
Material）：各个方向上法线分布一致的材质，满足 <span
class="math inline">\(f_r\left(\theta_i, \phi;\theta_r, \phi_r\right) =
f_r\left(\theta_i, \theta_r, \phi_r - \phi_i\right)\)</span>.</li>
<li>各向异性材质（Anisotropic
Material）：各个方向上法线分布不一致的材质，有： <span
class="math inline">\(f_r\left(\theta_i, \phi;\theta_r, \phi_r\right)
\neq f_r\left(\theta_i, \theta_r, \phi_r -
\phi_i\right)\)</span>，常见于打磨过的金属，尼龙材料。</li>
</ul>
<h2 id="brdf-的性质">BRDF 的性质</h2>
<ul>
<li>非负性（Non-negativity）</li>
</ul>
<p><span class="math display">\[
f_r\left(\omega_i \rightarrow \omega_r \right) \ge 0
\]</span></p>
<ul>
<li>线性（Linearity）</li>
</ul>
<p><span class="math display">\[
L_r\left(\mathrm{p}, \omega_r\right) = \int_{H^2}f_r\left(\mathrm{p},
\omega_i \rightarrow \omega_r\right)L_i\left(\mathrm{p}, \omega_i
\right) \cos \theta_i \, \mathrm{d} \omega_i
\]</span></p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231383755-bd8a667b-47f4-45c6-96f8-3972624567c6.png" alt="线性" style="zoom:75%;" />
</center>
<ul>
<li>可逆性（Reciprocity principle）</li>
</ul>
<p><span class="math display">\[
f_r\left(\omega_r \rightarrow \omega_i\right) = f_r\left(\omega_i
\rightarrow \omega_r\right)
\]</span></p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231384090-803d2a17-f56f-4351-8d6e-2fa0819f0f74.png" alt="可逆性" style="zoom:75%;" />
</center>
<ul>
<li>能量守恒（Energy conservation）</li>
</ul>
<p><span class="math display">\[
\forall \omega_r \int_{H^2}f_r\left(\omega_i \rightarrow \omega_r\right)
\cos \theta_i \, \mathrm{d}\omega_i \le 1
\]</span></p>
<ul>
<li>各向同性 vs. 各向异性
<ul>
<li>对于各向同性：<span class="math inline">\(f_r\left(\theta_i,
\phi_i;\theta_r, \phi_r\right) = f_r\left(\theta_i, \theta_r, \phi_r -
\phi_i\right)\)</span>.</li>
<li>对于各向异性：<span class="math inline">\(f_r\left(\theta_i,
\theta_r, \phi_r - \phi_i\right) = f_r\left(\theta_r, \theta_i, \phi_i -
\phi_r\right) = f_r\left(\theta_i, \theta_r, \left|\phi_r -
\phi_i\right|\right)\)</span></li>
</ul></li>
</ul>
<h2 id="brdf-的测量">BRDF 的测量</h2>
<p>我们希望准确的测量出真实世界材质的
BDRF。如下图所示，我们可以通过以下的实验方式测量某一种材质的 BDRF。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231385956-af271128-7eb4-4b0b-9362-edbf58429e82.png" alt="BRDF 的测量" style="zoom:75%;" />
</center>
<p>我们可以通过这样的装置得到各个入射方向和出射方向的
BDRF，测量的算法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">foreach outgoing direction wo</span><br><span class="line">    move light to illuminate surface with a thin beam from wo</span><br><span class="line">    <span class="keyword">for</span> each incoming direction wi</span><br><span class="line">        move sensor to be at direction wi from surface</span><br><span class="line">        measure incident radiance</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a
href="http://filmicworlds.com/blog/everything-has-fresnel/">Everything
has Fresnel</a></li>
</ul>
]]></content>
      <categories>
        <category>GAMES 101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>材质</tag>
        <tag>外观</tag>
      </tags>
  </entry>
  <entry>
    <title>相机、镜头和光场</title>
    <url>/2023/07/16/%E7%9B%B8%E6%9C%BA%E3%80%81%E9%95%9C%E5%A4%B4%E5%92%8C%E5%85%89%E5%9C%BA/</url>
    <content><![CDATA[<blockquote>
<p>Imaging = Synthesis + Capture.</p>
</blockquote>
<h2 id="小孔成像">小孔成像</h2>
<p>用一个带有小孔的板遮挡在墙体与物之间，墙体上就会形成物的倒立的实像，这样的一种现象叫小孔成像（Pinhole
Image Formation）。小孔成像的特点是得到的成像没有景深效果。</p>
<p>除了小孔成像之外，我们还会使用透镜成像。之所以必须要使用小孔或者透镜是因为传感器上每个点需要记录对应方向光线的数据，如果不使用小孔或者透镜，那么到达传感器上的光线将来自各个方向，不能区分。</p>
<h2 id="视场">视场</h2>
<p>摄像机的视场（Field of
View，FOV）的大小和传感器的大小以及焦距（小孔成像中指的是传感器和小孔的距离）有关。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231658150-69b5c7d1-d326-49ce-ac8b-7285641e57fe.png" alt="Img" style="zoom:75%;" />
</center>
<p>由图可知： <span class="math display">\[
\text{FOV} = 2 \arctan \left(\frac{h}{2f}\right)
\]</span> 从上述公式可以看出：</p>
<ul>
<li>传感器越大，视场越大；</li>
<li>焦距越短，视场越大。</li>
</ul>
<p>由于一些历史原因，在实际应用中，我们会采用 <span
class="math inline">\(35\text{mm}\)</span> 胶片（<span
class="math inline">\(36 \times
24\text{mm}\)</span>）对应的焦距来反映视场的大小。焦距越小，对应的视场越大；焦距越大，拍摄的距离越远。较小的传感器需要使用较短的焦距来保持一样的视场。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231658975-1eb3311a-ddac-4c9e-b540-7ab06c035f85.png" alt="Img" style="zoom:75%;" />
</center>
<h2 id="曝光">曝光</h2>
<p>曝光（Exposure，H）可以表示为曝光时间 T 和 Irradiance E 的乘积：
<span class="math display">\[
H = T \times E
\]</span> 其中，曝光时间由快门控制，Irradiance
是单位时间传感器单位面积上接受的光的强度，由光圈和焦距控制。</p>
<h3 id="曝光控制">曝光控制</h3>
<p>曝光的控制由以下三个参数决定：</p>
<ul>
<li>光圈大小（Aperture size）：光圈的大小由 f-stop
控制，光圈是一个类似于瞳孔的结构，记作 F / N，其中 N 是 f 数，计算公式是
<span
class="math inline">\(\frac{f}{D}\)</span>，也就是焦距除以光圈直径。光圈越大景深效果越明显。</li>
<li>快门速度（Shutter
speed）：决定了传感器的感光时间；快门速度越慢，得到的图片会出现模糊，我们称作<strong>运动模糊</strong>（Motion
Blur）。运动模糊会使图像变模糊，但是可以体现出运动速度快，符合人眼规律。对于某些包含快速旋转物体的图片，由于图像每一个部分都在不同时间拍摄，因此会出现卷帘快门（Rolling
Shutter）的现象。</li>
<li>ISO 感光度（ISO
gain）：传感器值乘一个常数变换为数字图像值，是一种后期处理。在数字相机中，高
ISO 会增加噪声。ISO 是一种线性增长（ISO 200 增加亮度的一半就是 ISO
100）。</li>
</ul>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231671812-06e3d19d-09fc-4ac4-970f-ab7ff19a9e3b.png" alt="Img" style="zoom:75%;" />
</center>
<p>光圈和快门速度都可以控制曝光，因此理论上在一定的组合方式下，能够得到相同的曝光结果。但是，由于光圈和快门速度所带来的副作用不同，因此不同组合产生的效果也会有一些不同。在下表中，光圈和快门速度的组合能够得到相同的曝光。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231672238-aedbbe15-ac1e-41f5-b2c9-72785837282f.png" alt="Img" style="zoom:75%;" />
</center>
<h2 id="薄透镜近似thin-lens-approximation">薄透镜近似（Thin Lens
Approximation）</h2>
<p>真实的透镜都是由透镜组所组成的。真实的透镜并不是理想的，这是因为平行光经过真实透镜后不能聚焦在同一个点上。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231672675-b8b0d124-50a0-4d90-bff4-4d6c9aee4af9.png" alt="Img" style="zoom:75%;" />
</center>
<p>理想的薄透镜满足以下三点：</p>
<ul>
<li>所有经过透镜的平行光都会聚焦在它的焦点；</li>
<li>所有经过透镜的焦点的光都会变成平行光；</li>
<li>透镜的焦距可以任意的变换。</li>
</ul>
<h3 id="透镜方程">透镜方程</h3>
<p>在薄透镜中，焦距 <span class="math inline">\(f\)</span>，物距 <span
class="math inline">\(z_0\)</span>，像距 <span
class="math inline">\(z_i\)</span> 满足： <span class="math display">\[
\frac{1}{f} = \frac{1}{z_0} + \frac{1}{z_i}
\]</span></p>
<p>这被称为<strong>薄透镜方程</strong>（The Thin Lens Equation）。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231672903-c3ed5271-bfd3-4dfd-9b6a-d8dfb00dc546.png" alt="Img" style="zoom:75%;" />
</center>
<h4 id="薄透镜方程的证明">薄透镜方程的证明</h4>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231673590-bbfb3d53-0524-486b-a469-bf853dba2051.png" alt="Img" style="zoom:75%;" />
</center>
<p>根据相似三角形的性质，我们可以从蓝色相似三角形组和红色相似三角形组可以得到：
<span class="math display">\[
\begin{align*}
\frac{h_0}{z-f} &amp;= \frac{h_i}{f} \\
\frac{h_0}{f} &amp;= \frac{h_i}{z_i - f}
\end{align*}
\]</span> 联立公式可以得到： <span class="math display">\[
\frac{z_o - f}{f} = \frac{f}{z_i - f}
\]</span> 整理可得： <span class="math display">\[
\frac{1}{f} = \frac{1}{z_o} + \frac{1}{z_i}
\]</span></p>
<h3 id="离焦模糊defocus-blur">离焦模糊（Defocus Blur）</h3>
<p>当我们的物体不在聚焦平面的时候，它的像对应在传感器平面上是一个光圈，这个光圈被称为<strong>弥散圆</strong>（Circle
of Confusion，CoC），这就是<strong>离焦模糊</strong>（Defocus
Blur）现象。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231674535-1416f49a-531a-4bbc-85db-73f194a1afa0.png" alt="Img" style="zoom:75%;" />
</center>
<p>弥散圆的直径 <span class="math inline">\(C\)</span> 和透镜的直径
<span class="math inline">\(A\)</span> 满足： <span
class="math display">\[
\frac{C}{A} = \frac{d&#39;}{z_i} = \frac{\left|z_s - z_i\right|}{z_i}
\]</span> 我们又知道，光圈的大小 f-stop
由焦距和光圈的直径有决定。因此，上式可以改写成： <span
class="math display">\[
C = A  \frac{\left|z_s - z_i\right|}{z_i} = \frac{f}{N} \frac{\left|z_s
- z_i\right|}{z_i}
\]</span> 因此，光圈 f-stop
越大，拍出来的相片越清晰，对应光圈的直径越小。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231675921-4fc42586-8e33-4cd1-83f8-619bf13d3470.png" alt="Img" style="zoom:75%;" />
</center>
<h3
id="薄透镜下的光线追踪ray-tracing-ideal-thin-lenses">薄透镜下的光线追踪（Ray
Tracing Ideal Thin Lenses）</h3>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231676268-ed66e9ca-3a5b-45fd-a2b5-e1968c323de5.png" alt="Img" style="zoom:75%;" />
</center>
<p>之前我们的路径追踪都是在小孔摄像机的假设下。现在我们使用薄透镜模型进行光线追踪。首先，我们需要定义：</p>
<ul>
<li>传感器大小，透镜的焦距以及透镜的孔径大小；</li>
<li>确定成像平面的距离 <span
class="math inline">\(z_o\)</span>。那么我们可以推算出传感器平面的距离
<span class="math inline">\(z_i\)</span>。</li>
</ul>
<p>我们按照以下方法确定路径：</p>
<ul>
<li>选定每一个传感器像素上的点 <span
class="math inline">\(x&#39;\)</span>;</li>
<li>在透镜平面上随机采样点 <span
class="math inline">\(x&#39;&#39;\)</span>;</li>
<li>光线经过透镜会打到成像平面上的 <span
class="math inline">\(x&#39;&#39;&#39;\)</span> 点；</li>
<li>计算从 <span class="math inline">\(x&#39;&#39;&#39;\)</span> 到
<span class="math inline">\(x&#39;&#39;\)</span> 的 radiance，就是对应的
<span class="math inline">\(x&#39;\)</span> 的结果。</li>
</ul>
<h3 id="景深">景深</h3>
<p>我们认为，当一段深度的物体能够保证 CoC
是足够小的，那么这一段深度我们称作<strong>景深</strong>（Depth
ofField）。在实际中我们认为 CoC
小于一个像素的大小都可以看作足够小。景深的计算如下所示：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231677188-491ab800-13c1-4ef9-964d-b28f5368fd5c.png" alt="Img" style="zoom:75%;" />
</center>
<p>根据离焦模糊公式和薄透镜方程有： <span class="math display">\[
\begin{align*}
\frac{d_N-d_S}{d_N} &amp; =\frac{C}{A} \\
\frac{d_S-d_F}{d_F} &amp; =\frac{C}{A} \\
N &amp; =\frac{f}{A} \\
\frac{1}{D_F}+\frac{1}{d_F} &amp; =\frac{1}{f} \\
\frac{1}{D_S}+\frac{1}{d_S} &amp; =\frac{1}{f} \\
\frac{1}{D_N}+\frac{1}{d_N} &amp; =\frac{1}{f}
\end{align*}
\]</span> 因此： <span class="math display">\[
\begin{align*}
\mathrm{DOF} &amp; =D_F-D_N \\
D_F &amp; =\frac{D_S f^2}{f^2-N C\left(D_S-f\right)} \\
D_N &amp; =\frac{D_S f^2}{f^2+N C\left(D_S-f\right)}
\end{align*}
\]</span></p>
<h2 id="光场light-field-lumigraph">光场（Light Field / Lumigraph）</h2>
<p>对于人眼来说，不关心光线究竟是从哪里来的，因此可以用一张图片来模拟一种光。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231678046-0fe98b34-50a7-4f9f-8146-47b5ae1ffcd5.png" alt="Img" style="zoom:75%;" />
</center>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231678074-152214f3-3d37-46dd-b496-0adc5cb7f7a1.png" alt="Img" style="zoom:75%;" />
</center>
<p>在这里介绍全光函数（The Plenoptic Function）： <span
class="math display">\[
P\left(\theta, \phi, \lambda, t, V_X, V_Y, V_Z\right)
\]</span></p>
<ul>
<li><span class="math inline">\(\theta\)</span>、<span
class="math inline">\(\phi\)</span>
表示来提交，通过这两个参数可以描述光线的强度（即灰度值）；</li>
<li><span class="math inline">\(\lambda\)</span>
表示不同的波长，可以描述颜色信息；</li>
<li><span class="math inline">\(t\)</span>，时间维度，引入 <span
class="math inline">\(t\)</span> 后图片就动起来了，这就是电影；</li>
<li><span class="math inline">\(V_X\)</span>、<span
class="math inline">\(V_Y\)</span>、<span
class="math inline">\(V_Z\)</span>，位置坐标，引入<span
class="math inline">\(V_X\)</span>、<span
class="math inline">\(V_Y\)</span>、<span
class="math inline">\(V_Z\)</span> 后可以表示全息投影。</li>
</ul>
<p>通过全光函数，我们可以记录所有的信息。光场（Light Field /
Lumigraph）可以看作全光函数的一部分信息。</p>
<p>首先，我们定义光线，我们忽略颜色和时间参数。光线可以由两种方式进行定义，第一种方式是使用
3 维的起点以及 2 维的方向定义光线： <span class="math display">\[
P\left(\theta, \phi, V_X, V_Y, V_Z\right)
\]</span> 通过 5
个维度我们定义了一个光线。但是我们可以通过两个点定义一条光线，这样子我们只需要四个维度就可以表示一条光线（只要我们定义好两个平面，上面的点都是
2 维的，因此两个点只需要 4 个维度就可以了）。</p>
<p>对于任何一个物体，我们可以使用一个包围盒来描述在各个方向上看到的光线情况。我们不关心包围盒内的物体情况，我们在观察时只用查询对应光场函数就可以了。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231679656-2033b6ec-3f03-45ab-8fee-ce5d4359bccf.png" alt="Img" style="zoom:75%;" />
</center>
<p>我们关注一个面上的光场情况。前文提到，我们可以使用两个点表示一条光线。因此对于光场，我们也可以使用两个平面表示一个光场。其中，远离物体的为
s-t 平面，靠近物体的为 u-v 平面。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231679960-6ec8e408-4a6b-4dc1-9fbd-43f3016e907e.png" alt="Img" style="zoom:75%;" />
</center>
<p>如果我们固定某一个平面上面的点，我们可以观察在另一平面上不同点的分布：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231680107-fff8418e-a8b4-4a84-ab44-5cda0c9573d0.png" alt="Img" style="zoom:75%;" />
</center>
<ul>
<li>当我们固定 u-v 平面上的点，每一个 s-t 平面都是一副完整的图像；</li>
<li>当我们固定 s-t 平面上的点，每一个 u-v
平面上的点都是同一个像素在不同方向上看到的结果。</li>
</ul>
<p>根据这样的方式，我们可以造出光场照相机（Light Field
Camera）。光场照相机是一系列镜头矩阵构成的照相机。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231680577-e8ad6228-075b-4fec-8a4c-27373462143c.png" alt="Img" style="zoom:75%;" />
</center>
]]></content>
      <categories>
        <category>GAMES 101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>相机</tag>
        <tag>镜头</tag>
        <tag>光场</tag>
      </tags>
  </entry>
  <entry>
    <title>石蒜模拟器——为 Next 主题加上🐟吧~</title>
    <url>/2024/02/23/%E7%9F%B3%E8%92%9C%E6%A8%A1%E6%8B%9F%E5%99%A8-%E4%B8%BA-Next-%E4%B8%BB%E9%A2%98%E5%8A%A0%E4%B8%8A%F0%9F%90%9F%E5%90%A7/</url>
    <content><![CDATA[<p>Next 主题添加<a
href="https://github.com/itorr/sakana">石蒜模拟器</a>还是很 easy
滴~。根据 Next 文档，只需在主题配置文件中配置
<code>custom_file_path</code> 选项即可，具体的配置如下：</p>
<span id="more"></span>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Define custom file paths.</span></span><br><span class="line"><span class="comment"># Create your custom files in site directory `source/_data` and uncomment needed files below.</span></span><br><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment"># head: source/_data/head.swig</span></span><br><span class="line">  <span class="comment"># header: source/_data/header.swig</span></span><br><span class="line">  <span class="comment"># sidebar: source/_data/sidebar.swig</span></span><br><span class="line">  <span class="comment"># postMeta: source/_data/post-meta.swig</span></span><br><span class="line">  <span class="comment"># postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class="line">  <span class="attr">footer:</span> <span class="string">source/_data/footer.swig</span></span><br><span class="line">  <span class="comment"># bodyEnd: source/_data/body-end.swig</span></span><br><span class="line">  <span class="comment"># variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment"># mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="comment"># style: source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>
<p>然后再在 <code>source/_data</code> 目录下新建 <code>footer.njk</code>
文件，内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">  <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/sakana-widget@2.7.0/lib/sakana.min.css&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;sakana-widget&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: fixed; bottom: 10px; right: 20px; z-index: 999;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">initSakanaWidget</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">SakanaWidget</span>().<span class="title function_">mount</span>(<span class="string">&#x27;#sakana-widget&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">  <span class="attr">async</span></span></span><br><span class="line"><span class="tag">  <span class="attr">onload</span>=<span class="string">&quot;initSakanaWidget()&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/sakana-widget@2.7.0/lib/sakana.min.js&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就 OK 了，重新部署 Hexo，就可以看到 Sakana
了。其他的主题也可使用类似的方法来实现。如果你的主题没有
<code>custom_file_path</code> 选项，可以直接在主题的 <code>layout</code>
文件中添加上面的代码。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a
href="https://kanochi.cn/archives/7/">石蒜模拟器-为你的博客或网站加上🐟吧~</a></li>
<li><a
href="https://www.naokuoteng.cn/posts/e5482ed2.html">给友链页面添加一个
Sakana~</a></li>
<li><a href="https://zero617.top/2022/09/2e7c2ba499b6.html">快来为你的
Hexo 博客添加可爱的石蒜模拟器吧！</a></li>
<li><a href="https://github.com/itorr/sakana">itorr/sakana |
GitHub</a></li>
<li><a
href="https://github.com/dsrkafuu/sakana-widget">dsrkafuu/sakana-widget
| GitHub</a></li>
</ul>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>リコリス・リコイル</tag>
        <tag>石蒜模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title>着色</title>
    <url>/2023/07/16/%E7%9D%80%E8%89%B2/</url>
    <content><![CDATA[<blockquote>
<p>在 GAMES101 这门课中，认为着色是将一个材质应用到一个物体上。</p>
</blockquote>
<h2 id="blinn-phong-反射模型blinn-phong-reflectance-model">Blinn-Phong
反射模型（Blinn-Phong Reflectance Model）</h2>
<p>Blinn-Phong
反射模型是一个简单的着色模型，这个模型考虑了以下几个部分：漫反射（Diffuse
reflection），高光（Specular highlights），环境光（Ambient
lighting）。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230043719-b38a5f9a-4dad-4dfb-99ec-e604b0566325.png" alt="Img" style="zoom:100%;" />
</center>
<h3 id="模型定义">模型定义</h3>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230045266-484d6e6c-e83f-4c4b-9282-93b68c6dfc80.png" alt="光线反射模型" style="zoom:100%;" />
</center>
<p>对于任意的着色点（Shading poing），我们定义：</p>
<ul>
<li><p>观察方向（Viewer direction）<span
class="math inline">\(\vec{v}\)</span>，是着色点到观察点的连线；</p></li>
<li><p>法线（Surface normal）<span
class="math inline">\(\vec{n}\)</span>，是垂直于反射面的方向向量；</p></li>
<li><p>光照方向（Light direction）<span
class="math inline">\(\vec{l}\)</span>，是着色点和光源的连线。</p></li>
</ul>
<p>向量 <span class="math inline">\(\vec{v}\)</span>、<span
class="math inline">\(\vec{n}\)</span>、<span
class="math inline">\(\vec{l}\)</span>
都是单位向量。同时我们还需要定义物体表面的参数，例如颜色，亮度。</p>
<p>着色是局部的操作，着色时，不考虑其他的物体遮挡，因此着色中没有阴影。</p>
<h3 id="漫反射diffuse-reflection">漫反射（Diffuse Reflection）</h3>
<p>漫反射中光会向各个方向均匀反射，从如何方向观察到的表面颜色多是相同的。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230047344-9a171c3d-f50c-4bf2-8726-1d499ed1bb5a.png" alt="漫反射示意图" style="zoom:75%;" />
</center>
<p><strong>Lambert’s 余弦定律</strong>（Lambert’s Cosine
Law）表明了漫反射光的能量和入射角度之间的关系。光线反射的能量和光照方向（<span
class="math inline">\(\vec{l}\)</span>）以及法线（<span
class="math inline">\(\vec{n}\)</span>）的夹角余弦值（即 <span
class="math inline">\(\cos \theta\)</span>）成正比。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230047998-59946ccc-229d-419a-9de3-d6e126ed8e3d.png" alt="Lambert’s 余弦定律" style="zoom:75%;" />
</center>
<p>由于 <span class="math inline">\(\vec{l}\)</span> 和 <span
class="math inline">\(\vec{n}\)</span> 都是单位向量，所以可以得到：
<span class="math display">\[
\cos \theta = \vec{l} \cdot \vec{n}
\]</span>
对于一个点光源，在同一时刻的光的能量集中在一个球壳上，考虑到能量守恒定律，每个时刻球壳上的能量总和不变。随着球壳的变大，单位面积上的光能量会变小。设距离为
<span class="math inline">\(1\)</span> 时的能量为 <span
class="math inline">\(I\)</span>，则在距离为 <span
class="math inline">\(r\)</span> 的地方光的能量为： <span
class="math display">\[
\frac{I}{r^2}
\]</span> 经过上述分析，得出的漫反射公式为： <span
class="math display">\[
L_d = k_d \frac{I}{r^2} \max \left(0,\boldsymbol{n} \cdot
\boldsymbol{l}\right)
\]</span></p>
<p>上述公式中，<span class="math inline">\(k_d\)</span>
表示漫反射系数，如果用 RGB
定义一个向量作为漫反射系数就可以代表这个反射点的颜色。<span
class="math inline">\(\max \left(0,\boldsymbol{n} \cdot
\boldsymbol{l}\right)\)</span>
可以把反射光线在反方向的光线过滤掉，这些光线没有任何贡献。从公式可以看出，漫反射与观测方向没有任何关系，符合漫反射的定义。</p>
<p>下图表述了不同的 <span class="math inline">\(k_d\)</span>
下的漫反射效果：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230051381-ebf6114d-6390-4c87-8473-0fd2cc02eaa6.png" alt="Lambert’s 余弦定律" style="zoom:75%;" />
</center>
<h3 id="高光项镜面反射">高光项（镜面反射）</h3>
<p>镜面反射取决于观察方向，当观察方向与反射方向接近时我们就能看到高光，如下图所示：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230074681-e0497c4d-4714-47f7-8bb4-0b163621ce2d.png" alt="镜面反射示意图" style="zoom:75%;" />
</center>
<p>在实际应用中一般用<strong>半程向量</strong>（Half
vector）来刻画观察方向和反射方向的解决程度。如果观察方向和反射方向非常接近，则半程向量和法线方向非常接近，如下图所示：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230075798-ab5f2a87-53c2-4c1e-9e68-47333026d731.png" alt="半程向量示意图" style="zoom:75%;" />
</center>
<p>半程向量用 <span class="math inline">\(\vec{h}\)</span> 表示，<span
class="math inline">\(\vec{h}\)</span> 也是单位向量，显然： <span
class="math display">\[
\vec{h} = \frac{\vec{v} + \vec{l}} {\left\|\vec{v} + \vec{l}\right\|}
\]</span> 高光项计算公式为： <span class="math display">\[
\begin{align*}
L_s &amp;= k_s \frac{I} {r^2} \max\left(0, \cos \alpha \right)^p \\
&amp; = k_s \frac{I} {r^2} \max\left(0, \vec{n} \cdot \vec{h} \right)
\end{align*}
\]</span></p>
<p>公式中 <span class="math inline">\(k_s\)</span>
为镜面反射系数。Blinn-Phong 反射模型中的高光项不考虑 Lambert’s
余弦定律，即忽略 <span class="math inline">\(\left(0,\boldsymbol{n}
\cdot \boldsymbol{l}\right)\)</span>. 在公式中，有一个指数 <span
class="math inline">\(p\)</span>，引入这个指数是为了将高光限制在一个小范围内，一般来说：<span
class="math inline">\(p\in\left[100, 200\right]\)</span>。不同的 <span
class="math inline">\(p\)</span> 对余弦函数的影响如下：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230078747-e9a54e57-216f-4d57-936a-ad05c887f497.png" alt="指数的选择" style="zoom:75%;" />
</center>
<p>选取不同的 <span class="math inline">\(p\)</span> 和 <span
class="math inline">\(k_s\)</span> 的得到的效果如下图所示：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230079173-753ff962-9657-422f-8842-0bdc36f76b7c.png" alt="Img" style="zoom:100%;" />
</center>
<h3 id="环境光">环境光</h3>
<p>在 Blinn-Phong
反射模型中认为环境光是一个常数，不依赖于光源方向、法线方向和观察方向。环境光计算公式如下：
<span class="math display">\[
L_a = k_a I_a
\]</span> 其中 <span class="math inline">\(I_a\)</span>
为环境光反射系数。</p>
<h3 id="blinn-phong-反射模型">Blinn-Phong 反射模型</h3>
<p>综上所述，Blinn-Phong 反射模型如下： <span class="math display">\[
\begin{align*}
L &amp;= L_a + L_d + L_S \\
&amp;= k_aI_a + k_d \frac{I}{r^2} \max\left(0, \vec{n} \cdot
\vec{l}\right) + k_s \frac{I}{r^2} \max\left(0, \vec{n} \cdot
\vec{h}\right)^p
\end{align*}
\]</span></p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230080150-2dd31032-835b-4844-8dc5-70479b002326.png" alt="Blinn-Phong 反射模型" style="zoom:100%;" />
</center>
<h2 id="着色频率shading-frequencies">着色频率（Shading
Frequencies）</h2>
<p>根据不同的着色方式，有不同的着色频率，主要的着色频率分为三种——面着色、顶点着色和像素着色。主要的不同之处在于法线的选择方式不同。</p>
<ul>
<li><strong>面着色</strong>（Flat
Shading，指的是计算每一个三角形平面的法线后对一个平面整体进行着色；</li>
<li><strong>顶点着色</strong>（Gouraud
Shading），指的是计算每一个三角形三个顶点的法线后进行着色，最后在三角形内部插值得到颜色。顶点法线的计算是通过顶点相邻面的法线的（加权）平均值求出；</li>
<li><strong>像素着色</strong>（Phong
Shading），指的是计算出每一个像素的法线进行着色。三角形内部点法线的计算需要依靠重心坐标进行插值计算。</li>
</ul>
<p>不同的着色频率的效果如下所示：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230081961-97fcfe87-65e7-4450-96a8-23612143e532.png" alt="Img" style="zoom:100%;" />
</center>
<p>当几何体相对复杂，构造精细的时候，三种着色效果产生的结果不相上下，如下图所示：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230082185-4a581a7f-93ef-4136-8d25-7f3e61e3d0a2.png" alt="Img" style="zoom:75%;" />
</center>
<p>如何定义一个顶点的法线呢？有两种方法，一种是使用一个球形包围盒，求顶点法线就简化成了求球表面顶点的法线，如下如所示：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230083024-b99a0202-a6bc-4e13-9371-e2dd89781bf3.png" alt="Img" style="zoom:50%;" />
</center>
<p>另外一种方法是求出顶点相邻的三角形的法线，然后做一个平均，再做一个归一化，即：
<span class="math display">\[
N_v = \frac{\sum_i N_i}{\left\| \sum_i N_i \right\|}
\]</span></p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230083668-cfcc2ce1-73d5-4def-9f84-c3e252a22245.png" alt="Img" style="zoom:50%;" />
</center>
<p>如何求出每个像素的法线呢？先求出三角形顶点的法线，在通过插值的方式求出每个像素的法线，如下图所示：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230084990-758e0bc0-c1b8-40d4-9103-188f54e45e52.png" alt="Img" style="zoom:75%;" />
</center>
<h2
id="实时渲染管线real-time-rendering-pipeline">实时渲染管线（Real-time
Rendering Pipeline）</h2>
<p>管线是从模型到图片生成的过程。管线分为以下过程：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230085432-ae7b5ff2-172f-4fea-8e71-0c57e43eb60e.png" alt="管线" style="zoom:100%;" />
</center>
<p>首先将顶点的三位向量作为输入，进行几何变换后划分三角形区域。通过光栅化获得一个个小的碎片（或者是一个个小像素）后进行着色，得到我们的输出。</p>
<p>我们可以定义顶点或者像素的着色方式来提供不同的着色要求，这被称为程序
Shader。硬件中会提供这样的编程方式定制不同的着色方式，以 OpenGL
为例，可以定义以下的着色函数：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> myTexture;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightDir;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> uv;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> norm;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> diffuseShader() &#123;</span><br><span class="line">    <span class="type">vec3</span> kd;</span><br><span class="line">    kd = texture2d(myTexture, uv);</span><br><span class="line">    kd *= <span class="built_in">clamp</span>(<span class="built_in">dot</span>(-lightDir, norm), <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = (kd, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们定义了一个简单的漫反射着色器。同时，着色器会自动应用到每一个顶点或者是像素上，不需要我们使用显式的
for 循环进行遍历。</p>
<blockquote>
<p>我们可以进入 <a
href="https://www.shadertoy.com/view/ld3Gz2">Shadertoy</a> 网站练习
Shader 编程，编程的结果会直接显示在网页中。</p>
<p>关于管线的更多内容可以参考文章：《细说图形学渲染管线》。</p>
</blockquote>
<h2 id="纹理映射texture-mapping">纹理映射（Texture Mapping）</h2>
<h3 id="三维物体表面展开">三维物体表面展开</h3>
<p>任何一个三维物体的表面都是二维的图形，可以将一个三维物体表面映射到一个二维的图像上。例如下图所示的地图和地球仪：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230094013-747a11f3-77e8-4205-9cad-3cdcdad3e7d6.png" alt="管线" style="zoom:100%;" />
</center>
<p>建立一个 <span class="math inline">\(\left(u, v\right)\)</span>
坐标系，且 <span class="math inline">\(u, v \in \left[0,
1\right]\)</span>. 如下图所示：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230092205-c34c08e3-f4c8-4c03-94b9-7b5c4a8697ef.png" alt="管线" style="zoom:100%;" />
</center>
<p>在知道知道每一个三角形的顶点坐标和对应的纹理坐标的情况下，可以通过插值的方法求出三角形内部所有点的对应的纹理坐标，需要使用重心坐标计算。</p>
<p>在为墙面，地面加入纹理的时候可以使用边缘连接连续的纹理，称为
tiled。这样子就可以复用纹理拼接大表面。</p>
<h3 id="重心坐标">重心坐标</h3>
<p>通过插值，我们可以好的三角形内部平滑变化的值，例如纹理坐标、颜色、法线等等。要插值，就要使用<strong>重心坐标</strong>（Barycentric
Coordinates）。</p>
<p>重心坐标是一种使用三角形三个顶点定义的坐标系统，坐标为 <span
class="math inline">\(\left(\alpha, \beta, \gamma \right)\)</span>.</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230101576-b88a05f4-f641-42eb-8807-2910c54528e0.png" alt="Img" style="zoom:50%;" />
</center>
<p>对于任意一点 <span class="math inline">\(\left(x,
y\right)\)</span>，如果满足： <span class="math display">\[
\left(x, y\right) =  \alpha A + \beta B + \gamma C \\
\alpha + \beta + \gamma = 1
\]</span> 则这个点在 <span class="math inline">\(\triangle ABC\)</span>
所处的平面上。如果 <span class="math inline">\(\alpha\)</span>、<span
class="math inline">\(\beta\)</span>、<span
class="math inline">\(\gamma\)</span> 全部大于 <span
class="math inline">\(0\)</span>，则这个点在 <span
class="math inline">\(\triangle ABC\)</span>
内部。这说明三角形平面上任意一点都可以用三角形三个顶点坐标的线性组合表示。只需要计算出三个系数中的
2 个，就可以通过 <span class="math inline">\(\alpha + \beta + \gamma =
1\)</span> 得出第 3 个系数的值。</p>
<p>我们还可以使用面积来计算重心坐标，假设点 <span
class="math inline">\(A\)</span>、<span
class="math inline">\(B\)</span>、<span class="math inline">\(C\)</span>
对应的小三角形的面积分别为 <span
class="math inline">\(A_A\)</span>、<span
class="math inline">\(A_B\)</span>、<span
class="math inline">\(A_C\)</span>，如下图所示：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230104883-801545ed-978d-41d6-a865-e5c82a40ecf8.png" alt="Img" style="zoom:50%;" />
</center>
<p>则重心坐标为： <span class="math display">\[
\begin{align*}
\alpha &amp;= \frac{A_a}{A_a + A_b + A_c} \\
\beta &amp;= \frac{A_b}{A_a + A_b + A_c} \\
\gamma &amp;= \frac{A_c}{A_a + A_b + A_c}
\end{align*}
\]</span> 重心坐标为 <span class="math inline">\(\left(\frac{1}{3},
\frac{1}{3}, \frac{1}{3}\right)\)</span> 的点是 <span
class="math inline">\(\triangle ABC\)</span> 的重心。</p>
<p>在已知要求的点的坐标的坐标的前提下，<span
class="math inline">\(\triangle ABC\)</span>
的重心坐标公式可以写成如下形式： <span class="math display">\[
\begin{align*}
\alpha &amp;
=\frac{-\left(x-x_B\right)\left(y_C-y_B\right)+\left(y-y_B\right)\left(x_C-x_B\right)}{-\left(x_A-x_B\right)\left(y_C-y_B\right)+\left(y_A-y_B\right)\left(x_C-x_B\right)}
\\
\beta &amp;
=\frac{-\left(x-x_C\right)\left(y_A-y_C\right)+\left(y-y_C\right)\left(x_A-x_C\right)}{-\left(x_B-x_C\right)\left(y_A-y_C\right)+\left(y_B-y_C\right)\left(x_A-x_C\right)}
\\
\gamma &amp; =1-\alpha-\beta
\end{align*}
\]</span>
如果三角形三个顶点对应了三个向量（颜色，法线或者纹理坐标），那么内部点对应的向量值是使用重心坐标进行的线性组合。</p>
<p>假设三个顶点对应的向量是 <span
class="math inline">\(V_A\)</span>、<span
class="math inline">\(V_B\)</span>、<span
class="math inline">\(V_C\)</span>，那么三角形中任意一点的插值后向量是
<span class="math inline">\(V = \alpha V_a + \beta V_B + \gamma
V_C\)</span>. 如下图所示是对颜色的插值：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230108225-c2c8c30b-8858-42c5-98a7-975576770a44.png" alt="Img" style="zoom:50%;" />
</center>
<p>注意，重心坐标在投影后不能保证结果不变，所以我们要在空间中使用三维坐标的重心公式进行插值。</p>
<h3 id="纹理映射的问题">纹理映射的问题</h3>
<p>纹理映射主要分为两步，第一步是把像素点坐标映射到纹理坐标：<span
class="math inline">\(\left(x, y\right) \rightarrow \left(u,
v\right)\)</span>。第二步根据纹理坐标得到对应的漫反射系数 <span
class="math inline">\(\left(u, v\right) \rightarrow k_d\)</span>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> each rasterized screen <span class="title">sample</span><span class="params">(x, y)</span>:</span></span><br><span class="line"><span class="function">	(u, v) =</span> <span class="function">evaluate texture coordinate <span class="title">at</span> <span class="params">(x, y)</span></span>;</span><br><span class="line">    texcolor = texture.<span class="built_in">sample</span>(x, y);</span><br><span class="line">	set sample<span class="number">&#x27;</span>s color to texcolor;</span><br></pre></td></tr></table></figure>
<p>纹理上的像素叫做纹理元素或者纹素（Texel），如果纹理过大或者过小都会出现一些问题。</p>
<h4 id="纹理太小">纹理太小</h4>
<p>如果纹理本身太小，但是物体像素点比较多，那么就会产生非常多类似于马赛克的像素。这是由于多个相邻的像素会映射到同一个纹理坐标。我们可以采用双线性插值来解决这个问题。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230114928-e9c9d19d-1fa8-4717-b025-2b71904ea6ed.png" alt="Img" style="zoom:100%;" />
</center>
<p><strong>双线性插值</strong>（Bilinear
Interpolation）指的是对于任意一个纹理坐标，使用其临近的四个纹素值进行两次线性插值得到这个坐标对应的漫反射率。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230114360-71c7eaee-8d70-4564-ae77-58190c5647a6.png" alt="双线性插值示意图" style="zoom:50%;" />
</center>
<p>在一维上的线性插值可以表示为： <span class="math display">\[
\text{lerp}\left(x, v_0, v_1\right) = v_0 + x\left(v_1 - v_0\right)
\]</span> 双线性插值先在水平方向上做两次线性插值： <span
class="math display">\[
\begin{align*}
u_0 &amp; = \text{lerp}\left(s, u_{00}, u_{10}\right) \\
u_1 &amp; = \text{lerp}\left(s, u_{01}, u_{11}\right) \\
\end{align*}
\]</span> 然后在垂直方向上做一次线性插值： <span class="math display">\[
f\left(x, y\right) = \text{lerp}\left(t, u_0, u_1\right)
\]</span> <strong>双立方插值</strong>（Bicubic Interpolation：使用相邻
16 个点进行计算，效果更好但是计算量相对来说更大。</p>
<h4 id="纹理太大">纹理太大</h4>
<p>当纹理过大的时候，近处的物体会产生锯齿，远处的物体会产生摩尔纹，也就是说结果会产生走样。主要原因是因为当物体离得越远，每一个像素所代表的纹素的数量会变多。这个时候再使用像素和纹素一一对应的方式是不可靠的。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230117164-0f91b0ea-a96a-4343-8c2a-f6bce9e658e7.png" alt="纹理过大结果示意图" style="zoom:50%;" />
</center>
<p>我们的解决方法是避免采样。通过像素点直接得到对应纹素区域的平均值。</p>
<p>引入 <strong>MipMap</strong> 来解决范围查询的问题。Mipmap
是一个快速、近似并且只应用于正方形区域的范围查询方法。主要思想如下：我们从一张纹理生成一系列的纹理，每一个纹理的大小都是之前纹理大小的一半，最后得到的最小的纹理是一个
<span class="math inline">\(1 \times 1\)</span>
的纹理，这就是一个图像金字塔。最终存储这些纹理额外的开销是原本纹理的
<span class="math inline">\(\frac{1}{3}\)</span>。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230118956-f78f0f7c-326c-4580-a797-70594d182d11.png" alt="纹理过大结果示意图" style="zoom:100%;" />
</center>
<p>我们需要计算每一个像素对应纹理的方形大小，并使用对应层的纹理。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230119359-fb3307e7-7a94-4ff6-b12e-4da02612fb5a.png" alt="Mipmap 对应层数计算" style="zoom:75%;" />
</center>
<p>对于一个点 <span class="math inline">\(u\left(0, 0\right)\)</span>
和其相邻的两个点之间在纹理上的距离，可以用微分形式表示，那么这个像素所对应纹理方形的大小是：
<span class="math display">\[
L = \max\left(\sqrt{\left(\frac{\mathrm{d}u}{\mathrm{d}x}\right)^2 +
\left(\frac{\mathrm{d}v}{\mathrm{d}x}\right)^2},
\sqrt{\left(\frac{\mathrm{d}u}{\mathrm{d}y}\right)^2 +
\left(\frac{\mathrm{d}v}{\mathrm{d}y}\right)^2}\right)
\]</span> 那么对应的层数为： <span class="math display">\[
D = \log_2 L
\]</span> 将 Mipmap 层数可视化的效果如下图所示：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230120918-6dc26752-7b2c-4470-863b-7cd5b076ba3e.png" alt="Mipmap 层数可视化" style="zoom:100%;" />
</center>
<p>可以看出，Mipmap
只能查出整数的层，为了保证能够查询到非整数的层，使用三线性插值法得到对应的结果。首先，对于任意一个非整数层数，我们在其上下两层使用双线性插值进行取值。接下来我们在两个层之间使用线性插值就可以得到最后的结果。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230121854-e2edee8e-084d-4167-80b0-7dce704b7bfa.png" alt="Img" style="zoom:70%;" />
</center>
<p>使用三线性插值法的到效果如下：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230122237-274f524d-5d63-4d8d-a008-93b0c7b9757e.png" alt="Img" style="zoom:75%;" />
</center>
<p>Mipmap
也存在局限性。由于所有的纹理都必须对应到一个正方形的区域，但是并不是所有的纹理都可以被一个正方形完美的包住（例如细长的长方形，或者是在对角线上的长方形）。最终远处的纹理会变得非常的模糊，丢失了许多细节。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230123225-11b439f0-3491-45df-837d-8e2688f945c2.png" alt="Img" style="zoom:100%;" />
</center>
<p>为了解决这个问题，我们使用<strong>各向异性过滤</strong>（Anisotropic
Filtering）解决。各向异性过滤指的是加入只在水平方向或者竖直方向上缩小的纹理，这样可以应对不同长方形纹理块区域。但是对于对角线上的纹理块依然不好解决，并且存储多余的纹理需要多使用原来纹理三倍的开销。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230123810-b1e7feca-62ec-4d97-bff2-cfa02afd6cb5.png" alt="各向异性过滤的纹理图" style="zoom:75%;" />
</center>
<p>除此之外我们还可以使用 EWA
过滤得到更好的结果。可以把纹理拆分成不同的圆形块进行多次查询获得最终的结果。但是开销也会比较大。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230124064-5fe39933-13df-45f5-bec5-d724410a6145.png" alt="EWA 过滤的纹理图" style="zoom:75%;" />
</center>
<h2 id="纹理的应用">纹理的应用</h2>
<p>纹理除了是一个「贴图」之外，纹理还有各种各样的应用。在现代的 GPU
中，纹理是一块内存加上范围查询（滤波）的结果。除了上面简单的纹理应用之外，我们还可以使用纹理做以下事情。</p>
<h3 id="环境贴图">环境贴图</h3>
<p><strong>环境贴图</strong>（Environment
Map）指的是环境中四面八方的情况。可以使用纹理来描述环境光的样子。环境光纹理可以看作一个光滑镜面的球表面在环境中所记录的信息。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230125475-d4d2a80e-88c9-4bb8-91c8-c19969cf1f41.png" alt=Img" style="zoom:75%;" />
</center>
<p>我们需要将球表面展开成一个平面，可以使用两种展开方式：</p>
<ol type="1">
<li><strong>墨卡托投影法</strong>（Mercator
Projection）：通过将球面映射到一个平面上，我们可以使用墨卡托投影法。墨卡托投影法应用于目前地球仪的投影。它的特点是靠近南北极的地方会发生较大的畸变，这不是一个均匀地描述。</li>
</ol>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230125867-f5a91235-4d89-4dce-bb58-d70872c3e507.png" alt=Img" style="zoom:100%;" />
</center>
<ol start="2" type="1">
<li><strong>立方体映射</strong>（Cube
Map）：我们为光滑球定义一个包围盒，将球面投影到立方体的六个平面上，这样做就会得到
6
张纹理，并且畸变比较小。但是在计算纹素时需要计算球面上的点对应哪一张纹理，需要判断点和方向的位置关系。</li>
</ol>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230126371-2bd84266-ecf8-4f0e-954f-362b79de8f7d.png" alt=Img" style="zoom:75%;" />
</center>
<h3 id="凹凸贴图">凹凸贴图</h3>
<p><strong>凹凸贴图</strong>是指用纹理的方式得到物体表面凹凸不平的感觉，相比于直接通过做出物体凹凸不平的方式，这种方法更加的简单。对于任何一个点，我们只需要改变这个点的法线方向就可以表达出这个点高度的变化。因此这个贴图也被称作<strong>法线贴图</strong>（Bump
mapping）。纹理上的点定义的是点高度的移动，通过纹理上信息我们可以求出新的法线方向。</p>
<p>在二维的情况下，我们假设原物体是一条直线，原始法线方向为 <span
class="math inline">\(\left(0, 1\right)\)</span>。对于任意一个点 <span
class="math inline">\(p\)</span>，我们定义 <span
class="math inline">\(p\)</span> 点的导数是 <span
class="math inline">\(\mathrm{d}p = c \cdot [h(p + 1) -
h(p)]\)</span>。常数 <span class="math inline">\(c\)</span>
定义了凹凸贴图对于法线的影响。那么该点切线的方向是 <span
class="math inline">\(\left(1, \mathrm{d}
p\right)\)</span>。法线的方向和切线的方向成 <span
class="math inline">\(90\)</span> 度角，法线的方向向量是 <span
class="math inline">\(\left(\mathrm{d} p, -1\right)\)</span>
正则化后的结果。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230127805-b1f12349-d7b2-438d-8af7-d5416c7a605e.png" alt=Img" style="zoom:50%;" />
</center>
<p>推广到三维情况，对于一个原始法线是 <span
class="math inline">\(\left(0, 0, 1\right)\)</span> 的平面，我们在 <span
class="math inline">\(u\)</span> 方向和 <span
class="math inline">\(v\)</span> 方向上各做一次求导，结果为： <span
class="math display">\[
\begin{align*}
\frac{\mathrm{d}p}{\mathrm{d}u} &amp; = c1 \cdot [h(u + 1) - h(u)] \\
\frac{\mathrm{d}p}{\mathrm{d}v} &amp; = c2 \cdot [h(v + 1) - h(v)] \\
\end{align*}
\]</span> 法线方向是： <span class="math display">\[
\left(-\frac{\mathrm{d}p}{\mathrm{d}u},-\frac{\mathrm{d}p}{\mathrm{d}v},1\right)
\]</span></p>
<p>对于任意方向的原始法线，我们都可以先按照局部坐标系计算法线后通过变换变换到世界坐标系上。</p>
<p>除了凹凸贴图之外，还有另外一种贴图称作位移贴图。位移贴图会移动所有顶点位置。因此使用顶点贴图的时候模型三角形分的越细越好。凹凸贴图并没有实际改变物体的形状，所以在物体的边上依旧可以看到光滑的曲线。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/230128989-0e9ae946-8361-4fcd-9145-34df33d2ae11.png" alt=Img" style="zoom:100%;" />
</center>
<p>贴图可以推广到三维空间，我们可以使用三维贴图，计算三维空间中任意一个点对应的纹理。</p>
<h3 id="阴影贴图">阴影贴图</h3>
<p>贴图还可以直接加入一些阴影，直接计算好贴在纹理上，这样会使得阴影计算变得很快。纹理可以记录一些已经计算好阴影的信息。</p>
<h2 id="阴影">阴影</h2>
<p><strong>Shadow Mapping</strong>
是一种使用光栅化生成阴影的算法，在计算阴影的时候我们不需要知道场景的几何信息。Shadow
Mapping 的方法只适用于在点光源下计算硬阴影。</p>
<p>硬阴影指的是一个点是否在阴影内是确定的，它不是在阴影内就在阴影外；只有点光源才可以产生这种情况。软阴影指的是阴影是有过渡的，一个点可以接收到部分光线；当不忽略光源大小的时候，就会产生这种情况。可以接收到部分光线的区域一般称为半影。</p>
<p>一个点是否在阴影中取决于光源和摄像机是不是都可以看到这个点。如果都可以看到这个点，那么说明这个点不在阴影里。因此我们使用如下方式进行计算：</p>
<ol type="1">
<li>从光源位置看向场景，做出深度图；</li>
<li>从摄像机位置看向场景，对于每一个看到的点，计算到光源的距离，并且得到光源深度图上对应像素点的距离进行比较。如果距离一样，那么说明这个点不在阴影中，反之，这个点在阴影中。</li>
</ol>
<p>这样的算法有两个问题：</p>
<ol type="1">
<li>距离是一个浮点数，不容易进行比较。需要引入一定的宽容度。这是数值精度的问题，不能从本质解决问题；</li>
<li>阴影的质量和光源深度图的分辨率有关。如果光源深度图太小，但是摄像机分辨率大就容易出现走样问题；</li>
<li>这个方法只适合硬阴影，不适合软阴影。</li>
</ol>
]]></content>
      <categories>
        <category>GAMES 101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>着色</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数复习</title>
    <url>/2023/07/16/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="向量vectors">向量（Vectors）</h2>
<p>向量指的是具有<strong>大小</strong>（Magnitude）和<strong>方向</strong>（Direction）的量。在物理学中也称为矢量。向量的表示通常使用小写字母上面加上向右的箭头
<span class="math inline">\(\rightarrow\)</span> 表示，例如 <span
class="math inline">\(\vec{a}\)</span>，或者使用粗体的小写字母表示，例如
<span class="math inline">\(\boldsymbol{a}\)</span>.</p>
<p>向量具有平移不变形。向量只与大小和方向有关系，和向量的起点和终点没有关系。向量也只包含两个属性：<strong>大小</strong>和<strong>方向</strong>。</p>
<p>对于空间中的两个点 <span class="math inline">\(𝐴\)</span> 和 <span
class="math inline">\(𝐵\)</span>，从 <span
class="math inline">\(𝐴\)</span> 到 <span
class="math inline">\(𝐵\)</span> 的向量可以表示为 <span
class="math inline">\(\overrightarrow{AB}\)</span>，计算方法为 <span
class="math inline">\(\overrightarrow{AB} = B - A\)</span>.</p>
<p>对于向量 <span class="math inline">\(\vec{a}\)</span>
来说，其大小，即 <span class="math inline">\(\vec{a}\)</span>
的模（norm）记为：<span class="math inline">\(\left\| \vec{a}
\right\|\)</span>.</p>
<h3 id="向量归一化vector-normalization">向量归一化（Vector
Normalization）</h3>
<p><strong>模为 1 的向量</strong>称之为<strong>单位向量（Unit
vector）</strong>，对于向量 <span
class="math inline">\(\vec{a}\)</span>，与其方向相同的单位向量记为：<span
class="math inline">\(\hat{a}\)</span>，计算公式为：</p>
<p><span class="math display">\[
\hat{a} = \frac{\vec{a}}{\left\| \vec{a} \right\|}
\]</span></p>
<blockquote>
<p>上述公式不适应于零向量。零向量方向是唯一的，没有对应的单位向量。</p>
<p>单位向量一般用来表示方向。</p>
</blockquote>
<h3 id="向量加法vector-addition">向量加法（Vector Addition）</h3>
<p>向量的加法可以用两种法则：<strong>平行四边形法则</strong>（Parallelogram
law）或者<strong>三角形法则</strong>（Triangle law）。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/229414846-986e11d8-e705-4cea-bdc0-f76aa376d60a.png" alt="Img" style="zoom:30%;" />
</center>
<p>两个向量相加时，以表示这两个向量的线段为邻边作平行四边形，这两个邻边之间的对角线就代表向量和的大小和方向，这就叫做平行四边形定则。</p>
<p>三角形法则是指，将一个向量的起点移动到另一个向量的终点时，向量和为从未移动向量的起点指向所移动向量的终点的向量。三角形法则适用于多个向量求和，只需要将向量按照相加顺序依次首尾排列，第一个向量的起点指向最后一个向量的终点的向量就是求和的结果。</p>
<p>在代数上，对于在笛卡尔坐标系中定义的向量，向量求和可以简化为求向量各个对应坐标值的和。</p>
<h3
id="笛卡尔坐标系cartesian-coordinates-system">笛卡尔坐标系（Cartesian
Coordinates System）</h3>
<p>笛卡尔坐标系，亦称直角坐标系，是一种正交坐标系。二维的直角坐标系是由两条相互垂直，相交于原点的数线构成的。在平面内，任何一点的坐标是根据数轴上对应的点的坐标设定的。对于向量，我们认为所有向量都是以原点为起点，那么终点的坐标就可以表示一个唯一的向量。</p>
<p>在计算机图形学中，我们默认所有的向量都是列向量，用符号表示向量，向量的转置以及向量的模如下：</p>
<p><span class="math display">\[
A=\begin{bmatrix}
x \\
y
\end{bmatrix}
\]</span></p>
<p><span class="math display">\[
A^{\mathrm{T}} = \begin{bmatrix}
x &amp; y
\end{bmatrix}^{T}
\]</span></p>
<p><span class="math display">\[
\left\| A \right\| = \sqrt{x^2 + y^{2}}
\]</span></p>
<h3 id="向量乘法vector-multiplication">向量乘法（Vector
Multiplication）</h3>
<h4 id="点乘dot-product">点乘（Dot Product）</h4>
<p>点乘，又称为向量的内积。计算公式为：</p>
<p><span class="math display">\[
\vec{a} \cdot \vec{b}=\left\| \vec{a} \right\| \left\|\vec{b} \right\|
\cos \theta
\]</span></p>
<p>在笛卡尔坐标系下点乘的计算结果是逐坐标元素相乘后相加的结果。</p>
<p>在 2 维情况下：</p>
<p><span class="math display">\[
\vec{a} \cdot \vec{b} = \begin{bmatrix} x_a \\ y_a \end{bmatrix} \cdot
\begin{bmatrix} x_b \\ y_b \end{bmatrix} = x_a x_b + y_a y_b
\]</span></p>
<p>在 3 维情况下：</p>
<p><span class="math display">\[
\vec{a} \cdot \vec{b} = \begin{bmatrix} x_a \\ y_a \\ z_a  \end{bmatrix}
\cdot \begin{bmatrix} x_b \\ y_b \\ z_b \end{bmatrix} = x_a x_b + y_a
y_b + z_a z_b
\]</span></p>
<p>点乘的性质：</p>
<p><span class="math display">\[
\begin{align*}
\vec{a} \cdot \vec{b} &amp;= \vec{b} \cdot \vec{a} \text{ (交换律)} \\
\vec{a} \cdot (\vec{b} + \vec{c}) &amp;= \vec{a} \cdot \vec{b} + \vec{a}
\cdot \vec{c} \text{ (分配律)} \\
(k \vec{a}) \cdot \vec{b} &amp;= \vec{a} \cdot (k\vec{b}) = k(\vec{a}
\cdot \vec{b})
\end{align*}
\]</span></p>
<p>点乘的应用：</p>
<ol type="1">
<li>计算出两个向量的夹角：</li>
</ol>
<p><span class="math display">\[
\cos \theta=\frac{\vec{a} \cdot \vec{b}}{\left\| \vec{a} \right \|
\left\| \vec{b} \right\|}
\]</span></p>
<p>用 <span class="math inline">\(\vec{a}\)</span> 和 <span
class="math inline">\(\vec{b}\)</span> 的单位向量表示为：</p>
<p><span class="math display">\[
\cos \theta = \hat{a} \cdot \hat{b}
\]</span></p>
<ol start="2" type="1">
<li>计算一个向量在另外一个向量上的投影：</li>
</ol>
<p>向量 <span class="math inline">\(\vec{b}\)</span> 在向量 <span
class="math inline">\(\vec{a}\)</span> 上的投影满足：</p>
<p><span class="math display">\[
\vec{b}_{\perp} = k \vec{a}
\]</span></p>
<p><span class="math inline">\(k\)</span> 的大小为：</p>
<p><span class="math display">\[
k = \left\| \vec{b}_{\perp} \right\| = \left\| \vec{b} \right\| \cos
\theta
\]</span></p>
<p>已知两个向量的内积，则 <span class="math inline">\(k\)</span>
的大小可表示如下：</p>
<p><span class="math display">\[
k = \left\| \vec{b} \right\| \cos \theta = \frac{\vec{a} \cdot
\vec{b}}{\left\| \vec{a} \right\|}
\]</span></p>
<ol start="3" type="1">
<li>计算两个向量的接近程度：根据 <span
class="math inline">\(\cos\)</span> 在角度 <span
class="math inline">\(\left[0, \pi \right]\)</span>
之间的值可以得出结论，越接近（夹角比较小）的两个向量的单位向量点乘结果越接近于
<span
class="math inline">\(1\)</span>，反之越远离（夹角比较大）的两个向量的单位向量点乘结果越接近于
<span class="math inline">\(-1\)</span>.</li>
<li>计算两个向量的方向是相同还是相反的：首先我们定义两个向量的方向相同或者相反。如图所示，向量
<span class="math inline">\(\vec{a}\)</span>
以其垂线为分界，在上半部分（上半圆）的向量认为和向量 <span
class="math inline">\(\vec{a}\)</span>
方向基本相同，在下半部分（下半圆）的向量认为和向量 <span
class="math inline">\(\vec{a}\)</span> 方向基本相反。</li>
</ol>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/229419075-8481a506-5625-415a-9119-046d7eb172be.png" alt="Img" style="zoom:45%;" />
</center>
<p>如果两个向量方向基本相同，那么点乘的结果大于 <span
class="math inline">\(0\)</span>；如果两个向量的方向基本相反，点乘的结果小于
<span
class="math inline">\(0\)</span>；如果两个向量是垂直的，那么点乘的结果等于
<span class="math inline">\(0\)</span>.</p>
<h4 id="叉乘cross-product">叉乘（Cross product）</h4>
<p>叉乘，又称作向量的外积。两个向量叉乘的结果还是一个向量，这个向量和原来的两个向量垂直。叉乘的结果向量的长度为：</p>
<p><span class="math display">\[
\left\| \vec{a} \times \vec{b} \right\| = \left\| \vec{a} \right\|
\left\| \vec{b} \right\| \sin {\varphi}
\]</span></p>
<p>结果向量的方向满足<strong>右手定则</strong>。叉乘不满足交换律。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/229419697-1137b072-5391-4dd0-9f7f-bfa03129e82a.png" alt="Img" style="zoom:100%;" />
</center>
<blockquote>
<p>叉乘在右手坐标系中满足右手定则，在左手坐标系中满足左手定则，但其代数运算在右手坐标系和左手坐标系的是一样的。</p>
</blockquote>
<p>叉乘的性质：</p>
<p><span class="math display">\[
\begin{align*}
\vec{a} \times \vec{b} &amp;= - \vec{b} \times \vec{a} \\
\vec{a} \times \vec{a} &amp;= \vec{0} \\
\vec{a} \times (\vec{b} + \vec{c}) &amp;= \vec{a} \times \vec{b} +
\vec{a} \times \vec{c} \\
\vec{a} \times {k \vec{b}} &amp;= k (\vec{a} \times \vec{b}) \\
\end{align*}
\]</span></p>
<p>在笛卡尔坐标系的表示下进行叉乘计算的结果可以写作：</p>
<p><span class="math display">\[
\vec{a} \times \vec{b} = \begin{bmatrix}
y_a z_b-y_b z_a \\
z_a x_b-x_a z_b \\
x_a y_b-y_a x_b
\end{bmatrix}
\]</span></p>
<p>我们可以将向量 <span class="math inline">\(\vec{a}\)</span>
写成等价的矩阵形式：</p>
<p><span class="math display">\[
\vec{a} \times \vec{b} = A^{*} b = \begin{bmatrix}
0 &amp; -z_a &amp; y_a  \\
z_a &amp; 0 &amp; -x_a \\
-y_a &amp; x_a &amp; 0
\end{bmatrix}
\begin{bmatrix}
x_b \\
y_b \\
z_b
\end{bmatrix}
\]</span></p>
<p>称 <span class="math inline">\(A^*\)</span> 为向量 <span
class="math inline">\(\vec{a}\)</span> 的对偶矩阵（dual matrix）.</p>
<p>叉乘的应用：</p>
<ol type="1">
<li>判断一个向量在另一个向量的左边还是右边：如果 <span
class="math inline">\(\vec{a} \times \vec{b}\)</span> 的方向与 <span
class="math inline">\(z\)</span> 轴正方向相同，则说明 <span
class="math inline">\(\vec{b}\)</span> 在 <span
class="math inline">\(\vec{a}\)</span> 的左侧；如果相反，则说明 <span
class="math inline">\(\vec{b}\)</span> 在 <span
class="math inline">\(\vec{a}\)</span> 的右侧。将 <span
class="math inline">\(\vec{a}\)</span> 和 <span
class="math inline">\(\vec{b}\)</span> 的起点移动到重合到一起，如果
<span class="math inline">\(\vec{b}\)</span> 在 <span
class="math inline">\(\vec{a}\)</span> 的左侧，则 <span
class="math inline">\(\vec{b}\)</span> 的终点在 <span
class="math inline">\(\vec{a}\)</span> 的左侧；如果 <span
class="math inline">\(\vec{b}\)</span> 在 <span
class="math inline">\(\vec{a}\)</span> 的右侧，则 <span
class="math inline">\(\vec{b}\)</span> 的终点在 <span
class="math inline">\(\vec{a}\)</span> 的右侧。</li>
<li>判定一个点在三角形的内部还是外部：如果 点 <span
class="math inline">\(P\)</span> 在点 <span
class="math inline">\(\overrightarrow{AB}\)</span>，<span
class="math inline">\(\overrightarrow{BC}\)</span>，<span
class="math inline">\(\overrightarrow{CA}\)</span> 的同一侧，则说明点
<span class="math inline">\(P\)</span> 在 <span
class="math inline">\(\triangle ABC\)</span> 的内部。即可以判断 <span
class="math inline">\(\overrightarrow{AB} \times
\overrightarrow{AP}\)</span>，<span
class="math inline">\(\overrightarrow{BC} \times
\overrightarrow{BP}\)</span>，<span
class="math inline">\(\overrightarrow{CA} \times
\overrightarrow{CP}\)</span> 的方向是否全部相同。</li>
</ol>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/229421008-1c4ef68b-ca64-4d19-9517-151b5d051c03.png" alt="Img" style="zoom:50%;" />
</center>
<h2
id="正交基和笛卡尔坐标系orthonormal-bases-and-coordinate-frames">正交基和笛卡尔坐标系（Orthonormal
bases and coordinate frames）</h2>
<p>对于任意的 3 个 3 维向量，满足：</p>
<p><span class="math display">\[
\begin{align*}
&amp; \left\| \vec{u} \right\| = \left\| \vec{v} \right\| = \left\|
\vec{w} \right\| = 1 \\
&amp; \vec{u} \cdot \vec{v}=\vec{v} \cdot \vec{w}=\vec{u} \cdot
\vec{w}=0 \\
&amp; \vec{w}=\vec{u} \times \vec{v} \quad \text {(right-handed)} \\
\end{align*}
\]</span></p>
<p>则向量 <span class="math inline">\(\vec{u}\)</span>、<span
class="math inline">\(\vec{v}\)</span>、<span
class="math inline">\(\vec{w}\)</span>
定义了一个右手坐标系，对于任意一个向量 <span
class="math inline">\(\vec{p}\)</span>，在这个坐标系中的表示为：</p>
<p><span class="math display">\[
\vec{p}=(\vec{p} \cdot \vec{u}) \vec{u}+(\vec{p} \cdot \vec{v})
\vec{v}+(\vec{p} \cdot \vec{w}) \vec{w}
\]</span></p>
<p>其中 <span class="math inline">\(\vec{p} \cdot \vec{u}\)</span> 是
<span class="math inline">\(\vec{p}\)</span> 在 <span
class="math inline">\(\vec{u}\)</span> 的投影（projection）。</p>
<h2 id="矩阵matrices">矩阵（Matrices）</h2>
<p>矩阵是一个数的阵列（array），这个阵列中的数可以是实数也可以是虚数。如下所示是一个由实数组成的矩阵。</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 3 \\
5 &amp; 2 \\
0 &amp; 4
\end{bmatrix}
\]</span></p>
<p>矩阵的加法和标量乘法（multiplication by a
scalar）只需逐元素操作即可。</p>
<h3 id="矩阵乘法matrix-multiplication">矩阵乘法（Matrix
Multiplication）</h3>
<p>矩阵乘法 <span class="math inline">\(A \times B\)</span> 必须满足
<span class="math inline">\(A\)</span> 的列数 = <span
class="math inline">\(B\)</span> 的行数。求出的矩阵的大小为：</p>
<p><span class="math display">\[
A_{n\times m} B_{n \times p} = C_{n \times p}
\]</span></p>
<p>乘法性质：</p>
<p><span class="math display">\[
\begin{align*}
AB &amp;\neq BA \text{ (一般来说不满足交换律)}. \\
(AB)C &amp;= A(BC) \\
(A + B)C &amp;= AC + BC \\
(AB)^{\mathrm{T}} &amp;= B^{\mathrm{T}} A^{\mathrm{T}} \\
\end{align*}
\]</span></p>
<p>矩阵和向量相乘时，认为向量是一个列向量并乘在矩阵的右边。</p>
<h3 id="单位矩阵和逆identity-matrix-and-inverses">单位矩阵和逆（Identity
Matrix And Inverses）</h3>
<p>单位矩阵是一个左上到右下对角线值为 1，其他值为 0
的正方形矩阵，以长度为 3 的单位矩阵为例：</p>
<p><span class="math display">\[
I_{3 \times 3}=\begin{bmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 1
\end{bmatrix}
\]</span></p>
<p>单位矩阵定义了矩阵的逆运算。对于矩阵 <span
class="math inline">\(A\)</span> 来说，矩阵的逆 <span
class="math inline">\(A^{-1}\)</span> 满足：</p>
<p><span class="math display">\[
\begin{align*}
AA^{-1} &amp;= A^{-1}A = I \\
(AB)^{-1} &amp;= B^{-1} A^{-1} \\
(A^\mathrm{T})^{-1} &amp;= (A^{-1})^\mathrm{T} = A^{-\mathrm{T}}
\end{align*}
\]</span></p>
<h3
id="向量乘法的矩阵形式vector-multiplication-in-matrix-form">向量乘法的矩阵形式（Vector
Multiplication In Matrix form）</h3>
<p>点乘：</p>
<p><span class="math display">\[
\vec{a} \cdot \vec{b} = \vec{a}^{\mathrm{T}}\vec{b} = \begin{bmatrix}
x_a &amp; y_a &amp; z_a \end{bmatrix} \begin{bmatrix} x_b \\ y_b \\ z_b
\end{bmatrix} = x_a y_a + y_a y_b + z_a z_ b
\]</span></p>
<p>叉乘：</p>
<p><span class="math display">\[
\vec{a} \times \vec{b} = A^{*} b = \begin{bmatrix}
0 &amp; -z_a &amp; y_a \\
z_a &amp; 0 &amp; -x_a \\
-y_a &amp; x_a &amp; 0
\end{bmatrix}
\begin{bmatrix}
x_b \\
y_b \\
z_b
\end{bmatrix}
\]</span></p>
]]></content>
      <categories>
        <category>GAMES 101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>光线追踪</tag>
      </tags>
  </entry>
  <entry>
    <title>结构体、共用体、枚举</title>
    <url>/2023/07/16/%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E5%85%B1%E7%94%A8%E4%BD%93%E3%80%81%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<h2 id="结构体类型的概念及定义">结构体类型的概念及定义</h2>
<p>构造类型：不是基本类型的数据结构也不是指针，它是若干个相同或不同类型的数据构成的集合，常用的构造类型有数组、结构体、共用体。</p>
<p>数组用于保存多个相同类型的数据。</p>
<p>结构体用于保存多个不同类型的数据。</p>
<h3 id="结构体的概念">结构体的概念</h3>
<p>结构体是一种构造类型的数据结构。</p>
<p>是一种或多种基本类型或构造类型的数据的集合。</p>
<h3 id="结构体类型的定义">结构体类型的定义</h3>
<h4
id="先定义结构体类型再去定义结构体变量">先定义结构体类型，再去定义结构体变量</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 &#123;</span></span><br><span class="line">    成员;</span><br><span class="line">&#125; 结构体变量<span class="number">1</span>, 结构体变量<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 变量3, 变量4;</span></span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125; lucy, bob, lilei;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">xiaohong</span>, <span class="title">xiaoming</span>;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：一般在全局定义结构体。</p>
</blockquote>
<h4 id="无名结构体的定义">无名结构体的定义</h4>
<p>在定义结构体类型的时候，没有结构体类型名，顺便定义结构体变量，因为没有类型名，所以以后不能再定义相关类型的数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    成员列表;</span><br><span class="line">&#125; 变量<span class="number">1</span>, 变量<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125; lucy, bob;</span><br></pre></td></tr></table></figure>
<h4 id="给结构体类型取别名">给结构体类型取别名</h4>
<p>这是经常做的事情。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> 结构体名 &#123;</span></span><br><span class="line">    成员列表;</span><br><span class="line">&#125; 别名;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>typedef</code>
给结构体起了一个别名，在使用别名定义结构体变量变量时不要加上
<code>strcut</code>.</p>
</blockquote>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125; STU;</span><br></pre></td></tr></table></figure>
<p><code>STU lucy;</code> 和 <code>struct stu;</code> 是等价的。</p>
<h2 id="结构体变量的定义初始化及使用">结构体变量的定义初始化及使用</h2>
<h3 id="结构体变量的定义和初始化">结构体变量的定义和初始化</h3>
<p>结构体变量，是个变量，这个变量是若干个数据的集合。</p>
<ol type="1">
<li>在定义结构体变量之前首先得有结构体类型。</li>
<li>在定义结构体变量的时候，可以顺便给结构体变量赋初值。</li>
<li>结构体变量初始化的时候，各个成员顺序初始化。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 定义结构体变量之定义结构体类型的同时定义结构体变量</span></span><br><span class="line">&#125; zhangsan, lisi = &#123;<span class="number">1002</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用typedef对结构体类型取别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125; MSG;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 定义结构体变量之类型定义完毕之后定义变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">wangwu</span>;</span></span><br><span class="line">    <span class="comment">// 结构体变量的初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">zhaoliu</span> =</span> &#123;<span class="number">1001</span>, <span class="string">&quot;赵六&quot;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    <span class="comment">// 如果使用typedef对结构体类型取别名</span></span><br><span class="line">    <span class="comment">// 就无法在定义类型的同时定义结构体变量</span></span><br><span class="line">    <span class="comment">// 在定义结构体变量的时候不用加struct</span></span><br><span class="line">    MSG msg1, msg2 = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="string">&#x27;w&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体变量的使用">结构体变量的使用</h3>
<p>结构体变量对成员调用的方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">结构体变量.结构体成员</span><br></pre></td></tr></table></figure>
<p><strong>结构体变量的简单使用：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125; zhangsan, lisi = &#123;<span class="number">1002</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125; MSG;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">wangwu</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">zhaoliu</span> =</span> &#123;<span class="number">1001</span>, <span class="string">&quot;赵六&quot;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    MSG msg1, msg2 = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="string">&#x27;w&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">// 结构体变量的使用</span></span><br><span class="line">    zhangsan.id = <span class="number">1001</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(zhangsan.name, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    zhangsan.sex = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    zhangsan.age = <span class="number">18</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d - %s - %c - %d\n&quot;</span>, zhangsan.id, zhangsan.name, zhangsan.sex,</span><br><span class="line">           zhangsan.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d - %s - %c - %d\n&quot;</span>, lisi.id, lisi.name, lisi.sex, lisi.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d - %s - %c - %d\n&quot;</span>, zhaoliu.id, zhaoliu.name, zhaoliu.sex,</span><br><span class="line">           zhaoliu.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d - %d - %c\n&quot;</span>, msg2.a, msg2.b, msg2.c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/59fbf612-ec92-45ae-ad17-8968adc14597"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p><strong>在结构体中嵌套结构体：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在结构体中嵌套结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125; BD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    BD birthday;</span><br><span class="line">&#125; STU;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    STU xiaoming;</span><br><span class="line">    xiaoming.id = <span class="number">1001</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(xiaoming.name, <span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果结构体中嵌套结构体，赋值时找到最内层的成员再进行赋值</span></span><br><span class="line">    xiaoming.birthday.year = <span class="number">2002</span>;</span><br><span class="line">    xiaoming.birthday.month = <span class="number">12</span>;</span><br><span class="line">    xiaoming.birthday.day = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d - %s - %d-%d-%d\n&quot;</span>, xiaoming.id, xiaoming.name,</span><br><span class="line">           xiaoming.birthday.year, xiaoming.birthday.month,</span><br><span class="line">           xiaoming.birthday.day);</span><br><span class="line">    <span class="comment">// 嵌套的形式定义并初始化</span></span><br><span class="line">    STU xiaoli = &#123;<span class="number">1002</span>, <span class="string">&quot;小丽&quot;</span>, <span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d - %s - %d-%d-%d\n&quot;</span>, xiaoli.id, xiaoli.name, xiaoli.birthday.year,</span><br><span class="line">           xiaoli.birthday.month, xiaoli.birthday.day);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/0ba410eb-be6c-4b95-bd0f-c63e11d2576c"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h3
id="相同类型的结构体变量可以相互赋值">相同类型的结构体变量可以相互赋值</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">zhangsan</span>;</span></span><br><span class="line">    zhangsan.id = <span class="number">1001</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(zhangsan.name, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    zhangsan.sex = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    zhangsan.age = <span class="number">18</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d - %s - %c - %d\n&quot;</span>, zhangsan.id, zhangsan.name, zhangsan.sex,</span><br><span class="line">           zhangsan.age);</span><br><span class="line">    <span class="comment">// 相同类型的结构体变量之间可以直接赋值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">lisi</span>;</span></span><br><span class="line">    lisi = zhangsan;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d - %s - %c - %d\n&quot;</span>, lisi.id, lisi.name, lisi.sex, lisi.age);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/1600c6a0-551c-4545-be40-833e838c7f9c"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="结构体数组">结构体数组</h2>
<blockquote>
<p>结构体数组是个数组，由若干个相同类型的结构体变量构成的集合。</p>
</blockquote>
<p><strong>结构体数组的定义方法：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体类型名 数组名[元素个数];</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> <span class="title">edu</span>[3];</span></span><br></pre></td></tr></table></figure>
<p><strong>结构体数组元素的引用：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">数组名[索引];</span><br></pre></td></tr></table></figure>
<p>结构体数组元素对成员的使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">数组名[索引].成员</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125; STU;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个结构体数组</span></span><br><span class="line">    STU edu[<span class="number">3</span>] = &#123;&#123;<span class="number">101</span>, <span class="string">&quot;Lucy&quot;</span>, <span class="number">78</span>&#125;, &#123;<span class="number">102</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">59.5</span>&#125;, &#123;<span class="number">103</span>, <span class="string">&quot;Tom&quot;</span>, <span class="number">85</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">// 输出结构体数组中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d - %s - %.2f\n&quot;</span>, edu[j].num, edu[j].name, edu[j].score);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        sum += edu[i].score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;平均成绩为%.2f\n&quot;</span>, sum / <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/e33e0370-4391-488e-9a46-546671d78fca"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="结构体指针">结构体指针</h2>
<p>结构体的地址，结构体变量存放内存中，也有起始地址。</p>
<p><strong>结构体指针变量的定义方法：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 *指针名;</span></span><br></pre></td></tr></table></figure>
<p><strong>结构体指针变量对成员的引用：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(*结构体指针变量名).成员</span><br><span class="line">结构体指针变量名‐&gt;成员</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个结构体指针变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">s</span>;</span></span><br><span class="line">    <span class="comment">// 在堆区开辟结构体空间并将其地址保存在结构体指针变量中</span></span><br><span class="line">    s = (<span class="keyword">struct</span> stu *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> stu));</span><br><span class="line">    s-&gt;id = <span class="number">1001</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(s-&gt;name, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    s-&gt;sex = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    s-&gt;age = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d - %s - %c - %d\n&quot;</span>, s-&gt;id, s-&gt;name, s-&gt;sex, s-&gt;age);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/deee6855-afbc-410a-a566-81459db4dab9"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="结构体内存分配问题">结构体内存分配问题</h2>
<p><strong>规则 1：以多少个字节为单位开辟内存</strong></p>
<p>为结构体变量分配内存时，先去找结构体的基本数据类型，找到占用字节数最大的那个类型，以它为基准开辟空间。</p>
<ol type="1">
<li>成员中只有 <code>char</code> 类型，以 1 字节为单位开辟空间。</li>
<li>成员中出现了 <code>short</code> 类型，没有更大的基本数据类型，以 2
个字节为单位开辟内存。</li>
<li>出现了
<code>int</code>、<code>float</code>，没有更大字节的基本数据类型，以 4
个字节为单位开辟内存。</li>
<li>出现了 <code>double</code>
<ol type="1">
<li>在 <code>msvc</code> 中，以 8 个字节为单位开辟空间。</li>
<li>在 <code>gcc</code> 中，以 4 字节为得开辟空间。</li>
</ol></li>
</ol>
<p><strong>规则 2：字节对齐</strong></p>
<ol type="1">
<li><code>char</code>：1 字节对齐，即存放 <code>char</code>
类型的变量的地址是 1 的倍数。</li>
<li><code>short</code>：2 字节对齐，即存放 <code>short</code>
类型的变量的地址是 2 的倍数。</li>
<li><code>int</code>：4 字节对齐，即存放 <code>int</code>
类型的变量的地址是 4 的倍数。</li>
<li><code>long</code>：在 32 位的操作系统中，4 字节对齐，即存放
<code>long</code> 类型的变量的地址是 4 的倍数。</li>
<li><code>float</code>：4 字节对齐，即存放 <code>float</code>
类型的变量的地址是 4 的倍数。</li>
<li><code>double</code>：
<ol type="1">
<li>在 <code>msvc</code> 中，8 字节对齐，即存放 <code>double</code>
类型的变量的地址是 8 的倍数。</li>
<li>在 <code>gcc</code> 中，4 字节对齐，即存放 <code>double</code>
类型的变量的地址是 4 的倍数。</li>
</ol></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125; lucy; <span class="comment">// 8字节</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125; lucy; <span class="comment">// 8字节</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125; temp; <span class="comment">// 8字节</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> b;</span><br><span class="line">&#125; temp; <span class="comment">// 12字节</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125; temp; <span class="comment">// 16字节</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">&#125;; <span class="comment">// 12字节</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>字节对齐是一种空间换时间的操作。</p>
</blockquote>
<h3 id="位段">位段</h3>
<p>在结构体中，以位为单位的成员，称之为位段（位域）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packed_data</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a : <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b : <span class="number">6</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> c : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> d : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">&#125; data;</span><br></pre></td></tr></table></figure>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/53efd5a1-afe4-4259-b71c-7b6f3daeee5f"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<blockquote>
<p>注意：不能对位段成员取地址</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packed_data</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a : <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b : <span class="number">6</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> c : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> d : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">&#125; data;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;(data.i));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/a6798353-3a76-4cba-b258-cc75406623d2"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<blockquote>
<p>注意：</p>
<ol type="1">
<li>对于位段成员赋值时不要超出位段定义的范围，例如成员 a 定义为 2
为，则去哦最大值为 3，如果给 a 赋值为 5，会取最低 2 位进行赋值。</li>
<li>位段成员必须为整型或字符型。</li>
<li>一个位段成员必须存放在一个存储单元中，不能跨两个单元，第一个单元不能容纳下一个位段，则该空间不用，从下一个单元其存放该位段。</li>
</ol>
</blockquote>
<p><strong>位段的存储单元：</strong></p>
<ol type="1">
<li><code>char</code> 型的位段，存储单元是 1 个字节；</li>
<li><code>short int</code> 型的位段，存储单元是 2 个字节；</li>
<li><code>int</code> 型的位段，存储单元是 4 字节；</li>
<li><code>long int</code> 型的位段，存储单元是 4 字节。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a : <span class="number">7</span>;</span><br><span class="line">    <span class="type">char</span> b : <span class="number">7</span>;</span><br><span class="line">    <span class="type">char</span> c : <span class="number">2</span>;</span><br><span class="line">&#125; temp;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(temp));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/9a5a3396-0ef9-4b60-896b-037084ab837b"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p><strong>位段的长度不能大于存储单元的长度：</strong></p>
<ol type="1">
<li><code>char</code> 型位段不能大于 8 位；</li>
<li><code>short</code> 型位段不能大于 16 位；</li>
<li><code>int</code> 型位段不能大于 32 位；</li>
<li><code>long</code> 型位段不能大于 32 位。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a : <span class="number">9</span>;</span><br><span class="line">    <span class="type">char</span> b : <span class="number">7</span>;</span><br><span class="line">    <span class="type">char</span> c : <span class="number">2</span>;</span><br><span class="line">&#125; temp;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(temp));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">分析：编译出错，位段a不能大于其存储单元的大小</span><br></pre></td></tr></table></figure>
<p><strong>如一个段要从另一个存储单元开始，可以定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">m_type</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b : <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c : <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">m_type</span> <span class="title">temp</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(temp));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/433b3003-4261-4070-b141-3510ab816bd9"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>长度为 0 的位段作用是使下一个位段从下一个存储单元开始存放，将 a、b
存储在一个存储单元中，c 存储在下一个单元。</p>
<p><strong>可以定义无意义位段，如：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> a: <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> : <span class="number">2</span>;</span><br><span class="line"><span class="type">unsigned</span> b: <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a : <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> b : <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c : <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> d : <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> e : <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> f : <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> g : <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> h : <span class="number">1</span>;</span><br><span class="line">&#125; temp;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> p0;</span><br><span class="line">    <span class="comment">// p0=0x01;// 0000 0001</span></span><br><span class="line">    temp.a = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// p0 = temp; // 错的，类型不匹配</span></span><br><span class="line">    <span class="comment">// p0=(char) temp;//错的，编译器不允许将结构体变量，强制转成基本类型的。</span></span><br><span class="line">    p0 = *((<span class="type">char</span> *)(&amp;temp));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="共用体">共用体</h2>
<p>共用体和结构体类似，也是一种构造类型的数据结构。</p>
<p>定义共用体类型的方法和结构体非常相似，把 <code>struct</code> 改成
<code>union</code> 就可以了。</p>
<p>在进行某些算法的时候，需要使几种不同类型的变量存到同一段内存单元中，几个变量所使用空间相互重叠，共用体就是这样一种结构。</p>
<p>共用体所有成员占有同一段地址空间，共用体的大小是其占内存长度最大的成员的大小</p>
<p><strong>共用体的特点：</strong></p>
<ol type="1">
<li>同一内存段可以用来存放几种不同类型的成员，但每一瞬时只有一种起作用。</li>
<li>共用体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原有的成员的值会被覆盖。</li>
<li>共用体变量的地址和它的各成员的地址都是同一地址。</li>
<li>共用体变量的初始化
<code>union data a=&#123;123&#125;;</code>，初始化共用体为第一个成员。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个共用体</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">un</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 定义共用体变量</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">un</span> <span class="title">myun</span>;</span></span><br><span class="line">    myun.a = <span class="number">100</span>;</span><br><span class="line">    myun.b = <span class="number">200</span>;</span><br><span class="line">    myun.c = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d, c = %d\n&quot;</span>, myun.a, myun.b, myun.c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/e9e093b7-5b59-45ad-8ee7-5dda248c367b"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="枚举">枚举</h2>
<p>将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。</p>
<p>枚举类型也是个构造类型的</p>
<p><strong>枚举类型的定义：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> 枚举类型名&#123;</span></span><br><span class="line">    枚举值列表;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在枚举值表中应列出所有可用值，也称为枚举元素。</p>
<p>枚举变量仅能取枚举值所列元素。</p>
<p><strong>枚举变量的定义方法：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> 枚举类型名 枚举变量名;</span></span><br></pre></td></tr></table></figure>
<ol type="1">
<li>枚举值是常量；</li>
<li>枚举元素本身由系统定义了一个表示序号的数值，默认从 0 开始；</li>
<li>可以改变枚举值的默认值。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span> &#123;</span> mon = <span class="number">3</span>, tue, wed, thu, fri = <span class="number">4</span>, sat, sun &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mon);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tue);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, wed);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, thu);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, fri);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sat);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sun);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/docs/assets/62458905/9f84fd78-2150-4089-a342-66f6a57fae18"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
]]></content>
      <categories>
        <category>C 语言基础</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>结构体</tag>
        <tag>共用体</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>颜色与感知</title>
    <url>/2023/07/16/%E9%A2%9C%E8%89%B2%E4%B8%8E%E6%84%9F%E7%9F%A5/</url>
    <content><![CDATA[<h2 id="physical-basis-of-color">Physical Basis of Color</h2>
<p>牛顿通过实验认识到，白光是由多种颜色的光线混合起来得到的。而我们在生活中可以看到的光在波长约
400 mm-700 mm 之间。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231681716-8658c9c9-0ea3-470d-8f34-f0bd878f187f.png" alt="Img" style="zoom:75%;" />
</center>
<p>对于不同光，我们可以使用<strong>功率谱密度</strong>（Spectral Power
Distribution，SPD）表示。功率谱密度展示了不同波长下光能量的多少。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231681887-f196d5c3-0738-4a9f-874d-23718bb12964.png" alt="Img" style="zoom:75%;" />
</center>
<p>SPD 具有叠加性：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231682218-28fed8bf-bf68-437b-afa8-fbc758d885e4.png" alt="Img" style="zoom:75%;" />
</center>
<p>而颜色，应该是人对于不同光线的感知，而光的一种属性，但不同波长的光确实会表现出不同的「颜色」。</p>
<h2 id="biological-basis-of-color">Biological Basis of Color</h2>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231683077-db020a4c-8e6b-469b-a760-05667bfe9da1.png" alt="Img" style="zoom:75%;" />
</center>
<p>人的眼睛通过视网膜感受光线，在视网膜上存在着两种细胞：</p>
<ul>
<li>杆细胞（Rods）感受光线的明暗（也就是灰度值）；</li>
<li>锥细胞（Cones）感受颜色。锥细胞分为三种类型，对不同的波长的光线的响应不同。</li>
</ul>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231683290-85add764-405e-479d-890d-5f5584e5c96f.png" alt="Img" style="zoom:75%;" />
</center>
<blockquote>
<p>不同人的锥细胞的分布很不一样。</p>
</blockquote>
<h2 id="tristimulus-theory-of-color">Tristimulus Theory of Color</h2>
<p>锥细胞可以分为 S、M、L
三种，分别对短波，中波以及长波有更强的响应。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231684228-7188ec7d-6184-4160-be8d-379c8e02567f.png" alt="Img" style="zoom:75%;" />
</center>
<p>对于这三条谱功率密度曲线，我们记为 <span
class="math inline">\(r_S\left(\lambda\right)\)</span>、<span
class="math inline">\(r_M\left(\lambda\right)\)</span>、<span
class="math inline">\(r_L\left(\lambda\right)\)</span>
那么对应的细胞感受到的能量是： <span class="math display">\[
\begin{align*}
S &amp; =\int r_S(\lambda) s(\lambda) d \lambda \\
M &amp; =\int r_M(\lambda) s(\lambda) d \lambda \\
L &amp; =\int r_L(\lambda) s(\lambda) d \lambda
\end{align*}
\]</span></p>
<h3 id="the-human-visual-system">The Human Visual System</h3>
<p>对于人眼来说，我们并不关注每一种波长的分布，我们只关心三个响应量 （S,
M, L）。即使是不同的光谱，也有可能有相同的响应，这就是同色异谱现象。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231684791-9e980ac3-0fc6-401e-84db-a7c00672d601.png" alt="Img" style="zoom:75%;" />
</center>
<h2 id="同异谱metamerism">同⾊异谱（Metamerism）</h2>
<p>同色异谱（Metamerism）指的是两种不同的谱密度分布得到了相同响应量，也就是相同的颜色。因此，当我们使用一些设备（例如屏幕）模拟其他颜色的时候，并不需要按照原来的谱密度进行模拟。</p>
<h2 id="颜色匹配color-reproduction-matching">颜色匹配（Color
Reproduction / Matching）</h2>
<h3 id="加色系统">加色系统</h3>
<p>常见的加色系统为 RGB
系统，在加色系统中，越多的颜色混合，得到的颜色越白。在 RGB
系统中我们只要得到 RGB 的谱密度 <span
class="math inline">\(s_R\left(\lambda\right)\)</span>、<span
class="math inline">\(s_G\left(\lambda\right)\)</span>、<span
class="math inline">\(s_B\left(\lambda\right)\)</span>，就可以通过 <span
class="math inline">\(s_R\left(\lambda\right) + s_G\left(\lambda\right)
+ s_B\left(\lambda\right)\)</span> 得到对应的颜色。</p>
<p>每一种波长的颜色通过人眼的方式进行匹配，当两种颜色看上去一致的时候，对应的
RGB 能量就是对应的结果。但是可能存在某些颜色，使用 RGB
不可以调整出来，这个时候通过在原来的颜色上加入某些颜色使得颜色看上去一致。这个时候对应的颜色分量能量我们视为负数。</p>
<h4 id="cie-rgb-匹配方程">CIE RGB 匹配方程</h4>
<p>CIE RGB 使用红色（波长 700 nm），绿色（波长 546.1 nm）以及蓝色（波长
435.8 nm）三种颜色的光进行实验，最终得到如下的结果：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231686582-f2e42abc-750e-4fb9-8f75-816ad1df2b96.png" alt="Img" style="zoom:75%;" />
</center>
<p>对应颜色的计算方式为： <span class="math display">\[
\begin{aligned}
R_{\mathrm{CIE} \mathrm{RGB}} &amp; =\int_\lambda s(\lambda)
\bar{r}(\lambda) d \lambda \\
G_{\mathrm{CIE} \mathrm{RGB}} &amp; =\int_\lambda s(\lambda)
\bar{g}(\lambda) d \lambda \\
B_{\mathrm{CIE} \mathrm{RGB}} &amp; =\int_\lambda s(\lambda)
\bar{b}(\lambda) d \lambda
\end{aligned}
\]</span> 目前还会广泛使用 sRGB（standardized
RGB）色彩空间，通过一个标准的屏幕来调整其他的屏幕色彩。这种方式被广泛使用，但是其色域比较窄。</p>
<h2 id="色彩空间">色彩空间</h2>
<h3 id="cie-xyz-色彩空间">CIE XYZ 色彩空间</h3>
<p>XYZ 色彩匹配函数是人造的函数。其中 Y
的结果可以大致反应图片的亮度。这样的设计不仅所有颜色能量都是正值，同时可以表示出所有的颜色。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231687146-9d38e7d6-0600-4528-80be-592139c7dae3.png" alt="Img" style="zoom:75%;" />
</center>
<p>我们令 <span
class="math inline">\(x+y+z=1\)</span>，通过归一化的方式，我们可以将 XYZ
三维空间变成一个二维的空间进行表示： <span class="math display">\[
\begin{aligned}
x &amp; =\frac{X}{X+Y+Z} \\
y &amp; =\frac{Y}{X+Y+Z} \\
z &amp; =\frac{Z}{X+Y+Z}
\end{aligned}
\]</span></p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231687412-cffa1a44-c410-47bd-b206-59c8b0ec0c43.png" alt="Img" style="zoom:75%;" />
</center>
<p>对于 XYZ 颜色的分布，我们可以得到以下结果：</p>
<ul>
<li>分布图的边缘都是纯色；</li>
<li>中间的颜色没有那么纯；</li>
<li>白色是最不纯的颜色，位置在 <span
class="math inline">\(\left(\frac{1}{3},\frac{1}{3}\right)\)</span>
处。</li>
</ul>
<p>色域指的是一系列颜色集所能得到的颜色的集合。不同的颜色空间能够得到不同的色域。</p>
<h2 id="感知颜色系统">感知颜色系统</h2>
<h3 id="hsv-色彩空间">HSV 色彩空间</h3>
<p>HSV
色彩空间由<strong>色调</strong>（Hue），<strong>饱和度</strong>（Saturation）以及<strong>亮度</strong>（Lightness）三个部分组成。其中：</p>
<ul>
<li>色调表示颜色的种类；</li>
<li>饱和度表示颜色的纯度（饱和度越低，颜色越白）；</li>
<li>亮度表示颜色的亮度（亮度越低，颜色越黑）。</li>
</ul>
<h1 id="颜色与感知color-and-perception">颜色与感知（Color and
Perception）</h1>
<h2 id="physical-basis-of-color-1">Physical Basis of Color</h2>
<p>牛顿通过实验认识到，白光是由多种颜色的光线混合起来得到的。而我们在生活中可以看到的光在波长约
400 mm-700 mm 之间。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231681716-8658c9c9-0ea3-470d-8f34-f0bd878f187f.png" alt="Img" style="zoom:75%;" />
</center>
<p>对于不同光，我们可以使用<strong>功率谱密度</strong>（Spectral Power
Distribution，SPD）表示。功率谱密度展示了不同波长下光能量的多少。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231681887-f196d5c3-0738-4a9f-874d-23718bb12964.png" alt="Img" style="zoom:75%;" />
</center>
<p>SPD 具有叠加性：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231682218-28fed8bf-bf68-437b-afa8-fbc758d885e4.png" alt="Img" style="zoom:75%;" />
</center>
<p>而颜色，应该是人对于不同光线的感知，而光的一种属性，但不同波长的光确实会表现出不同的「颜色」。</p>
<h2 id="biological-basis-of-color-1">Biological Basis of Color</h2>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231683077-db020a4c-8e6b-469b-a760-05667bfe9da1.png" alt="Img" style="zoom:75%;" />
</center>
<p>人的眼睛通过视网膜感受光线，在视网膜上存在着两种细胞：</p>
<ul>
<li>杆细胞（Rods）感受光线的明暗（也就是灰度值）；</li>
<li>锥细胞（Cones）感受颜色。锥细胞分为三种类型，对不同的波长的光线的响应不同。</li>
</ul>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231683290-85add764-405e-479d-890d-5f5584e5c96f.png" alt="Img" style="zoom:75%;" />
</center>
<blockquote>
<p>不同人的锥细胞的分布很不一样。</p>
</blockquote>
<h2 id="tristimulus-theory-of-color-1">Tristimulus Theory of Color</h2>
<p>锥细胞可以分为 S、M、L
三种，分别对短波，中波以及长波有更强的响应。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231684228-7188ec7d-6184-4160-be8d-379c8e02567f.png" alt="Img" style="zoom:75%;" />
</center>
<p>对于这三条谱功率密度曲线，我们记为 <span
class="math inline">\(r_S\left(\lambda\right)\)</span>、<span
class="math inline">\(r_M\left(\lambda\right)\)</span>、<span
class="math inline">\(r_L\left(\lambda\right)\)</span>
那么对应的细胞感受到的能量是： <span class="math display">\[
\begin{align*}
S &amp; =\int r_S(\lambda) s(\lambda) d \lambda \\
M &amp; =\int r_M(\lambda) s(\lambda) d \lambda \\
L &amp; =\int r_L(\lambda) s(\lambda) d \lambda
\end{align*}
\]</span></p>
<h3 id="the-human-visual-system-1">The Human Visual System</h3>
<p>对于人眼来说，我们并不关注每一种波长的分布，我们只关心三个响应量 （S,
M, L）。即使是不同的光谱，也有可能有相同的响应，这就是同色异谱现象。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231684791-9e980ac3-0fc6-401e-84db-a7c00672d601.png" alt="Img" style="zoom:75%;" />
</center>
<h2 id="同异谱metamerism-1">同⾊异谱（Metamerism）</h2>
<p>同色异谱（Metamerism）指的是两种不同的谱密度分布得到了相同响应量，也就是相同的颜色。因此，当我们使用一些设备（例如屏幕）模拟其他颜色的时候，并不需要按照原来的谱密度进行模拟。</p>
<h2 id="颜色匹配color-reproduction-matching-1">颜色匹配（Color
Reproduction / Matching）</h2>
<h3 id="加色系统-1">加色系统</h3>
<p>常见的加色系统为 RGB
系统，在加色系统中，越多的颜色混合，得到的颜色越白。在 RGB
系统中我们只要得到 RGB 的谱密度 <span
class="math inline">\(s_R\left(\lambda\right)\)</span>、<span
class="math inline">\(s_G\left(\lambda\right)\)</span>、<span
class="math inline">\(s_B\left(\lambda\right)\)</span>，就可以通过 <span
class="math inline">\(s_R\left(\lambda\right) + s_G\left(\lambda\right)
+ s_B\left(\lambda\right)\)</span> 得到对应的颜色。</p>
<p>每一种波长的颜色通过人眼的方式进行匹配，当两种颜色看上去一致的时候，对应的
RGB 能量就是对应的结果。但是可能存在某些颜色，使用 RGB
不可以调整出来，这个时候通过在原来的颜色上加入某些颜色使得颜色看上去一致。这个时候对应的颜色分量能量我们视为负数。</p>
<h4 id="cie-rgb-匹配方程-1">CIE RGB 匹配方程</h4>
<p>CIE RGB 使用红色（波长 700 nm），绿色（波长 546.1 nm）以及蓝色（波长
435.8 nm）三种颜色的光进行实验，最终得到如下的结果：</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231686582-f2e42abc-750e-4fb9-8f75-816ad1df2b96.png" alt="Img" style="zoom:75%;" />
</center>
<p>对应颜色的计算方式为： <span class="math display">\[
\begin{aligned}
R_{\mathrm{CIE} \mathrm{RGB}} &amp; =\int_\lambda s(\lambda)
\bar{r}(\lambda) d \lambda \\
G_{\mathrm{CIE} \mathrm{RGB}} &amp; =\int_\lambda s(\lambda)
\bar{g}(\lambda) d \lambda \\
B_{\mathrm{CIE} \mathrm{RGB}} &amp; =\int_\lambda s(\lambda)
\bar{b}(\lambda) d \lambda
\end{aligned}
\]</span> 目前还会广泛使用 sRGB（standardized
RGB）色彩空间，通过一个标准的屏幕来调整其他的屏幕色彩。这种方式被广泛使用，但是其色域比较窄。</p>
<h2 id="色彩空间-1">色彩空间</h2>
<h3 id="cie-xyz-色彩空间-1">CIE XYZ 色彩空间</h3>
<p>XYZ 色彩匹配函数是人造的函数。其中 Y
的结果可以大致反应图片的亮度。这样的设计不仅所有颜色能量都是正值，同时可以表示出所有的颜色。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231687146-9d38e7d6-0600-4528-80be-592139c7dae3.png" alt="Img" style="zoom:75%;" />
</center>
<p>我们令 <span
class="math inline">\(x+y+z=1\)</span>，通过归一化的方式，我们可以将 XYZ
三维空间变成一个二维的空间进行表示： <span class="math display">\[
\begin{aligned}
x &amp; =\frac{X}{X+Y+Z} \\
y &amp; =\frac{Y}{X+Y+Z} \\
z &amp; =\frac{Z}{X+Y+Z}
\end{aligned}
\]</span></p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231687412-cffa1a44-c410-47bd-b206-59c8b0ec0c43.png" alt="Img" style="zoom:75%;" />
</center>
<p>对于 XYZ 颜色的分布，我们可以得到以下结果：</p>
<ul>
<li>分布图的边缘都是纯色；</li>
<li>中间的颜色没有那么纯；</li>
<li>白色是最不纯的颜色，位置在 <span
class="math inline">\(\left(\frac{1}{3},\frac{1}{3}\right)\)</span>
处。</li>
</ul>
<p>色域指的是一系列颜色集所能得到的颜色的集合。不同的颜色空间能够得到不同的色域。</p>
<h2 id="感知颜色系统-1">感知颜色系统</h2>
<h3 id="hsv-色彩空间-1">HSV 色彩空间</h3>
<p>HSV
色彩空间由<strong>色调</strong>（Hue），<strong>饱和度</strong>（Saturation）以及<strong>亮度</strong>（Lightness）三个部分组成。其中：</p>
<ul>
<li>色调表示颜色的种类；</li>
<li>饱和度表示颜色的纯度（饱和度越低，颜色越白）；</li>
<li>亮度表示颜色的亮度（亮度越低，颜色越黑）。</li>
</ul>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231688159-a27e13ab-a8a8-47b5-ab5f-3558e19b2b57.png" alt="Img" style="zoom:75%;" />
</center>
<h3 id="cielab-空间lab">CIELAB 空间（L*a*b）</h3>
<p>Lab 颜色空间也是根据人的感知建立的颜色空间。共包含了 3 个方向，L*
方向指的是亮度，a* 方向指的是红绿互补色对，b*
方向是蓝黄互补色对。之所以会选择这样的互补色对是因为黑白色，红绿色以及黄蓝色是三对互补色。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231688637-835b0d19-3b26-48e4-b2c7-7230413c5c46.png" alt="Img" style="zoom:75%;" />
</center>
<h3 id="减色系统">减色系统</h3>
<h4 id="cmyk-颜色空间">CMYK 颜色空间</h4>
<p>CMYK 颜色空间是一种减色系统，当混合的颜色越多，得到的颜色越黑。CMYK
广泛应用于打印中。CMYK 包含 4
种基础色，分别是青色（Cyan），品红（Magenta），黄色（Yellow）和黑色（Key）。使用前三种颜色就可以得到黑色，但是基于成本原因，还是加入了
K 降低成本。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231688995-9cf5305f-3c3d-4af1-a855-44ceee2a369c.png" alt="Img" style="zoom:75%;" />
</center>
]]></content>
      <categories>
        <category>GAMES 101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>颜色</tag>
        <tag>感知</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符重载</title>
    <url>/2023/07/16/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="运算符重载概述">运算符重载概述</h2>
<blockquote>
<p>C++
允许在同一作用域中的某个<strong>函数</strong>和<strong>运算符</strong>指定多个定义，分别称为<strong>函数重载</strong>和<strong>运算符重载</strong>。</p>
<p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</p>
<p>当您调用一个<strong>重载函数</strong>或<strong>重载运算符</strong>时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为<strong>重载决策</strong>。</p>
</blockquote>
<h2 id="可重载运算符-不可重载运算符">可重载运算符 / 不可重载运算符</h2>
<p>下面是可重载的运算符列表：</p>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">分类</th>
<th style="text-align: center;">解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">双目算术运算符</td>
<td
style="text-align: center;"><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">关系运算符</td>
<td
style="text-align: center;"><code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">逻辑运算符</td>
<td
style="text-align: center;"><code>\|\|</code>、<code>&amp;&amp;</code>、<code>!</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">单目运算符</td>
<td
style="text-align: center;"><code>+</code>、<code>-</code>、<code>*</code>、<code>&amp;</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">自增自减运算符</td>
<td style="text-align: center;"><code>++</code>、<code>--</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">位运算符</td>
<td
style="text-align: center;"><code>\|</code>、<code>&amp;</code>、<code>~</code>、<code>^</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">赋值运算符</td>
<td
style="text-align: center;"><code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>&amp;=</code>、<code>\|=</code>、<code>^=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">空间申请与释放</td>
<td
style="text-align: center;"><code>new</code>、<code>delete</code>、<code>new[]</code>、<code>delete[]</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">其他运算符</td>
<td
style="text-align: center;"><code>()</code>、<code>-&gt;</code>、<code>,</code>、<code>[]</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>C++ 智能指针 <code>-&gt;</code> 运算符。</p>
</blockquote>
<p>下面是不可重载的运算符列表：</p>
<ul>
<li><code>.</code>：成员访问运算符</li>
<li><code>.</code>、<code>-*</code>：成员指针访问运算符</li>
<li><code>::</code>：域运算符</li>
<li><code>sizeof</code>：长度运算符</li>
<li><code>?:</code>：条件运算符</li>
<li><code>#</code>： 预处理符号</li>
</ul>
<h2 id="重载运算符的一些规则和建议">重载运算符的一些规则和建议</h2>
<ol type="1">
<li>对于
<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>
这些双目算术运算符和
<code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>
这些关系运算符来说，既可以使用成员函数的方式重载，也可以使用非成员函数的方式重载，如果是两个相同类型的相加，如一个
<code>Person</code> 类型的数据和另外一个 <code>Person</code>
类型的数据相加，则哪种方式都可以；但如果是一个 <code>int</code>
类型的数据和 <code>Person</code>
类型的数据相加，则要使用非成员函数的方式重载。建议：非成员函数的方式重载。</li>
<li>对于 <code>+</code>、<code>-</code>
这两个单目运算符来说，既可以通过成员函数的方式重载，也可以使用非成员函数的方式重载。建议：非成员函数的方式重载。</li>
<li>对于 <code>++</code>、<code>--</code>
这两个运算符来说，必须通过成员函数的方式重载，对于后置的操作符要有一个占位参数。</li>
<li>对于 <code>&lt;&lt;</code>、<code>&gt;&gt;</code>
这两个流操作运算符来说，必须通过非成员函数的方式重载。</li>
<li>对于
<code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>&amp;=</code>、<code>|=</code>、<code>^=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>
这些赋值运算符来说，必须通过非成员函数的方式重载。</li>
<li><code>()</code>、<code>[]</code>、<code>-&gt;</code>
必须通过成员函数重载。</li>
<li>不要重载
<code>||</code>、<code>&amp;&amp;</code>、<code>!</code>、<code>&amp;</code>.</li>
</ol>
<h2 id="运算符重载的一些例子">运算符重载的一些例子</h2>
<h3 id="vec2">vec2</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file    :   vec2.h</span></span><br><span class="line"><span class="comment"> * @date    :   2023/06/21 12:11:34</span></span><br><span class="line"><span class="comment"> * @author  :   yaojie</span></span><br><span class="line"><span class="comment"> * @version :   1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> VEC2_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VEC2_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vec2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vec2</span>();</span><br><span class="line">    <span class="built_in">Vec2</span>(<span class="type">double</span> x, <span class="type">double</span> y);</span><br><span class="line">    <span class="built_in">Vec2</span>(<span class="type">const</span> Vec2 &amp;v);</span><br><span class="line">    ~<span class="built_in">Vec2</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vec2 &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Vec2 &amp;v);</span><br><span class="line">    Vec2 &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> Vec2 &amp;v);</span><br><span class="line">    Vec2 &amp;<span class="keyword">operator</span>-=(<span class="type">const</span> Vec2 &amp;v);</span><br><span class="line">    Vec2 &amp;<span class="keyword">operator</span>*=(<span class="type">const</span> Vec2 &amp;v);</span><br><span class="line">    Vec2 &amp;<span class="keyword">operator</span>/=(<span class="type">const</span> Vec2 &amp;v);</span><br><span class="line"></span><br><span class="line">    Vec2 &amp;<span class="keyword">operator</span>+();</span><br><span class="line">    Vec2 <span class="keyword">operator</span>-();</span><br><span class="line">    Vec2 &amp;<span class="keyword">operator</span>++();</span><br><span class="line">    Vec2 <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line">    Vec2 &amp;<span class="keyword">operator</span>--();</span><br><span class="line">    Vec2 <span class="keyword">operator</span>--(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>[](std::<span class="type">size_t</span> idx);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> <span class="keyword">operator</span>[](std::<span class="type">size_t</span> idx) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> Vec2 <span class="keyword">operator</span>+(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2);</span><br><span class="line">    <span class="keyword">friend</span> Vec2 <span class="keyword">operator</span>-(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2);</span><br><span class="line">    <span class="keyword">friend</span> Vec2 <span class="keyword">operator</span>*(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2);</span><br><span class="line">    <span class="keyword">friend</span> Vec2 <span class="keyword">operator</span>/(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="type">const</span> Vec2 &amp;v);</span><br><span class="line">    <span class="keyword">friend</span> std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;is, Vec2 &amp;v);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="type">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file    :   vec2.cpp</span></span><br><span class="line"><span class="comment"> * @date    :   2023/06/21 12:29:10</span></span><br><span class="line"><span class="comment"> * @author  :   yaojie</span></span><br><span class="line"><span class="comment"> * @version :   1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vec2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line">Vec2::<span class="built_in">Vec2</span>() : <span class="built_in">x</span>(<span class="number">0</span>), <span class="built_in">y</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Vec2::<span class="built_in">Vec2</span>(<span class="type">double</span> x, <span class="type">double</span> y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Vec2::<span class="built_in">Vec2</span>(<span class="type">const</span> Vec2 &amp;v) &#123;</span><br><span class="line">    x = v.x;</span><br><span class="line">    y = v.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2::~<span class="built_in">Vec2</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Vec2::length</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">fsqrt</span>(x * x + y * y); &#125;</span><br><span class="line"></span><br><span class="line">Vec2 &amp;Vec2::<span class="keyword">operator</span>=(<span class="type">const</span> Vec2 &amp;v) &#123;</span><br><span class="line">    x = v.x;</span><br><span class="line">    y = v.y;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 &amp;Vec2::<span class="keyword">operator</span>+=(<span class="type">const</span> Vec2 &amp;v) &#123;</span><br><span class="line">    x += v.x;</span><br><span class="line">    y += v.y;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 &amp;Vec2::<span class="keyword">operator</span>-=(<span class="type">const</span> Vec2 &amp;v) &#123;</span><br><span class="line">    x -= v.x;</span><br><span class="line">    y -= v.y;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 &amp;Vec2::<span class="keyword">operator</span>*=(<span class="type">const</span> Vec2 &amp;v) &#123;</span><br><span class="line">    x *= v.x;</span><br><span class="line">    y *= v.y;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 &amp;Vec2::<span class="keyword">operator</span>/=(<span class="type">const</span> Vec2 &amp;v) &#123;</span><br><span class="line">    x /= v.x;</span><br><span class="line">    y /= v.y;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 &amp;Vec2::<span class="keyword">operator</span>+() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">Vec2 Vec2::<span class="keyword">operator</span>-() <span class="type">const</span> &#123; <span class="keyword">return</span> Vec2&#123;-x, -y&#125;; &#125;</span><br><span class="line"></span><br><span class="line">Vec2 &amp;Vec2::<span class="keyword">operator</span>++() &#123;</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">    y = y + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 Vec2::<span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    Vec2 tmp&#123;x, y&#125;;</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">    y = y + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 &amp;Vec2::<span class="keyword">operator</span>--() &#123;</span><br><span class="line">    x = x - <span class="number">1</span>;</span><br><span class="line">    y = y - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 Vec2::<span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">    Vec2 tmp&#123;x, y&#125;;</span><br><span class="line">    x = x - <span class="number">1</span>;</span><br><span class="line">    y = y - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 <span class="keyword">operator</span>+(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;v1.x + v2.x, v2.x + v2.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 <span class="keyword">operator</span>-(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;v1.x - v2.x, v2.x - v2.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 <span class="keyword">operator</span>*(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;v1.x * v2.x, v2.x * v2.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec2 <span class="keyword">operator</span>/(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;v1.x / v2.x, v2.x / v2.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(v1.x - v2.x) &lt; <span class="number">0.01</span> &amp;&amp; <span class="built_in">fabs</span>(v1.y - v2.y) &lt; <span class="number">0.01</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Vec2 &amp;v1, <span class="type">const</span> Vec2 &amp;v2) &#123; <span class="keyword">return</span> !(v1 == v2); &#125;</span><br><span class="line"></span><br><span class="line">std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="type">const</span> Vec2 &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; v.x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;is, Vec2 &amp;v) &#123;</span><br><span class="line">    is &gt;&gt; v.x &gt;&gt; v.y;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Vec2::<span class="keyword">operator</span>[](std::<span class="type">size_t</span> idx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;下标越界&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Vec2::<span class="keyword">operator</span>[](std::<span class="type">size_t</span> idx) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;下标越界&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="int">Int</h3>
<figure class="highlight h"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @FileName       : Int.h</span></span><br><span class="line"><span class="comment"> * @Author         : yaojie</span></span><br><span class="line"><span class="comment"> * @Date           : 2023/6/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Int</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Int();</span><br><span class="line"></span><br><span class="line">    Int(<span class="type">int</span> val);</span><br><span class="line"></span><br><span class="line">    Int(<span class="type">const</span> Int &amp;i);</span><br><span class="line"></span><br><span class="line">    ~Int();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Int &amp;operator+();</span><br><span class="line">    Int operator-();</span><br><span class="line"></span><br><span class="line">    Int &amp;operator++();</span><br><span class="line">    Int operator++(<span class="type">int</span>);</span><br><span class="line">    Int &amp;operator--();</span><br><span class="line">    Int operator--(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    Int &amp;operator=(<span class="type">const</span> Int &amp;i);</span><br><span class="line">    Int &amp;operator+=(<span class="type">const</span> Int &amp;i);</span><br><span class="line">    Int &amp;operator-=(<span class="type">const</span> Int &amp;i);</span><br><span class="line">    Int &amp;operator*=(<span class="type">const</span> Int &amp;i);</span><br><span class="line">    Int &amp;operator/=(<span class="type">const</span> Int &amp;i);</span><br><span class="line">    Int &amp;operator%=(<span class="type">const</span> Int &amp;i);</span><br><span class="line"></span><br><span class="line">    friend Int operator+(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b);</span><br><span class="line">    friend Int operator-(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b);</span><br><span class="line">    friend Int operator*(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b);</span><br><span class="line">    friend Int operator/(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b);</span><br><span class="line">    friend Int operator%(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b);</span><br><span class="line"></span><br><span class="line">    friend <span class="type">bool</span> operator==(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b);</span><br><span class="line">    friend <span class="type">bool</span> operator!=(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b);</span><br><span class="line">    friend <span class="type">bool</span> operator&gt;(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b);</span><br><span class="line">    friend <span class="type">bool</span> operator&lt;(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b);</span><br><span class="line">    friend <span class="type">bool</span> operator&gt;=(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b);</span><br><span class="line">    friend <span class="type">bool</span> operator&lt;=(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b);</span><br><span class="line"></span><br><span class="line">    friend <span class="built_in">std</span>::ostream &amp;operator&lt;&lt;(<span class="built_in">std</span>::ostream &amp;os, <span class="type">const</span> Int i);</span><br><span class="line">    friend <span class="built_in">std</span>::istream &amp;operator&gt;&gt;(<span class="built_in">std</span>::istream &amp;is, Int i);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// INT_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @FileName       : Int.cpp</span></span><br><span class="line"><span class="comment"> * @Author         : yaojie</span></span><br><span class="line"><span class="comment"> * @Date           : 2023/6/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Int.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Int::<span class="built_in">Int</span>() : <span class="built_in">Int</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Int::<span class="built_in">Int</span>(<span class="type">int</span> val) : <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Int::<span class="built_in">Int</span>(<span class="type">const</span> Int &amp;i) &#123; <span class="keyword">this</span>-&gt;val = i.val; &#125;</span><br><span class="line"></span><br><span class="line">Int::~<span class="built_in">Int</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Int &amp;Int::<span class="keyword">operator</span>+() &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">Int Int::<span class="keyword">operator</span>-() &#123; <span class="keyword">return</span> &#123;-<span class="keyword">this</span>-&gt;val&#125;; &#125;</span><br><span class="line"></span><br><span class="line">Int &amp;Int::<span class="keyword">operator</span>++() &#123;</span><br><span class="line">    ++<span class="keyword">this</span>-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Int Int::<span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    Int tmp&#123;<span class="keyword">this</span>-&gt;val&#125;;</span><br><span class="line">    <span class="keyword">this</span>-&gt;val++;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Int &amp;Int::<span class="keyword">operator</span>--() &#123;</span><br><span class="line">    --<span class="keyword">this</span>-&gt;val;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Int Int::<span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">    Int tmp&#123;<span class="keyword">this</span>-&gt;val&#125;;</span><br><span class="line">    <span class="keyword">this</span>-&gt;val--;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Int &amp;Int::<span class="keyword">operator</span>=(<span class="type">const</span> Int &amp;i) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;val = i.val;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Int &amp;Int::<span class="keyword">operator</span>+=(<span class="type">const</span> Int &amp;i) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;val += i.val;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Int &amp;Int::<span class="keyword">operator</span>-=(<span class="type">const</span> Int &amp;i) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;val -= i.val;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Int &amp;Int::<span class="keyword">operator</span>*=(<span class="type">const</span> Int &amp;i) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;val *= i.val;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Int &amp;Int::<span class="keyword">operator</span>/=(<span class="type">const</span> Int &amp;i) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;val /= i.val;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Int &amp;Int::<span class="keyword">operator</span>%=(<span class="type">const</span> Int &amp;i) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;val %= i.val;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Int <span class="keyword">operator</span>+(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b) &#123; <span class="keyword">return</span> &#123;a.val + b.val&#125;; &#125;</span><br><span class="line">Int <span class="keyword">operator</span>-(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b) &#123; <span class="keyword">return</span> &#123;a.val - b.val&#125;; &#125;</span><br><span class="line">Int <span class="keyword">operator</span>*(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b) &#123; <span class="keyword">return</span> &#123;a.val * b.val&#125;; &#125;</span><br><span class="line">Int <span class="keyword">operator</span>/(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b) &#123; <span class="keyword">return</span> &#123;a.val / b.val&#125;; &#125;</span><br><span class="line">Int <span class="keyword">operator</span>%(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b) &#123; <span class="keyword">return</span> &#123;a.val % b.val&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b) &#123; <span class="keyword">return</span> a.val == b.val; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b) &#123; <span class="keyword">return</span> a.val != b.val; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b) &#123; <span class="keyword">return</span> a.val &gt; b.val; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b) &#123; <span class="keyword">return</span> a.val &lt; b.val; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b) &#123; <span class="keyword">return</span> a.val &gt;= b.val; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> Int &amp;a, <span class="type">const</span> Int &amp;b) &#123; <span class="keyword">return</span> a.val &lt;= b.val; &#125;</span><br><span class="line"></span><br><span class="line">std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="type">const</span> Int i) &#123; <span class="keyword">return</span> os &lt;&lt; i.val; &#125;</span><br><span class="line">std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;is, Int i) &#123; <span class="keyword">return</span> is &gt;&gt; i.val; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.runoob.com/cplusplus/cpp-overloading.html">C++
重载运算符和重载函数 | 菜鸟教程</a></li>
<li>C++ Primer</li>
</ul>
]]></content>
      <categories>
        <category>C++ 基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>运算符重载</tag>
      </tags>
  </entry>
  <entry>
    <title>预处理</title>
    <url>/2023/07/16/%E9%A2%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="c-语言编译过程">C 语言编译过程</h2>
<p>预处理、编译、汇编、链接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -E main.c -o main.i <span class="comment"># 预处理</span></span><br><span class="line">gcc -S main.i -o main.s <span class="comment"># 编译</span></span><br><span class="line">gcc -c main.s -o main.o <span class="comment"># 汇编</span></span><br><span class="line">gcc main.o -o main <span class="comment">#链接</span></span><br></pre></td></tr></table></figure>
<ol type="1">
<li>预处理：将 <code>.c</code> 的头文件展开、宏展开，生成
<code>.i</code> 文件；</li>
<li>编译：将预处理后 <code>.i</code> 文件生成 <code>.s</code>
汇编文件；</li>
<li>汇编：将 <code>.s</code> 汇编文件生成 <code>.o</code>
目标文件；</li>
<li>链接：将 <code>.o</code> 文件链接成目标文件。</li>
</ol>
<h2 id="include">include</h2>
<p><code>#include&lt;&gt;</code>：用尖括号包含头文件，在系统指定的路径下找头文件。</p>
<p><code>#include ""</code>：用双引号包含头文件，先在当前目录下找头文件，找不到，再到系统指定的路径下找。</p>
<blockquote>
<p>注意：<code>include</code> 经常用来包含头文件，可以包含
<code>.c</code> 文件，但不要这么做，因为 <code>include</code>
包含的文件会在预编译被展开，如果一个 <code>.c</code>
被包含多次，展开多次，会导致函数重复定义。</p>
</blockquote>
<blockquote>
<p>注意：预处理只是对 <code>include</code>
等预处理操作进行处理并不会进行语法检查这个阶段有语法错误也不会报错，第二个阶段即编译阶段才进行语法检查。</p>
</blockquote>
<h2 id="define">define</h2>
<p>用来定义宏。</p>
<p><strong>不带参宏：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br></pre></td></tr></table></figure>
<p>在预编译的时候如果代码中出现了 PI 就用 3.14 去替换。</p>
<p>宏的好处：只要修改宏定义，其他地方在预编译的时候就会重新替换。</p>
<blockquote>
<p>注意：宏定义后边不要加分号。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PI = %lf\n&quot;</span>, PI);</span><br><span class="line">    <span class="type">double</span> d = PI;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d = %lf\n&quot;</span>, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/968daaa1-8453-4af8-a6e0-8e023250be1d"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p>宏定义的作用范围：从定义的地方到本文件末，可以使用
<code>#undef PI</code> 提前结束宏定义的作用。</p>
<p><strong>带参宏：</strong></p>
<p><code>#define S(a, b) a * b</code></p>
<p>注意带参宏的形参 a 和 b 没有类型名，<code>S(2, 4)</code>
将来在预处理的时候替换成实参替代字符串的形参，其他字符保留。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S(a, b) ((a) * (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, S(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, S(<span class="number">2</span> + <span class="number">8</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/54474424-669a-4578-b0b2-8702ff446ce1"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
<p><strong>带参宏和带参函数的区别：</strong></p>
<p>带参宏被调用多少次就会展开多少次，执行代码的时候没有函数调用的过程，不需要压栈弹栈。所以带参宏，浪费了空间，节省时间。</p>
<p>带参函数，代码只有一份，存在代码段，调用的时候去代码段取指令，调用的时候要压栈弹栈，有个调用的过程。带参函数是浪费了时间，节省了空间。</p>
<p>带参函数的形参是有类型的，带参宏的形参没有类型名。</p>
<p>如果功能实现的代码相对简单，并且不需要开辟太多的空间，可以选择使用带参宏，但是大多数情况都会使用函数。</p>
<h2 id="条件编译">条件编译</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> AAA</span></span><br><span class="line">	代码段一</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	代码段二</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AAA</span></span><br><span class="line">	代码段一</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	代码段二</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 表达式</span></span><br><span class="line">	程序段一</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	程序段二</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AAA</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> AAA</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello kitty!!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello tom\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure>
<img data-src="https://github.com/XinranSix/Computer-Graphics/assets/62458905/ff827787-315b-4865-8903-8c88cbbb3e9a"
alt="image" />
<figcaption aria-hidden="true">image</figcaption>
</figure>
]]></content>
      <categories>
        <category>C 语言基础</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title>高级渲染主题</title>
    <url>/2023/07/16/%E9%AB%98%E7%BA%A7%E6%B8%B2%E6%9F%93%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<h2 id="高级光线传播">高级光线传播</h2>
<p>高级光线传播方法有如下几种：</p>
<ul>
<li><p>无偏光线传播方法</p>
<ul>
<li><p>Bidirectional path tracing（BDPT）：双向路径追踪；</p></li>
<li><p>Metropolis light transport（MLT）。</p></li>
</ul></li>
<li><p>有偏光线传播方法</p>
<ul>
<li><p>Photon mapping：光子映射；</p></li>
<li><p>Vertex connection and merging（VCM）。</p></li>
</ul></li>
<li><p>Instant radiosity（VPL / many light methods）</p></li>
</ul>
<h3 id="有偏与无偏蒙特卡洛估计">有偏与无偏蒙特卡洛估计</h3>
<p><strong>无偏</strong>（Unbiased）蒙塔卡洛估计指的是不论我们选取多少样本进行估计，得到的期望值和正确值一样。</p>
<p><strong>有偏</strong>（Biased）蒙特卡洛估计指的是如果我们取样后得到的估计值与要预测的真实值是有偏差的，那么我们认为这是一个有偏估计。当我们采样足够大的的时候，有偏估计也可以收敛到正确值，这说明了有偏估计具有一致性（consistent）。</p>
<h3 id="bidirectional-path-tracing">Bidirectional Path Tracing</h3>
<p>BDPT
指的是我们分别从光源和眼睛（摄像机）引出半路径，并将半路径的终点连接起来形成路径。这种方法非常适用于光源出光线比较复杂的情况。但是实现困难并且渲非常慢，是一种无偏的估计。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231392207-a5d78f12-1277-461f-a1ae-9d554c986e50.png" alt="Img" style="zoom:75%;" />
</center>
<h3 id="metropolis-light-transport">Metropolis Light Transport</h3>
<p>MLT 使用使用马尔可夫链的方法进行采样：从当前采样点依据某种 PDF
跳到下一个采样点。</p>
<p>这种采样方式可以很容易的采样到某一个采样的临近点。其主要思想是，当一条路径可以到达光源时，那么临近的采样也应该容易到达光源。非常适用于困难场景的渲染，尤其是
SDS（Specular-Diffuse-Specular）路径。</p>
<p>但是很难估计收敛速度，每一个像素的收敛速度也不一样。操作独立，各个像素独立导致画面会比较「脏」，因此很难应用到动画上。MLT
也是无偏估计。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231392172-73920a70-5f9a-49a7-aa35-b991ddf63480.png" alt="Img" style="zoom:75%;" />
</center>
<h3 id="photon-mapping">Photon Mapping</h3>
<p>光子映射是一个分为两步的方法。是一种有偏估计。适合于 SDS
路径以及焦散（caustics）材质。</p>
<ol type="1">
<li>从光源出发射出光子，当光子反射到漫反射平面时停止，记录光子位置；</li>
<li>从摄像机射出半路径，直到路径反射到漫反射平面上。</li>
</ol>
<p>我们需要通过局部密度估计在计算单位面积内，光子数的多少。那么光子密度越高的地方应当越亮。对于任意一个点，我们选取临近
<span class="math inline">\(N\)</span> 个距离最近的光子，那么使用 <span
class="math inline">\(N\)</span> 处以光子所占的面积 <span
class="math inline">\(\Delta A\)</span> 就可以得到该就可以得到该
点的局部密度。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231391911-7372976e-6abb-463e-9728-13bb0b9eedef.png" alt="Img" style="zoom:75%;" />
</center>
<p>为什么这是一个有偏的方法？我们 <span class="math inline">\(N\)</span>
太少的话易产生噪声，但是 <span class="math inline">\(N\)</span>
太多又会模糊。当我们使用的光子足够多的时候，<span
class="math inline">\(\Delta A\)</span> 就趋近于 <span
class="math inline">\(\mathrm{d} A\)</span>
因此，只要我们的采样是有限的，得到的密度多少都会有偏差，所以这是一个有偏的估计。但是这是一致的估计。</p>
<h3 id="vertex-connection-and-merging">Vertex Connection and
Merging</h3>
<p>VCM
是一种结合了双向路径追踪和光子映射的方法。其主要思想是在双向光线追踪中如果半路径的结束点并不在一起但是距离比较近的话可以组合在一起。使用光子映射的方法来组合这些临近的「光子」。是一种有偏估计。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231392925-c6544672-d194-4ef0-af94-0436dc494bbe.png" alt="Img" style="zoom:75%;" />
</center>
<h3 id="instant-radiosity-ir">Instant Radiosity (IR)</h3>
<p>IR
最主要的思想是认为被照亮的表面可以当作一个小光源。从光源打出来的地方到一些表面后，到达点就是新的虚拟光源。之后就可以将这些虚拟光源看作光源进行渲染。优点是渲染速度快并且在漫反射场景中表现的很好;缺点是不能很好的处理反射材质。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231393236-81d73aa4-b02d-4d20-97ad-740a54f19f0c.png" alt="Img" style="zoom:75%;" />
</center>
<h2 id="高级外观建模advanced-appearance-modeling">高级外观建模（Advanced
Appearance Modeling）</h2>
<p>此节会介绍：</p>
<ul>
<li>Non-surface models（非表面模型）
<ul>
<li>Participating media（散射介质）</li>
<li>Hair / fur / fiber (BCSDF)（毛发）</li>
<li>Granular material（颗粒材质）</li>
</ul></li>
<li>Surface models（表面模型）
<ul>
<li>Translucent material (BSSRDF)</li>
<li>Cloth（织物）</li>
<li>Detailed material (non-statistical BRDF)</li>
</ul></li>
<li>Procedural appearance</li>
</ul>
<h3 id="non-surface-models">Non-surface models</h3>
<h4 id="participating-media">Participating media</h4>
<p>对于一些散射介质，例如云、雾，我们认为他们是非表面模型。因此他们不存在一个表面，而是由许多散射小颗粒组成的。任何一束光通过散射介质，会发生（部分）吸收或者散射。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231394358-e1607f8e-bcc5-4d0a-9121-328642f409bc.png" alt="Img" style="zoom:75%;" />
</center>
<p>我们采用<strong>相位函数</strong>（Phase
Function）去描述在某一点光的散射和散射角度的关系。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231408693-9766422c-77ab-4598-8c80-d2e94dc4ec57.png" alt="Img" style="zoom:75%;" />
</center>
<p>再渲染散射介质时：</p>
<ul>
<li>Randomly choose a direction to bounce;</li>
<li>Randomly choose a distance to go straight;</li>
<li>At each 'shading point', connect to the light.</li>
</ul>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231409723-b5066afd-4128-47cb-806f-763d2a5104d3.png" alt="Img" style="zoom:75%;" />
</center>
<h4 id="hair-fur-fiber">Hair / fur / fiber</h4>
<p>光线与头发的作用不是简单的光线和表面的作用，首先视头发为一个圆柱体。</p>
<p>在 Kajiya-Kay
模型中，我们认为一束光射到头发上后，头发会将光线散射为一个圆锥。Kajiya-Kay
模型做出来的效果并不好。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231412180-9fe05e93-e566-4cd6-a471-1d787d40e538.png" alt="Img" style="zoom:75%;" />
</center>
<p>在 Marschner
模型中，我们认为头发是一个能够透光的「玻璃」，光线应该分为三部分，分别是：</p>
<ul>
<li>R：光线直接反射光；</li>
<li>TT：光线经过两次折射后射出的折射光；</li>
<li>TRT：光线折射后经过一次介质内反射后的折射光。</li>
</ul>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231652667-750a6887-2407-4db2-a5dd-e801e5bfc75c.png" alt="Img" style="zoom:75%;" />
</center>
<p>以上的模型对于人类的毛发已经有了很好的表现，但是对于动物毛发来说，表现并不好。这是因为动物的毛发并不是单层的结构。动物毛发中包含一层毛髓质（Medulla），因此引入双层模型（Double
CylinderModel）来对毛发进行建模。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231653290-aa79bb6a-3fbc-4516-ae93-ef7b7d4b4ef6.png" alt="Img" style="zoom:75%;" />
</center>
<p>在这个模型中我们额外增加了两种光：</p>
<ul>
<li><span
class="math inline">\(\text{TT}^{\text{s}}\)</span>：经过了中间介质的 TT
光线；</li>
<li><span
class="math inline">\(\text{TRT}^{S}\)</span>：经过了中间介质的 TRT
光线。</li>
</ul>
<p>这样 5 种光线结合在一起得到的毛发会更加的真实。</p>
<h4 id="granular-material">Granular Material</h4>
<p>粒状材质是由细小的颗粒组成的材质，例如谷物，沙子，调味料等。这样的材质也有程序化的方法进行渲染。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231653886-d78f2d2f-192b-414c-9896-23438306c1b7.png" alt="Img" style="zoom:75%;" />
</center>
<h3 id="surface-models">Surface models</h3>
<h4 id="translucent-material">Translucent Material</h4>
<p>Translucent
材质指的是能够透光的一些材质，光线可以从一个地方进去并从另一个地方出去。例如玉石，水母都是典型的
Translucent 材质。</p>
<p>一条光在半透明材质上入射后，出射光的起点并不一定在入射点上（Subsurface
Scattering），因此我们需要对 BRDF 进行拓展。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231654420-34b0b24e-347e-4237-9808-46ace086b3ff.png" alt="Img" style="zoom:75%;" />
</center>
<p>此时 BDRF 就变成了
BSSDRF，此时我们需要引入新的位置参数，我们不仅要对角度进行积分。BSSDRF
的定义为： <span class="math display">\[
S\left(x_i,\omega_i,x_o,\omega_o\right)
\]</span></p>
<p>渲染方程要修正为： <span class="math display">\[
L\left(x_o,\omega_o\right) =
\int_A\int_{H^2}S\left(x_i,\omega_i,x_o,\omega_o\right)
L_i\left(x_i,\omega_i\right) \cos \theta_i \, \mathrm{d} \omega_i \,
\mathrm{d} A
\]</span></p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231654935-f6524435-3b1d-4841-8983-9760b05cb235.png" alt="Img" style="zoom:75%;" />
</center>
<p>我们会等效的认为，一个半透明材质上有一束光摄入相当于在介质的外部和内部各有一个光源。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231655049-ddb0d053-fede-4eb8-9249-2966ac6e11bc.png" alt="Img" style="zoom:75%;" />
</center>
<h4 id="cloth">Cloth</h4>
<p>织物的制作工艺比较的复杂。首先，多层（Ply）缠绕会变成一根纱（Yarn），多根纱相互缠绕就会变成一根线（Fiber）。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231655321-ee00b9c5-731f-42ec-b68d-2730c42d61ce.png" alt="Img" style="zoom:75%;" />
</center>
<p>我们可以使用两种编织工艺，一种是机织（Woven），通过线之间的经纬交叉得到布料，另一种方式是手打（Knitted）的方式，类似于织毛衣的过程。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231655403-f3c94387-5f28-43e7-9d76-da3644c902e9.png" alt="Img" style="zoom:75%;" />
</center>
<p>不同的布料有不同的 BDRF，常见的渲染方法有：</p>
<ul>
<li>Render as Surface
<ul>
<li>Given the weaving pattern, calculate the overall behavior</li>
<li>Render using a BRDF</li>
</ul></li>
<li>Render as Surface</li>
<li>Render as Participating Media
<ul>
<li>Properties of individual fibers &amp; their distribution -&gt;
scattering parameters</li>
<li>Render as a participating medium</li>
</ul></li>
<li>Render as Actual Fibers
<ul>
<li>Render every fiber explicitly</li>
</ul></li>
</ul>
<blockquote>
<p>对于天鹅绒材质等布料，使用 BDRF 并不合适。</p>
</blockquote>
<h3 id="真实世界模型">真实世界模型</h3>
<p>现在的渲染器渲染出的画面并不真实，主要原因是这些渲染器过于完美。在实际生活中的物体一般表面都会带有划痕，会让物体表面看起来更真实。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231656315-482c42ab-231f-4d6b-8091-3d889f29ef1d.png" alt="Img" style="zoom:75%;" />
</center>
<p>我们可以用微表面模型的发现分布来解决这种情况。我们只需要在微表面模型的分布上加一些噪声，就可以产生带有划痕的效果。但是，在这样的法线分布下，光线很难反射到光源处。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231656429-ac385ac6-7a37-4c8f-ab9f-71b8d21bac22.png" alt="Img" style="zoom:75%;" />
</center>
<p>因此，我们的解决方案是，我们对于每一个像素，对应一部分法线分布 <span
class="math inline">\(\mathcal{P}-\mathrm{NDF}\)</span>，使用这一部分的法线总体分布进行路径追踪。</p>
<center>
<img data-src="https://user-images.githubusercontent.com/62458905/231656768-777d08a2-c53f-4706-892f-966484098806.png" alt="Img" style="zoom:75%;" />
</center>
<p>此外，目前研究比较前沿的问题还有波动光学（Wave Optics）的渲染。</p>
<h2 id="程序化生成">程序化生成</h2>
<p>程序化生成（Procedural
Appearance）指的是我们可以不定义一个纹理，而是直接定义一个噪声，通过噪声计算纹理。木纹，陶瓷都可以定制对应的纹理进行程序化的生成。</p>
<p>不仅可以定义 2 维的噪声，也可以定义 3 维的噪声，在将物体切割时，3
维噪声会将切面的纹理动态地计算出来。</p>
<p>例如下面这个噪声函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">noise</span><span class="params">(x, y, z)</span> &gt; threshold:</span></span><br><span class="line"><span class="function">    reflectance =</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    reflectance = <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GAMES 101</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>高级渲染</tag>
      </tags>
  </entry>
</search>
